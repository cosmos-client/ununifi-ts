/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from 'protobufjs/minimal';

// Common aliases
const $Reader = $protobuf.Reader,
  $Writer = $protobuf.Writer,
  $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots['ununifi-client'] || ($protobuf.roots['ununifi-client'] = {});

export const ununifi = ($root.ununifi = (() => {
  /**
   * Namespace ununifi.
   * @exports ununifi
   * @namespace
   */
  const ununifi = {};

  ununifi.auction = (function () {
    /**
     * Namespace auction.
     * @memberof ununifi
     * @namespace
     */
    const auction = {};

    auction.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.auction
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.auction.Query#params}.
       * @memberof ununifi.auction.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.auction.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.auction.Query
       * @instance
       * @param {ununifi.auction.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.auction.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.auction.QueryParamsRequest,
            $root.ununifi.auction.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.auction.Query
       * @instance
       * @param {ununifi.auction.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.auction.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.auction.Query#auction}.
       * @memberof ununifi.auction.Query
       * @typedef AuctionCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.auction.QueryGetAuctionResponse} [response] QueryGetAuctionResponse
       */

      /**
       * Calls Auction.
       * @function auction
       * @memberof ununifi.auction.Query
       * @instance
       * @param {ununifi.auction.IQueryGetAuctionRequest} request QueryGetAuctionRequest message or plain object
       * @param {ununifi.auction.Query.AuctionCallback} callback Node-style callback called with the error, if any, and QueryGetAuctionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.auction = function auction(request, callback) {
          return this.rpcCall(
            auction,
            $root.ununifi.auction.QueryGetAuctionRequest,
            $root.ununifi.auction.QueryGetAuctionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Auction' },
      );

      /**
       * Calls Auction.
       * @function auction
       * @memberof ununifi.auction.Query
       * @instance
       * @param {ununifi.auction.IQueryGetAuctionRequest} request QueryGetAuctionRequest message or plain object
       * @returns {Promise<ununifi.auction.QueryGetAuctionResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.auction.Query#auctionAll}.
       * @memberof ununifi.auction.Query
       * @typedef AuctionAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.auction.QueryAllAuctionResponse} [response] QueryAllAuctionResponse
       */

      /**
       * Calls AuctionAll.
       * @function auctionAll
       * @memberof ununifi.auction.Query
       * @instance
       * @param {ununifi.auction.IQueryAllAuctionRequest} request QueryAllAuctionRequest message or plain object
       * @param {ununifi.auction.Query.AuctionAllCallback} callback Node-style callback called with the error, if any, and QueryAllAuctionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.auctionAll = function auctionAll(request, callback) {
          return this.rpcCall(
            auctionAll,
            $root.ununifi.auction.QueryAllAuctionRequest,
            $root.ununifi.auction.QueryAllAuctionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AuctionAll' },
      );

      /**
       * Calls AuctionAll.
       * @function auctionAll
       * @memberof ununifi.auction.Query
       * @instance
       * @param {ununifi.auction.IQueryAllAuctionRequest} request QueryAllAuctionRequest message or plain object
       * @returns {Promise<ununifi.auction.QueryAllAuctionResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    auction.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.auction
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.auction
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.auction.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.auction.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.QueryParamsRequest
       * @static
       * @param {ununifi.auction.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.auction.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.QueryParamsRequest
       * @static
       * @param {ununifi.auction.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.auction.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.QueryParamsRequest) return object;
        return new $root.ununifi.auction.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.QueryParamsRequest
       * @static
       * @param {ununifi.auction.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.auction.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    auction.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.auction
       * @interface IQueryParamsResponse
       * @property {ununifi.auction.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.auction
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.auction.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.auction.IParams|null|undefined} params
       * @memberof ununifi.auction.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.auction.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.QueryParamsResponse
       * @static
       * @param {ununifi.auction.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.auction.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.auction.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.QueryParamsResponse
       * @static
       * @param {ununifi.auction.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.auction.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.auction.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.auction.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.QueryParamsResponse) return object;
        let message = new $root.ununifi.auction.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.auction.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.auction.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.QueryParamsResponse
       * @static
       * @param {ununifi.auction.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.auction.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.auction.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    auction.QueryGetAuctionRequest = (function () {
      /**
       * Properties of a QueryGetAuctionRequest.
       * @memberof ununifi.auction
       * @interface IQueryGetAuctionRequest
       * @property {Long|null} [id] QueryGetAuctionRequest id
       */

      /**
       * Constructs a new QueryGetAuctionRequest.
       * @memberof ununifi.auction
       * @classdesc Represents a QueryGetAuctionRequest.
       * @implements IQueryGetAuctionRequest
       * @constructor
       * @param {ununifi.auction.IQueryGetAuctionRequest=} [properties] Properties to set
       */
      function QueryGetAuctionRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetAuctionRequest id.
       * @member {Long} id
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @instance
       */
      QueryGetAuctionRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryGetAuctionRequest message. Does not implicitly {@link ununifi.auction.QueryGetAuctionRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @static
       * @param {ununifi.auction.IQueryGetAuctionRequest} message QueryGetAuctionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetAuctionRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetAuctionRequest message, length delimited. Does not implicitly {@link ununifi.auction.QueryGetAuctionRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @static
       * @param {ununifi.auction.IQueryGetAuctionRequest} message QueryGetAuctionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetAuctionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetAuctionRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.QueryGetAuctionRequest} QueryGetAuctionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetAuctionRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.QueryGetAuctionRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetAuctionRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.QueryGetAuctionRequest} QueryGetAuctionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetAuctionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetAuctionRequest message.
       * @function verify
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetAuctionRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryGetAuctionRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.QueryGetAuctionRequest} QueryGetAuctionRequest
       */
      QueryGetAuctionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.QueryGetAuctionRequest) return object;
        let message = new $root.ununifi.auction.QueryGetAuctionRequest();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetAuctionRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @static
       * @param {ununifi.auction.QueryGetAuctionRequest} message QueryGetAuctionRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetAuctionRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this QueryGetAuctionRequest to JSON.
       * @function toJSON
       * @memberof ununifi.auction.QueryGetAuctionRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetAuctionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetAuctionRequest;
    })();

    auction.QueryGetAuctionResponse = (function () {
      /**
       * Properties of a QueryGetAuctionResponse.
       * @memberof ununifi.auction
       * @interface IQueryGetAuctionResponse
       * @property {google.protobuf.IAny|null} [auction] QueryGetAuctionResponse auction
       */

      /**
       * Constructs a new QueryGetAuctionResponse.
       * @memberof ununifi.auction
       * @classdesc Represents a QueryGetAuctionResponse.
       * @implements IQueryGetAuctionResponse
       * @constructor
       * @param {ununifi.auction.IQueryGetAuctionResponse=} [properties] Properties to set
       */
      function QueryGetAuctionResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetAuctionResponse auction.
       * @member {google.protobuf.IAny|null|undefined} auction
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @instance
       */
      QueryGetAuctionResponse.prototype.auction = null;

      /**
       * Encodes the specified QueryGetAuctionResponse message. Does not implicitly {@link ununifi.auction.QueryGetAuctionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @static
       * @param {ununifi.auction.IQueryGetAuctionResponse} message QueryGetAuctionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetAuctionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.auction != null && Object.hasOwnProperty.call(message, 'auction'))
          $root.google.protobuf.Any.encode(message.auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetAuctionResponse message, length delimited. Does not implicitly {@link ununifi.auction.QueryGetAuctionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @static
       * @param {ununifi.auction.IQueryGetAuctionResponse} message QueryGetAuctionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetAuctionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetAuctionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.QueryGetAuctionResponse} QueryGetAuctionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetAuctionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.QueryGetAuctionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.auction = $root.google.protobuf.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetAuctionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.QueryGetAuctionResponse} QueryGetAuctionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetAuctionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetAuctionResponse message.
       * @function verify
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetAuctionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.auction != null && message.hasOwnProperty('auction')) {
          let error = $root.google.protobuf.Any.verify(message.auction);
          if (error) return 'auction.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetAuctionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.QueryGetAuctionResponse} QueryGetAuctionResponse
       */
      QueryGetAuctionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.QueryGetAuctionResponse) return object;
        let message = new $root.ununifi.auction.QueryGetAuctionResponse();
        if (object.auction != null) {
          if (typeof object.auction !== 'object') throw TypeError('.ununifi.auction.QueryGetAuctionResponse.auction: object expected');
          message.auction = $root.google.protobuf.Any.fromObject(object.auction);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetAuctionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @static
       * @param {ununifi.auction.QueryGetAuctionResponse} message QueryGetAuctionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetAuctionResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.auction = null;
        if (message.auction != null && message.hasOwnProperty('auction'))
          object.auction = $root.google.protobuf.Any.toObject(message.auction, options);
        return object;
      };

      /**
       * Converts this QueryGetAuctionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.auction.QueryGetAuctionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetAuctionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetAuctionResponse;
    })();

    auction.QueryAllAuctionRequest = (function () {
      /**
       * Properties of a QueryAllAuctionRequest.
       * @memberof ununifi.auction
       * @interface IQueryAllAuctionRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllAuctionRequest pagination
       */

      /**
       * Constructs a new QueryAllAuctionRequest.
       * @memberof ununifi.auction
       * @classdesc Represents a QueryAllAuctionRequest.
       * @implements IQueryAllAuctionRequest
       * @constructor
       * @param {ununifi.auction.IQueryAllAuctionRequest=} [properties] Properties to set
       */
      function QueryAllAuctionRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllAuctionRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @instance
       */
      QueryAllAuctionRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllAuctionRequest message. Does not implicitly {@link ununifi.auction.QueryAllAuctionRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @static
       * @param {ununifi.auction.IQueryAllAuctionRequest} message QueryAllAuctionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAuctionRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllAuctionRequest message, length delimited. Does not implicitly {@link ununifi.auction.QueryAllAuctionRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @static
       * @param {ununifi.auction.IQueryAllAuctionRequest} message QueryAllAuctionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAuctionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllAuctionRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.QueryAllAuctionRequest} QueryAllAuctionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAuctionRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.QueryAllAuctionRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllAuctionRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.QueryAllAuctionRequest} QueryAllAuctionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAuctionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllAuctionRequest message.
       * @function verify
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllAuctionRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllAuctionRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.QueryAllAuctionRequest} QueryAllAuctionRequest
       */
      QueryAllAuctionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.QueryAllAuctionRequest) return object;
        let message = new $root.ununifi.auction.QueryAllAuctionRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.ununifi.auction.QueryAllAuctionRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllAuctionRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @static
       * @param {ununifi.auction.QueryAllAuctionRequest} message QueryAllAuctionRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllAuctionRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllAuctionRequest to JSON.
       * @function toJSON
       * @memberof ununifi.auction.QueryAllAuctionRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllAuctionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllAuctionRequest;
    })();

    auction.QueryAllAuctionResponse = (function () {
      /**
       * Properties of a QueryAllAuctionResponse.
       * @memberof ununifi.auction
       * @interface IQueryAllAuctionResponse
       * @property {Array.<google.protobuf.IAny>|null} [auctions] QueryAllAuctionResponse auctions
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllAuctionResponse pagination
       */

      /**
       * Constructs a new QueryAllAuctionResponse.
       * @memberof ununifi.auction
       * @classdesc Represents a QueryAllAuctionResponse.
       * @implements IQueryAllAuctionResponse
       * @constructor
       * @param {ununifi.auction.IQueryAllAuctionResponse=} [properties] Properties to set
       */
      function QueryAllAuctionResponse(properties) {
        this.auctions = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllAuctionResponse auctions.
       * @member {Array.<google.protobuf.IAny>} auctions
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @instance
       */
      QueryAllAuctionResponse.prototype.auctions = $util.emptyArray;

      /**
       * QueryAllAuctionResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @instance
       */
      QueryAllAuctionResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllAuctionResponse message. Does not implicitly {@link ununifi.auction.QueryAllAuctionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @static
       * @param {ununifi.auction.IQueryAllAuctionResponse} message QueryAllAuctionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAuctionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.auctions != null && message.auctions.length)
          for (let i = 0; i < message.auctions.length; ++i)
            $root.google.protobuf.Any.encode(message.auctions[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllAuctionResponse message, length delimited. Does not implicitly {@link ununifi.auction.QueryAllAuctionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @static
       * @param {ununifi.auction.IQueryAllAuctionResponse} message QueryAllAuctionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAuctionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllAuctionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.QueryAllAuctionResponse} QueryAllAuctionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAuctionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.QueryAllAuctionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.auctions && message.auctions.length)) message.auctions = [];
              message.auctions.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllAuctionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.QueryAllAuctionResponse} QueryAllAuctionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAuctionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllAuctionResponse message.
       * @function verify
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllAuctionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.auctions != null && message.hasOwnProperty('auctions')) {
          if (!Array.isArray(message.auctions)) return 'auctions: array expected';
          for (let i = 0; i < message.auctions.length; ++i) {
            let error = $root.google.protobuf.Any.verify(message.auctions[i]);
            if (error) return 'auctions.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllAuctionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.QueryAllAuctionResponse} QueryAllAuctionResponse
       */
      QueryAllAuctionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.QueryAllAuctionResponse) return object;
        let message = new $root.ununifi.auction.QueryAllAuctionResponse();
        if (object.auctions) {
          if (!Array.isArray(object.auctions)) throw TypeError('.ununifi.auction.QueryAllAuctionResponse.auctions: array expected');
          message.auctions = [];
          for (let i = 0; i < object.auctions.length; ++i) {
            if (typeof object.auctions[i] !== 'object')
              throw TypeError('.ununifi.auction.QueryAllAuctionResponse.auctions: object expected');
            message.auctions[i] = $root.google.protobuf.Any.fromObject(object.auctions[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.auction.QueryAllAuctionResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllAuctionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @static
       * @param {ununifi.auction.QueryAllAuctionResponse} message QueryAllAuctionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllAuctionResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.auctions = [];
        if (options.defaults) object.pagination = null;
        if (message.auctions && message.auctions.length) {
          object.auctions = [];
          for (let j = 0; j < message.auctions.length; ++j)
            object.auctions[j] = $root.google.protobuf.Any.toObject(message.auctions[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllAuctionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.auction.QueryAllAuctionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllAuctionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllAuctionResponse;
    })();

    auction.BaseAuction = (function () {
      /**
       * Properties of a BaseAuction.
       * @memberof ununifi.auction
       * @interface IBaseAuction
       * @property {Long|null} [id] BaseAuction id
       * @property {string|null} [initiator] BaseAuction initiator
       * @property {cosmos.base.v1beta1.ICoin|null} [lot] BaseAuction lot
       * @property {string|null} [bidder] BaseAuction bidder
       * @property {cosmos.base.v1beta1.ICoin|null} [bid] BaseAuction bid
       * @property {boolean|null} [has_received_bids] BaseAuction has_received_bids
       * @property {google.protobuf.ITimestamp|null} [end_time] BaseAuction end_time
       * @property {google.protobuf.ITimestamp|null} [max_end_time] BaseAuction max_end_time
       */

      /**
       * Constructs a new BaseAuction.
       * @memberof ununifi.auction
       * @classdesc Represents a BaseAuction.
       * @implements IBaseAuction
       * @constructor
       * @param {ununifi.auction.IBaseAuction=} [properties] Properties to set
       */
      function BaseAuction(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * BaseAuction id.
       * @member {Long} id
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * BaseAuction initiator.
       * @member {string} initiator
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.initiator = '';

      /**
       * BaseAuction lot.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} lot
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.lot = null;

      /**
       * BaseAuction bidder.
       * @member {string} bidder
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.bidder = '';

      /**
       * BaseAuction bid.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} bid
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.bid = null;

      /**
       * BaseAuction has_received_bids.
       * @member {boolean} has_received_bids
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.has_received_bids = false;

      /**
       * BaseAuction end_time.
       * @member {google.protobuf.ITimestamp|null|undefined} end_time
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.end_time = null;

      /**
       * BaseAuction max_end_time.
       * @member {google.protobuf.ITimestamp|null|undefined} max_end_time
       * @memberof ununifi.auction.BaseAuction
       * @instance
       */
      BaseAuction.prototype.max_end_time = null;

      /**
       * Encodes the specified BaseAuction message. Does not implicitly {@link ununifi.auction.BaseAuction.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.BaseAuction
       * @static
       * @param {ununifi.auction.IBaseAuction} message BaseAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BaseAuction.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.initiator != null && Object.hasOwnProperty.call(message, 'initiator'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.initiator);
        if (message.lot != null && Object.hasOwnProperty.call(message, 'lot'))
          $root.cosmos.base.v1beta1.Coin.encode(message.lot, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.bidder);
        if (message.bid != null && Object.hasOwnProperty.call(message, 'bid'))
          $root.cosmos.base.v1beta1.Coin.encode(message.bid, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        if (message.has_received_bids != null && Object.hasOwnProperty.call(message, 'has_received_bids'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.has_received_bids);
        if (message.end_time != null && Object.hasOwnProperty.call(message, 'end_time'))
          $root.google.protobuf.Timestamp.encode(message.end_time, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.max_end_time != null && Object.hasOwnProperty.call(message, 'max_end_time'))
          $root.google.protobuf.Timestamp.encode(message.max_end_time, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified BaseAuction message, length delimited. Does not implicitly {@link ununifi.auction.BaseAuction.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.BaseAuction
       * @static
       * @param {ununifi.auction.IBaseAuction} message BaseAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BaseAuction.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BaseAuction message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.BaseAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.BaseAuction} BaseAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BaseAuction.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.BaseAuction();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.initiator = reader.string();
              break;
            case 3:
              message.lot = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.bidder = reader.string();
              break;
            case 5:
              message.bid = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 6:
              message.has_received_bids = reader.bool();
              break;
            case 7:
              message.end_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 8:
              message.max_end_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a BaseAuction message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.BaseAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.BaseAuction} BaseAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BaseAuction.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BaseAuction message.
       * @function verify
       * @memberof ununifi.auction.BaseAuction
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BaseAuction.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.initiator != null && message.hasOwnProperty('initiator'))
          if (!$util.isString(message.initiator)) return 'initiator: string expected';
        if (message.lot != null && message.hasOwnProperty('lot')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.lot);
          if (error) return 'lot.' + error;
        }
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.bid != null && message.hasOwnProperty('bid')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.bid);
          if (error) return 'bid.' + error;
        }
        if (message.has_received_bids != null && message.hasOwnProperty('has_received_bids'))
          if (typeof message.has_received_bids !== 'boolean') return 'has_received_bids: boolean expected';
        if (message.end_time != null && message.hasOwnProperty('end_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.end_time);
          if (error) return 'end_time.' + error;
        }
        if (message.max_end_time != null && message.hasOwnProperty('max_end_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.max_end_time);
          if (error) return 'max_end_time.' + error;
        }
        return null;
      };

      /**
       * Creates a BaseAuction message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.BaseAuction
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.BaseAuction} BaseAuction
       */
      BaseAuction.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.BaseAuction) return object;
        let message = new $root.ununifi.auction.BaseAuction();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.initiator != null) message.initiator = String(object.initiator);
        if (object.lot != null) {
          if (typeof object.lot !== 'object') throw TypeError('.ununifi.auction.BaseAuction.lot: object expected');
          message.lot = $root.cosmos.base.v1beta1.Coin.fromObject(object.lot);
        }
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.bid != null) {
          if (typeof object.bid !== 'object') throw TypeError('.ununifi.auction.BaseAuction.bid: object expected');
          message.bid = $root.cosmos.base.v1beta1.Coin.fromObject(object.bid);
        }
        if (object.has_received_bids != null) message.has_received_bids = Boolean(object.has_received_bids);
        if (object.end_time != null) {
          if (typeof object.end_time !== 'object') throw TypeError('.ununifi.auction.BaseAuction.end_time: object expected');
          message.end_time = $root.google.protobuf.Timestamp.fromObject(object.end_time);
        }
        if (object.max_end_time != null) {
          if (typeof object.max_end_time !== 'object') throw TypeError('.ununifi.auction.BaseAuction.max_end_time: object expected');
          message.max_end_time = $root.google.protobuf.Timestamp.fromObject(object.max_end_time);
        }
        return message;
      };

      /**
       * Creates a plain object from a BaseAuction message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.BaseAuction
       * @static
       * @param {ununifi.auction.BaseAuction} message BaseAuction
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BaseAuction.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.initiator = '';
          object.lot = null;
          object.bidder = '';
          object.bid = null;
          object.has_received_bids = false;
          object.end_time = null;
          object.max_end_time = null;
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.initiator != null && message.hasOwnProperty('initiator')) object.initiator = message.initiator;
        if (message.lot != null && message.hasOwnProperty('lot'))
          object.lot = $root.cosmos.base.v1beta1.Coin.toObject(message.lot, options);
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.bid != null && message.hasOwnProperty('bid'))
          object.bid = $root.cosmos.base.v1beta1.Coin.toObject(message.bid, options);
        if (message.has_received_bids != null && message.hasOwnProperty('has_received_bids'))
          object.has_received_bids = message.has_received_bids;
        if (message.end_time != null && message.hasOwnProperty('end_time'))
          object.end_time = $root.google.protobuf.Timestamp.toObject(message.end_time, options);
        if (message.max_end_time != null && message.hasOwnProperty('max_end_time'))
          object.max_end_time = $root.google.protobuf.Timestamp.toObject(message.max_end_time, options);
        return object;
      };

      /**
       * Converts this BaseAuction to JSON.
       * @function toJSON
       * @memberof ununifi.auction.BaseAuction
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BaseAuction.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return BaseAuction;
    })();

    auction.SurplusAuction = (function () {
      /**
       * Properties of a SurplusAuction.
       * @memberof ununifi.auction
       * @interface ISurplusAuction
       * @property {ununifi.auction.IBaseAuction|null} [base_auction] SurplusAuction base_auction
       */

      /**
       * Constructs a new SurplusAuction.
       * @memberof ununifi.auction
       * @classdesc Represents a SurplusAuction.
       * @implements ISurplusAuction
       * @constructor
       * @param {ununifi.auction.ISurplusAuction=} [properties] Properties to set
       */
      function SurplusAuction(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * SurplusAuction base_auction.
       * @member {ununifi.auction.IBaseAuction|null|undefined} base_auction
       * @memberof ununifi.auction.SurplusAuction
       * @instance
       */
      SurplusAuction.prototype.base_auction = null;

      /**
       * Encodes the specified SurplusAuction message. Does not implicitly {@link ununifi.auction.SurplusAuction.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.SurplusAuction
       * @static
       * @param {ununifi.auction.ISurplusAuction} message SurplusAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SurplusAuction.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.base_auction != null && Object.hasOwnProperty.call(message, 'base_auction'))
          $root.ununifi.auction.BaseAuction.encode(message.base_auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified SurplusAuction message, length delimited. Does not implicitly {@link ununifi.auction.SurplusAuction.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.SurplusAuction
       * @static
       * @param {ununifi.auction.ISurplusAuction} message SurplusAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SurplusAuction.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a SurplusAuction message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.SurplusAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.SurplusAuction} SurplusAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SurplusAuction.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.SurplusAuction();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.base_auction = $root.ununifi.auction.BaseAuction.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a SurplusAuction message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.SurplusAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.SurplusAuction} SurplusAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SurplusAuction.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a SurplusAuction message.
       * @function verify
       * @memberof ununifi.auction.SurplusAuction
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      SurplusAuction.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.base_auction != null && message.hasOwnProperty('base_auction')) {
          let error = $root.ununifi.auction.BaseAuction.verify(message.base_auction);
          if (error) return 'base_auction.' + error;
        }
        return null;
      };

      /**
       * Creates a SurplusAuction message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.SurplusAuction
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.SurplusAuction} SurplusAuction
       */
      SurplusAuction.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.SurplusAuction) return object;
        let message = new $root.ununifi.auction.SurplusAuction();
        if (object.base_auction != null) {
          if (typeof object.base_auction !== 'object') throw TypeError('.ununifi.auction.SurplusAuction.base_auction: object expected');
          message.base_auction = $root.ununifi.auction.BaseAuction.fromObject(object.base_auction);
        }
        return message;
      };

      /**
       * Creates a plain object from a SurplusAuction message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.SurplusAuction
       * @static
       * @param {ununifi.auction.SurplusAuction} message SurplusAuction
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      SurplusAuction.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.base_auction = null;
        if (message.base_auction != null && message.hasOwnProperty('base_auction'))
          object.base_auction = $root.ununifi.auction.BaseAuction.toObject(message.base_auction, options);
        return object;
      };

      /**
       * Converts this SurplusAuction to JSON.
       * @function toJSON
       * @memberof ununifi.auction.SurplusAuction
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      SurplusAuction.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return SurplusAuction;
    })();

    auction.DebtAuction = (function () {
      /**
       * Properties of a DebtAuction.
       * @memberof ununifi.auction
       * @interface IDebtAuction
       * @property {ununifi.auction.IBaseAuction|null} [base_auction] DebtAuction base_auction
       * @property {cosmos.base.v1beta1.ICoin|null} [corresponding_debt] DebtAuction corresponding_debt
       */

      /**
       * Constructs a new DebtAuction.
       * @memberof ununifi.auction
       * @classdesc Represents a DebtAuction.
       * @implements IDebtAuction
       * @constructor
       * @param {ununifi.auction.IDebtAuction=} [properties] Properties to set
       */
      function DebtAuction(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * DebtAuction base_auction.
       * @member {ununifi.auction.IBaseAuction|null|undefined} base_auction
       * @memberof ununifi.auction.DebtAuction
       * @instance
       */
      DebtAuction.prototype.base_auction = null;

      /**
       * DebtAuction corresponding_debt.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} corresponding_debt
       * @memberof ununifi.auction.DebtAuction
       * @instance
       */
      DebtAuction.prototype.corresponding_debt = null;

      /**
       * Encodes the specified DebtAuction message. Does not implicitly {@link ununifi.auction.DebtAuction.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.DebtAuction
       * @static
       * @param {ununifi.auction.IDebtAuction} message DebtAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DebtAuction.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.base_auction != null && Object.hasOwnProperty.call(message, 'base_auction'))
          $root.ununifi.auction.BaseAuction.encode(message.base_auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.corresponding_debt != null && Object.hasOwnProperty.call(message, 'corresponding_debt'))
          $root.cosmos.base.v1beta1.Coin.encode(message.corresponding_debt, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified DebtAuction message, length delimited. Does not implicitly {@link ununifi.auction.DebtAuction.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.DebtAuction
       * @static
       * @param {ununifi.auction.IDebtAuction} message DebtAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DebtAuction.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DebtAuction message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.DebtAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.DebtAuction} DebtAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DebtAuction.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.DebtAuction();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.base_auction = $root.ununifi.auction.BaseAuction.decode(reader, reader.uint32());
              break;
            case 2:
              message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a DebtAuction message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.DebtAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.DebtAuction} DebtAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DebtAuction.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DebtAuction message.
       * @function verify
       * @memberof ununifi.auction.DebtAuction
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DebtAuction.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.base_auction != null && message.hasOwnProperty('base_auction')) {
          let error = $root.ununifi.auction.BaseAuction.verify(message.base_auction);
          if (error) return 'base_auction.' + error;
        }
        if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.corresponding_debt);
          if (error) return 'corresponding_debt.' + error;
        }
        return null;
      };

      /**
       * Creates a DebtAuction message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.DebtAuction
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.DebtAuction} DebtAuction
       */
      DebtAuction.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.DebtAuction) return object;
        let message = new $root.ununifi.auction.DebtAuction();
        if (object.base_auction != null) {
          if (typeof object.base_auction !== 'object') throw TypeError('.ununifi.auction.DebtAuction.base_auction: object expected');
          message.base_auction = $root.ununifi.auction.BaseAuction.fromObject(object.base_auction);
        }
        if (object.corresponding_debt != null) {
          if (typeof object.corresponding_debt !== 'object')
            throw TypeError('.ununifi.auction.DebtAuction.corresponding_debt: object expected');
          message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.fromObject(object.corresponding_debt);
        }
        return message;
      };

      /**
       * Creates a plain object from a DebtAuction message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.DebtAuction
       * @static
       * @param {ununifi.auction.DebtAuction} message DebtAuction
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DebtAuction.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.base_auction = null;
          object.corresponding_debt = null;
        }
        if (message.base_auction != null && message.hasOwnProperty('base_auction'))
          object.base_auction = $root.ununifi.auction.BaseAuction.toObject(message.base_auction, options);
        if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt'))
          object.corresponding_debt = $root.cosmos.base.v1beta1.Coin.toObject(message.corresponding_debt, options);
        return object;
      };

      /**
       * Converts this DebtAuction to JSON.
       * @function toJSON
       * @memberof ununifi.auction.DebtAuction
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DebtAuction.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return DebtAuction;
    })();

    auction.CollateralAuction = (function () {
      /**
       * Properties of a CollateralAuction.
       * @memberof ununifi.auction
       * @interface ICollateralAuction
       * @property {ununifi.auction.IBaseAuction|null} [base_auction] CollateralAuction base_auction
       * @property {cosmos.base.v1beta1.ICoin|null} [corresponding_debt] CollateralAuction corresponding_debt
       * @property {cosmos.base.v1beta1.ICoin|null} [max_bid] CollateralAuction max_bid
       * @property {Array.<ununifi.auction.IWeightedAddress>|null} [lot_returns] CollateralAuction lot_returns
       */

      /**
       * Constructs a new CollateralAuction.
       * @memberof ununifi.auction
       * @classdesc Represents a CollateralAuction.
       * @implements ICollateralAuction
       * @constructor
       * @param {ununifi.auction.ICollateralAuction=} [properties] Properties to set
       */
      function CollateralAuction(properties) {
        this.lot_returns = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * CollateralAuction base_auction.
       * @member {ununifi.auction.IBaseAuction|null|undefined} base_auction
       * @memberof ununifi.auction.CollateralAuction
       * @instance
       */
      CollateralAuction.prototype.base_auction = null;

      /**
       * CollateralAuction corresponding_debt.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} corresponding_debt
       * @memberof ununifi.auction.CollateralAuction
       * @instance
       */
      CollateralAuction.prototype.corresponding_debt = null;

      /**
       * CollateralAuction max_bid.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} max_bid
       * @memberof ununifi.auction.CollateralAuction
       * @instance
       */
      CollateralAuction.prototype.max_bid = null;

      /**
       * CollateralAuction lot_returns.
       * @member {Array.<ununifi.auction.IWeightedAddress>} lot_returns
       * @memberof ununifi.auction.CollateralAuction
       * @instance
       */
      CollateralAuction.prototype.lot_returns = $util.emptyArray;

      /**
       * Encodes the specified CollateralAuction message. Does not implicitly {@link ununifi.auction.CollateralAuction.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.CollateralAuction
       * @static
       * @param {ununifi.auction.ICollateralAuction} message CollateralAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CollateralAuction.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.base_auction != null && Object.hasOwnProperty.call(message, 'base_auction'))
          $root.ununifi.auction.BaseAuction.encode(message.base_auction, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.corresponding_debt != null && Object.hasOwnProperty.call(message, 'corresponding_debt'))
          $root.cosmos.base.v1beta1.Coin.encode(message.corresponding_debt, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.max_bid != null && Object.hasOwnProperty.call(message, 'max_bid'))
          $root.cosmos.base.v1beta1.Coin.encode(message.max_bid, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.lot_returns != null && message.lot_returns.length)
          for (let i = 0; i < message.lot_returns.length; ++i)
            $root.ununifi.auction.WeightedAddress.encode(message.lot_returns[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified CollateralAuction message, length delimited. Does not implicitly {@link ununifi.auction.CollateralAuction.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.CollateralAuction
       * @static
       * @param {ununifi.auction.ICollateralAuction} message CollateralAuction message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CollateralAuction.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CollateralAuction message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.CollateralAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.CollateralAuction} CollateralAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CollateralAuction.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.CollateralAuction();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.base_auction = $root.ununifi.auction.BaseAuction.decode(reader, reader.uint32());
              break;
            case 2:
              message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.max_bid = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              if (!(message.lot_returns && message.lot_returns.length)) message.lot_returns = [];
              message.lot_returns.push($root.ununifi.auction.WeightedAddress.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CollateralAuction message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.CollateralAuction
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.CollateralAuction} CollateralAuction
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CollateralAuction.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CollateralAuction message.
       * @function verify
       * @memberof ununifi.auction.CollateralAuction
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CollateralAuction.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.base_auction != null && message.hasOwnProperty('base_auction')) {
          let error = $root.ununifi.auction.BaseAuction.verify(message.base_auction);
          if (error) return 'base_auction.' + error;
        }
        if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.corresponding_debt);
          if (error) return 'corresponding_debt.' + error;
        }
        if (message.max_bid != null && message.hasOwnProperty('max_bid')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.max_bid);
          if (error) return 'max_bid.' + error;
        }
        if (message.lot_returns != null && message.hasOwnProperty('lot_returns')) {
          if (!Array.isArray(message.lot_returns)) return 'lot_returns: array expected';
          for (let i = 0; i < message.lot_returns.length; ++i) {
            let error = $root.ununifi.auction.WeightedAddress.verify(message.lot_returns[i]);
            if (error) return 'lot_returns.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a CollateralAuction message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.CollateralAuction
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.CollateralAuction} CollateralAuction
       */
      CollateralAuction.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.CollateralAuction) return object;
        let message = new $root.ununifi.auction.CollateralAuction();
        if (object.base_auction != null) {
          if (typeof object.base_auction !== 'object') throw TypeError('.ununifi.auction.CollateralAuction.base_auction: object expected');
          message.base_auction = $root.ununifi.auction.BaseAuction.fromObject(object.base_auction);
        }
        if (object.corresponding_debt != null) {
          if (typeof object.corresponding_debt !== 'object')
            throw TypeError('.ununifi.auction.CollateralAuction.corresponding_debt: object expected');
          message.corresponding_debt = $root.cosmos.base.v1beta1.Coin.fromObject(object.corresponding_debt);
        }
        if (object.max_bid != null) {
          if (typeof object.max_bid !== 'object') throw TypeError('.ununifi.auction.CollateralAuction.max_bid: object expected');
          message.max_bid = $root.cosmos.base.v1beta1.Coin.fromObject(object.max_bid);
        }
        if (object.lot_returns) {
          if (!Array.isArray(object.lot_returns)) throw TypeError('.ununifi.auction.CollateralAuction.lot_returns: array expected');
          message.lot_returns = [];
          for (let i = 0; i < object.lot_returns.length; ++i) {
            if (typeof object.lot_returns[i] !== 'object')
              throw TypeError('.ununifi.auction.CollateralAuction.lot_returns: object expected');
            message.lot_returns[i] = $root.ununifi.auction.WeightedAddress.fromObject(object.lot_returns[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a CollateralAuction message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.CollateralAuction
       * @static
       * @param {ununifi.auction.CollateralAuction} message CollateralAuction
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CollateralAuction.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.lot_returns = [];
        if (options.defaults) {
          object.base_auction = null;
          object.corresponding_debt = null;
          object.max_bid = null;
        }
        if (message.base_auction != null && message.hasOwnProperty('base_auction'))
          object.base_auction = $root.ununifi.auction.BaseAuction.toObject(message.base_auction, options);
        if (message.corresponding_debt != null && message.hasOwnProperty('corresponding_debt'))
          object.corresponding_debt = $root.cosmos.base.v1beta1.Coin.toObject(message.corresponding_debt, options);
        if (message.max_bid != null && message.hasOwnProperty('max_bid'))
          object.max_bid = $root.cosmos.base.v1beta1.Coin.toObject(message.max_bid, options);
        if (message.lot_returns && message.lot_returns.length) {
          object.lot_returns = [];
          for (let j = 0; j < message.lot_returns.length; ++j)
            object.lot_returns[j] = $root.ununifi.auction.WeightedAddress.toObject(message.lot_returns[j], options);
        }
        return object;
      };

      /**
       * Converts this CollateralAuction to JSON.
       * @function toJSON
       * @memberof ununifi.auction.CollateralAuction
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CollateralAuction.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CollateralAuction;
    })();

    auction.WeightedAddress = (function () {
      /**
       * Properties of a WeightedAddress.
       * @memberof ununifi.auction
       * @interface IWeightedAddress
       * @property {string|null} [address] WeightedAddress address
       * @property {string|null} [weight] WeightedAddress weight
       */

      /**
       * Constructs a new WeightedAddress.
       * @memberof ununifi.auction
       * @classdesc Represents a WeightedAddress.
       * @implements IWeightedAddress
       * @constructor
       * @param {ununifi.auction.IWeightedAddress=} [properties] Properties to set
       */
      function WeightedAddress(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * WeightedAddress address.
       * @member {string} address
       * @memberof ununifi.auction.WeightedAddress
       * @instance
       */
      WeightedAddress.prototype.address = '';

      /**
       * WeightedAddress weight.
       * @member {string} weight
       * @memberof ununifi.auction.WeightedAddress
       * @instance
       */
      WeightedAddress.prototype.weight = '';

      /**
       * Encodes the specified WeightedAddress message. Does not implicitly {@link ununifi.auction.WeightedAddress.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.WeightedAddress
       * @static
       * @param {ununifi.auction.IWeightedAddress} message WeightedAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      WeightedAddress.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
        if (message.weight != null && Object.hasOwnProperty.call(message, 'weight'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.weight);
        return writer;
      };

      /**
       * Encodes the specified WeightedAddress message, length delimited. Does not implicitly {@link ununifi.auction.WeightedAddress.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.WeightedAddress
       * @static
       * @param {ununifi.auction.IWeightedAddress} message WeightedAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      WeightedAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a WeightedAddress message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.WeightedAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.WeightedAddress} WeightedAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      WeightedAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.WeightedAddress();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a WeightedAddress message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.WeightedAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.WeightedAddress} WeightedAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      WeightedAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a WeightedAddress message.
       * @function verify
       * @memberof ununifi.auction.WeightedAddress
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      WeightedAddress.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        if (message.weight != null && message.hasOwnProperty('weight'))
          if (!$util.isString(message.weight)) return 'weight: string expected';
        return null;
      };

      /**
       * Creates a WeightedAddress message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.WeightedAddress
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.WeightedAddress} WeightedAddress
       */
      WeightedAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.WeightedAddress) return object;
        let message = new $root.ununifi.auction.WeightedAddress();
        if (object.address != null) message.address = String(object.address);
        if (object.weight != null) message.weight = String(object.weight);
        return message;
      };

      /**
       * Creates a plain object from a WeightedAddress message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.WeightedAddress
       * @static
       * @param {ununifi.auction.WeightedAddress} message WeightedAddress
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      WeightedAddress.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.address = '';
          object.weight = '';
        }
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        if (message.weight != null && message.hasOwnProperty('weight')) object.weight = message.weight;
        return object;
      };

      /**
       * Converts this WeightedAddress to JSON.
       * @function toJSON
       * @memberof ununifi.auction.WeightedAddress
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      WeightedAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return WeightedAddress;
    })();

    auction.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.auction
       * @interface IParams
       * @property {google.protobuf.IDuration|null} [max_auction_duration] Params max_auction_duration
       * @property {google.protobuf.IDuration|null} [bid_duration] Params bid_duration
       * @property {string|null} [increment_surplus] Params increment_surplus
       * @property {string|null} [increment_debt] Params increment_debt
       * @property {string|null} [increment_collateral] Params increment_collateral
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.auction
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.auction.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params max_auction_duration.
       * @member {google.protobuf.IDuration|null|undefined} max_auction_duration
       * @memberof ununifi.auction.Params
       * @instance
       */
      Params.prototype.max_auction_duration = null;

      /**
       * Params bid_duration.
       * @member {google.protobuf.IDuration|null|undefined} bid_duration
       * @memberof ununifi.auction.Params
       * @instance
       */
      Params.prototype.bid_duration = null;

      /**
       * Params increment_surplus.
       * @member {string} increment_surplus
       * @memberof ununifi.auction.Params
       * @instance
       */
      Params.prototype.increment_surplus = '';

      /**
       * Params increment_debt.
       * @member {string} increment_debt
       * @memberof ununifi.auction.Params
       * @instance
       */
      Params.prototype.increment_debt = '';

      /**
       * Params increment_collateral.
       * @member {string} increment_collateral
       * @memberof ununifi.auction.Params
       * @instance
       */
      Params.prototype.increment_collateral = '';

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.auction.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.Params
       * @static
       * @param {ununifi.auction.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.max_auction_duration != null && Object.hasOwnProperty.call(message, 'max_auction_duration'))
          $root.google.protobuf.Duration.encode(message.max_auction_duration, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.bid_duration != null && Object.hasOwnProperty.call(message, 'bid_duration'))
          $root.google.protobuf.Duration.encode(message.bid_duration, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.increment_surplus != null && Object.hasOwnProperty.call(message, 'increment_surplus'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.increment_surplus);
        if (message.increment_debt != null && Object.hasOwnProperty.call(message, 'increment_debt'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.increment_debt);
        if (message.increment_collateral != null && Object.hasOwnProperty.call(message, 'increment_collateral'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.increment_collateral);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.auction.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.Params
       * @static
       * @param {ununifi.auction.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.max_auction_duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.bid_duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.increment_surplus = reader.string();
              break;
            case 4:
              message.increment_debt = reader.string();
              break;
            case 5:
              message.increment_collateral = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.auction.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.max_auction_duration != null && message.hasOwnProperty('max_auction_duration')) {
          let error = $root.google.protobuf.Duration.verify(message.max_auction_duration);
          if (error) return 'max_auction_duration.' + error;
        }
        if (message.bid_duration != null && message.hasOwnProperty('bid_duration')) {
          let error = $root.google.protobuf.Duration.verify(message.bid_duration);
          if (error) return 'bid_duration.' + error;
        }
        if (message.increment_surplus != null && message.hasOwnProperty('increment_surplus'))
          if (!$util.isString(message.increment_surplus)) return 'increment_surplus: string expected';
        if (message.increment_debt != null && message.hasOwnProperty('increment_debt'))
          if (!$util.isString(message.increment_debt)) return 'increment_debt: string expected';
        if (message.increment_collateral != null && message.hasOwnProperty('increment_collateral'))
          if (!$util.isString(message.increment_collateral)) return 'increment_collateral: string expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.Params) return object;
        let message = new $root.ununifi.auction.Params();
        if (object.max_auction_duration != null) {
          if (typeof object.max_auction_duration !== 'object')
            throw TypeError('.ununifi.auction.Params.max_auction_duration: object expected');
          message.max_auction_duration = $root.google.protobuf.Duration.fromObject(object.max_auction_duration);
        }
        if (object.bid_duration != null) {
          if (typeof object.bid_duration !== 'object') throw TypeError('.ununifi.auction.Params.bid_duration: object expected');
          message.bid_duration = $root.google.protobuf.Duration.fromObject(object.bid_duration);
        }
        if (object.increment_surplus != null) message.increment_surplus = String(object.increment_surplus);
        if (object.increment_debt != null) message.increment_debt = String(object.increment_debt);
        if (object.increment_collateral != null) message.increment_collateral = String(object.increment_collateral);
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.Params
       * @static
       * @param {ununifi.auction.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.max_auction_duration = null;
          object.bid_duration = null;
          object.increment_surplus = '';
          object.increment_debt = '';
          object.increment_collateral = '';
        }
        if (message.max_auction_duration != null && message.hasOwnProperty('max_auction_duration'))
          object.max_auction_duration = $root.google.protobuf.Duration.toObject(message.max_auction_duration, options);
        if (message.bid_duration != null && message.hasOwnProperty('bid_duration'))
          object.bid_duration = $root.google.protobuf.Duration.toObject(message.bid_duration, options);
        if (message.increment_surplus != null && message.hasOwnProperty('increment_surplus'))
          object.increment_surplus = message.increment_surplus;
        if (message.increment_debt != null && message.hasOwnProperty('increment_debt')) object.increment_debt = message.increment_debt;
        if (message.increment_collateral != null && message.hasOwnProperty('increment_collateral'))
          object.increment_collateral = message.increment_collateral;
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.auction.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    auction.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.auction
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.auction.Msg#placeBid}.
       * @memberof ununifi.auction.Msg
       * @typedef PlaceBidCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.auction.MsgPlaceBidResponse} [response] MsgPlaceBidResponse
       */

      /**
       * Calls PlaceBid.
       * @function placeBid
       * @memberof ununifi.auction.Msg
       * @instance
       * @param {ununifi.auction.IMsgPlaceBid} request MsgPlaceBid message or plain object
       * @param {ununifi.auction.Msg.PlaceBidCallback} callback Node-style callback called with the error, if any, and MsgPlaceBidResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.placeBid = function placeBid(request, callback) {
          return this.rpcCall(placeBid, $root.ununifi.auction.MsgPlaceBid, $root.ununifi.auction.MsgPlaceBidResponse, request, callback);
        }),
        'name',
        { value: 'PlaceBid' },
      );

      /**
       * Calls PlaceBid.
       * @function placeBid
       * @memberof ununifi.auction.Msg
       * @instance
       * @param {ununifi.auction.IMsgPlaceBid} request MsgPlaceBid message or plain object
       * @returns {Promise<ununifi.auction.MsgPlaceBidResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    auction.MsgPlaceBid = (function () {
      /**
       * Properties of a MsgPlaceBid.
       * @memberof ununifi.auction
       * @interface IMsgPlaceBid
       * @property {Long|null} [auction_id] MsgPlaceBid auction_id
       * @property {string|null} [bidder] MsgPlaceBid bidder
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgPlaceBid amount
       */

      /**
       * Constructs a new MsgPlaceBid.
       * @memberof ununifi.auction
       * @classdesc Represents a MsgPlaceBid.
       * @implements IMsgPlaceBid
       * @constructor
       * @param {ununifi.auction.IMsgPlaceBid=} [properties] Properties to set
       */
      function MsgPlaceBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgPlaceBid auction_id.
       * @member {Long} auction_id
       * @memberof ununifi.auction.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.auction_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgPlaceBid bidder.
       * @member {string} bidder
       * @memberof ununifi.auction.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.bidder = '';

      /**
       * MsgPlaceBid amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.auction.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.amount = null;

      /**
       * Encodes the specified MsgPlaceBid message. Does not implicitly {@link ununifi.auction.MsgPlaceBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.MsgPlaceBid
       * @static
       * @param {ununifi.auction.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.auction_id != null && Object.hasOwnProperty.call(message, 'auction_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.auction_id);
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bidder);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgPlaceBid message, length delimited. Does not implicitly {@link ununifi.auction.MsgPlaceBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.MsgPlaceBid
       * @static
       * @param {ununifi.auction.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPlaceBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.MsgPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.MsgPlaceBid} MsgPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.MsgPlaceBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.auction_id = reader.uint64();
              break;
            case 2:
              message.bidder = reader.string();
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPlaceBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.MsgPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.MsgPlaceBid} MsgPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPlaceBid message.
       * @function verify
       * @memberof ununifi.auction.MsgPlaceBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPlaceBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.auction_id != null && message.hasOwnProperty('auction_id'))
          if (
            !$util.isInteger(message.auction_id) &&
            !(message.auction_id && $util.isInteger(message.auction_id.low) && $util.isInteger(message.auction_id.high))
          )
            return 'auction_id: integer|Long expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgPlaceBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.MsgPlaceBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.MsgPlaceBid} MsgPlaceBid
       */
      MsgPlaceBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.MsgPlaceBid) return object;
        let message = new $root.ununifi.auction.MsgPlaceBid();
        if (object.auction_id != null)
          if ($util.Long) (message.auction_id = $util.Long.fromValue(object.auction_id)).unsigned = true;
          else if (typeof object.auction_id === 'string') message.auction_id = parseInt(object.auction_id, 10);
          else if (typeof object.auction_id === 'number') message.auction_id = object.auction_id;
          else if (typeof object.auction_id === 'object')
            message.auction_id = new $util.LongBits(object.auction_id.low >>> 0, object.auction_id.high >>> 0).toNumber(true);
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.auction.MsgPlaceBid.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgPlaceBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.MsgPlaceBid
       * @static
       * @param {ununifi.auction.MsgPlaceBid} message MsgPlaceBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPlaceBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.auction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.auction_id = options.longs === String ? '0' : 0;
          object.bidder = '';
          object.amount = null;
        }
        if (message.auction_id != null && message.hasOwnProperty('auction_id'))
          if (typeof message.auction_id === 'number')
            object.auction_id = options.longs === String ? String(message.auction_id) : message.auction_id;
          else
            object.auction_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.auction_id)
                : options.longs === Number
                ? new $util.LongBits(message.auction_id.low >>> 0, message.auction_id.high >>> 0).toNumber(true)
                : message.auction_id;
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this MsgPlaceBid to JSON.
       * @function toJSON
       * @memberof ununifi.auction.MsgPlaceBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPlaceBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPlaceBid;
    })();

    auction.MsgPlaceBidResponse = (function () {
      /**
       * Properties of a MsgPlaceBidResponse.
       * @memberof ununifi.auction
       * @interface IMsgPlaceBidResponse
       */

      /**
       * Constructs a new MsgPlaceBidResponse.
       * @memberof ununifi.auction
       * @classdesc Represents a MsgPlaceBidResponse.
       * @implements IMsgPlaceBidResponse
       * @constructor
       * @param {ununifi.auction.IMsgPlaceBidResponse=} [properties] Properties to set
       */
      function MsgPlaceBidResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgPlaceBidResponse message. Does not implicitly {@link ununifi.auction.MsgPlaceBidResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @static
       * @param {ununifi.auction.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBidResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgPlaceBidResponse message, length delimited. Does not implicitly {@link ununifi.auction.MsgPlaceBidResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @static
       * @param {ununifi.auction.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPlaceBidResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.MsgPlaceBidResponse} MsgPlaceBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBidResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.MsgPlaceBidResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPlaceBidResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.MsgPlaceBidResponse} MsgPlaceBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBidResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPlaceBidResponse message.
       * @function verify
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPlaceBidResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgPlaceBidResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.MsgPlaceBidResponse} MsgPlaceBidResponse
       */
      MsgPlaceBidResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.MsgPlaceBidResponse) return object;
        return new $root.ununifi.auction.MsgPlaceBidResponse();
      };

      /**
       * Creates a plain object from a MsgPlaceBidResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @static
       * @param {ununifi.auction.MsgPlaceBidResponse} message MsgPlaceBidResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPlaceBidResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgPlaceBidResponse to JSON.
       * @function toJSON
       * @memberof ununifi.auction.MsgPlaceBidResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPlaceBidResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPlaceBidResponse;
    })();

    auction.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.auction
       * @interface IGenesisState
       * @property {Long|null} [next_auction_id] GenesisState next_auction_id
       * @property {ununifi.auction.IParams|null} [params] GenesisState params
       * @property {Array.<google.protobuf.IAny>|null} [auctions] GenesisState auctions
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.auction
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.auction.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.auctions = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState next_auction_id.
       * @member {Long} next_auction_id
       * @memberof ununifi.auction.GenesisState
       * @instance
       */
      GenesisState.prototype.next_auction_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * GenesisState params.
       * @member {ununifi.auction.IParams|null|undefined} params
       * @memberof ununifi.auction.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState auctions.
       * @member {Array.<google.protobuf.IAny>} auctions
       * @memberof ununifi.auction.GenesisState
       * @instance
       */
      GenesisState.prototype.auctions = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.auction.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.auction.GenesisState
       * @static
       * @param {ununifi.auction.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.next_auction_id != null && Object.hasOwnProperty.call(message, 'next_auction_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.next_auction_id);
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.auction.Params.encode(message.params, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.auctions != null && message.auctions.length)
          for (let i = 0; i < message.auctions.length; ++i)
            $root.google.protobuf.Any.encode(message.auctions[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.auction.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.auction.GenesisState
       * @static
       * @param {ununifi.auction.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.auction.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.auction.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.auction.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.next_auction_id = reader.uint64();
              break;
            case 2:
              message.params = $root.ununifi.auction.Params.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.auctions && message.auctions.length)) message.auctions = [];
              message.auctions.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.auction.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.auction.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.auction.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.next_auction_id != null && message.hasOwnProperty('next_auction_id'))
          if (
            !$util.isInteger(message.next_auction_id) &&
            !(message.next_auction_id && $util.isInteger(message.next_auction_id.low) && $util.isInteger(message.next_auction_id.high))
          )
            return 'next_auction_id: integer|Long expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.auction.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.auctions != null && message.hasOwnProperty('auctions')) {
          if (!Array.isArray(message.auctions)) return 'auctions: array expected';
          for (let i = 0; i < message.auctions.length; ++i) {
            let error = $root.google.protobuf.Any.verify(message.auctions[i]);
            if (error) return 'auctions.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.auction.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.auction.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.auction.GenesisState) return object;
        let message = new $root.ununifi.auction.GenesisState();
        if (object.next_auction_id != null)
          if ($util.Long) (message.next_auction_id = $util.Long.fromValue(object.next_auction_id)).unsigned = true;
          else if (typeof object.next_auction_id === 'string') message.next_auction_id = parseInt(object.next_auction_id, 10);
          else if (typeof object.next_auction_id === 'number') message.next_auction_id = object.next_auction_id;
          else if (typeof object.next_auction_id === 'object')
            message.next_auction_id = new $util.LongBits(object.next_auction_id.low >>> 0, object.next_auction_id.high >>> 0).toNumber(
              true,
            );
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.auction.GenesisState.params: object expected');
          message.params = $root.ununifi.auction.Params.fromObject(object.params);
        }
        if (object.auctions) {
          if (!Array.isArray(object.auctions)) throw TypeError('.ununifi.auction.GenesisState.auctions: array expected');
          message.auctions = [];
          for (let i = 0; i < object.auctions.length; ++i) {
            if (typeof object.auctions[i] !== 'object') throw TypeError('.ununifi.auction.GenesisState.auctions: object expected');
            message.auctions[i] = $root.google.protobuf.Any.fromObject(object.auctions[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.auction.GenesisState
       * @static
       * @param {ununifi.auction.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.auctions = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.next_auction_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.next_auction_id = options.longs === String ? '0' : 0;
          object.params = null;
        }
        if (message.next_auction_id != null && message.hasOwnProperty('next_auction_id'))
          if (typeof message.next_auction_id === 'number')
            object.next_auction_id = options.longs === String ? String(message.next_auction_id) : message.next_auction_id;
          else
            object.next_auction_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.next_auction_id)
                : options.longs === Number
                ? new $util.LongBits(message.next_auction_id.low >>> 0, message.next_auction_id.high >>> 0).toNumber(true)
                : message.next_auction_id;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.auction.Params.toObject(message.params, options);
        if (message.auctions && message.auctions.length) {
          object.auctions = [];
          for (let j = 0; j < message.auctions.length; ++j)
            object.auctions[j] = $root.google.protobuf.Any.toObject(message.auctions[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.auction.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    return auction;
  })();

  ununifi.cdp = (function () {
    /**
     * Namespace cdp.
     * @memberof ununifi
     * @namespace
     */
    const cdp = {};

    cdp.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.cdp
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.cdp.Query#params}.
       * @memberof ununifi.cdp.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.cdp.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(params, $root.ununifi.cdp.QueryParamsRequest, $root.ununifi.cdp.QueryParamsResponse, request, callback);
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.cdp.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Query#cdp}.
       * @memberof ununifi.cdp.Query
       * @typedef CdpCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.QueryGetCdpResponse} [response] QueryGetCdpResponse
       */

      /**
       * Calls Cdp.
       * @function cdp
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryGetCdpRequest} request QueryGetCdpRequest message or plain object
       * @param {ununifi.cdp.Query.CdpCallback} callback Node-style callback called with the error, if any, and QueryGetCdpResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.cdp = function cdp(request, callback) {
          return this.rpcCall(cdp, $root.ununifi.cdp.QueryGetCdpRequest, $root.ununifi.cdp.QueryGetCdpResponse, request, callback);
        }),
        'name',
        { value: 'Cdp' },
      );

      /**
       * Calls Cdp.
       * @function cdp
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryGetCdpRequest} request QueryGetCdpRequest message or plain object
       * @returns {Promise<ununifi.cdp.QueryGetCdpResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Query#cdpAll}.
       * @memberof ununifi.cdp.Query
       * @typedef CdpAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.QueryAllCdpResponse} [response] QueryAllCdpResponse
       */

      /**
       * Calls CdpAll.
       * @function cdpAll
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryAllCdpRequest} request QueryAllCdpRequest message or plain object
       * @param {ununifi.cdp.Query.CdpAllCallback} callback Node-style callback called with the error, if any, and QueryAllCdpResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.cdpAll = function cdpAll(request, callback) {
          return this.rpcCall(cdpAll, $root.ununifi.cdp.QueryAllCdpRequest, $root.ununifi.cdp.QueryAllCdpResponse, request, callback);
        }),
        'name',
        { value: 'CdpAll' },
      );

      /**
       * Calls CdpAll.
       * @function cdpAll
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryAllCdpRequest} request QueryAllCdpRequest message or plain object
       * @returns {Promise<ununifi.cdp.QueryAllCdpResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Query#accountAll}.
       * @memberof ununifi.cdp.Query
       * @typedef AccountAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.QueryAllAccountResponse} [response] QueryAllAccountResponse
       */

      /**
       * Calls AccountAll.
       * @function accountAll
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryAllAccountRequest} request QueryAllAccountRequest message or plain object
       * @param {ununifi.cdp.Query.AccountAllCallback} callback Node-style callback called with the error, if any, and QueryAllAccountResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.accountAll = function accountAll(request, callback) {
          return this.rpcCall(
            accountAll,
            $root.ununifi.cdp.QueryAllAccountRequest,
            $root.ununifi.cdp.QueryAllAccountResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AccountAll' },
      );

      /**
       * Calls AccountAll.
       * @function accountAll
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryAllAccountRequest} request QueryAllAccountRequest message or plain object
       * @returns {Promise<ununifi.cdp.QueryAllAccountResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Query#depositAll}.
       * @memberof ununifi.cdp.Query
       * @typedef DepositAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.QueryAllDepositResponse} [response] QueryAllDepositResponse
       */

      /**
       * Calls DepositAll.
       * @function depositAll
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryAllDepositRequest} request QueryAllDepositRequest message or plain object
       * @param {ununifi.cdp.Query.DepositAllCallback} callback Node-style callback called with the error, if any, and QueryAllDepositResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.depositAll = function depositAll(request, callback) {
          return this.rpcCall(
            depositAll,
            $root.ununifi.cdp.QueryAllDepositRequest,
            $root.ununifi.cdp.QueryAllDepositResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DepositAll' },
      );

      /**
       * Calls DepositAll.
       * @function depositAll
       * @memberof ununifi.cdp.Query
       * @instance
       * @param {ununifi.cdp.IQueryAllDepositRequest} request QueryAllDepositRequest message or plain object
       * @returns {Promise<ununifi.cdp.QueryAllDepositResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    cdp.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.cdp
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.cdp.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.cdp.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryParamsRequest
       * @static
       * @param {ununifi.cdp.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryParamsRequest
       * @static
       * @param {ununifi.cdp.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.cdp.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryParamsRequest) return object;
        return new $root.ununifi.cdp.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryParamsRequest
       * @static
       * @param {ununifi.cdp.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    cdp.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.cdp
       * @interface IQueryParamsResponse
       * @property {ununifi.cdp.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.cdp.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.cdp.IParams|null|undefined} params
       * @memberof ununifi.cdp.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.cdp.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryParamsResponse
       * @static
       * @param {ununifi.cdp.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.cdp.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryParamsResponse
       * @static
       * @param {ununifi.cdp.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.cdp.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.cdp.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.cdp.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryParamsResponse) return object;
        let message = new $root.ununifi.cdp.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.cdp.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.cdp.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryParamsResponse
       * @static
       * @param {ununifi.cdp.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.cdp.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    cdp.QueryGetCdpRequest = (function () {
      /**
       * Properties of a QueryGetCdpRequest.
       * @memberof ununifi.cdp
       * @interface IQueryGetCdpRequest
       * @property {string|null} [owner] QueryGetCdpRequest owner
       * @property {string|null} [collateral_type] QueryGetCdpRequest collateral_type
       */

      /**
       * Constructs a new QueryGetCdpRequest.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryGetCdpRequest.
       * @implements IQueryGetCdpRequest
       * @constructor
       * @param {ununifi.cdp.IQueryGetCdpRequest=} [properties] Properties to set
       */
      function QueryGetCdpRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetCdpRequest owner.
       * @member {string} owner
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @instance
       */
      QueryGetCdpRequest.prototype.owner = '';

      /**
       * QueryGetCdpRequest collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @instance
       */
      QueryGetCdpRequest.prototype.collateral_type = '';

      /**
       * Encodes the specified QueryGetCdpRequest message. Does not implicitly {@link ununifi.cdp.QueryGetCdpRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @static
       * @param {ununifi.cdp.IQueryGetCdpRequest} message QueryGetCdpRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetCdpRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
        return writer;
      };

      /**
       * Encodes the specified QueryGetCdpRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryGetCdpRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @static
       * @param {ununifi.cdp.IQueryGetCdpRequest} message QueryGetCdpRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetCdpRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetCdpRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryGetCdpRequest} QueryGetCdpRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetCdpRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryGetCdpRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.collateral_type = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetCdpRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryGetCdpRequest} QueryGetCdpRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetCdpRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetCdpRequest message.
       * @function verify
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetCdpRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        return null;
      };

      /**
       * Creates a QueryGetCdpRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryGetCdpRequest} QueryGetCdpRequest
       */
      QueryGetCdpRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryGetCdpRequest) return object;
        let message = new $root.ununifi.cdp.QueryGetCdpRequest();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetCdpRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @static
       * @param {ununifi.cdp.QueryGetCdpRequest} message QueryGetCdpRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetCdpRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.collateral_type = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        return object;
      };

      /**
       * Converts this QueryGetCdpRequest to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryGetCdpRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetCdpRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetCdpRequest;
    })();

    cdp.QueryGetCdpResponse = (function () {
      /**
       * Properties of a QueryGetCdpResponse.
       * @memberof ununifi.cdp
       * @interface IQueryGetCdpResponse
       * @property {ununifi.cdp.IAugmentedCdp|null} [cdp] QueryGetCdpResponse cdp
       */

      /**
       * Constructs a new QueryGetCdpResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryGetCdpResponse.
       * @implements IQueryGetCdpResponse
       * @constructor
       * @param {ununifi.cdp.IQueryGetCdpResponse=} [properties] Properties to set
       */
      function QueryGetCdpResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetCdpResponse cdp.
       * @member {ununifi.cdp.IAugmentedCdp|null|undefined} cdp
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @instance
       */
      QueryGetCdpResponse.prototype.cdp = null;

      /**
       * Encodes the specified QueryGetCdpResponse message. Does not implicitly {@link ununifi.cdp.QueryGetCdpResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @static
       * @param {ununifi.cdp.IQueryGetCdpResponse} message QueryGetCdpResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetCdpResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.cdp != null && Object.hasOwnProperty.call(message, 'cdp'))
          $root.ununifi.cdp.AugmentedCdp.encode(message.cdp, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetCdpResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryGetCdpResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @static
       * @param {ununifi.cdp.IQueryGetCdpResponse} message QueryGetCdpResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetCdpResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetCdpResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryGetCdpResponse} QueryGetCdpResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetCdpResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryGetCdpResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cdp = $root.ununifi.cdp.AugmentedCdp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetCdpResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryGetCdpResponse} QueryGetCdpResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetCdpResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetCdpResponse message.
       * @function verify
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetCdpResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.cdp != null && message.hasOwnProperty('cdp')) {
          let error = $root.ununifi.cdp.AugmentedCdp.verify(message.cdp);
          if (error) return 'cdp.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetCdpResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryGetCdpResponse} QueryGetCdpResponse
       */
      QueryGetCdpResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryGetCdpResponse) return object;
        let message = new $root.ununifi.cdp.QueryGetCdpResponse();
        if (object.cdp != null) {
          if (typeof object.cdp !== 'object') throw TypeError('.ununifi.cdp.QueryGetCdpResponse.cdp: object expected');
          message.cdp = $root.ununifi.cdp.AugmentedCdp.fromObject(object.cdp);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetCdpResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @static
       * @param {ununifi.cdp.QueryGetCdpResponse} message QueryGetCdpResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetCdpResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.cdp = null;
        if (message.cdp != null && message.hasOwnProperty('cdp'))
          object.cdp = $root.ununifi.cdp.AugmentedCdp.toObject(message.cdp, options);
        return object;
      };

      /**
       * Converts this QueryGetCdpResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryGetCdpResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetCdpResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetCdpResponse;
    })();

    cdp.QueryAllCdpRequest = (function () {
      /**
       * Properties of a QueryAllCdpRequest.
       * @memberof ununifi.cdp
       * @interface IQueryAllCdpRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllCdpRequest pagination
       */

      /**
       * Constructs a new QueryAllCdpRequest.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryAllCdpRequest.
       * @implements IQueryAllCdpRequest
       * @constructor
       * @param {ununifi.cdp.IQueryAllCdpRequest=} [properties] Properties to set
       */
      function QueryAllCdpRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllCdpRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @instance
       */
      QueryAllCdpRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllCdpRequest message. Does not implicitly {@link ununifi.cdp.QueryAllCdpRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @static
       * @param {ununifi.cdp.IQueryAllCdpRequest} message QueryAllCdpRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllCdpRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllCdpRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllCdpRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @static
       * @param {ununifi.cdp.IQueryAllCdpRequest} message QueryAllCdpRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllCdpRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllCdpRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryAllCdpRequest} QueryAllCdpRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllCdpRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryAllCdpRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllCdpRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryAllCdpRequest} QueryAllCdpRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllCdpRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllCdpRequest message.
       * @function verify
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllCdpRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllCdpRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryAllCdpRequest} QueryAllCdpRequest
       */
      QueryAllCdpRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryAllCdpRequest) return object;
        let message = new $root.ununifi.cdp.QueryAllCdpRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.ununifi.cdp.QueryAllCdpRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllCdpRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @static
       * @param {ununifi.cdp.QueryAllCdpRequest} message QueryAllCdpRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllCdpRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllCdpRequest to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryAllCdpRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllCdpRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllCdpRequest;
    })();

    cdp.QueryAllCdpResponse = (function () {
      /**
       * Properties of a QueryAllCdpResponse.
       * @memberof ununifi.cdp
       * @interface IQueryAllCdpResponse
       * @property {Array.<ununifi.cdp.IAugmentedCdp>|null} [cdp] QueryAllCdpResponse cdp
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllCdpResponse pagination
       */

      /**
       * Constructs a new QueryAllCdpResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryAllCdpResponse.
       * @implements IQueryAllCdpResponse
       * @constructor
       * @param {ununifi.cdp.IQueryAllCdpResponse=} [properties] Properties to set
       */
      function QueryAllCdpResponse(properties) {
        this.cdp = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllCdpResponse cdp.
       * @member {Array.<ununifi.cdp.IAugmentedCdp>} cdp
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @instance
       */
      QueryAllCdpResponse.prototype.cdp = $util.emptyArray;

      /**
       * QueryAllCdpResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @instance
       */
      QueryAllCdpResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllCdpResponse message. Does not implicitly {@link ununifi.cdp.QueryAllCdpResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @static
       * @param {ununifi.cdp.IQueryAllCdpResponse} message QueryAllCdpResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllCdpResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.cdp != null && message.cdp.length)
          for (let i = 0; i < message.cdp.length; ++i)
            $root.ununifi.cdp.AugmentedCdp.encode(message.cdp[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllCdpResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllCdpResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @static
       * @param {ununifi.cdp.IQueryAllCdpResponse} message QueryAllCdpResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllCdpResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllCdpResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryAllCdpResponse} QueryAllCdpResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllCdpResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryAllCdpResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.cdp && message.cdp.length)) message.cdp = [];
              message.cdp.push($root.ununifi.cdp.AugmentedCdp.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllCdpResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryAllCdpResponse} QueryAllCdpResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllCdpResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllCdpResponse message.
       * @function verify
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllCdpResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.cdp != null && message.hasOwnProperty('cdp')) {
          if (!Array.isArray(message.cdp)) return 'cdp: array expected';
          for (let i = 0; i < message.cdp.length; ++i) {
            let error = $root.ununifi.cdp.AugmentedCdp.verify(message.cdp[i]);
            if (error) return 'cdp.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllCdpResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryAllCdpResponse} QueryAllCdpResponse
       */
      QueryAllCdpResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryAllCdpResponse) return object;
        let message = new $root.ununifi.cdp.QueryAllCdpResponse();
        if (object.cdp) {
          if (!Array.isArray(object.cdp)) throw TypeError('.ununifi.cdp.QueryAllCdpResponse.cdp: array expected');
          message.cdp = [];
          for (let i = 0; i < object.cdp.length; ++i) {
            if (typeof object.cdp[i] !== 'object') throw TypeError('.ununifi.cdp.QueryAllCdpResponse.cdp: object expected');
            message.cdp[i] = $root.ununifi.cdp.AugmentedCdp.fromObject(object.cdp[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.ununifi.cdp.QueryAllCdpResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllCdpResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @static
       * @param {ununifi.cdp.QueryAllCdpResponse} message QueryAllCdpResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllCdpResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.cdp = [];
        if (options.defaults) object.pagination = null;
        if (message.cdp && message.cdp.length) {
          object.cdp = [];
          for (let j = 0; j < message.cdp.length; ++j) object.cdp[j] = $root.ununifi.cdp.AugmentedCdp.toObject(message.cdp[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllCdpResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryAllCdpResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllCdpResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllCdpResponse;
    })();

    cdp.QueryAllAccountRequest = (function () {
      /**
       * Properties of a QueryAllAccountRequest.
       * @memberof ununifi.cdp
       * @interface IQueryAllAccountRequest
       */

      /**
       * Constructs a new QueryAllAccountRequest.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryAllAccountRequest.
       * @implements IQueryAllAccountRequest
       * @constructor
       * @param {ununifi.cdp.IQueryAllAccountRequest=} [properties] Properties to set
       */
      function QueryAllAccountRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryAllAccountRequest message. Does not implicitly {@link ununifi.cdp.QueryAllAccountRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @static
       * @param {ununifi.cdp.IQueryAllAccountRequest} message QueryAllAccountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAccountRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryAllAccountRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllAccountRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @static
       * @param {ununifi.cdp.IQueryAllAccountRequest} message QueryAllAccountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllAccountRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryAllAccountRequest} QueryAllAccountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAccountRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryAllAccountRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllAccountRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryAllAccountRequest} QueryAllAccountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAccountRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllAccountRequest message.
       * @function verify
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllAccountRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryAllAccountRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryAllAccountRequest} QueryAllAccountRequest
       */
      QueryAllAccountRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryAllAccountRequest) return object;
        return new $root.ununifi.cdp.QueryAllAccountRequest();
      };

      /**
       * Creates a plain object from a QueryAllAccountRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @static
       * @param {ununifi.cdp.QueryAllAccountRequest} message QueryAllAccountRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllAccountRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryAllAccountRequest to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryAllAccountRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllAccountRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllAccountRequest;
    })();

    cdp.QueryAllAccountResponse = (function () {
      /**
       * Properties of a QueryAllAccountResponse.
       * @memberof ununifi.cdp
       * @interface IQueryAllAccountResponse
       * @property {Array.<google.protobuf.IAny>|null} [accounts] QueryAllAccountResponse accounts
       */

      /**
       * Constructs a new QueryAllAccountResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryAllAccountResponse.
       * @implements IQueryAllAccountResponse
       * @constructor
       * @param {ununifi.cdp.IQueryAllAccountResponse=} [properties] Properties to set
       */
      function QueryAllAccountResponse(properties) {
        this.accounts = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllAccountResponse accounts.
       * @member {Array.<google.protobuf.IAny>} accounts
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @instance
       */
      QueryAllAccountResponse.prototype.accounts = $util.emptyArray;

      /**
       * Encodes the specified QueryAllAccountResponse message. Does not implicitly {@link ununifi.cdp.QueryAllAccountResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @static
       * @param {ununifi.cdp.IQueryAllAccountResponse} message QueryAllAccountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAccountResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.accounts != null && message.accounts.length)
          for (let i = 0; i < message.accounts.length; ++i)
            $root.google.protobuf.Any.encode(message.accounts[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllAccountResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllAccountResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @static
       * @param {ununifi.cdp.IQueryAllAccountResponse} message QueryAllAccountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllAccountResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryAllAccountResponse} QueryAllAccountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAccountResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryAllAccountResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.accounts && message.accounts.length)) message.accounts = [];
              message.accounts.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllAccountResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryAllAccountResponse} QueryAllAccountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllAccountResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllAccountResponse message.
       * @function verify
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllAccountResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.accounts != null && message.hasOwnProperty('accounts')) {
          if (!Array.isArray(message.accounts)) return 'accounts: array expected';
          for (let i = 0; i < message.accounts.length; ++i) {
            let error = $root.google.protobuf.Any.verify(message.accounts[i]);
            if (error) return 'accounts.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryAllAccountResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryAllAccountResponse} QueryAllAccountResponse
       */
      QueryAllAccountResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryAllAccountResponse) return object;
        let message = new $root.ununifi.cdp.QueryAllAccountResponse();
        if (object.accounts) {
          if (!Array.isArray(object.accounts)) throw TypeError('.ununifi.cdp.QueryAllAccountResponse.accounts: array expected');
          message.accounts = [];
          for (let i = 0; i < object.accounts.length; ++i) {
            if (typeof object.accounts[i] !== 'object') throw TypeError('.ununifi.cdp.QueryAllAccountResponse.accounts: object expected');
            message.accounts[i] = $root.google.protobuf.Any.fromObject(object.accounts[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllAccountResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @static
       * @param {ununifi.cdp.QueryAllAccountResponse} message QueryAllAccountResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllAccountResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.accounts = [];
        if (message.accounts && message.accounts.length) {
          object.accounts = [];
          for (let j = 0; j < message.accounts.length; ++j)
            object.accounts[j] = $root.google.protobuf.Any.toObject(message.accounts[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryAllAccountResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryAllAccountResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllAccountResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllAccountResponse;
    })();

    cdp.QueryAllDepositRequest = (function () {
      /**
       * Properties of a QueryAllDepositRequest.
       * @memberof ununifi.cdp
       * @interface IQueryAllDepositRequest
       * @property {string|null} [owner] QueryAllDepositRequest owner
       * @property {string|null} [collateral_type] QueryAllDepositRequest collateral_type
       */

      /**
       * Constructs a new QueryAllDepositRequest.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryAllDepositRequest.
       * @implements IQueryAllDepositRequest
       * @constructor
       * @param {ununifi.cdp.IQueryAllDepositRequest=} [properties] Properties to set
       */
      function QueryAllDepositRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllDepositRequest owner.
       * @member {string} owner
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @instance
       */
      QueryAllDepositRequest.prototype.owner = '';

      /**
       * QueryAllDepositRequest collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @instance
       */
      QueryAllDepositRequest.prototype.collateral_type = '';

      /**
       * Encodes the specified QueryAllDepositRequest message. Does not implicitly {@link ununifi.cdp.QueryAllDepositRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @static
       * @param {ununifi.cdp.IQueryAllDepositRequest} message QueryAllDepositRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
        return writer;
      };

      /**
       * Encodes the specified QueryAllDepositRequest message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllDepositRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @static
       * @param {ununifi.cdp.IQueryAllDepositRequest} message QueryAllDepositRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllDepositRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryAllDepositRequest} QueryAllDepositRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryAllDepositRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.collateral_type = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllDepositRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryAllDepositRequest} QueryAllDepositRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllDepositRequest message.
       * @function verify
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllDepositRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        return null;
      };

      /**
       * Creates a QueryAllDepositRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryAllDepositRequest} QueryAllDepositRequest
       */
      QueryAllDepositRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryAllDepositRequest) return object;
        let message = new $root.ununifi.cdp.QueryAllDepositRequest();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        return message;
      };

      /**
       * Creates a plain object from a QueryAllDepositRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @static
       * @param {ununifi.cdp.QueryAllDepositRequest} message QueryAllDepositRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllDepositRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.collateral_type = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        return object;
      };

      /**
       * Converts this QueryAllDepositRequest to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryAllDepositRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllDepositRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllDepositRequest;
    })();

    cdp.QueryAllDepositResponse = (function () {
      /**
       * Properties of a QueryAllDepositResponse.
       * @memberof ununifi.cdp
       * @interface IQueryAllDepositResponse
       * @property {Array.<ununifi.cdp.IDeposit>|null} [deposits] QueryAllDepositResponse deposits
       */

      /**
       * Constructs a new QueryAllDepositResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a QueryAllDepositResponse.
       * @implements IQueryAllDepositResponse
       * @constructor
       * @param {ununifi.cdp.IQueryAllDepositResponse=} [properties] Properties to set
       */
      function QueryAllDepositResponse(properties) {
        this.deposits = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllDepositResponse deposits.
       * @member {Array.<ununifi.cdp.IDeposit>} deposits
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @instance
       */
      QueryAllDepositResponse.prototype.deposits = $util.emptyArray;

      /**
       * Encodes the specified QueryAllDepositResponse message. Does not implicitly {@link ununifi.cdp.QueryAllDepositResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @static
       * @param {ununifi.cdp.IQueryAllDepositResponse} message QueryAllDepositResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deposits != null && message.deposits.length)
          for (let i = 0; i < message.deposits.length; ++i)
            $root.ununifi.cdp.Deposit.encode(message.deposits[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllDepositResponse message, length delimited. Does not implicitly {@link ununifi.cdp.QueryAllDepositResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @static
       * @param {ununifi.cdp.IQueryAllDepositResponse} message QueryAllDepositResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllDepositResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.QueryAllDepositResponse} QueryAllDepositResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.QueryAllDepositResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.deposits && message.deposits.length)) message.deposits = [];
              message.deposits.push($root.ununifi.cdp.Deposit.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllDepositResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.QueryAllDepositResponse} QueryAllDepositResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllDepositResponse message.
       * @function verify
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllDepositResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deposits != null && message.hasOwnProperty('deposits')) {
          if (!Array.isArray(message.deposits)) return 'deposits: array expected';
          for (let i = 0; i < message.deposits.length; ++i) {
            let error = $root.ununifi.cdp.Deposit.verify(message.deposits[i]);
            if (error) return 'deposits.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryAllDepositResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.QueryAllDepositResponse} QueryAllDepositResponse
       */
      QueryAllDepositResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.QueryAllDepositResponse) return object;
        let message = new $root.ununifi.cdp.QueryAllDepositResponse();
        if (object.deposits) {
          if (!Array.isArray(object.deposits)) throw TypeError('.ununifi.cdp.QueryAllDepositResponse.deposits: array expected');
          message.deposits = [];
          for (let i = 0; i < object.deposits.length; ++i) {
            if (typeof object.deposits[i] !== 'object') throw TypeError('.ununifi.cdp.QueryAllDepositResponse.deposits: object expected');
            message.deposits[i] = $root.ununifi.cdp.Deposit.fromObject(object.deposits[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllDepositResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @static
       * @param {ununifi.cdp.QueryAllDepositResponse} message QueryAllDepositResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllDepositResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.deposits = [];
        if (message.deposits && message.deposits.length) {
          object.deposits = [];
          for (let j = 0; j < message.deposits.length; ++j)
            object.deposits[j] = $root.ununifi.cdp.Deposit.toObject(message.deposits[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryAllDepositResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.QueryAllDepositResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllDepositResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllDepositResponse;
    })();

    cdp.Cdp = (function () {
      /**
       * Properties of a Cdp.
       * @memberof ununifi.cdp
       * @interface ICdp
       * @property {Long|null} [id] Cdp id
       * @property {string|null} [owner] Cdp owner
       * @property {string|null} [type] Cdp type
       * @property {cosmos.base.v1beta1.ICoin|null} [collateral] Cdp collateral
       * @property {cosmos.base.v1beta1.ICoin|null} [principal] Cdp principal
       * @property {cosmos.base.v1beta1.ICoin|null} [accumulated_fees] Cdp accumulated_fees
       * @property {google.protobuf.ITimestamp|null} [fees_updated] Cdp fees_updated
       * @property {string|null} [interest_factor] Cdp interest_factor
       */

      /**
       * Constructs a new Cdp.
       * @memberof ununifi.cdp
       * @classdesc Represents a Cdp.
       * @implements ICdp
       * @constructor
       * @param {ununifi.cdp.ICdp=} [properties] Properties to set
       */
      function Cdp(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Cdp id.
       * @member {Long} id
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Cdp owner.
       * @member {string} owner
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.owner = '';

      /**
       * Cdp type.
       * @member {string} type
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.type = '';

      /**
       * Cdp collateral.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.collateral = null;

      /**
       * Cdp principal.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} principal
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.principal = null;

      /**
       * Cdp accumulated_fees.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} accumulated_fees
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.accumulated_fees = null;

      /**
       * Cdp fees_updated.
       * @member {google.protobuf.ITimestamp|null|undefined} fees_updated
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.fees_updated = null;

      /**
       * Cdp interest_factor.
       * @member {string} interest_factor
       * @memberof ununifi.cdp.Cdp
       * @instance
       */
      Cdp.prototype.interest_factor = '';

      /**
       * Encodes the specified Cdp message. Does not implicitly {@link ununifi.cdp.Cdp.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.Cdp
       * @static
       * @param {ununifi.cdp.ICdp} message Cdp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Cdp.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
        if (message.type != null && Object.hasOwnProperty.call(message, 'type'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.type);
        if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
          $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.principal != null && Object.hasOwnProperty.call(message, 'principal'))
          $root.cosmos.base.v1beta1.Coin.encode(message.principal, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        if (message.accumulated_fees != null && Object.hasOwnProperty.call(message, 'accumulated_fees'))
          $root.cosmos.base.v1beta1.Coin.encode(message.accumulated_fees, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
        if (message.fees_updated != null && Object.hasOwnProperty.call(message, 'fees_updated'))
          $root.google.protobuf.Timestamp.encode(message.fees_updated, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.interest_factor != null && Object.hasOwnProperty.call(message, 'interest_factor'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.interest_factor);
        return writer;
      };

      /**
       * Encodes the specified Cdp message, length delimited. Does not implicitly {@link ununifi.cdp.Cdp.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.Cdp
       * @static
       * @param {ununifi.cdp.ICdp} message Cdp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Cdp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Cdp message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.Cdp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.Cdp} Cdp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Cdp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.Cdp();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.owner = reader.string();
              break;
            case 3:
              message.type = reader.string();
              break;
            case 4:
              message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 5:
              message.principal = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 6:
              message.accumulated_fees = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 7:
              message.fees_updated = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 8:
              message.interest_factor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Cdp message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.Cdp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.Cdp} Cdp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Cdp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Cdp message.
       * @function verify
       * @memberof ununifi.cdp.Cdp
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Cdp.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.type != null && message.hasOwnProperty('type')) if (!$util.isString(message.type)) return 'type: string expected';
        if (message.collateral != null && message.hasOwnProperty('collateral')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
          if (error) return 'collateral.' + error;
        }
        if (message.principal != null && message.hasOwnProperty('principal')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.principal);
          if (error) return 'principal.' + error;
        }
        if (message.accumulated_fees != null && message.hasOwnProperty('accumulated_fees')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.accumulated_fees);
          if (error) return 'accumulated_fees.' + error;
        }
        if (message.fees_updated != null && message.hasOwnProperty('fees_updated')) {
          let error = $root.google.protobuf.Timestamp.verify(message.fees_updated);
          if (error) return 'fees_updated.' + error;
        }
        if (message.interest_factor != null && message.hasOwnProperty('interest_factor'))
          if (!$util.isString(message.interest_factor)) return 'interest_factor: string expected';
        return null;
      };

      /**
       * Creates a Cdp message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.Cdp
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.Cdp} Cdp
       */
      Cdp.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.Cdp) return object;
        let message = new $root.ununifi.cdp.Cdp();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.owner != null) message.owner = String(object.owner);
        if (object.type != null) message.type = String(object.type);
        if (object.collateral != null) {
          if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.Cdp.collateral: object expected');
          message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
        }
        if (object.principal != null) {
          if (typeof object.principal !== 'object') throw TypeError('.ununifi.cdp.Cdp.principal: object expected');
          message.principal = $root.cosmos.base.v1beta1.Coin.fromObject(object.principal);
        }
        if (object.accumulated_fees != null) {
          if (typeof object.accumulated_fees !== 'object') throw TypeError('.ununifi.cdp.Cdp.accumulated_fees: object expected');
          message.accumulated_fees = $root.cosmos.base.v1beta1.Coin.fromObject(object.accumulated_fees);
        }
        if (object.fees_updated != null) {
          if (typeof object.fees_updated !== 'object') throw TypeError('.ununifi.cdp.Cdp.fees_updated: object expected');
          message.fees_updated = $root.google.protobuf.Timestamp.fromObject(object.fees_updated);
        }
        if (object.interest_factor != null) message.interest_factor = String(object.interest_factor);
        return message;
      };

      /**
       * Creates a plain object from a Cdp message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.Cdp
       * @static
       * @param {ununifi.cdp.Cdp} message Cdp
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Cdp.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.owner = '';
          object.type = '';
          object.collateral = null;
          object.principal = null;
          object.accumulated_fees = null;
          object.fees_updated = null;
          object.interest_factor = '';
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.type != null && message.hasOwnProperty('type')) object.type = message.type;
        if (message.collateral != null && message.hasOwnProperty('collateral'))
          object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
        if (message.principal != null && message.hasOwnProperty('principal'))
          object.principal = $root.cosmos.base.v1beta1.Coin.toObject(message.principal, options);
        if (message.accumulated_fees != null && message.hasOwnProperty('accumulated_fees'))
          object.accumulated_fees = $root.cosmos.base.v1beta1.Coin.toObject(message.accumulated_fees, options);
        if (message.fees_updated != null && message.hasOwnProperty('fees_updated'))
          object.fees_updated = $root.google.protobuf.Timestamp.toObject(message.fees_updated, options);
        if (message.interest_factor != null && message.hasOwnProperty('interest_factor')) object.interest_factor = message.interest_factor;
        return object;
      };

      /**
       * Converts this Cdp to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.Cdp
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Cdp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Cdp;
    })();

    cdp.Deposit = (function () {
      /**
       * Properties of a Deposit.
       * @memberof ununifi.cdp
       * @interface IDeposit
       * @property {Long|null} [cdp_id] Deposit cdp_id
       * @property {string|null} [depositor] Deposit depositor
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] Deposit amount
       */

      /**
       * Constructs a new Deposit.
       * @memberof ununifi.cdp
       * @classdesc Represents a Deposit.
       * @implements IDeposit
       * @constructor
       * @param {ununifi.cdp.IDeposit=} [properties] Properties to set
       */
      function Deposit(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Deposit cdp_id.
       * @member {Long} cdp_id
       * @memberof ununifi.cdp.Deposit
       * @instance
       */
      Deposit.prototype.cdp_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Deposit depositor.
       * @member {string} depositor
       * @memberof ununifi.cdp.Deposit
       * @instance
       */
      Deposit.prototype.depositor = '';

      /**
       * Deposit amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.cdp.Deposit
       * @instance
       */
      Deposit.prototype.amount = null;

      /**
       * Encodes the specified Deposit message. Does not implicitly {@link ununifi.cdp.Deposit.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.Deposit
       * @static
       * @param {ununifi.cdp.IDeposit} message Deposit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Deposit.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.cdp_id != null && Object.hasOwnProperty.call(message, 'cdp_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.cdp_id);
        if (message.depositor != null && Object.hasOwnProperty.call(message, 'depositor'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.depositor);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Deposit message, length delimited. Does not implicitly {@link ununifi.cdp.Deposit.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.Deposit
       * @static
       * @param {ununifi.cdp.IDeposit} message Deposit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Deposit.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Deposit message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.Deposit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.Deposit} Deposit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Deposit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.Deposit();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cdp_id = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Deposit message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.Deposit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.Deposit} Deposit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Deposit.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Deposit message.
       * @function verify
       * @memberof ununifi.cdp.Deposit
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Deposit.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.cdp_id != null && message.hasOwnProperty('cdp_id'))
          if (
            !$util.isInteger(message.cdp_id) &&
            !(message.cdp_id && $util.isInteger(message.cdp_id.low) && $util.isInteger(message.cdp_id.high))
          )
            return 'cdp_id: integer|Long expected';
        if (message.depositor != null && message.hasOwnProperty('depositor'))
          if (!$util.isString(message.depositor)) return 'depositor: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a Deposit message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.Deposit
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.Deposit} Deposit
       */
      Deposit.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.Deposit) return object;
        let message = new $root.ununifi.cdp.Deposit();
        if (object.cdp_id != null)
          if ($util.Long) (message.cdp_id = $util.Long.fromValue(object.cdp_id)).unsigned = true;
          else if (typeof object.cdp_id === 'string') message.cdp_id = parseInt(object.cdp_id, 10);
          else if (typeof object.cdp_id === 'number') message.cdp_id = object.cdp_id;
          else if (typeof object.cdp_id === 'object')
            message.cdp_id = new $util.LongBits(object.cdp_id.low >>> 0, object.cdp_id.high >>> 0).toNumber(true);
        if (object.depositor != null) message.depositor = String(object.depositor);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.cdp.Deposit.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a Deposit message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.Deposit
       * @static
       * @param {ununifi.cdp.Deposit} message Deposit
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Deposit.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.cdp_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.cdp_id = options.longs === String ? '0' : 0;
          object.depositor = '';
          object.amount = null;
        }
        if (message.cdp_id != null && message.hasOwnProperty('cdp_id'))
          if (typeof message.cdp_id === 'number') object.cdp_id = options.longs === String ? String(message.cdp_id) : message.cdp_id;
          else
            object.cdp_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.cdp_id)
                : options.longs === Number
                ? new $util.LongBits(message.cdp_id.low >>> 0, message.cdp_id.high >>> 0).toNumber(true)
                : message.cdp_id;
        if (message.depositor != null && message.hasOwnProperty('depositor')) object.depositor = message.depositor;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this Deposit to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.Deposit
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Deposit.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Deposit;
    })();

    cdp.AugmentedCdp = (function () {
      /**
       * Properties of an AugmentedCdp.
       * @memberof ununifi.cdp
       * @interface IAugmentedCdp
       * @property {ununifi.cdp.ICdp|null} [cdp] AugmentedCdp cdp
       * @property {cosmos.base.v1beta1.ICoin|null} [collateral_value] AugmentedCdp collateral_value
       * @property {string|null} [collateralization_ratio] AugmentedCdp collateralization_ratio
       */

      /**
       * Constructs a new AugmentedCdp.
       * @memberof ununifi.cdp
       * @classdesc Represents an AugmentedCdp.
       * @implements IAugmentedCdp
       * @constructor
       * @param {ununifi.cdp.IAugmentedCdp=} [properties] Properties to set
       */
      function AugmentedCdp(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * AugmentedCdp cdp.
       * @member {ununifi.cdp.ICdp|null|undefined} cdp
       * @memberof ununifi.cdp.AugmentedCdp
       * @instance
       */
      AugmentedCdp.prototype.cdp = null;

      /**
       * AugmentedCdp collateral_value.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral_value
       * @memberof ununifi.cdp.AugmentedCdp
       * @instance
       */
      AugmentedCdp.prototype.collateral_value = null;

      /**
       * AugmentedCdp collateralization_ratio.
       * @member {string} collateralization_ratio
       * @memberof ununifi.cdp.AugmentedCdp
       * @instance
       */
      AugmentedCdp.prototype.collateralization_ratio = '';

      /**
       * Encodes the specified AugmentedCdp message. Does not implicitly {@link ununifi.cdp.AugmentedCdp.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.AugmentedCdp
       * @static
       * @param {ununifi.cdp.IAugmentedCdp} message AugmentedCdp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      AugmentedCdp.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.cdp != null && Object.hasOwnProperty.call(message, 'cdp'))
          $root.ununifi.cdp.Cdp.encode(message.cdp, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.collateral_value != null && Object.hasOwnProperty.call(message, 'collateral_value'))
          $root.cosmos.base.v1beta1.Coin.encode(message.collateral_value, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.collateralization_ratio != null && Object.hasOwnProperty.call(message, 'collateralization_ratio'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.collateralization_ratio);
        return writer;
      };

      /**
       * Encodes the specified AugmentedCdp message, length delimited. Does not implicitly {@link ununifi.cdp.AugmentedCdp.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.AugmentedCdp
       * @static
       * @param {ununifi.cdp.IAugmentedCdp} message AugmentedCdp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      AugmentedCdp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an AugmentedCdp message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.AugmentedCdp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.AugmentedCdp} AugmentedCdp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      AugmentedCdp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.AugmentedCdp();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cdp = $root.ununifi.cdp.Cdp.decode(reader, reader.uint32());
              break;
            case 2:
              message.collateral_value = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.collateralization_ratio = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an AugmentedCdp message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.AugmentedCdp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.AugmentedCdp} AugmentedCdp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      AugmentedCdp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an AugmentedCdp message.
       * @function verify
       * @memberof ununifi.cdp.AugmentedCdp
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      AugmentedCdp.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.cdp != null && message.hasOwnProperty('cdp')) {
          let error = $root.ununifi.cdp.Cdp.verify(message.cdp);
          if (error) return 'cdp.' + error;
        }
        if (message.collateral_value != null && message.hasOwnProperty('collateral_value')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral_value);
          if (error) return 'collateral_value.' + error;
        }
        if (message.collateralization_ratio != null && message.hasOwnProperty('collateralization_ratio'))
          if (!$util.isString(message.collateralization_ratio)) return 'collateralization_ratio: string expected';
        return null;
      };

      /**
       * Creates an AugmentedCdp message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.AugmentedCdp
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.AugmentedCdp} AugmentedCdp
       */
      AugmentedCdp.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.AugmentedCdp) return object;
        let message = new $root.ununifi.cdp.AugmentedCdp();
        if (object.cdp != null) {
          if (typeof object.cdp !== 'object') throw TypeError('.ununifi.cdp.AugmentedCdp.cdp: object expected');
          message.cdp = $root.ununifi.cdp.Cdp.fromObject(object.cdp);
        }
        if (object.collateral_value != null) {
          if (typeof object.collateral_value !== 'object') throw TypeError('.ununifi.cdp.AugmentedCdp.collateral_value: object expected');
          message.collateral_value = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral_value);
        }
        if (object.collateralization_ratio != null) message.collateralization_ratio = String(object.collateralization_ratio);
        return message;
      };

      /**
       * Creates a plain object from an AugmentedCdp message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.AugmentedCdp
       * @static
       * @param {ununifi.cdp.AugmentedCdp} message AugmentedCdp
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      AugmentedCdp.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.cdp = null;
          object.collateral_value = null;
          object.collateralization_ratio = '';
        }
        if (message.cdp != null && message.hasOwnProperty('cdp')) object.cdp = $root.ununifi.cdp.Cdp.toObject(message.cdp, options);
        if (message.collateral_value != null && message.hasOwnProperty('collateral_value'))
          object.collateral_value = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral_value, options);
        if (message.collateralization_ratio != null && message.hasOwnProperty('collateralization_ratio'))
          object.collateralization_ratio = message.collateralization_ratio;
        return object;
      };

      /**
       * Converts this AugmentedCdp to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.AugmentedCdp
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      AugmentedCdp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return AugmentedCdp;
    })();

    cdp.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.cdp
       * @interface IParams
       * @property {Array.<ununifi.cdp.ICollateralParam>|null} [collateral_params] Params collateral_params
       * @property {Array.<ununifi.cdp.IDebtParam>|null} [debt_params] Params debt_params
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.cdp
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.cdp.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.collateral_params = [];
        this.debt_params = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params collateral_params.
       * @member {Array.<ununifi.cdp.ICollateralParam>} collateral_params
       * @memberof ununifi.cdp.Params
       * @instance
       */
      Params.prototype.collateral_params = $util.emptyArray;

      /**
       * Params debt_params.
       * @member {Array.<ununifi.cdp.IDebtParam>} debt_params
       * @memberof ununifi.cdp.Params
       * @instance
       */
      Params.prototype.debt_params = $util.emptyArray;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.cdp.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.Params
       * @static
       * @param {ununifi.cdp.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.collateral_params != null && message.collateral_params.length)
          for (let i = 0; i < message.collateral_params.length; ++i)
            $root.ununifi.cdp.CollateralParam.encode(
              message.collateral_params[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.debt_params != null && message.debt_params.length)
          for (let i = 0; i < message.debt_params.length; ++i)
            $root.ununifi.cdp.DebtParam.encode(message.debt_params[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.cdp.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.Params
       * @static
       * @param {ununifi.cdp.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.collateral_params && message.collateral_params.length)) message.collateral_params = [];
              message.collateral_params.push($root.ununifi.cdp.CollateralParam.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.debt_params && message.debt_params.length)) message.debt_params = [];
              message.debt_params.push($root.ununifi.cdp.DebtParam.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.cdp.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.collateral_params != null && message.hasOwnProperty('collateral_params')) {
          if (!Array.isArray(message.collateral_params)) return 'collateral_params: array expected';
          for (let i = 0; i < message.collateral_params.length; ++i) {
            let error = $root.ununifi.cdp.CollateralParam.verify(message.collateral_params[i]);
            if (error) return 'collateral_params.' + error;
          }
        }
        if (message.debt_params != null && message.hasOwnProperty('debt_params')) {
          if (!Array.isArray(message.debt_params)) return 'debt_params: array expected';
          for (let i = 0; i < message.debt_params.length; ++i) {
            let error = $root.ununifi.cdp.DebtParam.verify(message.debt_params[i]);
            if (error) return 'debt_params.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.Params) return object;
        let message = new $root.ununifi.cdp.Params();
        if (object.collateral_params) {
          if (!Array.isArray(object.collateral_params)) throw TypeError('.ununifi.cdp.Params.collateral_params: array expected');
          message.collateral_params = [];
          for (let i = 0; i < object.collateral_params.length; ++i) {
            if (typeof object.collateral_params[i] !== 'object') throw TypeError('.ununifi.cdp.Params.collateral_params: object expected');
            message.collateral_params[i] = $root.ununifi.cdp.CollateralParam.fromObject(object.collateral_params[i]);
          }
        }
        if (object.debt_params) {
          if (!Array.isArray(object.debt_params)) throw TypeError('.ununifi.cdp.Params.debt_params: array expected');
          message.debt_params = [];
          for (let i = 0; i < object.debt_params.length; ++i) {
            if (typeof object.debt_params[i] !== 'object') throw TypeError('.ununifi.cdp.Params.debt_params: object expected');
            message.debt_params[i] = $root.ununifi.cdp.DebtParam.fromObject(object.debt_params[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.Params
       * @static
       * @param {ununifi.cdp.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.collateral_params = [];
          object.debt_params = [];
        }
        if (message.collateral_params && message.collateral_params.length) {
          object.collateral_params = [];
          for (let j = 0; j < message.collateral_params.length; ++j)
            object.collateral_params[j] = $root.ununifi.cdp.CollateralParam.toObject(message.collateral_params[j], options);
        }
        if (message.debt_params && message.debt_params.length) {
          object.debt_params = [];
          for (let j = 0; j < message.debt_params.length; ++j)
            object.debt_params[j] = $root.ununifi.cdp.DebtParam.toObject(message.debt_params[j], options);
        }
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    cdp.CollateralParam = (function () {
      /**
       * Properties of a CollateralParam.
       * @memberof ununifi.cdp
       * @interface ICollateralParam
       * @property {string|null} [denom] CollateralParam denom
       * @property {string|null} [type] CollateralParam type
       * @property {string|null} [liquidation_ratio] CollateralParam liquidation_ratio
       * @property {cosmos.base.v1beta1.ICoin|null} [debt_limit] CollateralParam debt_limit
       * @property {string|null} [stability_fee] CollateralParam stability_fee
       * @property {string|null} [auction_size] CollateralParam auction_size
       * @property {string|null} [liquidation_penalty] CollateralParam liquidation_penalty
       * @property {number|null} [prefix] CollateralParam prefix
       * @property {string|null} [spot_market_id] CollateralParam spot_market_id
       * @property {string|null} [liquidation_market_id] CollateralParam liquidation_market_id
       * @property {string|null} [keeper_reward_percentage] CollateralParam keeper_reward_percentage
       * @property {string|null} [check_collateralization_index_count] CollateralParam check_collateralization_index_count
       * @property {string|null} [conversion_factor] CollateralParam conversion_factor
       */

      /**
       * Constructs a new CollateralParam.
       * @memberof ununifi.cdp
       * @classdesc Represents a CollateralParam.
       * @implements ICollateralParam
       * @constructor
       * @param {ununifi.cdp.ICollateralParam=} [properties] Properties to set
       */
      function CollateralParam(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * CollateralParam denom.
       * @member {string} denom
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.denom = '';

      /**
       * CollateralParam type.
       * @member {string} type
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.type = '';

      /**
       * CollateralParam liquidation_ratio.
       * @member {string} liquidation_ratio
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.liquidation_ratio = '';

      /**
       * CollateralParam debt_limit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} debt_limit
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.debt_limit = null;

      /**
       * CollateralParam stability_fee.
       * @member {string} stability_fee
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.stability_fee = '';

      /**
       * CollateralParam auction_size.
       * @member {string} auction_size
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.auction_size = '';

      /**
       * CollateralParam liquidation_penalty.
       * @member {string} liquidation_penalty
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.liquidation_penalty = '';

      /**
       * CollateralParam prefix.
       * @member {number} prefix
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.prefix = 0;

      /**
       * CollateralParam spot_market_id.
       * @member {string} spot_market_id
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.spot_market_id = '';

      /**
       * CollateralParam liquidation_market_id.
       * @member {string} liquidation_market_id
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.liquidation_market_id = '';

      /**
       * CollateralParam keeper_reward_percentage.
       * @member {string} keeper_reward_percentage
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.keeper_reward_percentage = '';

      /**
       * CollateralParam check_collateralization_index_count.
       * @member {string} check_collateralization_index_count
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.check_collateralization_index_count = '';

      /**
       * CollateralParam conversion_factor.
       * @member {string} conversion_factor
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       */
      CollateralParam.prototype.conversion_factor = '';

      /**
       * Encodes the specified CollateralParam message. Does not implicitly {@link ununifi.cdp.CollateralParam.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.CollateralParam
       * @static
       * @param {ununifi.cdp.ICollateralParam} message CollateralParam message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CollateralParam.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.type != null && Object.hasOwnProperty.call(message, 'type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.type);
        if (message.liquidation_ratio != null && Object.hasOwnProperty.call(message, 'liquidation_ratio'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.liquidation_ratio);
        if (message.debt_limit != null && Object.hasOwnProperty.call(message, 'debt_limit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.debt_limit, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.stability_fee != null && Object.hasOwnProperty.call(message, 'stability_fee'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.stability_fee);
        if (message.auction_size != null && Object.hasOwnProperty.call(message, 'auction_size'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.auction_size);
        if (message.liquidation_penalty != null && Object.hasOwnProperty.call(message, 'liquidation_penalty'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.liquidation_penalty);
        if (message.prefix != null && Object.hasOwnProperty.call(message, 'prefix'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).uint32(message.prefix);
        if (message.spot_market_id != null && Object.hasOwnProperty.call(message, 'spot_market_id'))
          writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.spot_market_id);
        if (message.liquidation_market_id != null && Object.hasOwnProperty.call(message, 'liquidation_market_id'))
          writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.liquidation_market_id);
        if (message.keeper_reward_percentage != null && Object.hasOwnProperty.call(message, 'keeper_reward_percentage'))
          writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.keeper_reward_percentage);
        if (
          message.check_collateralization_index_count != null &&
          Object.hasOwnProperty.call(message, 'check_collateralization_index_count')
        )
          writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.check_collateralization_index_count);
        if (message.conversion_factor != null && Object.hasOwnProperty.call(message, 'conversion_factor'))
          writer.uint32(/* id 13, wireType 2 =*/ 106).string(message.conversion_factor);
        return writer;
      };

      /**
       * Encodes the specified CollateralParam message, length delimited. Does not implicitly {@link ununifi.cdp.CollateralParam.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.CollateralParam
       * @static
       * @param {ununifi.cdp.ICollateralParam} message CollateralParam message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CollateralParam.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CollateralParam message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.CollateralParam
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.CollateralParam} CollateralParam
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CollateralParam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.CollateralParam();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.type = reader.string();
              break;
            case 3:
              message.liquidation_ratio = reader.string();
              break;
            case 4:
              message.debt_limit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 5:
              message.stability_fee = reader.string();
              break;
            case 6:
              message.auction_size = reader.string();
              break;
            case 7:
              message.liquidation_penalty = reader.string();
              break;
            case 8:
              message.prefix = reader.uint32();
              break;
            case 9:
              message.spot_market_id = reader.string();
              break;
            case 10:
              message.liquidation_market_id = reader.string();
              break;
            case 11:
              message.keeper_reward_percentage = reader.string();
              break;
            case 12:
              message.check_collateralization_index_count = reader.string();
              break;
            case 13:
              message.conversion_factor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CollateralParam message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.CollateralParam
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.CollateralParam} CollateralParam
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CollateralParam.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CollateralParam message.
       * @function verify
       * @memberof ununifi.cdp.CollateralParam
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CollateralParam.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.type != null && message.hasOwnProperty('type')) if (!$util.isString(message.type)) return 'type: string expected';
        if (message.liquidation_ratio != null && message.hasOwnProperty('liquidation_ratio'))
          if (!$util.isString(message.liquidation_ratio)) return 'liquidation_ratio: string expected';
        if (message.debt_limit != null && message.hasOwnProperty('debt_limit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.debt_limit);
          if (error) return 'debt_limit.' + error;
        }
        if (message.stability_fee != null && message.hasOwnProperty('stability_fee'))
          if (!$util.isString(message.stability_fee)) return 'stability_fee: string expected';
        if (message.auction_size != null && message.hasOwnProperty('auction_size'))
          if (!$util.isString(message.auction_size)) return 'auction_size: string expected';
        if (message.liquidation_penalty != null && message.hasOwnProperty('liquidation_penalty'))
          if (!$util.isString(message.liquidation_penalty)) return 'liquidation_penalty: string expected';
        if (message.prefix != null && message.hasOwnProperty('prefix'))
          if (!$util.isInteger(message.prefix)) return 'prefix: integer expected';
        if (message.spot_market_id != null && message.hasOwnProperty('spot_market_id'))
          if (!$util.isString(message.spot_market_id)) return 'spot_market_id: string expected';
        if (message.liquidation_market_id != null && message.hasOwnProperty('liquidation_market_id'))
          if (!$util.isString(message.liquidation_market_id)) return 'liquidation_market_id: string expected';
        if (message.keeper_reward_percentage != null && message.hasOwnProperty('keeper_reward_percentage'))
          if (!$util.isString(message.keeper_reward_percentage)) return 'keeper_reward_percentage: string expected';
        if (message.check_collateralization_index_count != null && message.hasOwnProperty('check_collateralization_index_count'))
          if (!$util.isString(message.check_collateralization_index_count)) return 'check_collateralization_index_count: string expected';
        if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
          if (!$util.isString(message.conversion_factor)) return 'conversion_factor: string expected';
        return null;
      };

      /**
       * Creates a CollateralParam message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.CollateralParam
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.CollateralParam} CollateralParam
       */
      CollateralParam.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.CollateralParam) return object;
        let message = new $root.ununifi.cdp.CollateralParam();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.type != null) message.type = String(object.type);
        if (object.liquidation_ratio != null) message.liquidation_ratio = String(object.liquidation_ratio);
        if (object.debt_limit != null) {
          if (typeof object.debt_limit !== 'object') throw TypeError('.ununifi.cdp.CollateralParam.debt_limit: object expected');
          message.debt_limit = $root.cosmos.base.v1beta1.Coin.fromObject(object.debt_limit);
        }
        if (object.stability_fee != null) message.stability_fee = String(object.stability_fee);
        if (object.auction_size != null) message.auction_size = String(object.auction_size);
        if (object.liquidation_penalty != null) message.liquidation_penalty = String(object.liquidation_penalty);
        if (object.prefix != null) message.prefix = object.prefix >>> 0;
        if (object.spot_market_id != null) message.spot_market_id = String(object.spot_market_id);
        if (object.liquidation_market_id != null) message.liquidation_market_id = String(object.liquidation_market_id);
        if (object.keeper_reward_percentage != null) message.keeper_reward_percentage = String(object.keeper_reward_percentage);
        if (object.check_collateralization_index_count != null)
          message.check_collateralization_index_count = String(object.check_collateralization_index_count);
        if (object.conversion_factor != null) message.conversion_factor = String(object.conversion_factor);
        return message;
      };

      /**
       * Creates a plain object from a CollateralParam message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.CollateralParam
       * @static
       * @param {ununifi.cdp.CollateralParam} message CollateralParam
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CollateralParam.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          object.type = '';
          object.liquidation_ratio = '';
          object.debt_limit = null;
          object.stability_fee = '';
          object.auction_size = '';
          object.liquidation_penalty = '';
          object.prefix = 0;
          object.spot_market_id = '';
          object.liquidation_market_id = '';
          object.keeper_reward_percentage = '';
          object.check_collateralization_index_count = '';
          object.conversion_factor = '';
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.type != null && message.hasOwnProperty('type')) object.type = message.type;
        if (message.liquidation_ratio != null && message.hasOwnProperty('liquidation_ratio'))
          object.liquidation_ratio = message.liquidation_ratio;
        if (message.debt_limit != null && message.hasOwnProperty('debt_limit'))
          object.debt_limit = $root.cosmos.base.v1beta1.Coin.toObject(message.debt_limit, options);
        if (message.stability_fee != null && message.hasOwnProperty('stability_fee')) object.stability_fee = message.stability_fee;
        if (message.auction_size != null && message.hasOwnProperty('auction_size')) object.auction_size = message.auction_size;
        if (message.liquidation_penalty != null && message.hasOwnProperty('liquidation_penalty'))
          object.liquidation_penalty = message.liquidation_penalty;
        if (message.prefix != null && message.hasOwnProperty('prefix')) object.prefix = message.prefix;
        if (message.spot_market_id != null && message.hasOwnProperty('spot_market_id')) object.spot_market_id = message.spot_market_id;
        if (message.liquidation_market_id != null && message.hasOwnProperty('liquidation_market_id'))
          object.liquidation_market_id = message.liquidation_market_id;
        if (message.keeper_reward_percentage != null && message.hasOwnProperty('keeper_reward_percentage'))
          object.keeper_reward_percentage = message.keeper_reward_percentage;
        if (message.check_collateralization_index_count != null && message.hasOwnProperty('check_collateralization_index_count'))
          object.check_collateralization_index_count = message.check_collateralization_index_count;
        if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
          object.conversion_factor = message.conversion_factor;
        return object;
      };

      /**
       * Converts this CollateralParam to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.CollateralParam
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CollateralParam.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CollateralParam;
    })();

    cdp.DebtParam = (function () {
      /**
       * Properties of a DebtParam.
       * @memberof ununifi.cdp
       * @interface IDebtParam
       * @property {string|null} [denom] DebtParam denom
       * @property {string|null} [reference_asset] DebtParam reference_asset
       * @property {string|null} [conversion_factor] DebtParam conversion_factor
       * @property {string|null} [debt_floor] DebtParam debt_floor
       * @property {cosmos.base.v1beta1.ICoin|null} [global_debt_limit] DebtParam global_debt_limit
       * @property {string|null} [debt_denom] DebtParam debt_denom
       * @property {string|null} [surplus_auction_threshold] DebtParam surplus_auction_threshold
       * @property {string|null} [surplus_auction_lot] DebtParam surplus_auction_lot
       * @property {string|null} [debt_auction_threshold] DebtParam debt_auction_threshold
       * @property {string|null} [debt_auction_lot] DebtParam debt_auction_lot
       * @property {boolean|null} [circuit_breaker] DebtParam circuit_breaker
       */

      /**
       * Constructs a new DebtParam.
       * @memberof ununifi.cdp
       * @classdesc Represents a DebtParam.
       * @implements IDebtParam
       * @constructor
       * @param {ununifi.cdp.IDebtParam=} [properties] Properties to set
       */
      function DebtParam(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * DebtParam denom.
       * @member {string} denom
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.denom = '';

      /**
       * DebtParam reference_asset.
       * @member {string} reference_asset
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.reference_asset = '';

      /**
       * DebtParam conversion_factor.
       * @member {string} conversion_factor
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.conversion_factor = '';

      /**
       * DebtParam debt_floor.
       * @member {string} debt_floor
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.debt_floor = '';

      /**
       * DebtParam global_debt_limit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} global_debt_limit
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.global_debt_limit = null;

      /**
       * DebtParam debt_denom.
       * @member {string} debt_denom
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.debt_denom = '';

      /**
       * DebtParam surplus_auction_threshold.
       * @member {string} surplus_auction_threshold
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.surplus_auction_threshold = '';

      /**
       * DebtParam surplus_auction_lot.
       * @member {string} surplus_auction_lot
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.surplus_auction_lot = '';

      /**
       * DebtParam debt_auction_threshold.
       * @member {string} debt_auction_threshold
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.debt_auction_threshold = '';

      /**
       * DebtParam debt_auction_lot.
       * @member {string} debt_auction_lot
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.debt_auction_lot = '';

      /**
       * DebtParam circuit_breaker.
       * @member {boolean} circuit_breaker
       * @memberof ununifi.cdp.DebtParam
       * @instance
       */
      DebtParam.prototype.circuit_breaker = false;

      /**
       * Encodes the specified DebtParam message. Does not implicitly {@link ununifi.cdp.DebtParam.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.DebtParam
       * @static
       * @param {ununifi.cdp.IDebtParam} message DebtParam message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DebtParam.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.reference_asset != null && Object.hasOwnProperty.call(message, 'reference_asset'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reference_asset);
        if (message.conversion_factor != null && Object.hasOwnProperty.call(message, 'conversion_factor'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.conversion_factor);
        if (message.debt_floor != null && Object.hasOwnProperty.call(message, 'debt_floor'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.debt_floor);
        if (message.global_debt_limit != null && Object.hasOwnProperty.call(message, 'global_debt_limit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.global_debt_limit, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        if (message.debt_denom != null && Object.hasOwnProperty.call(message, 'debt_denom'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.debt_denom);
        if (message.surplus_auction_threshold != null && Object.hasOwnProperty.call(message, 'surplus_auction_threshold'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.surplus_auction_threshold);
        if (message.surplus_auction_lot != null && Object.hasOwnProperty.call(message, 'surplus_auction_lot'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.surplus_auction_lot);
        if (message.debt_auction_threshold != null && Object.hasOwnProperty.call(message, 'debt_auction_threshold'))
          writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.debt_auction_threshold);
        if (message.debt_auction_lot != null && Object.hasOwnProperty.call(message, 'debt_auction_lot'))
          writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.debt_auction_lot);
        if (message.circuit_breaker != null && Object.hasOwnProperty.call(message, 'circuit_breaker'))
          writer.uint32(/* id 11, wireType 0 =*/ 88).bool(message.circuit_breaker);
        return writer;
      };

      /**
       * Encodes the specified DebtParam message, length delimited. Does not implicitly {@link ununifi.cdp.DebtParam.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.DebtParam
       * @static
       * @param {ununifi.cdp.IDebtParam} message DebtParam message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DebtParam.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DebtParam message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.DebtParam
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.DebtParam} DebtParam
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DebtParam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.DebtParam();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.reference_asset = reader.string();
              break;
            case 3:
              message.conversion_factor = reader.string();
              break;
            case 4:
              message.debt_floor = reader.string();
              break;
            case 5:
              message.global_debt_limit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 6:
              message.debt_denom = reader.string();
              break;
            case 7:
              message.surplus_auction_threshold = reader.string();
              break;
            case 8:
              message.surplus_auction_lot = reader.string();
              break;
            case 9:
              message.debt_auction_threshold = reader.string();
              break;
            case 10:
              message.debt_auction_lot = reader.string();
              break;
            case 11:
              message.circuit_breaker = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a DebtParam message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.DebtParam
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.DebtParam} DebtParam
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DebtParam.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DebtParam message.
       * @function verify
       * @memberof ununifi.cdp.DebtParam
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DebtParam.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.reference_asset != null && message.hasOwnProperty('reference_asset'))
          if (!$util.isString(message.reference_asset)) return 'reference_asset: string expected';
        if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
          if (!$util.isString(message.conversion_factor)) return 'conversion_factor: string expected';
        if (message.debt_floor != null && message.hasOwnProperty('debt_floor'))
          if (!$util.isString(message.debt_floor)) return 'debt_floor: string expected';
        if (message.global_debt_limit != null && message.hasOwnProperty('global_debt_limit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.global_debt_limit);
          if (error) return 'global_debt_limit.' + error;
        }
        if (message.debt_denom != null && message.hasOwnProperty('debt_denom'))
          if (!$util.isString(message.debt_denom)) return 'debt_denom: string expected';
        if (message.surplus_auction_threshold != null && message.hasOwnProperty('surplus_auction_threshold'))
          if (!$util.isString(message.surplus_auction_threshold)) return 'surplus_auction_threshold: string expected';
        if (message.surplus_auction_lot != null && message.hasOwnProperty('surplus_auction_lot'))
          if (!$util.isString(message.surplus_auction_lot)) return 'surplus_auction_lot: string expected';
        if (message.debt_auction_threshold != null && message.hasOwnProperty('debt_auction_threshold'))
          if (!$util.isString(message.debt_auction_threshold)) return 'debt_auction_threshold: string expected';
        if (message.debt_auction_lot != null && message.hasOwnProperty('debt_auction_lot'))
          if (!$util.isString(message.debt_auction_lot)) return 'debt_auction_lot: string expected';
        if (message.circuit_breaker != null && message.hasOwnProperty('circuit_breaker'))
          if (typeof message.circuit_breaker !== 'boolean') return 'circuit_breaker: boolean expected';
        return null;
      };

      /**
       * Creates a DebtParam message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.DebtParam
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.DebtParam} DebtParam
       */
      DebtParam.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.DebtParam) return object;
        let message = new $root.ununifi.cdp.DebtParam();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.reference_asset != null) message.reference_asset = String(object.reference_asset);
        if (object.conversion_factor != null) message.conversion_factor = String(object.conversion_factor);
        if (object.debt_floor != null) message.debt_floor = String(object.debt_floor);
        if (object.global_debt_limit != null) {
          if (typeof object.global_debt_limit !== 'object') throw TypeError('.ununifi.cdp.DebtParam.global_debt_limit: object expected');
          message.global_debt_limit = $root.cosmos.base.v1beta1.Coin.fromObject(object.global_debt_limit);
        }
        if (object.debt_denom != null) message.debt_denom = String(object.debt_denom);
        if (object.surplus_auction_threshold != null) message.surplus_auction_threshold = String(object.surplus_auction_threshold);
        if (object.surplus_auction_lot != null) message.surplus_auction_lot = String(object.surplus_auction_lot);
        if (object.debt_auction_threshold != null) message.debt_auction_threshold = String(object.debt_auction_threshold);
        if (object.debt_auction_lot != null) message.debt_auction_lot = String(object.debt_auction_lot);
        if (object.circuit_breaker != null) message.circuit_breaker = Boolean(object.circuit_breaker);
        return message;
      };

      /**
       * Creates a plain object from a DebtParam message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.DebtParam
       * @static
       * @param {ununifi.cdp.DebtParam} message DebtParam
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DebtParam.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          object.reference_asset = '';
          object.conversion_factor = '';
          object.debt_floor = '';
          object.global_debt_limit = null;
          object.debt_denom = '';
          object.surplus_auction_threshold = '';
          object.surplus_auction_lot = '';
          object.debt_auction_threshold = '';
          object.debt_auction_lot = '';
          object.circuit_breaker = false;
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.reference_asset != null && message.hasOwnProperty('reference_asset')) object.reference_asset = message.reference_asset;
        if (message.conversion_factor != null && message.hasOwnProperty('conversion_factor'))
          object.conversion_factor = message.conversion_factor;
        if (message.debt_floor != null && message.hasOwnProperty('debt_floor')) object.debt_floor = message.debt_floor;
        if (message.global_debt_limit != null && message.hasOwnProperty('global_debt_limit'))
          object.global_debt_limit = $root.cosmos.base.v1beta1.Coin.toObject(message.global_debt_limit, options);
        if (message.debt_denom != null && message.hasOwnProperty('debt_denom')) object.debt_denom = message.debt_denom;
        if (message.surplus_auction_threshold != null && message.hasOwnProperty('surplus_auction_threshold'))
          object.surplus_auction_threshold = message.surplus_auction_threshold;
        if (message.surplus_auction_lot != null && message.hasOwnProperty('surplus_auction_lot'))
          object.surplus_auction_lot = message.surplus_auction_lot;
        if (message.debt_auction_threshold != null && message.hasOwnProperty('debt_auction_threshold'))
          object.debt_auction_threshold = message.debt_auction_threshold;
        if (message.debt_auction_lot != null && message.hasOwnProperty('debt_auction_lot'))
          object.debt_auction_lot = message.debt_auction_lot;
        if (message.circuit_breaker != null && message.hasOwnProperty('circuit_breaker')) object.circuit_breaker = message.circuit_breaker;
        return object;
      };

      /**
       * Converts this DebtParam to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.DebtParam
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DebtParam.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return DebtParam;
    })();

    cdp.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.cdp
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.cdp.Msg#createCdp}.
       * @memberof ununifi.cdp.Msg
       * @typedef CreateCdpCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.MsgCreateCdpResponse} [response] MsgCreateCdpResponse
       */

      /**
       * Calls CreateCdp.
       * @function createCdp
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgCreateCdp} request MsgCreateCdp message or plain object
       * @param {ununifi.cdp.Msg.CreateCdpCallback} callback Node-style callback called with the error, if any, and MsgCreateCdpResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.createCdp = function createCdp(request, callback) {
          return this.rpcCall(createCdp, $root.ununifi.cdp.MsgCreateCdp, $root.ununifi.cdp.MsgCreateCdpResponse, request, callback);
        }),
        'name',
        { value: 'CreateCdp' },
      );

      /**
       * Calls CreateCdp.
       * @function createCdp
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgCreateCdp} request MsgCreateCdp message or plain object
       * @returns {Promise<ununifi.cdp.MsgCreateCdpResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Msg#deposit}.
       * @memberof ununifi.cdp.Msg
       * @typedef DepositCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.MsgDepositResponse} [response] MsgDepositResponse
       */

      /**
       * Calls Deposit.
       * @function deposit
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgDeposit} request MsgDeposit message or plain object
       * @param {ununifi.cdp.Msg.DepositCallback} callback Node-style callback called with the error, if any, and MsgDepositResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.deposit = function deposit(request, callback) {
          return this.rpcCall(deposit, $root.ununifi.cdp.MsgDeposit, $root.ununifi.cdp.MsgDepositResponse, request, callback);
        }),
        'name',
        { value: 'Deposit' },
      );

      /**
       * Calls Deposit.
       * @function deposit
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgDeposit} request MsgDeposit message or plain object
       * @returns {Promise<ununifi.cdp.MsgDepositResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Msg#withdraw}.
       * @memberof ununifi.cdp.Msg
       * @typedef WithdrawCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.MsgWithdrawResponse} [response] MsgWithdrawResponse
       */

      /**
       * Calls Withdraw.
       * @function withdraw
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgWithdraw} request MsgWithdraw message or plain object
       * @param {ununifi.cdp.Msg.WithdrawCallback} callback Node-style callback called with the error, if any, and MsgWithdrawResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdraw = function withdraw(request, callback) {
          return this.rpcCall(withdraw, $root.ununifi.cdp.MsgWithdraw, $root.ununifi.cdp.MsgWithdrawResponse, request, callback);
        }),
        'name',
        { value: 'Withdraw' },
      );

      /**
       * Calls Withdraw.
       * @function withdraw
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgWithdraw} request MsgWithdraw message or plain object
       * @returns {Promise<ununifi.cdp.MsgWithdrawResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Msg#drawDebt}.
       * @memberof ununifi.cdp.Msg
       * @typedef DrawDebtCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.MsgDrawDebtResponse} [response] MsgDrawDebtResponse
       */

      /**
       * Calls DrawDebt.
       * @function drawDebt
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgDrawDebt} request MsgDrawDebt message or plain object
       * @param {ununifi.cdp.Msg.DrawDebtCallback} callback Node-style callback called with the error, if any, and MsgDrawDebtResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.drawDebt = function drawDebt(request, callback) {
          return this.rpcCall(drawDebt, $root.ununifi.cdp.MsgDrawDebt, $root.ununifi.cdp.MsgDrawDebtResponse, request, callback);
        }),
        'name',
        { value: 'DrawDebt' },
      );

      /**
       * Calls DrawDebt.
       * @function drawDebt
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgDrawDebt} request MsgDrawDebt message or plain object
       * @returns {Promise<ununifi.cdp.MsgDrawDebtResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Msg#repayDebt}.
       * @memberof ununifi.cdp.Msg
       * @typedef RepayDebtCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.MsgRepayDebtResponse} [response] MsgRepayDebtResponse
       */

      /**
       * Calls RepayDebt.
       * @function repayDebt
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgRepayDebt} request MsgRepayDebt message or plain object
       * @param {ununifi.cdp.Msg.RepayDebtCallback} callback Node-style callback called with the error, if any, and MsgRepayDebtResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.repayDebt = function repayDebt(request, callback) {
          return this.rpcCall(repayDebt, $root.ununifi.cdp.MsgRepayDebt, $root.ununifi.cdp.MsgRepayDebtResponse, request, callback);
        }),
        'name',
        { value: 'RepayDebt' },
      );

      /**
       * Calls RepayDebt.
       * @function repayDebt
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgRepayDebt} request MsgRepayDebt message or plain object
       * @returns {Promise<ununifi.cdp.MsgRepayDebtResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.cdp.Msg#liquidate}.
       * @memberof ununifi.cdp.Msg
       * @typedef LiquidateCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.cdp.MsgLiquidateResponse} [response] MsgLiquidateResponse
       */

      /**
       * Calls Liquidate.
       * @function liquidate
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgLiquidate} request MsgLiquidate message or plain object
       * @param {ununifi.cdp.Msg.LiquidateCallback} callback Node-style callback called with the error, if any, and MsgLiquidateResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.liquidate = function liquidate(request, callback) {
          return this.rpcCall(liquidate, $root.ununifi.cdp.MsgLiquidate, $root.ununifi.cdp.MsgLiquidateResponse, request, callback);
        }),
        'name',
        { value: 'Liquidate' },
      );

      /**
       * Calls Liquidate.
       * @function liquidate
       * @memberof ununifi.cdp.Msg
       * @instance
       * @param {ununifi.cdp.IMsgLiquidate} request MsgLiquidate message or plain object
       * @returns {Promise<ununifi.cdp.MsgLiquidateResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    cdp.MsgCreateCdp = (function () {
      /**
       * Properties of a MsgCreateCdp.
       * @memberof ununifi.cdp
       * @interface IMsgCreateCdp
       * @property {string|null} [sender] MsgCreateCdp sender
       * @property {cosmos.base.v1beta1.ICoin|null} [collateral] MsgCreateCdp collateral
       * @property {cosmos.base.v1beta1.ICoin|null} [principal] MsgCreateCdp principal
       * @property {string|null} [collateral_type] MsgCreateCdp collateral_type
       */

      /**
       * Constructs a new MsgCreateCdp.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgCreateCdp.
       * @implements IMsgCreateCdp
       * @constructor
       * @param {ununifi.cdp.IMsgCreateCdp=} [properties] Properties to set
       */
      function MsgCreateCdp(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCreateCdp sender.
       * @member {string} sender
       * @memberof ununifi.cdp.MsgCreateCdp
       * @instance
       */
      MsgCreateCdp.prototype.sender = '';

      /**
       * MsgCreateCdp collateral.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
       * @memberof ununifi.cdp.MsgCreateCdp
       * @instance
       */
      MsgCreateCdp.prototype.collateral = null;

      /**
       * MsgCreateCdp principal.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} principal
       * @memberof ununifi.cdp.MsgCreateCdp
       * @instance
       */
      MsgCreateCdp.prototype.principal = null;

      /**
       * MsgCreateCdp collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.MsgCreateCdp
       * @instance
       */
      MsgCreateCdp.prototype.collateral_type = '';

      /**
       * Encodes the specified MsgCreateCdp message. Does not implicitly {@link ununifi.cdp.MsgCreateCdp.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgCreateCdp
       * @static
       * @param {ununifi.cdp.IMsgCreateCdp} message MsgCreateCdp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateCdp.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
          $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.principal != null && Object.hasOwnProperty.call(message, 'principal'))
          $root.cosmos.base.v1beta1.Coin.encode(message.principal, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.collateral_type);
        return writer;
      };

      /**
       * Encodes the specified MsgCreateCdp message, length delimited. Does not implicitly {@link ununifi.cdp.MsgCreateCdp.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgCreateCdp
       * @static
       * @param {ununifi.cdp.IMsgCreateCdp} message MsgCreateCdp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateCdp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateCdp message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgCreateCdp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgCreateCdp} MsgCreateCdp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateCdp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgCreateCdp();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.principal = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.collateral_type = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateCdp message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgCreateCdp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgCreateCdp} MsgCreateCdp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateCdp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateCdp message.
       * @function verify
       * @memberof ununifi.cdp.MsgCreateCdp
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateCdp.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.collateral != null && message.hasOwnProperty('collateral')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
          if (error) return 'collateral.' + error;
        }
        if (message.principal != null && message.hasOwnProperty('principal')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.principal);
          if (error) return 'principal.' + error;
        }
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        return null;
      };

      /**
       * Creates a MsgCreateCdp message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgCreateCdp
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgCreateCdp} MsgCreateCdp
       */
      MsgCreateCdp.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgCreateCdp) return object;
        let message = new $root.ununifi.cdp.MsgCreateCdp();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.collateral != null) {
          if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.MsgCreateCdp.collateral: object expected');
          message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
        }
        if (object.principal != null) {
          if (typeof object.principal !== 'object') throw TypeError('.ununifi.cdp.MsgCreateCdp.principal: object expected');
          message.principal = $root.cosmos.base.v1beta1.Coin.fromObject(object.principal);
        }
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        return message;
      };

      /**
       * Creates a plain object from a MsgCreateCdp message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgCreateCdp
       * @static
       * @param {ununifi.cdp.MsgCreateCdp} message MsgCreateCdp
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateCdp.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.collateral = null;
          object.principal = null;
          object.collateral_type = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.collateral != null && message.hasOwnProperty('collateral'))
          object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
        if (message.principal != null && message.hasOwnProperty('principal'))
          object.principal = $root.cosmos.base.v1beta1.Coin.toObject(message.principal, options);
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        return object;
      };

      /**
       * Converts this MsgCreateCdp to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgCreateCdp
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateCdp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateCdp;
    })();

    cdp.MsgCreateCdpResponse = (function () {
      /**
       * Properties of a MsgCreateCdpResponse.
       * @memberof ununifi.cdp
       * @interface IMsgCreateCdpResponse
       */

      /**
       * Constructs a new MsgCreateCdpResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgCreateCdpResponse.
       * @implements IMsgCreateCdpResponse
       * @constructor
       * @param {ununifi.cdp.IMsgCreateCdpResponse=} [properties] Properties to set
       */
      function MsgCreateCdpResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgCreateCdpResponse message. Does not implicitly {@link ununifi.cdp.MsgCreateCdpResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @static
       * @param {ununifi.cdp.IMsgCreateCdpResponse} message MsgCreateCdpResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateCdpResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCreateCdpResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgCreateCdpResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @static
       * @param {ununifi.cdp.IMsgCreateCdpResponse} message MsgCreateCdpResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateCdpResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateCdpResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgCreateCdpResponse} MsgCreateCdpResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateCdpResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgCreateCdpResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateCdpResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgCreateCdpResponse} MsgCreateCdpResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateCdpResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateCdpResponse message.
       * @function verify
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateCdpResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgCreateCdpResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgCreateCdpResponse} MsgCreateCdpResponse
       */
      MsgCreateCdpResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgCreateCdpResponse) return object;
        return new $root.ununifi.cdp.MsgCreateCdpResponse();
      };

      /**
       * Creates a plain object from a MsgCreateCdpResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @static
       * @param {ununifi.cdp.MsgCreateCdpResponse} message MsgCreateCdpResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateCdpResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCreateCdpResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgCreateCdpResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateCdpResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateCdpResponse;
    })();

    cdp.MsgDeposit = (function () {
      /**
       * Properties of a MsgDeposit.
       * @memberof ununifi.cdp
       * @interface IMsgDeposit
       * @property {string|null} [depositor] MsgDeposit depositor
       * @property {string|null} [owner] MsgDeposit owner
       * @property {cosmos.base.v1beta1.ICoin|null} [collateral] MsgDeposit collateral
       * @property {string|null} [collateral_type] MsgDeposit collateral_type
       */

      /**
       * Constructs a new MsgDeposit.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgDeposit.
       * @implements IMsgDeposit
       * @constructor
       * @param {ununifi.cdp.IMsgDeposit=} [properties] Properties to set
       */
      function MsgDeposit(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgDeposit depositor.
       * @member {string} depositor
       * @memberof ununifi.cdp.MsgDeposit
       * @instance
       */
      MsgDeposit.prototype.depositor = '';

      /**
       * MsgDeposit owner.
       * @member {string} owner
       * @memberof ununifi.cdp.MsgDeposit
       * @instance
       */
      MsgDeposit.prototype.owner = '';

      /**
       * MsgDeposit collateral.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
       * @memberof ununifi.cdp.MsgDeposit
       * @instance
       */
      MsgDeposit.prototype.collateral = null;

      /**
       * MsgDeposit collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.MsgDeposit
       * @instance
       */
      MsgDeposit.prototype.collateral_type = '';

      /**
       * Encodes the specified MsgDeposit message. Does not implicitly {@link ununifi.cdp.MsgDeposit.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgDeposit
       * @static
       * @param {ununifi.cdp.IMsgDeposit} message MsgDeposit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDeposit.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.depositor != null && Object.hasOwnProperty.call(message, 'depositor'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.depositor);
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
        if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
          $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.collateral_type);
        return writer;
      };

      /**
       * Encodes the specified MsgDeposit message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDeposit.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgDeposit
       * @static
       * @param {ununifi.cdp.IMsgDeposit} message MsgDeposit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDeposit.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDeposit message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgDeposit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgDeposit} MsgDeposit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDeposit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgDeposit();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.depositor = reader.string();
              break;
            case 2:
              message.owner = reader.string();
              break;
            case 3:
              message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.collateral_type = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDeposit message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgDeposit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgDeposit} MsgDeposit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDeposit.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDeposit message.
       * @function verify
       * @memberof ununifi.cdp.MsgDeposit
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDeposit.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.depositor != null && message.hasOwnProperty('depositor'))
          if (!$util.isString(message.depositor)) return 'depositor: string expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.collateral != null && message.hasOwnProperty('collateral')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
          if (error) return 'collateral.' + error;
        }
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        return null;
      };

      /**
       * Creates a MsgDeposit message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgDeposit
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgDeposit} MsgDeposit
       */
      MsgDeposit.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgDeposit) return object;
        let message = new $root.ununifi.cdp.MsgDeposit();
        if (object.depositor != null) message.depositor = String(object.depositor);
        if (object.owner != null) message.owner = String(object.owner);
        if (object.collateral != null) {
          if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.MsgDeposit.collateral: object expected');
          message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
        }
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        return message;
      };

      /**
       * Creates a plain object from a MsgDeposit message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgDeposit
       * @static
       * @param {ununifi.cdp.MsgDeposit} message MsgDeposit
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDeposit.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.depositor = '';
          object.owner = '';
          object.collateral = null;
          object.collateral_type = '';
        }
        if (message.depositor != null && message.hasOwnProperty('depositor')) object.depositor = message.depositor;
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.collateral != null && message.hasOwnProperty('collateral'))
          object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        return object;
      };

      /**
       * Converts this MsgDeposit to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgDeposit
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDeposit.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDeposit;
    })();

    cdp.MsgDepositResponse = (function () {
      /**
       * Properties of a MsgDepositResponse.
       * @memberof ununifi.cdp
       * @interface IMsgDepositResponse
       */

      /**
       * Constructs a new MsgDepositResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgDepositResponse.
       * @implements IMsgDepositResponse
       * @constructor
       * @param {ununifi.cdp.IMsgDepositResponse=} [properties] Properties to set
       */
      function MsgDepositResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgDepositResponse message. Does not implicitly {@link ununifi.cdp.MsgDepositResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgDepositResponse
       * @static
       * @param {ununifi.cdp.IMsgDepositResponse} message MsgDepositResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDepositResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgDepositResponse
       * @static
       * @param {ununifi.cdp.IMsgDepositResponse} message MsgDepositResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgDepositResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgDepositResponse} MsgDepositResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgDepositResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgDepositResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgDepositResponse} MsgDepositResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositResponse message.
       * @function verify
       * @memberof ununifi.cdp.MsgDepositResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgDepositResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgDepositResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgDepositResponse} MsgDepositResponse
       */
      MsgDepositResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgDepositResponse) return object;
        return new $root.ununifi.cdp.MsgDepositResponse();
      };

      /**
       * Creates a plain object from a MsgDepositResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgDepositResponse
       * @static
       * @param {ununifi.cdp.MsgDepositResponse} message MsgDepositResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgDepositResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgDepositResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositResponse;
    })();

    cdp.MsgWithdraw = (function () {
      /**
       * Properties of a MsgWithdraw.
       * @memberof ununifi.cdp
       * @interface IMsgWithdraw
       * @property {string|null} [depositor] MsgWithdraw depositor
       * @property {string|null} [owner] MsgWithdraw owner
       * @property {cosmos.base.v1beta1.ICoin|null} [collateral] MsgWithdraw collateral
       * @property {string|null} [collateral_type] MsgWithdraw collateral_type
       */

      /**
       * Constructs a new MsgWithdraw.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgWithdraw.
       * @implements IMsgWithdraw
       * @constructor
       * @param {ununifi.cdp.IMsgWithdraw=} [properties] Properties to set
       */
      function MsgWithdraw(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdraw depositor.
       * @member {string} depositor
       * @memberof ununifi.cdp.MsgWithdraw
       * @instance
       */
      MsgWithdraw.prototype.depositor = '';

      /**
       * MsgWithdraw owner.
       * @member {string} owner
       * @memberof ununifi.cdp.MsgWithdraw
       * @instance
       */
      MsgWithdraw.prototype.owner = '';

      /**
       * MsgWithdraw collateral.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} collateral
       * @memberof ununifi.cdp.MsgWithdraw
       * @instance
       */
      MsgWithdraw.prototype.collateral = null;

      /**
       * MsgWithdraw collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.MsgWithdraw
       * @instance
       */
      MsgWithdraw.prototype.collateral_type = '';

      /**
       * Encodes the specified MsgWithdraw message. Does not implicitly {@link ununifi.cdp.MsgWithdraw.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgWithdraw
       * @static
       * @param {ununifi.cdp.IMsgWithdraw} message MsgWithdraw message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdraw.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.depositor != null && Object.hasOwnProperty.call(message, 'depositor'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.depositor);
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
        if (message.collateral != null && Object.hasOwnProperty.call(message, 'collateral'))
          $root.cosmos.base.v1beta1.Coin.encode(message.collateral, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.collateral_type);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdraw message, length delimited. Does not implicitly {@link ununifi.cdp.MsgWithdraw.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgWithdraw
       * @static
       * @param {ununifi.cdp.IMsgWithdraw} message MsgWithdraw message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdraw.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdraw message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgWithdraw
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgWithdraw} MsgWithdraw
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdraw.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgWithdraw();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.depositor = reader.string();
              break;
            case 2:
              message.owner = reader.string();
              break;
            case 3:
              message.collateral = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.collateral_type = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdraw message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgWithdraw
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgWithdraw} MsgWithdraw
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdraw.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdraw message.
       * @function verify
       * @memberof ununifi.cdp.MsgWithdraw
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdraw.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.depositor != null && message.hasOwnProperty('depositor'))
          if (!$util.isString(message.depositor)) return 'depositor: string expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.collateral != null && message.hasOwnProperty('collateral')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.collateral);
          if (error) return 'collateral.' + error;
        }
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdraw message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgWithdraw
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgWithdraw} MsgWithdraw
       */
      MsgWithdraw.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgWithdraw) return object;
        let message = new $root.ununifi.cdp.MsgWithdraw();
        if (object.depositor != null) message.depositor = String(object.depositor);
        if (object.owner != null) message.owner = String(object.owner);
        if (object.collateral != null) {
          if (typeof object.collateral !== 'object') throw TypeError('.ununifi.cdp.MsgWithdraw.collateral: object expected');
          message.collateral = $root.cosmos.base.v1beta1.Coin.fromObject(object.collateral);
        }
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdraw message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgWithdraw
       * @static
       * @param {ununifi.cdp.MsgWithdraw} message MsgWithdraw
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdraw.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.depositor = '';
          object.owner = '';
          object.collateral = null;
          object.collateral_type = '';
        }
        if (message.depositor != null && message.hasOwnProperty('depositor')) object.depositor = message.depositor;
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.collateral != null && message.hasOwnProperty('collateral'))
          object.collateral = $root.cosmos.base.v1beta1.Coin.toObject(message.collateral, options);
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        return object;
      };

      /**
       * Converts this MsgWithdraw to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgWithdraw
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdraw.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdraw;
    })();

    cdp.MsgWithdrawResponse = (function () {
      /**
       * Properties of a MsgWithdrawResponse.
       * @memberof ununifi.cdp
       * @interface IMsgWithdrawResponse
       */

      /**
       * Constructs a new MsgWithdrawResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgWithdrawResponse.
       * @implements IMsgWithdrawResponse
       * @constructor
       * @param {ununifi.cdp.IMsgWithdrawResponse=} [properties] Properties to set
       */
      function MsgWithdrawResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawResponse message. Does not implicitly {@link ununifi.cdp.MsgWithdrawResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @static
       * @param {ununifi.cdp.IMsgWithdrawResponse} message MsgWithdrawResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgWithdrawResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @static
       * @param {ununifi.cdp.IMsgWithdrawResponse} message MsgWithdrawResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgWithdrawResponse} MsgWithdrawResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgWithdrawResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgWithdrawResponse} MsgWithdrawResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawResponse message.
       * @function verify
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgWithdrawResponse} MsgWithdrawResponse
       */
      MsgWithdrawResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgWithdrawResponse) return object;
        return new $root.ununifi.cdp.MsgWithdrawResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @static
       * @param {ununifi.cdp.MsgWithdrawResponse} message MsgWithdrawResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgWithdrawResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawResponse;
    })();

    cdp.MsgDrawDebt = (function () {
      /**
       * Properties of a MsgDrawDebt.
       * @memberof ununifi.cdp
       * @interface IMsgDrawDebt
       * @property {string|null} [sender] MsgDrawDebt sender
       * @property {string|null} [collateral_type] MsgDrawDebt collateral_type
       * @property {cosmos.base.v1beta1.ICoin|null} [principal] MsgDrawDebt principal
       */

      /**
       * Constructs a new MsgDrawDebt.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgDrawDebt.
       * @implements IMsgDrawDebt
       * @constructor
       * @param {ununifi.cdp.IMsgDrawDebt=} [properties] Properties to set
       */
      function MsgDrawDebt(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgDrawDebt sender.
       * @member {string} sender
       * @memberof ununifi.cdp.MsgDrawDebt
       * @instance
       */
      MsgDrawDebt.prototype.sender = '';

      /**
       * MsgDrawDebt collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.MsgDrawDebt
       * @instance
       */
      MsgDrawDebt.prototype.collateral_type = '';

      /**
       * MsgDrawDebt principal.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} principal
       * @memberof ununifi.cdp.MsgDrawDebt
       * @instance
       */
      MsgDrawDebt.prototype.principal = null;

      /**
       * Encodes the specified MsgDrawDebt message. Does not implicitly {@link ununifi.cdp.MsgDrawDebt.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgDrawDebt
       * @static
       * @param {ununifi.cdp.IMsgDrawDebt} message MsgDrawDebt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDrawDebt.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
        if (message.principal != null && Object.hasOwnProperty.call(message, 'principal'))
          $root.cosmos.base.v1beta1.Coin.encode(message.principal, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgDrawDebt message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDrawDebt.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgDrawDebt
       * @static
       * @param {ununifi.cdp.IMsgDrawDebt} message MsgDrawDebt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDrawDebt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDrawDebt message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgDrawDebt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgDrawDebt} MsgDrawDebt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDrawDebt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgDrawDebt();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.collateral_type = reader.string();
              break;
            case 3:
              message.principal = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDrawDebt message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgDrawDebt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgDrawDebt} MsgDrawDebt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDrawDebt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDrawDebt message.
       * @function verify
       * @memberof ununifi.cdp.MsgDrawDebt
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDrawDebt.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        if (message.principal != null && message.hasOwnProperty('principal')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.principal);
          if (error) return 'principal.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgDrawDebt message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgDrawDebt
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgDrawDebt} MsgDrawDebt
       */
      MsgDrawDebt.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgDrawDebt) return object;
        let message = new $root.ununifi.cdp.MsgDrawDebt();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        if (object.principal != null) {
          if (typeof object.principal !== 'object') throw TypeError('.ununifi.cdp.MsgDrawDebt.principal: object expected');
          message.principal = $root.cosmos.base.v1beta1.Coin.fromObject(object.principal);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgDrawDebt message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgDrawDebt
       * @static
       * @param {ununifi.cdp.MsgDrawDebt} message MsgDrawDebt
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDrawDebt.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.collateral_type = '';
          object.principal = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        if (message.principal != null && message.hasOwnProperty('principal'))
          object.principal = $root.cosmos.base.v1beta1.Coin.toObject(message.principal, options);
        return object;
      };

      /**
       * Converts this MsgDrawDebt to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgDrawDebt
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDrawDebt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDrawDebt;
    })();

    cdp.MsgDrawDebtResponse = (function () {
      /**
       * Properties of a MsgDrawDebtResponse.
       * @memberof ununifi.cdp
       * @interface IMsgDrawDebtResponse
       */

      /**
       * Constructs a new MsgDrawDebtResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgDrawDebtResponse.
       * @implements IMsgDrawDebtResponse
       * @constructor
       * @param {ununifi.cdp.IMsgDrawDebtResponse=} [properties] Properties to set
       */
      function MsgDrawDebtResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgDrawDebtResponse message. Does not implicitly {@link ununifi.cdp.MsgDrawDebtResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @static
       * @param {ununifi.cdp.IMsgDrawDebtResponse} message MsgDrawDebtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDrawDebtResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgDrawDebtResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgDrawDebtResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @static
       * @param {ununifi.cdp.IMsgDrawDebtResponse} message MsgDrawDebtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDrawDebtResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDrawDebtResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgDrawDebtResponse} MsgDrawDebtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDrawDebtResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgDrawDebtResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDrawDebtResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgDrawDebtResponse} MsgDrawDebtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDrawDebtResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDrawDebtResponse message.
       * @function verify
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDrawDebtResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgDrawDebtResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgDrawDebtResponse} MsgDrawDebtResponse
       */
      MsgDrawDebtResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgDrawDebtResponse) return object;
        return new $root.ununifi.cdp.MsgDrawDebtResponse();
      };

      /**
       * Creates a plain object from a MsgDrawDebtResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @static
       * @param {ununifi.cdp.MsgDrawDebtResponse} message MsgDrawDebtResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDrawDebtResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgDrawDebtResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgDrawDebtResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDrawDebtResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDrawDebtResponse;
    })();

    cdp.MsgRepayDebt = (function () {
      /**
       * Properties of a MsgRepayDebt.
       * @memberof ununifi.cdp
       * @interface IMsgRepayDebt
       * @property {string|null} [sender] MsgRepayDebt sender
       * @property {string|null} [collateral_type] MsgRepayDebt collateral_type
       * @property {cosmos.base.v1beta1.ICoin|null} [payment] MsgRepayDebt payment
       */

      /**
       * Constructs a new MsgRepayDebt.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgRepayDebt.
       * @implements IMsgRepayDebt
       * @constructor
       * @param {ununifi.cdp.IMsgRepayDebt=} [properties] Properties to set
       */
      function MsgRepayDebt(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRepayDebt sender.
       * @member {string} sender
       * @memberof ununifi.cdp.MsgRepayDebt
       * @instance
       */
      MsgRepayDebt.prototype.sender = '';

      /**
       * MsgRepayDebt collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.MsgRepayDebt
       * @instance
       */
      MsgRepayDebt.prototype.collateral_type = '';

      /**
       * MsgRepayDebt payment.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} payment
       * @memberof ununifi.cdp.MsgRepayDebt
       * @instance
       */
      MsgRepayDebt.prototype.payment = null;

      /**
       * Encodes the specified MsgRepayDebt message. Does not implicitly {@link ununifi.cdp.MsgRepayDebt.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgRepayDebt
       * @static
       * @param {ununifi.cdp.IMsgRepayDebt} message MsgRepayDebt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayDebt.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
        if (message.payment != null && Object.hasOwnProperty.call(message, 'payment'))
          $root.cosmos.base.v1beta1.Coin.encode(message.payment, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgRepayDebt message, length delimited. Does not implicitly {@link ununifi.cdp.MsgRepayDebt.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgRepayDebt
       * @static
       * @param {ununifi.cdp.IMsgRepayDebt} message MsgRepayDebt message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayDebt.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRepayDebt message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgRepayDebt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgRepayDebt} MsgRepayDebt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayDebt.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgRepayDebt();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.collateral_type = reader.string();
              break;
            case 3:
              message.payment = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRepayDebt message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgRepayDebt
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgRepayDebt} MsgRepayDebt
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayDebt.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRepayDebt message.
       * @function verify
       * @memberof ununifi.cdp.MsgRepayDebt
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRepayDebt.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        if (message.payment != null && message.hasOwnProperty('payment')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.payment);
          if (error) return 'payment.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgRepayDebt message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgRepayDebt
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgRepayDebt} MsgRepayDebt
       */
      MsgRepayDebt.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgRepayDebt) return object;
        let message = new $root.ununifi.cdp.MsgRepayDebt();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        if (object.payment != null) {
          if (typeof object.payment !== 'object') throw TypeError('.ununifi.cdp.MsgRepayDebt.payment: object expected');
          message.payment = $root.cosmos.base.v1beta1.Coin.fromObject(object.payment);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgRepayDebt message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgRepayDebt
       * @static
       * @param {ununifi.cdp.MsgRepayDebt} message MsgRepayDebt
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRepayDebt.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.collateral_type = '';
          object.payment = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        if (message.payment != null && message.hasOwnProperty('payment'))
          object.payment = $root.cosmos.base.v1beta1.Coin.toObject(message.payment, options);
        return object;
      };

      /**
       * Converts this MsgRepayDebt to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgRepayDebt
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRepayDebt.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRepayDebt;
    })();

    cdp.MsgRepayDebtResponse = (function () {
      /**
       * Properties of a MsgRepayDebtResponse.
       * @memberof ununifi.cdp
       * @interface IMsgRepayDebtResponse
       */

      /**
       * Constructs a new MsgRepayDebtResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgRepayDebtResponse.
       * @implements IMsgRepayDebtResponse
       * @constructor
       * @param {ununifi.cdp.IMsgRepayDebtResponse=} [properties] Properties to set
       */
      function MsgRepayDebtResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRepayDebtResponse message. Does not implicitly {@link ununifi.cdp.MsgRepayDebtResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @static
       * @param {ununifi.cdp.IMsgRepayDebtResponse} message MsgRepayDebtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayDebtResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRepayDebtResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgRepayDebtResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @static
       * @param {ununifi.cdp.IMsgRepayDebtResponse} message MsgRepayDebtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayDebtResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRepayDebtResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgRepayDebtResponse} MsgRepayDebtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayDebtResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgRepayDebtResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRepayDebtResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgRepayDebtResponse} MsgRepayDebtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayDebtResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRepayDebtResponse message.
       * @function verify
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRepayDebtResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRepayDebtResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgRepayDebtResponse} MsgRepayDebtResponse
       */
      MsgRepayDebtResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgRepayDebtResponse) return object;
        return new $root.ununifi.cdp.MsgRepayDebtResponse();
      };

      /**
       * Creates a plain object from a MsgRepayDebtResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @static
       * @param {ununifi.cdp.MsgRepayDebtResponse} message MsgRepayDebtResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRepayDebtResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRepayDebtResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgRepayDebtResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRepayDebtResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRepayDebtResponse;
    })();

    cdp.MsgLiquidate = (function () {
      /**
       * Properties of a MsgLiquidate.
       * @memberof ununifi.cdp
       * @interface IMsgLiquidate
       * @property {string|null} [keeper] MsgLiquidate keeper
       * @property {string|null} [borrower] MsgLiquidate borrower
       * @property {string|null} [collateral_type] MsgLiquidate collateral_type
       */

      /**
       * Constructs a new MsgLiquidate.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgLiquidate.
       * @implements IMsgLiquidate
       * @constructor
       * @param {ununifi.cdp.IMsgLiquidate=} [properties] Properties to set
       */
      function MsgLiquidate(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgLiquidate keeper.
       * @member {string} keeper
       * @memberof ununifi.cdp.MsgLiquidate
       * @instance
       */
      MsgLiquidate.prototype.keeper = '';

      /**
       * MsgLiquidate borrower.
       * @member {string} borrower
       * @memberof ununifi.cdp.MsgLiquidate
       * @instance
       */
      MsgLiquidate.prototype.borrower = '';

      /**
       * MsgLiquidate collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.MsgLiquidate
       * @instance
       */
      MsgLiquidate.prototype.collateral_type = '';

      /**
       * Encodes the specified MsgLiquidate message. Does not implicitly {@link ununifi.cdp.MsgLiquidate.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgLiquidate
       * @static
       * @param {ununifi.cdp.IMsgLiquidate} message MsgLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidate.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.keeper != null && Object.hasOwnProperty.call(message, 'keeper'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.keeper);
        if (message.borrower != null && Object.hasOwnProperty.call(message, 'borrower'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.borrower);
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.collateral_type);
        return writer;
      };

      /**
       * Encodes the specified MsgLiquidate message, length delimited. Does not implicitly {@link ununifi.cdp.MsgLiquidate.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgLiquidate
       * @static
       * @param {ununifi.cdp.IMsgLiquidate} message MsgLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgLiquidate message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgLiquidate} MsgLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgLiquidate();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keeper = reader.string();
              break;
            case 2:
              message.borrower = reader.string();
              break;
            case 3:
              message.collateral_type = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgLiquidate message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgLiquidate} MsgLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgLiquidate message.
       * @function verify
       * @memberof ununifi.cdp.MsgLiquidate
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgLiquidate.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.keeper != null && message.hasOwnProperty('keeper'))
          if (!$util.isString(message.keeper)) return 'keeper: string expected';
        if (message.borrower != null && message.hasOwnProperty('borrower'))
          if (!$util.isString(message.borrower)) return 'borrower: string expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        return null;
      };

      /**
       * Creates a MsgLiquidate message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgLiquidate
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgLiquidate} MsgLiquidate
       */
      MsgLiquidate.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgLiquidate) return object;
        let message = new $root.ununifi.cdp.MsgLiquidate();
        if (object.keeper != null) message.keeper = String(object.keeper);
        if (object.borrower != null) message.borrower = String(object.borrower);
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        return message;
      };

      /**
       * Creates a plain object from a MsgLiquidate message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgLiquidate
       * @static
       * @param {ununifi.cdp.MsgLiquidate} message MsgLiquidate
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgLiquidate.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.keeper = '';
          object.borrower = '';
          object.collateral_type = '';
        }
        if (message.keeper != null && message.hasOwnProperty('keeper')) object.keeper = message.keeper;
        if (message.borrower != null && message.hasOwnProperty('borrower')) object.borrower = message.borrower;
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        return object;
      };

      /**
       * Converts this MsgLiquidate to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgLiquidate
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgLiquidate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgLiquidate;
    })();

    cdp.MsgLiquidateResponse = (function () {
      /**
       * Properties of a MsgLiquidateResponse.
       * @memberof ununifi.cdp
       * @interface IMsgLiquidateResponse
       */

      /**
       * Constructs a new MsgLiquidateResponse.
       * @memberof ununifi.cdp
       * @classdesc Represents a MsgLiquidateResponse.
       * @implements IMsgLiquidateResponse
       * @constructor
       * @param {ununifi.cdp.IMsgLiquidateResponse=} [properties] Properties to set
       */
      function MsgLiquidateResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgLiquidateResponse message. Does not implicitly {@link ununifi.cdp.MsgLiquidateResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @static
       * @param {ununifi.cdp.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidateResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgLiquidateResponse message, length delimited. Does not implicitly {@link ununifi.cdp.MsgLiquidateResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @static
       * @param {ununifi.cdp.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidateResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgLiquidateResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.MsgLiquidateResponse} MsgLiquidateResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.MsgLiquidateResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgLiquidateResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.MsgLiquidateResponse} MsgLiquidateResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidateResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgLiquidateResponse message.
       * @function verify
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgLiquidateResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgLiquidateResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.MsgLiquidateResponse} MsgLiquidateResponse
       */
      MsgLiquidateResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.MsgLiquidateResponse) return object;
        return new $root.ununifi.cdp.MsgLiquidateResponse();
      };

      /**
       * Creates a plain object from a MsgLiquidateResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @static
       * @param {ununifi.cdp.MsgLiquidateResponse} message MsgLiquidateResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgLiquidateResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgLiquidateResponse to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.MsgLiquidateResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgLiquidateResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgLiquidateResponse;
    })();

    cdp.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.cdp
       * @interface IGenesisState
       * @property {ununifi.cdp.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.cdp.ICdp>|null} [cdps] GenesisState cdps
       * @property {Array.<ununifi.cdp.IDeposit>|null} [deposits] GenesisState deposits
       * @property {Long|null} [starting_cdp_id] GenesisState starting_cdp_id
       * @property {string|null} [gov_denom] GenesisState gov_denom
       * @property {Array.<ununifi.cdp.IGenesisAccumulationTime>|null} [previous_accumulation_times] GenesisState previous_accumulation_times
       * @property {Array.<ununifi.cdp.IGenesisTotalPrincipal>|null} [total_principals] GenesisState total_principals
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.cdp
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.cdp.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.cdps = [];
        this.deposits = [];
        this.previous_accumulation_times = [];
        this.total_principals = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.cdp.IParams|null|undefined} params
       * @memberof ununifi.cdp.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState cdps.
       * @member {Array.<ununifi.cdp.ICdp>} cdps
       * @memberof ununifi.cdp.GenesisState
       * @instance
       */
      GenesisState.prototype.cdps = $util.emptyArray;

      /**
       * GenesisState deposits.
       * @member {Array.<ununifi.cdp.IDeposit>} deposits
       * @memberof ununifi.cdp.GenesisState
       * @instance
       */
      GenesisState.prototype.deposits = $util.emptyArray;

      /**
       * GenesisState starting_cdp_id.
       * @member {Long} starting_cdp_id
       * @memberof ununifi.cdp.GenesisState
       * @instance
       */
      GenesisState.prototype.starting_cdp_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * GenesisState gov_denom.
       * @member {string} gov_denom
       * @memberof ununifi.cdp.GenesisState
       * @instance
       */
      GenesisState.prototype.gov_denom = '';

      /**
       * GenesisState previous_accumulation_times.
       * @member {Array.<ununifi.cdp.IGenesisAccumulationTime>} previous_accumulation_times
       * @memberof ununifi.cdp.GenesisState
       * @instance
       */
      GenesisState.prototype.previous_accumulation_times = $util.emptyArray;

      /**
       * GenesisState total_principals.
       * @member {Array.<ununifi.cdp.IGenesisTotalPrincipal>} total_principals
       * @memberof ununifi.cdp.GenesisState
       * @instance
       */
      GenesisState.prototype.total_principals = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.cdp.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.GenesisState
       * @static
       * @param {ununifi.cdp.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.cdp.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.cdps != null && message.cdps.length)
          for (let i = 0; i < message.cdps.length; ++i)
            $root.ununifi.cdp.Cdp.encode(message.cdps[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.deposits != null && message.deposits.length)
          for (let i = 0; i < message.deposits.length; ++i)
            $root.ununifi.cdp.Deposit.encode(message.deposits[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.starting_cdp_id != null && Object.hasOwnProperty.call(message, 'starting_cdp_id'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.starting_cdp_id);
        if (message.gov_denom != null && Object.hasOwnProperty.call(message, 'gov_denom'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.gov_denom);
        if (message.previous_accumulation_times != null && message.previous_accumulation_times.length)
          for (let i = 0; i < message.previous_accumulation_times.length; ++i)
            $root.ununifi.cdp.GenesisAccumulationTime.encode(
              message.previous_accumulation_times[i],
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
        if (message.total_principals != null && message.total_principals.length)
          for (let i = 0; i < message.total_principals.length; ++i)
            $root.ununifi.cdp.GenesisTotalPrincipal.encode(
              message.total_principals[i],
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.cdp.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.GenesisState
       * @static
       * @param {ununifi.cdp.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.cdp.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.cdps && message.cdps.length)) message.cdps = [];
              message.cdps.push($root.ununifi.cdp.Cdp.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.deposits && message.deposits.length)) message.deposits = [];
              message.deposits.push($root.ununifi.cdp.Deposit.decode(reader, reader.uint32()));
              break;
            case 4:
              message.starting_cdp_id = reader.uint64();
              break;
            case 5:
              message.gov_denom = reader.string();
              break;
            case 6:
              if (!(message.previous_accumulation_times && message.previous_accumulation_times.length))
                message.previous_accumulation_times = [];
              message.previous_accumulation_times.push($root.ununifi.cdp.GenesisAccumulationTime.decode(reader, reader.uint32()));
              break;
            case 7:
              if (!(message.total_principals && message.total_principals.length)) message.total_principals = [];
              message.total_principals.push($root.ununifi.cdp.GenesisTotalPrincipal.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.cdp.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.cdp.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.cdps != null && message.hasOwnProperty('cdps')) {
          if (!Array.isArray(message.cdps)) return 'cdps: array expected';
          for (let i = 0; i < message.cdps.length; ++i) {
            let error = $root.ununifi.cdp.Cdp.verify(message.cdps[i]);
            if (error) return 'cdps.' + error;
          }
        }
        if (message.deposits != null && message.hasOwnProperty('deposits')) {
          if (!Array.isArray(message.deposits)) return 'deposits: array expected';
          for (let i = 0; i < message.deposits.length; ++i) {
            let error = $root.ununifi.cdp.Deposit.verify(message.deposits[i]);
            if (error) return 'deposits.' + error;
          }
        }
        if (message.starting_cdp_id != null && message.hasOwnProperty('starting_cdp_id'))
          if (
            !$util.isInteger(message.starting_cdp_id) &&
            !(message.starting_cdp_id && $util.isInteger(message.starting_cdp_id.low) && $util.isInteger(message.starting_cdp_id.high))
          )
            return 'starting_cdp_id: integer|Long expected';
        if (message.gov_denom != null && message.hasOwnProperty('gov_denom'))
          if (!$util.isString(message.gov_denom)) return 'gov_denom: string expected';
        if (message.previous_accumulation_times != null && message.hasOwnProperty('previous_accumulation_times')) {
          if (!Array.isArray(message.previous_accumulation_times)) return 'previous_accumulation_times: array expected';
          for (let i = 0; i < message.previous_accumulation_times.length; ++i) {
            let error = $root.ununifi.cdp.GenesisAccumulationTime.verify(message.previous_accumulation_times[i]);
            if (error) return 'previous_accumulation_times.' + error;
          }
        }
        if (message.total_principals != null && message.hasOwnProperty('total_principals')) {
          if (!Array.isArray(message.total_principals)) return 'total_principals: array expected';
          for (let i = 0; i < message.total_principals.length; ++i) {
            let error = $root.ununifi.cdp.GenesisTotalPrincipal.verify(message.total_principals[i]);
            if (error) return 'total_principals.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.GenesisState) return object;
        let message = new $root.ununifi.cdp.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.cdp.GenesisState.params: object expected');
          message.params = $root.ununifi.cdp.Params.fromObject(object.params);
        }
        if (object.cdps) {
          if (!Array.isArray(object.cdps)) throw TypeError('.ununifi.cdp.GenesisState.cdps: array expected');
          message.cdps = [];
          for (let i = 0; i < object.cdps.length; ++i) {
            if (typeof object.cdps[i] !== 'object') throw TypeError('.ununifi.cdp.GenesisState.cdps: object expected');
            message.cdps[i] = $root.ununifi.cdp.Cdp.fromObject(object.cdps[i]);
          }
        }
        if (object.deposits) {
          if (!Array.isArray(object.deposits)) throw TypeError('.ununifi.cdp.GenesisState.deposits: array expected');
          message.deposits = [];
          for (let i = 0; i < object.deposits.length; ++i) {
            if (typeof object.deposits[i] !== 'object') throw TypeError('.ununifi.cdp.GenesisState.deposits: object expected');
            message.deposits[i] = $root.ununifi.cdp.Deposit.fromObject(object.deposits[i]);
          }
        }
        if (object.starting_cdp_id != null)
          if ($util.Long) (message.starting_cdp_id = $util.Long.fromValue(object.starting_cdp_id)).unsigned = true;
          else if (typeof object.starting_cdp_id === 'string') message.starting_cdp_id = parseInt(object.starting_cdp_id, 10);
          else if (typeof object.starting_cdp_id === 'number') message.starting_cdp_id = object.starting_cdp_id;
          else if (typeof object.starting_cdp_id === 'object')
            message.starting_cdp_id = new $util.LongBits(object.starting_cdp_id.low >>> 0, object.starting_cdp_id.high >>> 0).toNumber(
              true,
            );
        if (object.gov_denom != null) message.gov_denom = String(object.gov_denom);
        if (object.previous_accumulation_times) {
          if (!Array.isArray(object.previous_accumulation_times))
            throw TypeError('.ununifi.cdp.GenesisState.previous_accumulation_times: array expected');
          message.previous_accumulation_times = [];
          for (let i = 0; i < object.previous_accumulation_times.length; ++i) {
            if (typeof object.previous_accumulation_times[i] !== 'object')
              throw TypeError('.ununifi.cdp.GenesisState.previous_accumulation_times: object expected');
            message.previous_accumulation_times[i] = $root.ununifi.cdp.GenesisAccumulationTime.fromObject(
              object.previous_accumulation_times[i],
            );
          }
        }
        if (object.total_principals) {
          if (!Array.isArray(object.total_principals)) throw TypeError('.ununifi.cdp.GenesisState.total_principals: array expected');
          message.total_principals = [];
          for (let i = 0; i < object.total_principals.length; ++i) {
            if (typeof object.total_principals[i] !== 'object')
              throw TypeError('.ununifi.cdp.GenesisState.total_principals: object expected');
            message.total_principals[i] = $root.ununifi.cdp.GenesisTotalPrincipal.fromObject(object.total_principals[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.GenesisState
       * @static
       * @param {ununifi.cdp.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.cdps = [];
          object.deposits = [];
          object.previous_accumulation_times = [];
          object.total_principals = [];
        }
        if (options.defaults) {
          object.params = null;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.starting_cdp_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.starting_cdp_id = options.longs === String ? '0' : 0;
          object.gov_denom = '';
        }
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.cdp.Params.toObject(message.params, options);
        if (message.cdps && message.cdps.length) {
          object.cdps = [];
          for (let j = 0; j < message.cdps.length; ++j) object.cdps[j] = $root.ununifi.cdp.Cdp.toObject(message.cdps[j], options);
        }
        if (message.deposits && message.deposits.length) {
          object.deposits = [];
          for (let j = 0; j < message.deposits.length; ++j)
            object.deposits[j] = $root.ununifi.cdp.Deposit.toObject(message.deposits[j], options);
        }
        if (message.starting_cdp_id != null && message.hasOwnProperty('starting_cdp_id'))
          if (typeof message.starting_cdp_id === 'number')
            object.starting_cdp_id = options.longs === String ? String(message.starting_cdp_id) : message.starting_cdp_id;
          else
            object.starting_cdp_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.starting_cdp_id)
                : options.longs === Number
                ? new $util.LongBits(message.starting_cdp_id.low >>> 0, message.starting_cdp_id.high >>> 0).toNumber(true)
                : message.starting_cdp_id;
        if (message.gov_denom != null && message.hasOwnProperty('gov_denom')) object.gov_denom = message.gov_denom;
        if (message.previous_accumulation_times && message.previous_accumulation_times.length) {
          object.previous_accumulation_times = [];
          for (let j = 0; j < message.previous_accumulation_times.length; ++j)
            object.previous_accumulation_times[j] = $root.ununifi.cdp.GenesisAccumulationTime.toObject(
              message.previous_accumulation_times[j],
              options,
            );
        }
        if (message.total_principals && message.total_principals.length) {
          object.total_principals = [];
          for (let j = 0; j < message.total_principals.length; ++j)
            object.total_principals[j] = $root.ununifi.cdp.GenesisTotalPrincipal.toObject(message.total_principals[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    cdp.GenesisAccumulationTime = (function () {
      /**
       * Properties of a GenesisAccumulationTime.
       * @memberof ununifi.cdp
       * @interface IGenesisAccumulationTime
       * @property {string|null} [collateral_type] GenesisAccumulationTime collateral_type
       * @property {google.protobuf.ITimestamp|null} [previous_accumulation_time] GenesisAccumulationTime previous_accumulation_time
       * @property {string|null} [interest_factor] GenesisAccumulationTime interest_factor
       */

      /**
       * Constructs a new GenesisAccumulationTime.
       * @memberof ununifi.cdp
       * @classdesc Represents a GenesisAccumulationTime.
       * @implements IGenesisAccumulationTime
       * @constructor
       * @param {ununifi.cdp.IGenesisAccumulationTime=} [properties] Properties to set
       */
      function GenesisAccumulationTime(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisAccumulationTime collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @instance
       */
      GenesisAccumulationTime.prototype.collateral_type = '';

      /**
       * GenesisAccumulationTime previous_accumulation_time.
       * @member {google.protobuf.ITimestamp|null|undefined} previous_accumulation_time
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @instance
       */
      GenesisAccumulationTime.prototype.previous_accumulation_time = null;

      /**
       * GenesisAccumulationTime interest_factor.
       * @member {string} interest_factor
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @instance
       */
      GenesisAccumulationTime.prototype.interest_factor = '';

      /**
       * Encodes the specified GenesisAccumulationTime message. Does not implicitly {@link ununifi.cdp.GenesisAccumulationTime.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @static
       * @param {ununifi.cdp.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisAccumulationTime.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
        if (message.previous_accumulation_time != null && Object.hasOwnProperty.call(message, 'previous_accumulation_time'))
          $root.google.protobuf.Timestamp.encode(
            message.previous_accumulation_time,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        if (message.interest_factor != null && Object.hasOwnProperty.call(message, 'interest_factor'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.interest_factor);
        return writer;
      };

      /**
       * Encodes the specified GenesisAccumulationTime message, length delimited. Does not implicitly {@link ununifi.cdp.GenesisAccumulationTime.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @static
       * @param {ununifi.cdp.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisAccumulationTime.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisAccumulationTime message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.GenesisAccumulationTime} GenesisAccumulationTime
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisAccumulationTime.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.GenesisAccumulationTime();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.collateral_type = reader.string();
              break;
            case 2:
              message.previous_accumulation_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.interest_factor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisAccumulationTime message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.GenesisAccumulationTime} GenesisAccumulationTime
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisAccumulationTime.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisAccumulationTime message.
       * @function verify
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisAccumulationTime.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.previous_accumulation_time);
          if (error) return 'previous_accumulation_time.' + error;
        }
        if (message.interest_factor != null && message.hasOwnProperty('interest_factor'))
          if (!$util.isString(message.interest_factor)) return 'interest_factor: string expected';
        return null;
      };

      /**
       * Creates a GenesisAccumulationTime message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.GenesisAccumulationTime} GenesisAccumulationTime
       */
      GenesisAccumulationTime.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.GenesisAccumulationTime) return object;
        let message = new $root.ununifi.cdp.GenesisAccumulationTime();
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        if (object.previous_accumulation_time != null) {
          if (typeof object.previous_accumulation_time !== 'object')
            throw TypeError('.ununifi.cdp.GenesisAccumulationTime.previous_accumulation_time: object expected');
          message.previous_accumulation_time = $root.google.protobuf.Timestamp.fromObject(object.previous_accumulation_time);
        }
        if (object.interest_factor != null) message.interest_factor = String(object.interest_factor);
        return message;
      };

      /**
       * Creates a plain object from a GenesisAccumulationTime message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @static
       * @param {ununifi.cdp.GenesisAccumulationTime} message GenesisAccumulationTime
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisAccumulationTime.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.collateral_type = '';
          object.previous_accumulation_time = null;
          object.interest_factor = '';
        }
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time'))
          object.previous_accumulation_time = $root.google.protobuf.Timestamp.toObject(message.previous_accumulation_time, options);
        if (message.interest_factor != null && message.hasOwnProperty('interest_factor')) object.interest_factor = message.interest_factor;
        return object;
      };

      /**
       * Converts this GenesisAccumulationTime to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.GenesisAccumulationTime
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisAccumulationTime.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisAccumulationTime;
    })();

    cdp.GenesisTotalPrincipal = (function () {
      /**
       * Properties of a GenesisTotalPrincipal.
       * @memberof ununifi.cdp
       * @interface IGenesisTotalPrincipal
       * @property {string|null} [collateral_type] GenesisTotalPrincipal collateral_type
       * @property {string|null} [total_principal] GenesisTotalPrincipal total_principal
       */

      /**
       * Constructs a new GenesisTotalPrincipal.
       * @memberof ununifi.cdp
       * @classdesc Represents a GenesisTotalPrincipal.
       * @implements IGenesisTotalPrincipal
       * @constructor
       * @param {ununifi.cdp.IGenesisTotalPrincipal=} [properties] Properties to set
       */
      function GenesisTotalPrincipal(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisTotalPrincipal collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @instance
       */
      GenesisTotalPrincipal.prototype.collateral_type = '';

      /**
       * GenesisTotalPrincipal total_principal.
       * @member {string} total_principal
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @instance
       */
      GenesisTotalPrincipal.prototype.total_principal = '';

      /**
       * Encodes the specified GenesisTotalPrincipal message. Does not implicitly {@link ununifi.cdp.GenesisTotalPrincipal.verify|verify} messages.
       * @function encode
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @static
       * @param {ununifi.cdp.IGenesisTotalPrincipal} message GenesisTotalPrincipal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisTotalPrincipal.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
        if (message.total_principal != null && Object.hasOwnProperty.call(message, 'total_principal'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.total_principal);
        return writer;
      };

      /**
       * Encodes the specified GenesisTotalPrincipal message, length delimited. Does not implicitly {@link ununifi.cdp.GenesisTotalPrincipal.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @static
       * @param {ununifi.cdp.IGenesisTotalPrincipal} message GenesisTotalPrincipal message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisTotalPrincipal.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisTotalPrincipal message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.cdp.GenesisTotalPrincipal} GenesisTotalPrincipal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisTotalPrincipal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.cdp.GenesisTotalPrincipal();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.collateral_type = reader.string();
              break;
            case 2:
              message.total_principal = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisTotalPrincipal message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.cdp.GenesisTotalPrincipal} GenesisTotalPrincipal
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisTotalPrincipal.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisTotalPrincipal message.
       * @function verify
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisTotalPrincipal.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        if (message.total_principal != null && message.hasOwnProperty('total_principal'))
          if (!$util.isString(message.total_principal)) return 'total_principal: string expected';
        return null;
      };

      /**
       * Creates a GenesisTotalPrincipal message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.cdp.GenesisTotalPrincipal} GenesisTotalPrincipal
       */
      GenesisTotalPrincipal.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.cdp.GenesisTotalPrincipal) return object;
        let message = new $root.ununifi.cdp.GenesisTotalPrincipal();
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        if (object.total_principal != null) message.total_principal = String(object.total_principal);
        return message;
      };

      /**
       * Creates a plain object from a GenesisTotalPrincipal message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @static
       * @param {ununifi.cdp.GenesisTotalPrincipal} message GenesisTotalPrincipal
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisTotalPrincipal.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.collateral_type = '';
          object.total_principal = '';
        }
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        if (message.total_principal != null && message.hasOwnProperty('total_principal')) object.total_principal = message.total_principal;
        return object;
      };

      /**
       * Converts this GenesisTotalPrincipal to JSON.
       * @function toJSON
       * @memberof ununifi.cdp.GenesisTotalPrincipal
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisTotalPrincipal.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisTotalPrincipal;
    })();

    return cdp;
  })();

  ununifi.ecosystemincentive = (function () {
    /**
     * Namespace ecosystemincentive.
     * @memberof ununifi
     * @namespace
     */
    const ecosystemincentive = {};

    ecosystemincentive.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#params}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.ecosystemincentive.QueryParamsRequest,
            $root.ununifi.ecosystemincentive.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#incentiveUnit}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef IncentiveUnitCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} [response] QueryIncentiveUnitResponse
       */

      /**
       * Calls IncentiveUnit.
       * @function incentiveUnit
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} request QueryIncentiveUnitRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.IncentiveUnitCallback} callback Node-style callback called with the error, if any, and QueryIncentiveUnitResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.incentiveUnit = function incentiveUnit(request, callback) {
          return this.rpcCall(
            incentiveUnit,
            $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest,
            $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'IncentiveUnit' },
      );

      /**
       * Calls IncentiveUnit.
       * @function incentiveUnit
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} request QueryIncentiveUnitRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryIncentiveUnitResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#allRewards}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef AllRewardsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryAllRewardsResponse} [response] QueryAllRewardsResponse
       */

      /**
       * Calls AllRewards.
       * @function allRewards
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} request QueryAllRewardsRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.AllRewardsCallback} callback Node-style callback called with the error, if any, and QueryAllRewardsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.allRewards = function allRewards(request, callback) {
          return this.rpcCall(
            allRewards,
            $root.ununifi.ecosystemincentive.QueryAllRewardsRequest,
            $root.ununifi.ecosystemincentive.QueryAllRewardsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AllRewards' },
      );

      /**
       * Calls AllRewards.
       * @function allRewards
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} request QueryAllRewardsRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryAllRewardsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#reward}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef RewardCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryRewardResponse} [response] QueryRewardResponse
       */

      /**
       * Calls Reward.
       * @function reward
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryRewardRequest} request QueryRewardRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.RewardCallback} callback Node-style callback called with the error, if any, and QueryRewardResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.reward = function reward(request, callback) {
          return this.rpcCall(
            reward,
            $root.ununifi.ecosystemincentive.QueryRewardRequest,
            $root.ununifi.ecosystemincentive.QueryRewardResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Reward' },
      );

      /**
       * Calls Reward.
       * @function reward
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryRewardRequest} request QueryRewardRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryRewardResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#recordedIncentiveUnitId}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef RecordedIncentiveUnitIdCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} [response] QueryRecordedIncentiveUnitIdResponse
       */

      /**
       * Calls RecordedIncentiveUnitId.
       * @function recordedIncentiveUnitId
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} request QueryRecordedIncentiveUnitIdRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.RecordedIncentiveUnitIdCallback} callback Node-style callback called with the error, if any, and QueryRecordedIncentiveUnitIdResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.recordedIncentiveUnitId = function recordedIncentiveUnitId(request, callback) {
          return this.rpcCall(
            recordedIncentiveUnitId,
            $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest,
            $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RecordedIncentiveUnitId' },
      );

      /**
       * Calls RecordedIncentiveUnitId.
       * @function recordedIncentiveUnitId
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} request QueryRecordedIncentiveUnitIdRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    ecosystemincentive.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsRequest) return object;
        return new $root.ununifi.ecosystemincentive.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    ecosystemincentive.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryParamsResponse
       * @property {ununifi.ecosystemincentive.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.ecosystemincentive.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    ecosystemincentive.QueryIncentiveUnitRequest = (function () {
      /**
       * Properties of a QueryIncentiveUnitRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryIncentiveUnitRequest
       * @property {string|null} [incentive_unit_id] QueryIncentiveUnitRequest incentive_unit_id
       */

      /**
       * Constructs a new QueryIncentiveUnitRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryIncentiveUnitRequest.
       * @implements IQueryIncentiveUnitRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest=} [properties] Properties to set
       */
      function QueryIncentiveUnitRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryIncentiveUnitRequest incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @instance
       */
      QueryIncentiveUnitRequest.prototype.incentive_unit_id = '';

      /**
       * Encodes the specified QueryIncentiveUnitRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} message QueryIncentiveUnitRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIncentiveUnitRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
        return writer;
      };

      /**
       * Encodes the specified QueryIncentiveUnitRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitRequest} message QueryIncentiveUnitRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIncentiveUnitRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryIncentiveUnitRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} QueryIncentiveUnitRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIncentiveUnitRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryIncentiveUnitRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} QueryIncentiveUnitRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIncentiveUnitRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryIncentiveUnitRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryIncentiveUnitRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        return null;
      };

      /**
       * Creates a QueryIncentiveUnitRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} QueryIncentiveUnitRequest
       */
      QueryIncentiveUnitRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitRequest();
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryIncentiveUnitRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryIncentiveUnitRequest} message QueryIncentiveUnitRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryIncentiveUnitRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.incentive_unit_id = '';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        return object;
      };

      /**
       * Converts this QueryIncentiveUnitRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryIncentiveUnitRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryIncentiveUnitRequest;
    })();

    ecosystemincentive.QueryIncentiveUnitResponse = (function () {
      /**
       * Properties of a QueryIncentiveUnitResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryIncentiveUnitResponse
       * @property {ununifi.ecosystemincentive.IIncentiveUnit|null} [incentive_unit] QueryIncentiveUnitResponse incentive_unit
       */

      /**
       * Constructs a new QueryIncentiveUnitResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryIncentiveUnitResponse.
       * @implements IQueryIncentiveUnitResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitResponse=} [properties] Properties to set
       */
      function QueryIncentiveUnitResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryIncentiveUnitResponse incentive_unit.
       * @member {ununifi.ecosystemincentive.IIncentiveUnit|null|undefined} incentive_unit
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @instance
       */
      QueryIncentiveUnitResponse.prototype.incentive_unit = null;

      /**
       * Encodes the specified QueryIncentiveUnitResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitResponse} message QueryIncentiveUnitResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIncentiveUnitResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit != null && Object.hasOwnProperty.call(message, 'incentive_unit'))
          $root.ununifi.ecosystemincentive.IncentiveUnit.encode(
            message.incentive_unit,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryIncentiveUnitResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryIncentiveUnitResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryIncentiveUnitResponse} message QueryIncentiveUnitResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIncentiveUnitResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryIncentiveUnitResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} QueryIncentiveUnitResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIncentiveUnitResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit = $root.ununifi.ecosystemincentive.IncentiveUnit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryIncentiveUnitResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} QueryIncentiveUnitResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIncentiveUnitResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryIncentiveUnitResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryIncentiveUnitResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit != null && message.hasOwnProperty('incentive_unit')) {
          let error = $root.ununifi.ecosystemincentive.IncentiveUnit.verify(message.incentive_unit);
          if (error) return 'incentive_unit.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryIncentiveUnitResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} QueryIncentiveUnitResponse
       */
      QueryIncentiveUnitResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryIncentiveUnitResponse();
        if (object.incentive_unit != null) {
          if (typeof object.incentive_unit !== 'object')
            throw TypeError('.ununifi.ecosystemincentive.QueryIncentiveUnitResponse.incentive_unit: object expected');
          message.incentive_unit = $root.ununifi.ecosystemincentive.IncentiveUnit.fromObject(object.incentive_unit);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryIncentiveUnitResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryIncentiveUnitResponse} message QueryIncentiveUnitResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryIncentiveUnitResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.incentive_unit = null;
        if (message.incentive_unit != null && message.hasOwnProperty('incentive_unit'))
          object.incentive_unit = $root.ununifi.ecosystemincentive.IncentiveUnit.toObject(message.incentive_unit, options);
        return object;
      };

      /**
       * Converts this QueryIncentiveUnitResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryIncentiveUnitResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryIncentiveUnitResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryIncentiveUnitResponse;
    })();

    ecosystemincentive.QueryAllRewardsRequest = (function () {
      /**
       * Properties of a QueryAllRewardsRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryAllRewardsRequest
       * @property {string|null} [subject_addr] QueryAllRewardsRequest subject_addr
       */

      /**
       * Constructs a new QueryAllRewardsRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryAllRewardsRequest.
       * @implements IQueryAllRewardsRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest=} [properties] Properties to set
       */
      function QueryAllRewardsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllRewardsRequest subject_addr.
       * @member {string} subject_addr
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @instance
       */
      QueryAllRewardsRequest.prototype.subject_addr = '';

      /**
       * Encodes the specified QueryAllRewardsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} message QueryAllRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRewardsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
        return writer;
      };

      /**
       * Encodes the specified QueryAllRewardsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsRequest} message QueryAllRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllRewardsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRewardsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryAllRewardsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subject_addr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllRewardsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllRewardsRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllRewardsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
          if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
        return null;
      };

      /**
       * Creates a QueryAllRewardsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryAllRewardsRequest} QueryAllRewardsRequest
       */
      QueryAllRewardsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryAllRewardsRequest) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryAllRewardsRequest();
        if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
        return message;
      };

      /**
       * Creates a plain object from a QueryAllRewardsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryAllRewardsRequest} message QueryAllRewardsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllRewardsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.subject_addr = '';
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
        return object;
      };

      /**
       * Converts this QueryAllRewardsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllRewardsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllRewardsRequest;
    })();

    ecosystemincentive.QueryAllRewardsResponse = (function () {
      /**
       * Properties of a QueryAllRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryAllRewardsResponse
       * @property {ununifi.ecosystemincentive.IRewardStore|null} [rewards] QueryAllRewardsResponse rewards
       */

      /**
       * Constructs a new QueryAllRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryAllRewardsResponse.
       * @implements IQueryAllRewardsResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse=} [properties] Properties to set
       */
      function QueryAllRewardsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllRewardsResponse rewards.
       * @member {ununifi.ecosystemincentive.IRewardStore|null|undefined} rewards
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @instance
       */
      QueryAllRewardsResponse.prototype.rewards = null;

      /**
       * Encodes the specified QueryAllRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse} message QueryAllRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRewardsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.rewards != null && Object.hasOwnProperty.call(message, 'rewards'))
          $root.ununifi.ecosystemincentive.RewardStore.encode(message.rewards, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryAllRewardsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryAllRewardsResponse} message QueryAllRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllRewardsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRewardsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryAllRewardsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards = $root.ununifi.ecosystemincentive.RewardStore.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllRewardsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllRewardsResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllRewardsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.rewards != null && message.hasOwnProperty('rewards')) {
          let error = $root.ununifi.ecosystemincentive.RewardStore.verify(message.rewards);
          if (error) return 'rewards.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllRewardsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryAllRewardsResponse} QueryAllRewardsResponse
       */
      QueryAllRewardsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryAllRewardsResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryAllRewardsResponse();
        if (object.rewards != null) {
          if (typeof object.rewards !== 'object')
            throw TypeError('.ununifi.ecosystemincentive.QueryAllRewardsResponse.rewards: object expected');
          message.rewards = $root.ununifi.ecosystemincentive.RewardStore.fromObject(object.rewards);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllRewardsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryAllRewardsResponse} message QueryAllRewardsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllRewardsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.rewards = null;
        if (message.rewards != null && message.hasOwnProperty('rewards'))
          object.rewards = $root.ununifi.ecosystemincentive.RewardStore.toObject(message.rewards, options);
        return object;
      };

      /**
       * Converts this QueryAllRewardsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryAllRewardsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllRewardsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllRewardsResponse;
    })();

    ecosystemincentive.QueryRewardRequest = (function () {
      /**
       * Properties of a QueryRewardRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryRewardRequest
       * @property {string|null} [subject_addr] QueryRewardRequest subject_addr
       * @property {string|null} [denom] QueryRewardRequest denom
       */

      /**
       * Constructs a new QueryRewardRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryRewardRequest.
       * @implements IQueryRewardRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryRewardRequest=} [properties] Properties to set
       */
      function QueryRewardRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRewardRequest subject_addr.
       * @member {string} subject_addr
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @instance
       */
      QueryRewardRequest.prototype.subject_addr = '';

      /**
       * QueryRewardRequest denom.
       * @member {string} denom
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @instance
       */
      QueryRewardRequest.prototype.denom = '';

      /**
       * Encodes the specified QueryRewardRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRewardRequest} message QueryRewardRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified QueryRewardRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRewardRequest} message QueryRewardRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRewardRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryRewardRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subject_addr = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRewardRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRewardRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRewardRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
          if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        return null;
      };

      /**
       * Creates a QueryRewardRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryRewardRequest} QueryRewardRequest
       */
      QueryRewardRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryRewardRequest) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryRewardRequest();
        if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
        if (object.denom != null) message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a QueryRewardRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryRewardRequest} message QueryRewardRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRewardRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.subject_addr = '';
          object.denom = '';
        }
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        return object;
      };

      /**
       * Converts this QueryRewardRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryRewardRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRewardRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRewardRequest;
    })();

    ecosystemincentive.QueryRewardResponse = (function () {
      /**
       * Properties of a QueryRewardResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryRewardResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [reward] QueryRewardResponse reward
       */

      /**
       * Constructs a new QueryRewardResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryRewardResponse.
       * @implements IQueryRewardResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryRewardResponse=} [properties] Properties to set
       */
      function QueryRewardResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRewardResponse reward.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} reward
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @instance
       */
      QueryRewardResponse.prototype.reward = null;

      /**
       * Encodes the specified QueryRewardResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRewardResponse} message QueryRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.reward != null && Object.hasOwnProperty.call(message, 'reward'))
          $root.cosmos.base.v1beta1.Coin.encode(message.reward, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryRewardResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRewardResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRewardResponse} message QueryRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRewardResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryRewardResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRewardResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRewardResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRewardResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.reward != null && message.hasOwnProperty('reward')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.reward);
          if (error) return 'reward.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryRewardResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryRewardResponse} QueryRewardResponse
       */
      QueryRewardResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryRewardResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryRewardResponse();
        if (object.reward != null) {
          if (typeof object.reward !== 'object') throw TypeError('.ununifi.ecosystemincentive.QueryRewardResponse.reward: object expected');
          message.reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.reward);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryRewardResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryRewardResponse} message QueryRewardResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRewardResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.reward = null;
        if (message.reward != null && message.hasOwnProperty('reward'))
          object.reward = $root.cosmos.base.v1beta1.Coin.toObject(message.reward, options);
        return object;
      };

      /**
       * Converts this QueryRewardResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryRewardResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRewardResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRewardResponse;
    })();

    ecosystemincentive.QueryRecordedIncentiveUnitIdRequest = (function () {
      /**
       * Properties of a QueryRecordedIncentiveUnitIdRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryRecordedIncentiveUnitIdRequest
       * @property {string|null} [class_id] QueryRecordedIncentiveUnitIdRequest class_id
       * @property {string|null} [nft_id] QueryRecordedIncentiveUnitIdRequest nft_id
       */

      /**
       * Constructs a new QueryRecordedIncentiveUnitIdRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryRecordedIncentiveUnitIdRequest.
       * @implements IQueryRecordedIncentiveUnitIdRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest=} [properties] Properties to set
       */
      function QueryRecordedIncentiveUnitIdRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRecordedIncentiveUnitIdRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @instance
       */
      QueryRecordedIncentiveUnitIdRequest.prototype.class_id = '';

      /**
       * QueryRecordedIncentiveUnitIdRequest nft_id.
       * @member {string} nft_id
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @instance
       */
      QueryRecordedIncentiveUnitIdRequest.prototype.nft_id = '';

      /**
       * Encodes the specified QueryRecordedIncentiveUnitIdRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} message QueryRecordedIncentiveUnitIdRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecordedIncentiveUnitIdRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified QueryRecordedIncentiveUnitIdRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdRequest} message QueryRecordedIncentiveUnitIdRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecordedIncentiveUnitIdRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRecordedIncentiveUnitIdRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} QueryRecordedIncentiveUnitIdRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecordedIncentiveUnitIdRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRecordedIncentiveUnitIdRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} QueryRecordedIncentiveUnitIdRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecordedIncentiveUnitIdRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRecordedIncentiveUnitIdRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRecordedIncentiveUnitIdRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates a QueryRecordedIncentiveUnitIdRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} QueryRecordedIncentiveUnitIdRequest
       */
      QueryRecordedIncentiveUnitIdRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryRecordedIncentiveUnitIdRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest} message QueryRecordedIncentiveUnitIdRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRecordedIncentiveUnitIdRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this QueryRecordedIncentiveUnitIdRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRecordedIncentiveUnitIdRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRecordedIncentiveUnitIdRequest;
    })();

    ecosystemincentive.QueryRecordedIncentiveUnitIdResponse = (function () {
      /**
       * Properties of a QueryRecordedIncentiveUnitIdResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryRecordedIncentiveUnitIdResponse
       * @property {string|null} [incentive_unit_id] QueryRecordedIncentiveUnitIdResponse incentive_unit_id
       */

      /**
       * Constructs a new QueryRecordedIncentiveUnitIdResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryRecordedIncentiveUnitIdResponse.
       * @implements IQueryRecordedIncentiveUnitIdResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdResponse=} [properties] Properties to set
       */
      function QueryRecordedIncentiveUnitIdResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRecordedIncentiveUnitIdResponse incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @instance
       */
      QueryRecordedIncentiveUnitIdResponse.prototype.incentive_unit_id = '';

      /**
       * Encodes the specified QueryRecordedIncentiveUnitIdResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdResponse} message QueryRecordedIncentiveUnitIdResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecordedIncentiveUnitIdResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
        return writer;
      };

      /**
       * Encodes the specified QueryRecordedIncentiveUnitIdResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecordedIncentiveUnitIdResponse} message QueryRecordedIncentiveUnitIdResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecordedIncentiveUnitIdResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRecordedIncentiveUnitIdResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} QueryRecordedIncentiveUnitIdResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecordedIncentiveUnitIdResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRecordedIncentiveUnitIdResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} QueryRecordedIncentiveUnitIdResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecordedIncentiveUnitIdResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRecordedIncentiveUnitIdResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRecordedIncentiveUnitIdResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        return null;
      };

      /**
       * Creates a QueryRecordedIncentiveUnitIdResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} QueryRecordedIncentiveUnitIdResponse
       */
      QueryRecordedIncentiveUnitIdResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse();
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryRecordedIncentiveUnitIdResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse} message QueryRecordedIncentiveUnitIdResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRecordedIncentiveUnitIdResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.incentive_unit_id = '';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        return object;
      };

      /**
       * Converts this QueryRecordedIncentiveUnitIdResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryRecordedIncentiveUnitIdResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRecordedIncentiveUnitIdResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRecordedIncentiveUnitIdResponse;
    })();

    ecosystemincentive.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.ecosystemincentive
       * @interface IParams
       * @property {Array.<ununifi.ecosystemincentive.IRewardParams>|null} [reward_params] Params reward_params
       * @property {Long|null} [max_incentive_unit_id_len] Params max_incentive_unit_id_len
       * @property {Long|null} [max_subject_info_num_in_unit] Params max_subject_info_num_in_unit
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.ecosystemincentive.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.reward_params = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params reward_params.
       * @member {Array.<ununifi.ecosystemincentive.IRewardParams>} reward_params
       * @memberof ununifi.ecosystemincentive.Params
       * @instance
       */
      Params.prototype.reward_params = $util.emptyArray;

      /**
       * Params max_incentive_unit_id_len.
       * @member {Long} max_incentive_unit_id_len
       * @memberof ununifi.ecosystemincentive.Params
       * @instance
       */
      Params.prototype.max_incentive_unit_id_len = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params max_subject_info_num_in_unit.
       * @member {Long} max_subject_info_num_in_unit
       * @memberof ununifi.ecosystemincentive.Params
       * @instance
       */
      Params.prototype.max_subject_info_num_in_unit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.reward_params != null && message.reward_params.length)
          for (let i = 0; i < message.reward_params.length; ++i)
            $root.ununifi.ecosystemincentive.RewardParams.encode(
              message.reward_params[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.max_incentive_unit_id_len != null && Object.hasOwnProperty.call(message, 'max_incentive_unit_id_len'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.max_incentive_unit_id_len);
        if (message.max_subject_info_num_in_unit != null && Object.hasOwnProperty.call(message, 'max_subject_info_num_in_unit'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.max_subject_info_num_in_unit);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.reward_params && message.reward_params.length)) message.reward_params = [];
              message.reward_params.push($root.ununifi.ecosystemincentive.RewardParams.decode(reader, reader.uint32()));
              break;
            case 2:
              message.max_incentive_unit_id_len = reader.uint64();
              break;
            case 3:
              message.max_subject_info_num_in_unit = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.reward_params != null && message.hasOwnProperty('reward_params')) {
          if (!Array.isArray(message.reward_params)) return 'reward_params: array expected';
          for (let i = 0; i < message.reward_params.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.RewardParams.verify(message.reward_params[i]);
            if (error) return 'reward_params.' + error;
          }
        }
        if (message.max_incentive_unit_id_len != null && message.hasOwnProperty('max_incentive_unit_id_len'))
          if (
            !$util.isInteger(message.max_incentive_unit_id_len) &&
            !(
              message.max_incentive_unit_id_len &&
              $util.isInteger(message.max_incentive_unit_id_len.low) &&
              $util.isInteger(message.max_incentive_unit_id_len.high)
            )
          )
            return 'max_incentive_unit_id_len: integer|Long expected';
        if (message.max_subject_info_num_in_unit != null && message.hasOwnProperty('max_subject_info_num_in_unit'))
          if (
            !$util.isInteger(message.max_subject_info_num_in_unit) &&
            !(
              message.max_subject_info_num_in_unit &&
              $util.isInteger(message.max_subject_info_num_in_unit.low) &&
              $util.isInteger(message.max_subject_info_num_in_unit.high)
            )
          )
            return 'max_subject_info_num_in_unit: integer|Long expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.Params) return object;
        let message = new $root.ununifi.ecosystemincentive.Params();
        if (object.reward_params) {
          if (!Array.isArray(object.reward_params)) throw TypeError('.ununifi.ecosystemincentive.Params.reward_params: array expected');
          message.reward_params = [];
          for (let i = 0; i < object.reward_params.length; ++i) {
            if (typeof object.reward_params[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.Params.reward_params: object expected');
            message.reward_params[i] = $root.ununifi.ecosystemincentive.RewardParams.fromObject(object.reward_params[i]);
          }
        }
        if (object.max_incentive_unit_id_len != null)
          if ($util.Long) (message.max_incentive_unit_id_len = $util.Long.fromValue(object.max_incentive_unit_id_len)).unsigned = true;
          else if (typeof object.max_incentive_unit_id_len === 'string')
            message.max_incentive_unit_id_len = parseInt(object.max_incentive_unit_id_len, 10);
          else if (typeof object.max_incentive_unit_id_len === 'number')
            message.max_incentive_unit_id_len = object.max_incentive_unit_id_len;
          else if (typeof object.max_incentive_unit_id_len === 'object')
            message.max_incentive_unit_id_len = new $util.LongBits(
              object.max_incentive_unit_id_len.low >>> 0,
              object.max_incentive_unit_id_len.high >>> 0,
            ).toNumber(true);
        if (object.max_subject_info_num_in_unit != null)
          if ($util.Long)
            (message.max_subject_info_num_in_unit = $util.Long.fromValue(object.max_subject_info_num_in_unit)).unsigned = true;
          else if (typeof object.max_subject_info_num_in_unit === 'string')
            message.max_subject_info_num_in_unit = parseInt(object.max_subject_info_num_in_unit, 10);
          else if (typeof object.max_subject_info_num_in_unit === 'number')
            message.max_subject_info_num_in_unit = object.max_subject_info_num_in_unit;
          else if (typeof object.max_subject_info_num_in_unit === 'object')
            message.max_subject_info_num_in_unit = new $util.LongBits(
              object.max_subject_info_num_in_unit.low >>> 0,
              object.max_subject_info_num_in_unit.high >>> 0,
            ).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {ununifi.ecosystemincentive.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.reward_params = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.max_incentive_unit_id_len =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.max_incentive_unit_id_len = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.max_subject_info_num_in_unit =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.max_subject_info_num_in_unit = options.longs === String ? '0' : 0;
        }
        if (message.reward_params && message.reward_params.length) {
          object.reward_params = [];
          for (let j = 0; j < message.reward_params.length; ++j)
            object.reward_params[j] = $root.ununifi.ecosystemincentive.RewardParams.toObject(message.reward_params[j], options);
        }
        if (message.max_incentive_unit_id_len != null && message.hasOwnProperty('max_incentive_unit_id_len'))
          if (typeof message.max_incentive_unit_id_len === 'number')
            object.max_incentive_unit_id_len =
              options.longs === String ? String(message.max_incentive_unit_id_len) : message.max_incentive_unit_id_len;
          else
            object.max_incentive_unit_id_len =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.max_incentive_unit_id_len)
                : options.longs === Number
                ? new $util.LongBits(message.max_incentive_unit_id_len.low >>> 0, message.max_incentive_unit_id_len.high >>> 0).toNumber(
                    true,
                  )
                : message.max_incentive_unit_id_len;
        if (message.max_subject_info_num_in_unit != null && message.hasOwnProperty('max_subject_info_num_in_unit'))
          if (typeof message.max_subject_info_num_in_unit === 'number')
            object.max_subject_info_num_in_unit =
              options.longs === String ? String(message.max_subject_info_num_in_unit) : message.max_subject_info_num_in_unit;
          else
            object.max_subject_info_num_in_unit =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.max_subject_info_num_in_unit)
                : options.longs === Number
                ? new $util.LongBits(
                    message.max_subject_info_num_in_unit.low >>> 0,
                    message.max_subject_info_num_in_unit.high >>> 0,
                  ).toNumber(true)
                : message.max_subject_info_num_in_unit;
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    ecosystemincentive.RewardParams = (function () {
      /**
       * Properties of a RewardParams.
       * @memberof ununifi.ecosystemincentive
       * @interface IRewardParams
       * @property {string|null} [module_name] RewardParams module_name
       * @property {Array.<ununifi.ecosystemincentive.IRewardRate>|null} [reward_rate] RewardParams reward_rate
       */

      /**
       * Constructs a new RewardParams.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a RewardParams.
       * @implements IRewardParams
       * @constructor
       * @param {ununifi.ecosystemincentive.IRewardParams=} [properties] Properties to set
       */
      function RewardParams(properties) {
        this.reward_rate = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardParams module_name.
       * @member {string} module_name
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @instance
       */
      RewardParams.prototype.module_name = '';

      /**
       * RewardParams reward_rate.
       * @member {Array.<ununifi.ecosystemincentive.IRewardRate>} reward_rate
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @instance
       */
      RewardParams.prototype.reward_rate = $util.emptyArray;

      /**
       * Encodes the specified RewardParams message. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.module_name != null && Object.hasOwnProperty.call(message, 'module_name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.module_name);
        if (message.reward_rate != null && message.reward_rate.length)
          for (let i = 0; i < message.reward_rate.length; ++i)
            $root.ununifi.ecosystemincentive.RewardRate.encode(
              message.reward_rate[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified RewardParams message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.RewardParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.module_name = reader.string();
              break;
            case 2:
              if (!(message.reward_rate && message.reward_rate.length)) message.reward_rate = [];
              message.reward_rate.push($root.ununifi.ecosystemincentive.RewardRate.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardParams message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.module_name != null && message.hasOwnProperty('module_name'))
          if (!$util.isString(message.module_name)) return 'module_name: string expected';
        if (message.reward_rate != null && message.hasOwnProperty('reward_rate')) {
          if (!Array.isArray(message.reward_rate)) return 'reward_rate: array expected';
          for (let i = 0; i < message.reward_rate.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.RewardRate.verify(message.reward_rate[i]);
            if (error) return 'reward_rate.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a RewardParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
       */
      RewardParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.RewardParams) return object;
        let message = new $root.ununifi.ecosystemincentive.RewardParams();
        if (object.module_name != null) message.module_name = String(object.module_name);
        if (object.reward_rate) {
          if (!Array.isArray(object.reward_rate)) throw TypeError('.ununifi.ecosystemincentive.RewardParams.reward_rate: array expected');
          message.reward_rate = [];
          for (let i = 0; i < object.reward_rate.length; ++i) {
            if (typeof object.reward_rate[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.RewardParams.reward_rate: object expected');
            message.reward_rate[i] = $root.ununifi.ecosystemincentive.RewardRate.fromObject(object.reward_rate[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a RewardParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {ununifi.ecosystemincentive.RewardParams} message RewardParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.reward_rate = [];
        if (options.defaults) object.module_name = '';
        if (message.module_name != null && message.hasOwnProperty('module_name')) object.module_name = message.module_name;
        if (message.reward_rate && message.reward_rate.length) {
          object.reward_rate = [];
          for (let j = 0; j < message.reward_rate.length; ++j)
            object.reward_rate[j] = $root.ununifi.ecosystemincentive.RewardRate.toObject(message.reward_rate[j], options);
        }
        return object;
      };

      /**
       * Converts this RewardParams to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardParams;
    })();

    ecosystemincentive.RewardRate = (function () {
      /**
       * Properties of a RewardRate.
       * @memberof ununifi.ecosystemincentive
       * @interface IRewardRate
       * @property {ununifi.ecosystemincentive.RewardType|null} [reward_type] RewardRate reward_type
       * @property {string|null} [rate] RewardRate rate
       */

      /**
       * Constructs a new RewardRate.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a RewardRate.
       * @implements IRewardRate
       * @constructor
       * @param {ununifi.ecosystemincentive.IRewardRate=} [properties] Properties to set
       */
      function RewardRate(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardRate reward_type.
       * @member {ununifi.ecosystemincentive.RewardType} reward_type
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @instance
       */
      RewardRate.prototype.reward_type = 0;

      /**
       * RewardRate rate.
       * @member {string} rate
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @instance
       */
      RewardRate.prototype.rate = '';

      /**
       * Encodes the specified RewardRate message. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardRate.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.reward_type != null && Object.hasOwnProperty.call(message, 'reward_type'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.reward_type);
        if (message.rate != null && Object.hasOwnProperty.call(message, 'rate'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.rate);
        return writer;
      };

      /**
       * Encodes the specified RewardRate message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardRate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardRate message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardRate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.RewardRate();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.reward_type = reader.int32();
              break;
            case 2:
              message.rate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardRate message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardRate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardRate message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardRate.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.reward_type != null && message.hasOwnProperty('reward_type'))
          switch (message.reward_type) {
            default:
              return 'reward_type: enum value expected';
            case 0:
              break;
          }
        if (message.rate != null && message.hasOwnProperty('rate')) if (!$util.isString(message.rate)) return 'rate: string expected';
        return null;
      };

      /**
       * Creates a RewardRate message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
       */
      RewardRate.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.RewardRate) return object;
        let message = new $root.ununifi.ecosystemincentive.RewardRate();
        switch (object.reward_type) {
          case 'NFTMARKET_FRONTEND':
          case 0:
            message.reward_type = 0;
            break;
        }
        if (object.rate != null) message.rate = String(object.rate);
        return message;
      };

      /**
       * Creates a plain object from a RewardRate message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {ununifi.ecosystemincentive.RewardRate} message RewardRate
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardRate.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.reward_type = options.enums === String ? 'NFTMARKET_FRONTEND' : 0;
          object.rate = '';
        }
        if (message.reward_type != null && message.hasOwnProperty('reward_type'))
          object.reward_type =
            options.enums === String ? $root.ununifi.ecosystemincentive.RewardType[message.reward_type] : message.reward_type;
        if (message.rate != null && message.hasOwnProperty('rate')) object.rate = message.rate;
        return object;
      };

      /**
       * Converts this RewardRate to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardRate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardRate;
    })();

    /**
     * RewardType enum.
     * @name ununifi.ecosystemincentive.RewardType
     * @enum {number}
     * @property {number} NFTMARKET_FRONTEND=0 NFTMARKET_FRONTEND value
     */
    ecosystemincentive.RewardType = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'NFTMARKET_FRONTEND')] = 0;
      return values;
    })();

    ecosystemincentive.IncentiveUnit = (function () {
      /**
       * Properties of an IncentiveUnit.
       * @memberof ununifi.ecosystemincentive
       * @interface IIncentiveUnit
       * @property {string|null} [id] IncentiveUnit id
       * @property {Array.<ununifi.ecosystemincentive.ISubjectInfo>|null} [subject_info_lists] IncentiveUnit subject_info_lists
       */

      /**
       * Constructs a new IncentiveUnit.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an IncentiveUnit.
       * @implements IIncentiveUnit
       * @constructor
       * @param {ununifi.ecosystemincentive.IIncentiveUnit=} [properties] Properties to set
       */
      function IncentiveUnit(properties) {
        this.subject_info_lists = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * IncentiveUnit id.
       * @member {string} id
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @instance
       */
      IncentiveUnit.prototype.id = '';

      /**
       * IncentiveUnit subject_info_lists.
       * @member {Array.<ununifi.ecosystemincentive.ISubjectInfo>} subject_info_lists
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @instance
       */
      IncentiveUnit.prototype.subject_info_lists = $util.emptyArray;

      /**
       * Encodes the specified IncentiveUnit message. Does not implicitly {@link ununifi.ecosystemincentive.IncentiveUnit.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @static
       * @param {ununifi.ecosystemincentive.IIncentiveUnit} message IncentiveUnit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IncentiveUnit.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        if (message.subject_info_lists != null && message.subject_info_lists.length)
          for (let i = 0; i < message.subject_info_lists.length; ++i)
            $root.ununifi.ecosystemincentive.SubjectInfo.encode(
              message.subject_info_lists[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified IncentiveUnit message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.IncentiveUnit.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @static
       * @param {ununifi.ecosystemincentive.IIncentiveUnit} message IncentiveUnit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IncentiveUnit.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an IncentiveUnit message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.IncentiveUnit} IncentiveUnit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IncentiveUnit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.IncentiveUnit();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              if (!(message.subject_info_lists && message.subject_info_lists.length)) message.subject_info_lists = [];
              message.subject_info_lists.push($root.ununifi.ecosystemincentive.SubjectInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an IncentiveUnit message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.IncentiveUnit} IncentiveUnit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IncentiveUnit.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an IncentiveUnit message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      IncentiveUnit.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        if (message.subject_info_lists != null && message.hasOwnProperty('subject_info_lists')) {
          if (!Array.isArray(message.subject_info_lists)) return 'subject_info_lists: array expected';
          for (let i = 0; i < message.subject_info_lists.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.SubjectInfo.verify(message.subject_info_lists[i]);
            if (error) return 'subject_info_lists.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an IncentiveUnit message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.IncentiveUnit} IncentiveUnit
       */
      IncentiveUnit.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.IncentiveUnit) return object;
        let message = new $root.ununifi.ecosystemincentive.IncentiveUnit();
        if (object.id != null) message.id = String(object.id);
        if (object.subject_info_lists) {
          if (!Array.isArray(object.subject_info_lists))
            throw TypeError('.ununifi.ecosystemincentive.IncentiveUnit.subject_info_lists: array expected');
          message.subject_info_lists = [];
          for (let i = 0; i < object.subject_info_lists.length; ++i) {
            if (typeof object.subject_info_lists[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.IncentiveUnit.subject_info_lists: object expected');
            message.subject_info_lists[i] = $root.ununifi.ecosystemincentive.SubjectInfo.fromObject(object.subject_info_lists[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an IncentiveUnit message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @static
       * @param {ununifi.ecosystemincentive.IncentiveUnit} message IncentiveUnit
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      IncentiveUnit.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.subject_info_lists = [];
        if (options.defaults) object.id = '';
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        if (message.subject_info_lists && message.subject_info_lists.length) {
          object.subject_info_lists = [];
          for (let j = 0; j < message.subject_info_lists.length; ++j)
            object.subject_info_lists[j] = $root.ununifi.ecosystemincentive.SubjectInfo.toObject(message.subject_info_lists[j], options);
        }
        return object;
      };

      /**
       * Converts this IncentiveUnit to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.IncentiveUnit
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      IncentiveUnit.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return IncentiveUnit;
    })();

    ecosystemincentive.SubjectInfo = (function () {
      /**
       * Properties of a SubjectInfo.
       * @memberof ununifi.ecosystemincentive
       * @interface ISubjectInfo
       * @property {string|null} [subject_addr] SubjectInfo subject_addr
       * @property {string|null} [weight] SubjectInfo weight
       */

      /**
       * Constructs a new SubjectInfo.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a SubjectInfo.
       * @implements ISubjectInfo
       * @constructor
       * @param {ununifi.ecosystemincentive.ISubjectInfo=} [properties] Properties to set
       */
      function SubjectInfo(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * SubjectInfo subject_addr.
       * @member {string} subject_addr
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @instance
       */
      SubjectInfo.prototype.subject_addr = '';

      /**
       * SubjectInfo weight.
       * @member {string} weight
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @instance
       */
      SubjectInfo.prototype.weight = '';

      /**
       * Encodes the specified SubjectInfo message. Does not implicitly {@link ununifi.ecosystemincentive.SubjectInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @static
       * @param {ununifi.ecosystemincentive.ISubjectInfo} message SubjectInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SubjectInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
        if (message.weight != null && Object.hasOwnProperty.call(message, 'weight'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.weight);
        return writer;
      };

      /**
       * Encodes the specified SubjectInfo message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.SubjectInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @static
       * @param {ununifi.ecosystemincentive.ISubjectInfo} message SubjectInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SubjectInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a SubjectInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.SubjectInfo} SubjectInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SubjectInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.SubjectInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subject_addr = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a SubjectInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.SubjectInfo} SubjectInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SubjectInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a SubjectInfo message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      SubjectInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
          if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
        if (message.weight != null && message.hasOwnProperty('weight'))
          if (!$util.isString(message.weight)) return 'weight: string expected';
        return null;
      };

      /**
       * Creates a SubjectInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.SubjectInfo} SubjectInfo
       */
      SubjectInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.SubjectInfo) return object;
        let message = new $root.ununifi.ecosystemincentive.SubjectInfo();
        if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
        if (object.weight != null) message.weight = String(object.weight);
        return message;
      };

      /**
       * Creates a plain object from a SubjectInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @static
       * @param {ununifi.ecosystemincentive.SubjectInfo} message SubjectInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      SubjectInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.subject_addr = '';
          object.weight = '';
        }
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
        if (message.weight != null && message.hasOwnProperty('weight')) object.weight = message.weight;
        return object;
      };

      /**
       * Converts this SubjectInfo to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.SubjectInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      SubjectInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return SubjectInfo;
    })();

    ecosystemincentive.RewardStore = (function () {
      /**
       * Properties of a RewardStore.
       * @memberof ununifi.ecosystemincentive
       * @interface IRewardStore
       * @property {string|null} [subject_addr] RewardStore subject_addr
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] RewardStore rewards
       */

      /**
       * Constructs a new RewardStore.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a RewardStore.
       * @implements IRewardStore
       * @constructor
       * @param {ununifi.ecosystemincentive.IRewardStore=} [properties] Properties to set
       */
      function RewardStore(properties) {
        this.rewards = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardStore subject_addr.
       * @member {string} subject_addr
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @instance
       */
      RewardStore.prototype.subject_addr = '';

      /**
       * RewardStore rewards.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @instance
       */
      RewardStore.prototype.rewards = $util.emptyArray;

      /**
       * Encodes the specified RewardStore message. Does not implicitly {@link ununifi.ecosystemincentive.RewardStore.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @static
       * @param {ununifi.ecosystemincentive.IRewardStore} message RewardStore message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardStore.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.subject_addr != null && Object.hasOwnProperty.call(message, 'subject_addr'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subject_addr);
        if (message.rewards != null && message.rewards.length)
          for (let i = 0; i < message.rewards.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified RewardStore message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardStore.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @static
       * @param {ununifi.ecosystemincentive.IRewardStore} message RewardStore message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardStore.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardStore message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.RewardStore} RewardStore
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardStore.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.RewardStore();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subject_addr = reader.string();
              break;
            case 2:
              if (!(message.rewards && message.rewards.length)) message.rewards = [];
              message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardStore message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.RewardStore} RewardStore
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardStore.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardStore message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardStore.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr'))
          if (!$util.isString(message.subject_addr)) return 'subject_addr: string expected';
        if (message.rewards != null && message.hasOwnProperty('rewards')) {
          if (!Array.isArray(message.rewards)) return 'rewards: array expected';
          for (let i = 0; i < message.rewards.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
            if (error) return 'rewards.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a RewardStore message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.RewardStore} RewardStore
       */
      RewardStore.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.RewardStore) return object;
        let message = new $root.ununifi.ecosystemincentive.RewardStore();
        if (object.subject_addr != null) message.subject_addr = String(object.subject_addr);
        if (object.rewards) {
          if (!Array.isArray(object.rewards)) throw TypeError('.ununifi.ecosystemincentive.RewardStore.rewards: array expected');
          message.rewards = [];
          for (let i = 0; i < object.rewards.length; ++i) {
            if (typeof object.rewards[i] !== 'object') throw TypeError('.ununifi.ecosystemincentive.RewardStore.rewards: object expected');
            message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a RewardStore message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @static
       * @param {ununifi.ecosystemincentive.RewardStore} message RewardStore
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardStore.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rewards = [];
        if (options.defaults) object.subject_addr = '';
        if (message.subject_addr != null && message.hasOwnProperty('subject_addr')) object.subject_addr = message.subject_addr;
        if (message.rewards && message.rewards.length) {
          object.rewards = [];
          for (let j = 0; j < message.rewards.length; ++j)
            object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
        }
        return object;
      };

      /**
       * Converts this RewardStore to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.RewardStore
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardStore.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardStore;
    })();

    ecosystemincentive.MemoInputs = (function () {
      /**
       * Properties of a MemoInputs.
       * @memberof ununifi.ecosystemincentive
       * @interface IMemoInputs
       * @property {string|null} [version] MemoInputs version
       * @property {string|null} [incentive_unit_id] MemoInputs incentive_unit_id
       */

      /**
       * Constructs a new MemoInputs.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MemoInputs.
       * @implements IMemoInputs
       * @constructor
       * @param {ununifi.ecosystemincentive.IMemoInputs=} [properties] Properties to set
       */
      function MemoInputs(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MemoInputs version.
       * @member {string} version
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @instance
       */
      MemoInputs.prototype.version = '';

      /**
       * MemoInputs incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @instance
       */
      MemoInputs.prototype.incentive_unit_id = '';

      /**
       * Encodes the specified MemoInputs message. Does not implicitly {@link ununifi.ecosystemincentive.MemoInputs.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @static
       * @param {ununifi.ecosystemincentive.IMemoInputs} message MemoInputs message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MemoInputs.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.version != null && Object.hasOwnProperty.call(message, 'version'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.version);
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.incentive_unit_id);
        return writer;
      };

      /**
       * Encodes the specified MemoInputs message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MemoInputs.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @static
       * @param {ununifi.ecosystemincentive.IMemoInputs} message MemoInputs message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MemoInputs.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MemoInputs message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MemoInputs} MemoInputs
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MemoInputs.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MemoInputs();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.incentive_unit_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MemoInputs message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MemoInputs} MemoInputs
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MemoInputs.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MemoInputs message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MemoInputs.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.version != null && message.hasOwnProperty('version'))
          if (!$util.isString(message.version)) return 'version: string expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        return null;
      };

      /**
       * Creates a MemoInputs message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MemoInputs} MemoInputs
       */
      MemoInputs.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MemoInputs) return object;
        let message = new $root.ununifi.ecosystemincentive.MemoInputs();
        if (object.version != null) message.version = String(object.version);
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        return message;
      };

      /**
       * Creates a plain object from a MemoInputs message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @static
       * @param {ununifi.ecosystemincentive.MemoInputs} message MemoInputs
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MemoInputs.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.version = '';
          object.incentive_unit_id = '';
        }
        if (message.version != null && message.hasOwnProperty('version')) object.version = message.version;
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        return object;
      };

      /**
       * Converts this MemoInputs to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MemoInputs
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MemoInputs.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MemoInputs;
    })();

    ecosystemincentive.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Msg#register}.
       * @memberof ununifi.ecosystemincentive.Msg
       * @typedef RegisterCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.MsgRegisterResponse} [response] MsgRegisterResponse
       */

      /**
       * Calls Register.
       * @function register
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgRegister} request MsgRegister message or plain object
       * @param {ununifi.ecosystemincentive.Msg.RegisterCallback} callback Node-style callback called with the error, if any, and MsgRegisterResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.register = function register(request, callback) {
          return this.rpcCall(
            register,
            $root.ununifi.ecosystemincentive.MsgRegister,
            $root.ununifi.ecosystemincentive.MsgRegisterResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Register' },
      );

      /**
       * Calls Register.
       * @function register
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgRegister} request MsgRegister message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.MsgRegisterResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawAllRewards}.
       * @memberof ununifi.ecosystemincentive.Msg
       * @typedef WithdrawAllRewardsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} [response] MsgWithdrawAllRewardsResponse
       */

      /**
       * Calls WithdrawAllRewards.
       * @function withdrawAllRewards
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
       * @param {ununifi.ecosystemincentive.Msg.WithdrawAllRewardsCallback} callback Node-style callback called with the error, if any, and MsgWithdrawAllRewardsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawAllRewards = function withdrawAllRewards(request, callback) {
          return this.rpcCall(
            withdrawAllRewards,
            $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards,
            $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawAllRewards' },
      );

      /**
       * Calls WithdrawAllRewards.
       * @function withdrawAllRewards
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawReward}.
       * @memberof ununifi.ecosystemincentive.Msg
       * @typedef WithdrawRewardCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} [response] MsgWithdrawRewardResponse
       */

      /**
       * Calls WithdrawReward.
       * @function withdrawReward
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
       * @param {ununifi.ecosystemincentive.Msg.WithdrawRewardCallback} callback Node-style callback called with the error, if any, and MsgWithdrawRewardResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawReward = function withdrawReward(request, callback) {
          return this.rpcCall(
            withdrawReward,
            $root.ununifi.ecosystemincentive.MsgWithdrawReward,
            $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawReward' },
      );

      /**
       * Calls WithdrawReward.
       * @function withdrawReward
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawRewardResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    ecosystemincentive.MsgRegister = (function () {
      /**
       * Properties of a MsgRegister.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgRegister
       * @property {string|null} [sender] MsgRegister sender
       * @property {string|null} [incentive_unit_id] MsgRegister incentive_unit_id
       * @property {Array.<string>|null} [subject_addrs] MsgRegister subject_addrs
       * @property {Array.<string>|null} [weights] MsgRegister weights
       */

      /**
       * Constructs a new MsgRegister.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgRegister.
       * @implements IMsgRegister
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgRegister=} [properties] Properties to set
       */
      function MsgRegister(properties) {
        this.subject_addrs = [];
        this.weights = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRegister sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @instance
       */
      MsgRegister.prototype.sender = '';

      /**
       * MsgRegister incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @instance
       */
      MsgRegister.prototype.incentive_unit_id = '';

      /**
       * MsgRegister subject_addrs.
       * @member {Array.<string>} subject_addrs
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @instance
       */
      MsgRegister.prototype.subject_addrs = $util.emptyArray;

      /**
       * MsgRegister weights.
       * @member {Array.<string>} weights
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @instance
       */
      MsgRegister.prototype.weights = $util.emptyArray;

      /**
       * Encodes the specified MsgRegister message. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegister.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @static
       * @param {ununifi.ecosystemincentive.IMsgRegister} message MsgRegister message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegister.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.incentive_unit_id);
        if (message.subject_addrs != null && message.subject_addrs.length)
          for (let i = 0; i < message.subject_addrs.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.subject_addrs[i]);
        if (message.weights != null && message.weights.length)
          for (let i = 0; i < message.weights.length; ++i) writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.weights[i]);
        return writer;
      };

      /**
       * Encodes the specified MsgRegister message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegister.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @static
       * @param {ununifi.ecosystemincentive.IMsgRegister} message MsgRegister message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegister.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegister message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgRegister} MsgRegister
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegister.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgRegister();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.incentive_unit_id = reader.string();
              break;
            case 3:
              if (!(message.subject_addrs && message.subject_addrs.length)) message.subject_addrs = [];
              message.subject_addrs.push(reader.string());
              break;
            case 4:
              if (!(message.weights && message.weights.length)) message.weights = [];
              message.weights.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegister message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgRegister} MsgRegister
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegister.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegister message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegister.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        if (message.subject_addrs != null && message.hasOwnProperty('subject_addrs')) {
          if (!Array.isArray(message.subject_addrs)) return 'subject_addrs: array expected';
          for (let i = 0; i < message.subject_addrs.length; ++i)
            if (!$util.isString(message.subject_addrs[i])) return 'subject_addrs: string[] expected';
        }
        if (message.weights != null && message.hasOwnProperty('weights')) {
          if (!Array.isArray(message.weights)) return 'weights: array expected';
          for (let i = 0; i < message.weights.length; ++i) if (!$util.isString(message.weights[i])) return 'weights: string[] expected';
        }
        return null;
      };

      /**
       * Creates a MsgRegister message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgRegister} MsgRegister
       */
      MsgRegister.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgRegister) return object;
        let message = new $root.ununifi.ecosystemincentive.MsgRegister();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        if (object.subject_addrs) {
          if (!Array.isArray(object.subject_addrs))
            throw TypeError('.ununifi.ecosystemincentive.MsgRegister.subject_addrs: array expected');
          message.subject_addrs = [];
          for (let i = 0; i < object.subject_addrs.length; ++i) message.subject_addrs[i] = String(object.subject_addrs[i]);
        }
        if (object.weights) {
          if (!Array.isArray(object.weights)) throw TypeError('.ununifi.ecosystemincentive.MsgRegister.weights: array expected');
          message.weights = [];
          for (let i = 0; i < object.weights.length; ++i) message.weights[i] = String(object.weights[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgRegister message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @static
       * @param {ununifi.ecosystemincentive.MsgRegister} message MsgRegister
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegister.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.subject_addrs = [];
          object.weights = [];
        }
        if (options.defaults) {
          object.sender = '';
          object.incentive_unit_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        if (message.subject_addrs && message.subject_addrs.length) {
          object.subject_addrs = [];
          for (let j = 0; j < message.subject_addrs.length; ++j) object.subject_addrs[j] = message.subject_addrs[j];
        }
        if (message.weights && message.weights.length) {
          object.weights = [];
          for (let j = 0; j < message.weights.length; ++j) object.weights[j] = message.weights[j];
        }
        return object;
      };

      /**
       * Converts this MsgRegister to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgRegister
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegister.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegister;
    })();

    ecosystemincentive.MsgRegisterResponse = (function () {
      /**
       * Properties of a MsgRegisterResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgRegisterResponse
       */

      /**
       * Constructs a new MsgRegisterResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgRegisterResponse.
       * @implements IMsgRegisterResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgRegisterResponse=} [properties] Properties to set
       */
      function MsgRegisterResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRegisterResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegisterResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgRegisterResponse} message MsgRegisterResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgRegisterResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgRegisterResponse} message MsgRegisterResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgRegisterResponse} MsgRegisterResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgRegisterResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgRegisterResponse} MsgRegisterResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRegisterResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgRegisterResponse} MsgRegisterResponse
       */
      MsgRegisterResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgRegisterResponse) return object;
        return new $root.ununifi.ecosystemincentive.MsgRegisterResponse();
      };

      /**
       * Creates a plain object from a MsgRegisterResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @static
       * @param {ununifi.ecosystemincentive.MsgRegisterResponse} message MsgRegisterResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRegisterResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgRegisterResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterResponse;
    })();

    ecosystemincentive.MsgWithdrawAllRewards = (function () {
      /**
       * Properties of a MsgWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawAllRewards
       * @property {string|null} [sender] MsgWithdrawAllRewards sender
       */

      /**
       * Constructs a new MsgWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawAllRewards.
       * @implements IMsgWithdrawAllRewards
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards=} [properties] Properties to set
       */
      function MsgWithdrawAllRewards(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawAllRewards sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @instance
       */
      MsgWithdrawAllRewards.prototype.sender = '';

      /**
       * Encodes the specified MsgWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewards.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewards.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawAllRewards message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawAllRewards.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
       */
      MsgWithdrawAllRewards.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards) return object;
        let message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
        if (object.sender != null) message.sender = String(object.sender);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawAllRewards message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewards} message MsgWithdrawAllRewards
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawAllRewards.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        return object;
      };

      /**
       * Converts this MsgWithdrawAllRewards to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawAllRewards.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawAllRewards;
    })();

    ecosystemincentive.MsgWithdrawAllRewardsResponse = (function () {
      /**
       * Properties of a MsgWithdrawAllRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawAllRewardsResponse
       */

      /**
       * Constructs a new MsgWithdrawAllRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawAllRewardsResponse.
       * @implements IMsgWithdrawAllRewardsResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse=} [properties] Properties to set
       */
      function MsgWithdrawAllRewardsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawAllRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewardsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawAllRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewardsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawAllRewardsResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawAllRewardsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawAllRewardsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
       */
      MsgWithdrawAllRewardsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse) return object;
        return new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawAllRewardsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawAllRewardsResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawAllRewardsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawAllRewardsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawAllRewardsResponse;
    })();

    ecosystemincentive.MsgWithdrawReward = (function () {
      /**
       * Properties of a MsgWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawReward
       * @property {string|null} [sender] MsgWithdrawReward sender
       * @property {string|null} [denom] MsgWithdrawReward denom
       */

      /**
       * Constructs a new MsgWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawReward.
       * @implements IMsgWithdrawReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward=} [properties] Properties to set
       */
      function MsgWithdrawReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawReward sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @instance
       */
      MsgWithdrawReward.prototype.sender = '';

      /**
       * MsgWithdrawReward denom.
       * @member {string} denom
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @instance
       */
      MsgWithdrawReward.prototype.denom = '';

      /**
       * Encodes the specified MsgWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
       */
      MsgWithdrawReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawReward) return object;
        let message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.denom != null) message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawReward} message MsgWithdrawReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.denom = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        return object;
      };

      /**
       * Converts this MsgWithdrawReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawReward;
    })();

    ecosystemincentive.MsgWithdrawRewardResponse = (function () {
      /**
       * Properties of a MsgWithdrawRewardResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawRewardResponse
       */

      /**
       * Constructs a new MsgWithdrawRewardResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawRewardResponse.
       * @implements IMsgWithdrawRewardResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse=} [properties] Properties to set
       */
      function MsgWithdrawRewardResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawRewardResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawRewardResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawRewardResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawRewardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawRewardResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawRewardResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawRewardResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawRewardResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
       */
      MsgWithdrawRewardResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse) return object;
        return new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawRewardResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} message MsgWithdrawRewardResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawRewardResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawRewardResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawRewardResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawRewardResponse;
    })();

    ecosystemincentive.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.ecosystemincentive
       * @interface IGenesisState
       * @property {ununifi.ecosystemincentive.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.ecosystemincentive.IIncentiveUnit>|null} [incentive_units] GenesisState incentive_units
       * @property {Array.<ununifi.ecosystemincentive.IRewardStore>|null} [reward_stores] GenesisState reward_stores
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.ecosystemincentive.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.incentive_units = [];
        this.reward_stores = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState incentive_units.
       * @member {Array.<ununifi.ecosystemincentive.IIncentiveUnit>} incentive_units
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @instance
       */
      GenesisState.prototype.incentive_units = $util.emptyArray;

      /**
       * GenesisState reward_stores.
       * @member {Array.<ununifi.ecosystemincentive.IRewardStore>} reward_stores
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @instance
       */
      GenesisState.prototype.reward_stores = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.incentive_units != null && message.incentive_units.length)
          for (let i = 0; i < message.incentive_units.length; ++i)
            $root.ununifi.ecosystemincentive.IncentiveUnit.encode(
              message.incentive_units[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.reward_stores != null && message.reward_stores.length)
          for (let i = 0; i < message.reward_stores.length; ++i)
            $root.ununifi.ecosystemincentive.RewardStore.encode(
              message.reward_stores[i],
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.incentive_units && message.incentive_units.length)) message.incentive_units = [];
              message.incentive_units.push($root.ununifi.ecosystemincentive.IncentiveUnit.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.reward_stores && message.reward_stores.length)) message.reward_stores = [];
              message.reward_stores.push($root.ununifi.ecosystemincentive.RewardStore.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.incentive_units != null && message.hasOwnProperty('incentive_units')) {
          if (!Array.isArray(message.incentive_units)) return 'incentive_units: array expected';
          for (let i = 0; i < message.incentive_units.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.IncentiveUnit.verify(message.incentive_units[i]);
            if (error) return 'incentive_units.' + error;
          }
        }
        if (message.reward_stores != null && message.hasOwnProperty('reward_stores')) {
          if (!Array.isArray(message.reward_stores)) return 'reward_stores: array expected';
          for (let i = 0; i < message.reward_stores.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.RewardStore.verify(message.reward_stores[i]);
            if (error) return 'reward_stores.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.GenesisState) return object;
        let message = new $root.ununifi.ecosystemincentive.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.ecosystemincentive.GenesisState.params: object expected');
          message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
        }
        if (object.incentive_units) {
          if (!Array.isArray(object.incentive_units))
            throw TypeError('.ununifi.ecosystemincentive.GenesisState.incentive_units: array expected');
          message.incentive_units = [];
          for (let i = 0; i < object.incentive_units.length; ++i) {
            if (typeof object.incentive_units[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.GenesisState.incentive_units: object expected');
            message.incentive_units[i] = $root.ununifi.ecosystemincentive.IncentiveUnit.fromObject(object.incentive_units[i]);
          }
        }
        if (object.reward_stores) {
          if (!Array.isArray(object.reward_stores))
            throw TypeError('.ununifi.ecosystemincentive.GenesisState.reward_stores: array expected');
          message.reward_stores = [];
          for (let i = 0; i < object.reward_stores.length; ++i) {
            if (typeof object.reward_stores[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.GenesisState.reward_stores: object expected');
            message.reward_stores[i] = $root.ununifi.ecosystemincentive.RewardStore.fromObject(object.reward_stores[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {ununifi.ecosystemincentive.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.incentive_units = [];
          object.reward_stores = [];
        }
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
        if (message.incentive_units && message.incentive_units.length) {
          object.incentive_units = [];
          for (let j = 0; j < message.incentive_units.length; ++j)
            object.incentive_units[j] = $root.ununifi.ecosystemincentive.IncentiveUnit.toObject(message.incentive_units[j], options);
        }
        if (message.reward_stores && message.reward_stores.length) {
          object.reward_stores = [];
          for (let j = 0; j < message.reward_stores.length; ++j)
            object.reward_stores[j] = $root.ununifi.ecosystemincentive.RewardStore.toObject(message.reward_stores[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    ecosystemincentive.EventRegister = (function () {
      /**
       * Properties of an EventRegister.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventRegister
       * @property {string|null} [incentive_unit_id] EventRegister incentive_unit_id
       * @property {Array.<ununifi.ecosystemincentive.ISubjectInfo>|null} [subject_info_lists] EventRegister subject_info_lists
       */

      /**
       * Constructs a new EventRegister.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventRegister.
       * @implements IEventRegister
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventRegister=} [properties] Properties to set
       */
      function EventRegister(properties) {
        this.subject_info_lists = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventRegister incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @instance
       */
      EventRegister.prototype.incentive_unit_id = '';

      /**
       * EventRegister subject_info_lists.
       * @member {Array.<ununifi.ecosystemincentive.ISubjectInfo>} subject_info_lists
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @instance
       */
      EventRegister.prototype.subject_info_lists = $util.emptyArray;

      /**
       * Encodes the specified EventRegister message. Does not implicitly {@link ununifi.ecosystemincentive.EventRegister.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @static
       * @param {ununifi.ecosystemincentive.IEventRegister} message EventRegister message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRegister.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
        if (message.subject_info_lists != null && message.subject_info_lists.length)
          for (let i = 0; i < message.subject_info_lists.length; ++i)
            $root.ununifi.ecosystemincentive.SubjectInfo.encode(
              message.subject_info_lists[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EventRegister message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventRegister.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @static
       * @param {ununifi.ecosystemincentive.IEventRegister} message EventRegister message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRegister.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventRegister message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventRegister} EventRegister
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRegister.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventRegister();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit_id = reader.string();
              break;
            case 2:
              if (!(message.subject_info_lists && message.subject_info_lists.length)) message.subject_info_lists = [];
              message.subject_info_lists.push($root.ununifi.ecosystemincentive.SubjectInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventRegister message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventRegister} EventRegister
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRegister.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventRegister message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventRegister.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        if (message.subject_info_lists != null && message.hasOwnProperty('subject_info_lists')) {
          if (!Array.isArray(message.subject_info_lists)) return 'subject_info_lists: array expected';
          for (let i = 0; i < message.subject_info_lists.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.SubjectInfo.verify(message.subject_info_lists[i]);
            if (error) return 'subject_info_lists.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an EventRegister message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventRegister} EventRegister
       */
      EventRegister.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventRegister) return object;
        let message = new $root.ununifi.ecosystemincentive.EventRegister();
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        if (object.subject_info_lists) {
          if (!Array.isArray(object.subject_info_lists))
            throw TypeError('.ununifi.ecosystemincentive.EventRegister.subject_info_lists: array expected');
          message.subject_info_lists = [];
          for (let i = 0; i < object.subject_info_lists.length; ++i) {
            if (typeof object.subject_info_lists[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.EventRegister.subject_info_lists: object expected');
            message.subject_info_lists[i] = $root.ununifi.ecosystemincentive.SubjectInfo.fromObject(object.subject_info_lists[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EventRegister message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @static
       * @param {ununifi.ecosystemincentive.EventRegister} message EventRegister
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventRegister.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.subject_info_lists = [];
        if (options.defaults) object.incentive_unit_id = '';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        if (message.subject_info_lists && message.subject_info_lists.length) {
          object.subject_info_lists = [];
          for (let j = 0; j < message.subject_info_lists.length; ++j)
            object.subject_info_lists[j] = $root.ununifi.ecosystemincentive.SubjectInfo.toObject(message.subject_info_lists[j], options);
        }
        return object;
      };

      /**
       * Converts this EventRegister to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventRegister
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventRegister.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventRegister;
    })();

    ecosystemincentive.EventWithdrawAllRewards = (function () {
      /**
       * Properties of an EventWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventWithdrawAllRewards
       * @property {string|null} [sender] EventWithdrawAllRewards sender
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [all_withdrawn_rewards] EventWithdrawAllRewards all_withdrawn_rewards
       */

      /**
       * Constructs a new EventWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventWithdrawAllRewards.
       * @implements IEventWithdrawAllRewards
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards=} [properties] Properties to set
       */
      function EventWithdrawAllRewards(properties) {
        this.all_withdrawn_rewards = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventWithdrawAllRewards sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @instance
       */
      EventWithdrawAllRewards.prototype.sender = '';

      /**
       * EventWithdrawAllRewards all_withdrawn_rewards.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} all_withdrawn_rewards
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @instance
       */
      EventWithdrawAllRewards.prototype.all_withdrawn_rewards = $util.emptyArray;

      /**
       * Encodes the specified EventWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawAllRewards.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.all_withdrawn_rewards != null && message.all_withdrawn_rewards.length)
          for (let i = 0; i < message.all_withdrawn_rewards.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(
              message.all_withdrawn_rewards[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EventWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventWithdrawAllRewards message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawAllRewards.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              if (!(message.all_withdrawn_rewards && message.all_withdrawn_rewards.length)) message.all_withdrawn_rewards = [];
              message.all_withdrawn_rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventWithdrawAllRewards message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventWithdrawAllRewards message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventWithdrawAllRewards.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.all_withdrawn_rewards != null && message.hasOwnProperty('all_withdrawn_rewards')) {
          if (!Array.isArray(message.all_withdrawn_rewards)) return 'all_withdrawn_rewards: array expected';
          for (let i = 0; i < message.all_withdrawn_rewards.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.all_withdrawn_rewards[i]);
            if (error) return 'all_withdrawn_rewards.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an EventWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
       */
      EventWithdrawAllRewards.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawAllRewards) return object;
        let message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.all_withdrawn_rewards) {
          if (!Array.isArray(object.all_withdrawn_rewards))
            throw TypeError('.ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: array expected');
          message.all_withdrawn_rewards = [];
          for (let i = 0; i < object.all_withdrawn_rewards.length; ++i) {
            if (typeof object.all_withdrawn_rewards[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: object expected');
            message.all_withdrawn_rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.all_withdrawn_rewards[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EventWithdrawAllRewards message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.EventWithdrawAllRewards} message EventWithdrawAllRewards
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventWithdrawAllRewards.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.all_withdrawn_rewards = [];
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.all_withdrawn_rewards && message.all_withdrawn_rewards.length) {
          object.all_withdrawn_rewards = [];
          for (let j = 0; j < message.all_withdrawn_rewards.length; ++j)
            object.all_withdrawn_rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.all_withdrawn_rewards[j], options);
        }
        return object;
      };

      /**
       * Converts this EventWithdrawAllRewards to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventWithdrawAllRewards.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventWithdrawAllRewards;
    })();

    ecosystemincentive.EventWithdrawReward = (function () {
      /**
       * Properties of an EventWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventWithdrawReward
       * @property {string|null} [sender] EventWithdrawReward sender
       * @property {cosmos.base.v1beta1.ICoin|null} [withdrawn_reward] EventWithdrawReward withdrawn_reward
       */

      /**
       * Constructs a new EventWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventWithdrawReward.
       * @implements IEventWithdrawReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventWithdrawReward=} [properties] Properties to set
       */
      function EventWithdrawReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventWithdrawReward sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @instance
       */
      EventWithdrawReward.prototype.sender = '';

      /**
       * EventWithdrawReward withdrawn_reward.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} withdrawn_reward
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @instance
       */
      EventWithdrawReward.prototype.withdrawn_reward = null;

      /**
       * Encodes the specified EventWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.withdrawn_reward != null && Object.hasOwnProperty.call(message, 'withdrawn_reward'))
          $root.cosmos.base.v1beta1.Coin.encode(message.withdrawn_reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EventWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventWithdrawReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventWithdrawReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventWithdrawReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventWithdrawReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.withdrawn_reward != null && message.hasOwnProperty('withdrawn_reward')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.withdrawn_reward);
          if (error) return 'withdrawn_reward.' + error;
        }
        return null;
      };

      /**
       * Creates an EventWithdrawReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
       */
      EventWithdrawReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawReward) return object;
        let message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.withdrawn_reward != null) {
          if (typeof object.withdrawn_reward !== 'object')
            throw TypeError('.ununifi.ecosystemincentive.EventWithdrawReward.withdrawn_reward: object expected');
          message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.withdrawn_reward);
        }
        return message;
      };

      /**
       * Creates a plain object from an EventWithdrawReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.EventWithdrawReward} message EventWithdrawReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventWithdrawReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.withdrawn_reward = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.withdrawn_reward != null && message.hasOwnProperty('withdrawn_reward'))
          object.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.withdrawn_reward, options);
        return object;
      };

      /**
       * Converts this EventWithdrawReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventWithdrawReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventWithdrawReward;
    })();

    ecosystemincentive.EventFailedParsingMemoInputs = (function () {
      /**
       * Properties of an EventFailedParsingMemoInputs.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventFailedParsingMemoInputs
       * @property {string|null} [class_id] EventFailedParsingMemoInputs class_id
       * @property {string|null} [nft_id] EventFailedParsingMemoInputs nft_id
       * @property {string|null} [memo] EventFailedParsingMemoInputs memo
       */

      /**
       * Constructs a new EventFailedParsingMemoInputs.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventFailedParsingMemoInputs.
       * @implements IEventFailedParsingMemoInputs
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventFailedParsingMemoInputs=} [properties] Properties to set
       */
      function EventFailedParsingMemoInputs(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventFailedParsingMemoInputs class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @instance
       */
      EventFailedParsingMemoInputs.prototype.class_id = '';

      /**
       * EventFailedParsingMemoInputs nft_id.
       * @member {string} nft_id
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @instance
       */
      EventFailedParsingMemoInputs.prototype.nft_id = '';

      /**
       * EventFailedParsingMemoInputs memo.
       * @member {string} memo
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @instance
       */
      EventFailedParsingMemoInputs.prototype.memo = '';

      /**
       * Encodes the specified EventFailedParsingMemoInputs message. Does not implicitly {@link ununifi.ecosystemincentive.EventFailedParsingMemoInputs.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @static
       * @param {ununifi.ecosystemincentive.IEventFailedParsingMemoInputs} message EventFailedParsingMemoInputs message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventFailedParsingMemoInputs.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        if (message.memo != null && Object.hasOwnProperty.call(message, 'memo'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.memo);
        return writer;
      };

      /**
       * Encodes the specified EventFailedParsingMemoInputs message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventFailedParsingMemoInputs.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @static
       * @param {ununifi.ecosystemincentive.IEventFailedParsingMemoInputs} message EventFailedParsingMemoInputs message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventFailedParsingMemoInputs.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventFailedParsingMemoInputs message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} EventFailedParsingMemoInputs
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventFailedParsingMemoInputs.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventFailedParsingMemoInputs();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            case 3:
              message.memo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventFailedParsingMemoInputs message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} EventFailedParsingMemoInputs
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventFailedParsingMemoInputs.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventFailedParsingMemoInputs message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventFailedParsingMemoInputs.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        if (message.memo != null && message.hasOwnProperty('memo')) if (!$util.isString(message.memo)) return 'memo: string expected';
        return null;
      };

      /**
       * Creates an EventFailedParsingMemoInputs message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} EventFailedParsingMemoInputs
       */
      EventFailedParsingMemoInputs.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventFailedParsingMemoInputs) return object;
        let message = new $root.ununifi.ecosystemincentive.EventFailedParsingMemoInputs();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        if (object.memo != null) message.memo = String(object.memo);
        return message;
      };

      /**
       * Creates a plain object from an EventFailedParsingMemoInputs message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @static
       * @param {ununifi.ecosystemincentive.EventFailedParsingMemoInputs} message EventFailedParsingMemoInputs
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventFailedParsingMemoInputs.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
          object.memo = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        if (message.memo != null && message.hasOwnProperty('memo')) object.memo = message.memo;
        return object;
      };

      /**
       * Converts this EventFailedParsingMemoInputs to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventFailedParsingMemoInputs
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventFailedParsingMemoInputs.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventFailedParsingMemoInputs;
    })();

    ecosystemincentive.EventRecordedIncentiveUnitId = (function () {
      /**
       * Properties of an EventRecordedIncentiveUnitId.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventRecordedIncentiveUnitId
       * @property {string|null} [incentive_unit_id] EventRecordedIncentiveUnitId incentive_unit_id
       * @property {string|null} [class_id] EventRecordedIncentiveUnitId class_id
       * @property {string|null} [nft_id] EventRecordedIncentiveUnitId nft_id
       */

      /**
       * Constructs a new EventRecordedIncentiveUnitId.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventRecordedIncentiveUnitId.
       * @implements IEventRecordedIncentiveUnitId
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventRecordedIncentiveUnitId=} [properties] Properties to set
       */
      function EventRecordedIncentiveUnitId(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventRecordedIncentiveUnitId incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @instance
       */
      EventRecordedIncentiveUnitId.prototype.incentive_unit_id = '';

      /**
       * EventRecordedIncentiveUnitId class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @instance
       */
      EventRecordedIncentiveUnitId.prototype.class_id = '';

      /**
       * EventRecordedIncentiveUnitId nft_id.
       * @member {string} nft_id
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @instance
       */
      EventRecordedIncentiveUnitId.prototype.nft_id = '';

      /**
       * Encodes the specified EventRecordedIncentiveUnitId message. Does not implicitly {@link ununifi.ecosystemincentive.EventRecordedIncentiveUnitId.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @static
       * @param {ununifi.ecosystemincentive.IEventRecordedIncentiveUnitId} message EventRecordedIncentiveUnitId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRecordedIncentiveUnitId.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventRecordedIncentiveUnitId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventRecordedIncentiveUnitId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @static
       * @param {ununifi.ecosystemincentive.IEventRecordedIncentiveUnitId} message EventRecordedIncentiveUnitId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRecordedIncentiveUnitId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventRecordedIncentiveUnitId message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} EventRecordedIncentiveUnitId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRecordedIncentiveUnitId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventRecordedIncentiveUnitId();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit_id = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventRecordedIncentiveUnitId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} EventRecordedIncentiveUnitId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRecordedIncentiveUnitId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventRecordedIncentiveUnitId message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventRecordedIncentiveUnitId.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventRecordedIncentiveUnitId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} EventRecordedIncentiveUnitId
       */
      EventRecordedIncentiveUnitId.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventRecordedIncentiveUnitId) return object;
        let message = new $root.ununifi.ecosystemincentive.EventRecordedIncentiveUnitId();
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventRecordedIncentiveUnitId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @static
       * @param {ununifi.ecosystemincentive.EventRecordedIncentiveUnitId} message EventRecordedIncentiveUnitId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventRecordedIncentiveUnitId.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.incentive_unit_id = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventRecordedIncentiveUnitId to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventRecordedIncentiveUnitId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventRecordedIncentiveUnitId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventRecordedIncentiveUnitId;
    })();

    ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward = (function () {
      /**
       * Properties of an EventDeletedNftIdRecordedForFrontendReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventDeletedNftIdRecordedForFrontendReward
       * @property {string|null} [incentive_unit_id] EventDeletedNftIdRecordedForFrontendReward incentive_unit_id
       * @property {string|null} [class_id] EventDeletedNftIdRecordedForFrontendReward class_id
       * @property {string|null} [nft_id] EventDeletedNftIdRecordedForFrontendReward nft_id
       */

      /**
       * Constructs a new EventDeletedNftIdRecordedForFrontendReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventDeletedNftIdRecordedForFrontendReward.
       * @implements IEventDeletedNftIdRecordedForFrontendReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward=} [properties] Properties to set
       */
      function EventDeletedNftIdRecordedForFrontendReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventDeletedNftIdRecordedForFrontendReward incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.incentive_unit_id = '';

      /**
       * EventDeletedNftIdRecordedForFrontendReward class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.class_id = '';

      /**
       * EventDeletedNftIdRecordedForFrontendReward nft_id.
       * @member {string} nft_id
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.nft_id = '';

      /**
       * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventDeletedNftIdRecordedForFrontendReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventDeletedNftIdRecordedForFrontendReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventDeletedNftIdRecordedForFrontendReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit_id = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventDeletedNftIdRecordedForFrontendReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventDeletedNftIdRecordedForFrontendReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventDeletedNftIdRecordedForFrontendReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventDeletedNftIdRecordedForFrontendReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
       */
      EventDeletedNftIdRecordedForFrontendReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward) return object;
        let message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventDeletedNftIdRecordedForFrontendReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventDeletedNftIdRecordedForFrontendReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.incentive_unit_id = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventDeletedNftIdRecordedForFrontendReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventDeletedNftIdRecordedForFrontendReward;
    })();

    ecosystemincentive.EventNotRegisteredIncentiveUnitId = (function () {
      /**
       * Properties of an EventNotRegisteredIncentiveUnitId.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventNotRegisteredIncentiveUnitId
       * @property {string|null} [incentive_unit_id] EventNotRegisteredIncentiveUnitId incentive_unit_id
       * @property {string|null} [class_id] EventNotRegisteredIncentiveUnitId class_id
       * @property {string|null} [nft_id] EventNotRegisteredIncentiveUnitId nft_id
       */

      /**
       * Constructs a new EventNotRegisteredIncentiveUnitId.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventNotRegisteredIncentiveUnitId.
       * @implements IEventNotRegisteredIncentiveUnitId
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventNotRegisteredIncentiveUnitId=} [properties] Properties to set
       */
      function EventNotRegisteredIncentiveUnitId(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventNotRegisteredIncentiveUnitId incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @instance
       */
      EventNotRegisteredIncentiveUnitId.prototype.incentive_unit_id = '';

      /**
       * EventNotRegisteredIncentiveUnitId class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @instance
       */
      EventNotRegisteredIncentiveUnitId.prototype.class_id = '';

      /**
       * EventNotRegisteredIncentiveUnitId nft_id.
       * @member {string} nft_id
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @instance
       */
      EventNotRegisteredIncentiveUnitId.prototype.nft_id = '';

      /**
       * Encodes the specified EventNotRegisteredIncentiveUnitId message. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @static
       * @param {ununifi.ecosystemincentive.IEventNotRegisteredIncentiveUnitId} message EventNotRegisteredIncentiveUnitId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventNotRegisteredIncentiveUnitId.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventNotRegisteredIncentiveUnitId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @static
       * @param {ununifi.ecosystemincentive.IEventNotRegisteredIncentiveUnitId} message EventNotRegisteredIncentiveUnitId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventNotRegisteredIncentiveUnitId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventNotRegisteredIncentiveUnitId message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} EventNotRegisteredIncentiveUnitId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventNotRegisteredIncentiveUnitId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit_id = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventNotRegisteredIncentiveUnitId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} EventNotRegisteredIncentiveUnitId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventNotRegisteredIncentiveUnitId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventNotRegisteredIncentiveUnitId message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventNotRegisteredIncentiveUnitId.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventNotRegisteredIncentiveUnitId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} EventNotRegisteredIncentiveUnitId
       */
      EventNotRegisteredIncentiveUnitId.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId) return object;
        let message = new $root.ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId();
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventNotRegisteredIncentiveUnitId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @static
       * @param {ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId} message EventNotRegisteredIncentiveUnitId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventNotRegisteredIncentiveUnitId.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.incentive_unit_id = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventNotRegisteredIncentiveUnitId to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventNotRegisteredIncentiveUnitId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventNotRegisteredIncentiveUnitId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventNotRegisteredIncentiveUnitId;
    })();

    ecosystemincentive.EventNotRecordedNftId = (function () {
      /**
       * Properties of an EventNotRecordedNftId.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventNotRecordedNftId
       * @property {string|null} [class_id] EventNotRecordedNftId class_id
       * @property {string|null} [nft_id] EventNotRecordedNftId nft_id
       */

      /**
       * Constructs a new EventNotRecordedNftId.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventNotRecordedNftId.
       * @implements IEventNotRecordedNftId
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId=} [properties] Properties to set
       */
      function EventNotRecordedNftId(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventNotRecordedNftId class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @instance
       */
      EventNotRecordedNftId.prototype.class_id = '';

      /**
       * EventNotRecordedNftId nft_id.
       * @member {string} nft_id
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @instance
       */
      EventNotRecordedNftId.prototype.nft_id = '';

      /**
       * Encodes the specified EventNotRecordedNftId message. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventNotRecordedNftId.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventNotRecordedNftId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventNotRecordedNftId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventNotRecordedNftId message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventNotRecordedNftId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventNotRecordedNftId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventNotRecordedNftId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventNotRecordedNftId message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventNotRecordedNftId.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventNotRecordedNftId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
       */
      EventNotRecordedNftId.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventNotRecordedNftId) return object;
        let message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventNotRecordedNftId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {ununifi.ecosystemincentive.EventNotRecordedNftId} message EventNotRecordedNftId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventNotRecordedNftId.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventNotRecordedNftId to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventNotRecordedNftId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventNotRecordedNftId;
    })();

    ecosystemincentive.EventUpdatedReward = (function () {
      /**
       * Properties of an EventUpdatedReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventUpdatedReward
       * @property {string|null} [incentive_unit_id] EventUpdatedReward incentive_unit_id
       * @property {cosmos.base.v1beta1.ICoin|null} [earned_reward] EventUpdatedReward earned_reward
       */

      /**
       * Constructs a new EventUpdatedReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventUpdatedReward.
       * @implements IEventUpdatedReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventUpdatedReward=} [properties] Properties to set
       */
      function EventUpdatedReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventUpdatedReward incentive_unit_id.
       * @member {string} incentive_unit_id
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @instance
       */
      EventUpdatedReward.prototype.incentive_unit_id = '';

      /**
       * EventUpdatedReward earned_reward.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} earned_reward
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @instance
       */
      EventUpdatedReward.prototype.earned_reward = null;

      /**
       * Encodes the specified EventUpdatedReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdatedReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.incentive_unit_id != null && Object.hasOwnProperty.call(message, 'incentive_unit_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.incentive_unit_id);
        if (message.earned_reward != null && Object.hasOwnProperty.call(message, 'earned_reward'))
          $root.cosmos.base.v1beta1.Coin.encode(message.earned_reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EventUpdatedReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdatedReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventUpdatedReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdatedReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.incentive_unit_id = reader.string();
              break;
            case 2:
              message.earned_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventUpdatedReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdatedReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventUpdatedReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventUpdatedReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          if (!$util.isString(message.incentive_unit_id)) return 'incentive_unit_id: string expected';
        if (message.earned_reward != null && message.hasOwnProperty('earned_reward')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.earned_reward);
          if (error) return 'earned_reward.' + error;
        }
        return null;
      };

      /**
       * Creates an EventUpdatedReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
       */
      EventUpdatedReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventUpdatedReward) return object;
        let message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
        if (object.incentive_unit_id != null) message.incentive_unit_id = String(object.incentive_unit_id);
        if (object.earned_reward != null) {
          if (typeof object.earned_reward !== 'object')
            throw TypeError('.ununifi.ecosystemincentive.EventUpdatedReward.earned_reward: object expected');
          message.earned_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.earned_reward);
        }
        return message;
      };

      /**
       * Creates a plain object from an EventUpdatedReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {ununifi.ecosystemincentive.EventUpdatedReward} message EventUpdatedReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventUpdatedReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.incentive_unit_id = '';
          object.earned_reward = null;
        }
        if (message.incentive_unit_id != null && message.hasOwnProperty('incentive_unit_id'))
          object.incentive_unit_id = message.incentive_unit_id;
        if (message.earned_reward != null && message.hasOwnProperty('earned_reward'))
          object.earned_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.earned_reward, options);
        return object;
      };

      /**
       * Converts this EventUpdatedReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventUpdatedReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventUpdatedReward;
    })();

    ecosystemincentive.EventVersionUnmatched = (function () {
      /**
       * Properties of an EventVersionUnmatched.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventVersionUnmatched
       * @property {string|null} [unmatched_version] EventVersionUnmatched unmatched_version
       * @property {string|null} [class_id] EventVersionUnmatched class_id
       * @property {string|null} [nft_id] EventVersionUnmatched nft_id
       */

      /**
       * Constructs a new EventVersionUnmatched.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventVersionUnmatched.
       * @implements IEventVersionUnmatched
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventVersionUnmatched=} [properties] Properties to set
       */
      function EventVersionUnmatched(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventVersionUnmatched unmatched_version.
       * @member {string} unmatched_version
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       */
      EventVersionUnmatched.prototype.unmatched_version = '';

      /**
       * EventVersionUnmatched class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       */
      EventVersionUnmatched.prototype.class_id = '';

      /**
       * EventVersionUnmatched nft_id.
       * @member {string} nft_id
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       */
      EventVersionUnmatched.prototype.nft_id = '';

      /**
       * Encodes the specified EventVersionUnmatched message. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventVersionUnmatched.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.unmatched_version != null && Object.hasOwnProperty.call(message, 'unmatched_version'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.unmatched_version);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventVersionUnmatched message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventVersionUnmatched.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventVersionUnmatched message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventVersionUnmatched.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unmatched_version = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventVersionUnmatched message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventVersionUnmatched.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventVersionUnmatched message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventVersionUnmatched.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.unmatched_version != null && message.hasOwnProperty('unmatched_version'))
          if (!$util.isString(message.unmatched_version)) return 'unmatched_version: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventVersionUnmatched message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
       */
      EventVersionUnmatched.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventVersionUnmatched) return object;
        let message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
        if (object.unmatched_version != null) message.unmatched_version = String(object.unmatched_version);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventVersionUnmatched message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {ununifi.ecosystemincentive.EventVersionUnmatched} message EventVersionUnmatched
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventVersionUnmatched.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.unmatched_version = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.unmatched_version != null && message.hasOwnProperty('unmatched_version'))
          object.unmatched_version = message.unmatched_version;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventVersionUnmatched to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventVersionUnmatched.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventVersionUnmatched;
    })();

    return ecosystemincentive;
  })();

  ununifi.ethereum = (function () {
    /**
     * Namespace ethereum.
     * @memberof ununifi
     * @namespace
     */
    const ethereum = {};

    ethereum.SignDocForMetamask = (function () {
      /**
       * Properties of a SignDocForMetamask.
       * @memberof ununifi.ethereum
       * @interface ISignDocForMetamask
       * @property {cosmos.tx.v1beta1.ITxBody|null} [body] SignDocForMetamask body
       * @property {cosmos.tx.v1beta1.IAuthInfo|null} [auth_info] SignDocForMetamask auth_info
       * @property {string|null} [chain_id] SignDocForMetamask chain_id
       * @property {Long|null} [account_number] SignDocForMetamask account_number
       */

      /**
       * Constructs a new SignDocForMetamask.
       * @memberof ununifi.ethereum
       * @classdesc Represents a SignDocForMetamask.
       * @implements ISignDocForMetamask
       * @constructor
       * @param {ununifi.ethereum.ISignDocForMetamask=} [properties] Properties to set
       */
      function SignDocForMetamask(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * SignDocForMetamask body.
       * @member {cosmos.tx.v1beta1.ITxBody|null|undefined} body
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @instance
       */
      SignDocForMetamask.prototype.body = null;

      /**
       * SignDocForMetamask auth_info.
       * @member {cosmos.tx.v1beta1.IAuthInfo|null|undefined} auth_info
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @instance
       */
      SignDocForMetamask.prototype.auth_info = null;

      /**
       * SignDocForMetamask chain_id.
       * @member {string} chain_id
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @instance
       */
      SignDocForMetamask.prototype.chain_id = '';

      /**
       * SignDocForMetamask account_number.
       * @member {Long} account_number
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @instance
       */
      SignDocForMetamask.prototype.account_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified SignDocForMetamask message. Does not implicitly {@link ununifi.ethereum.SignDocForMetamask.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @static
       * @param {ununifi.ethereum.ISignDocForMetamask} message SignDocForMetamask message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SignDocForMetamask.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.body != null && Object.hasOwnProperty.call(message, 'body'))
          $root.cosmos.tx.v1beta1.TxBody.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.auth_info != null && Object.hasOwnProperty.call(message, 'auth_info'))
          $root.cosmos.tx.v1beta1.AuthInfo.encode(message.auth_info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.chain_id);
        if (message.account_number != null && Object.hasOwnProperty.call(message, 'account_number'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.account_number);
        return writer;
      };

      /**
       * Encodes the specified SignDocForMetamask message, length delimited. Does not implicitly {@link ununifi.ethereum.SignDocForMetamask.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @static
       * @param {ununifi.ethereum.ISignDocForMetamask} message SignDocForMetamask message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SignDocForMetamask.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a SignDocForMetamask message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ethereum.SignDocForMetamask} SignDocForMetamask
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SignDocForMetamask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ethereum.SignDocForMetamask();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = $root.cosmos.tx.v1beta1.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.chain_id = reader.string();
              break;
            case 4:
              message.account_number = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a SignDocForMetamask message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ethereum.SignDocForMetamask} SignDocForMetamask
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SignDocForMetamask.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a SignDocForMetamask message.
       * @function verify
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      SignDocForMetamask.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.body != null && message.hasOwnProperty('body')) {
          let error = $root.cosmos.tx.v1beta1.TxBody.verify(message.body);
          if (error) return 'body.' + error;
        }
        if (message.auth_info != null && message.hasOwnProperty('auth_info')) {
          let error = $root.cosmos.tx.v1beta1.AuthInfo.verify(message.auth_info);
          if (error) return 'auth_info.' + error;
        }
        if (message.chain_id != null && message.hasOwnProperty('chain_id'))
          if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
        if (message.account_number != null && message.hasOwnProperty('account_number'))
          if (
            !$util.isInteger(message.account_number) &&
            !(message.account_number && $util.isInteger(message.account_number.low) && $util.isInteger(message.account_number.high))
          )
            return 'account_number: integer|Long expected';
        return null;
      };

      /**
       * Creates a SignDocForMetamask message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ethereum.SignDocForMetamask} SignDocForMetamask
       */
      SignDocForMetamask.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ethereum.SignDocForMetamask) return object;
        let message = new $root.ununifi.ethereum.SignDocForMetamask();
        if (object.body != null) {
          if (typeof object.body !== 'object') throw TypeError('.ununifi.ethereum.SignDocForMetamask.body: object expected');
          message.body = $root.cosmos.tx.v1beta1.TxBody.fromObject(object.body);
        }
        if (object.auth_info != null) {
          if (typeof object.auth_info !== 'object') throw TypeError('.ununifi.ethereum.SignDocForMetamask.auth_info: object expected');
          message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.fromObject(object.auth_info);
        }
        if (object.chain_id != null) message.chain_id = String(object.chain_id);
        if (object.account_number != null)
          if ($util.Long) (message.account_number = $util.Long.fromValue(object.account_number)).unsigned = true;
          else if (typeof object.account_number === 'string') message.account_number = parseInt(object.account_number, 10);
          else if (typeof object.account_number === 'number') message.account_number = object.account_number;
          else if (typeof object.account_number === 'object')
            message.account_number = new $util.LongBits(object.account_number.low >>> 0, object.account_number.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a SignDocForMetamask message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @static
       * @param {ununifi.ethereum.SignDocForMetamask} message SignDocForMetamask
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      SignDocForMetamask.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.body = null;
          object.auth_info = null;
          object.chain_id = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.account_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.account_number = options.longs === String ? '0' : 0;
        }
        if (message.body != null && message.hasOwnProperty('body'))
          object.body = $root.cosmos.tx.v1beta1.TxBody.toObject(message.body, options);
        if (message.auth_info != null && message.hasOwnProperty('auth_info'))
          object.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.toObject(message.auth_info, options);
        if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
        if (message.account_number != null && message.hasOwnProperty('account_number'))
          if (typeof message.account_number === 'number')
            object.account_number = options.longs === String ? String(message.account_number) : message.account_number;
          else
            object.account_number =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.account_number)
                : options.longs === Number
                ? new $util.LongBits(message.account_number.low >>> 0, message.account_number.high >>> 0).toNumber(true)
                : message.account_number;
        return object;
      };

      /**
       * Converts this SignDocForMetamask to JSON.
       * @function toJSON
       * @memberof ununifi.ethereum.SignDocForMetamask
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      SignDocForMetamask.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return SignDocForMetamask;
    })();

    return ethereum;
  })();

  ununifi.incentive = (function () {
    /**
     * Namespace incentive.
     * @memberof ununifi
     * @namespace
     */
    const incentive = {};

    incentive.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.incentive
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.incentive.Query#params}.
       * @memberof ununifi.incentive.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.incentive.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.incentive.Query
       * @instance
       * @param {ununifi.incentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.incentive.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.incentive.QueryParamsRequest,
            $root.ununifi.incentive.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.incentive.Query
       * @instance
       * @param {ununifi.incentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.incentive.QueryParamsResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    incentive.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.incentive
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.incentive
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.incentive.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.incentive.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.QueryParamsRequest
       * @static
       * @param {ununifi.incentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.incentive.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.QueryParamsRequest
       * @static
       * @param {ununifi.incentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.incentive.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.QueryParamsRequest) return object;
        return new $root.ununifi.incentive.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.QueryParamsRequest
       * @static
       * @param {ununifi.incentive.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    incentive.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.incentive
       * @interface IQueryParamsResponse
       * @property {ununifi.incentive.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.incentive
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.incentive.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.incentive.IParams|null|undefined} params
       * @memberof ununifi.incentive.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.incentive.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.QueryParamsResponse
       * @static
       * @param {ununifi.incentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.incentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.incentive.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.QueryParamsResponse
       * @static
       * @param {ununifi.incentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.incentive.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.incentive.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.incentive.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.QueryParamsResponse) return object;
        let message = new $root.ununifi.incentive.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.incentive.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.incentive.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.QueryParamsResponse
       * @static
       * @param {ununifi.incentive.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.incentive.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    incentive.BaseClaim = (function () {
      /**
       * Properties of a BaseClaim.
       * @memberof ununifi.incentive
       * @interface IBaseClaim
       * @property {string|null} [owner] BaseClaim owner
       * @property {cosmos.base.v1beta1.ICoin|null} [reward] BaseClaim reward
       */

      /**
       * Constructs a new BaseClaim.
       * @memberof ununifi.incentive
       * @classdesc Represents a BaseClaim.
       * @implements IBaseClaim
       * @constructor
       * @param {ununifi.incentive.IBaseClaim=} [properties] Properties to set
       */
      function BaseClaim(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * BaseClaim owner.
       * @member {string} owner
       * @memberof ununifi.incentive.BaseClaim
       * @instance
       */
      BaseClaim.prototype.owner = '';

      /**
       * BaseClaim reward.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} reward
       * @memberof ununifi.incentive.BaseClaim
       * @instance
       */
      BaseClaim.prototype.reward = null;

      /**
       * Encodes the specified BaseClaim message. Does not implicitly {@link ununifi.incentive.BaseClaim.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.BaseClaim
       * @static
       * @param {ununifi.incentive.IBaseClaim} message BaseClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BaseClaim.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.reward != null && Object.hasOwnProperty.call(message, 'reward'))
          $root.cosmos.base.v1beta1.Coin.encode(message.reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified BaseClaim message, length delimited. Does not implicitly {@link ununifi.incentive.BaseClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.BaseClaim
       * @static
       * @param {ununifi.incentive.IBaseClaim} message BaseClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BaseClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BaseClaim message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.BaseClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.BaseClaim} BaseClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BaseClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.BaseClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a BaseClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.BaseClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.BaseClaim} BaseClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BaseClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BaseClaim message.
       * @function verify
       * @memberof ununifi.incentive.BaseClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BaseClaim.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.reward != null && message.hasOwnProperty('reward')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.reward);
          if (error) return 'reward.' + error;
        }
        return null;
      };

      /**
       * Creates a BaseClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.BaseClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.BaseClaim} BaseClaim
       */
      BaseClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.BaseClaim) return object;
        let message = new $root.ununifi.incentive.BaseClaim();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.reward != null) {
          if (typeof object.reward !== 'object') throw TypeError('.ununifi.incentive.BaseClaim.reward: object expected');
          message.reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.reward);
        }
        return message;
      };

      /**
       * Creates a plain object from a BaseClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.BaseClaim
       * @static
       * @param {ununifi.incentive.BaseClaim} message BaseClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BaseClaim.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.reward = null;
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.reward != null && message.hasOwnProperty('reward'))
          object.reward = $root.cosmos.base.v1beta1.Coin.toObject(message.reward, options);
        return object;
      };

      /**
       * Converts this BaseClaim to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.BaseClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BaseClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return BaseClaim;
    })();

    incentive.BaseMultiClaim = (function () {
      /**
       * Properties of a BaseMultiClaim.
       * @memberof ununifi.incentive
       * @interface IBaseMultiClaim
       * @property {string|null} [owner] BaseMultiClaim owner
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [reward] BaseMultiClaim reward
       */

      /**
       * Constructs a new BaseMultiClaim.
       * @memberof ununifi.incentive
       * @classdesc Represents a BaseMultiClaim.
       * @implements IBaseMultiClaim
       * @constructor
       * @param {ununifi.incentive.IBaseMultiClaim=} [properties] Properties to set
       */
      function BaseMultiClaim(properties) {
        this.reward = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * BaseMultiClaim owner.
       * @member {string} owner
       * @memberof ununifi.incentive.BaseMultiClaim
       * @instance
       */
      BaseMultiClaim.prototype.owner = '';

      /**
       * BaseMultiClaim reward.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} reward
       * @memberof ununifi.incentive.BaseMultiClaim
       * @instance
       */
      BaseMultiClaim.prototype.reward = $util.emptyArray;

      /**
       * Encodes the specified BaseMultiClaim message. Does not implicitly {@link ununifi.incentive.BaseMultiClaim.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.BaseMultiClaim
       * @static
       * @param {ununifi.incentive.IBaseMultiClaim} message BaseMultiClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BaseMultiClaim.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.reward != null && message.reward.length)
          for (let i = 0; i < message.reward.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.reward[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified BaseMultiClaim message, length delimited. Does not implicitly {@link ununifi.incentive.BaseMultiClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.BaseMultiClaim
       * @static
       * @param {ununifi.incentive.IBaseMultiClaim} message BaseMultiClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BaseMultiClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BaseMultiClaim message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.BaseMultiClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.BaseMultiClaim} BaseMultiClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BaseMultiClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.BaseMultiClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              if (!(message.reward && message.reward.length)) message.reward = [];
              message.reward.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a BaseMultiClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.BaseMultiClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.BaseMultiClaim} BaseMultiClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BaseMultiClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BaseMultiClaim message.
       * @function verify
       * @memberof ununifi.incentive.BaseMultiClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BaseMultiClaim.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.reward != null && message.hasOwnProperty('reward')) {
          if (!Array.isArray(message.reward)) return 'reward: array expected';
          for (let i = 0; i < message.reward.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.reward[i]);
            if (error) return 'reward.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a BaseMultiClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.BaseMultiClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.BaseMultiClaim} BaseMultiClaim
       */
      BaseMultiClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.BaseMultiClaim) return object;
        let message = new $root.ununifi.incentive.BaseMultiClaim();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.reward) {
          if (!Array.isArray(object.reward)) throw TypeError('.ununifi.incentive.BaseMultiClaim.reward: array expected');
          message.reward = [];
          for (let i = 0; i < object.reward.length; ++i) {
            if (typeof object.reward[i] !== 'object') throw TypeError('.ununifi.incentive.BaseMultiClaim.reward: object expected');
            message.reward[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.reward[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a BaseMultiClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.BaseMultiClaim
       * @static
       * @param {ununifi.incentive.BaseMultiClaim} message BaseMultiClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BaseMultiClaim.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.reward = [];
        if (options.defaults) object.owner = '';
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.reward && message.reward.length) {
          object.reward = [];
          for (let j = 0; j < message.reward.length; ++j)
            object.reward[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.reward[j], options);
        }
        return object;
      };

      /**
       * Converts this BaseMultiClaim to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.BaseMultiClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BaseMultiClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return BaseMultiClaim;
    })();

    incentive.CdpMintingClaim = (function () {
      /**
       * Properties of a CdpMintingClaim.
       * @memberof ununifi.incentive
       * @interface ICdpMintingClaim
       * @property {ununifi.incentive.IBaseClaim|null} [base_claim] CdpMintingClaim base_claim
       * @property {Array.<ununifi.incentive.IRewardIndex>|null} [reward_indexes] CdpMintingClaim reward_indexes
       */

      /**
       * Constructs a new CdpMintingClaim.
       * @memberof ununifi.incentive
       * @classdesc Represents a CdpMintingClaim.
       * @implements ICdpMintingClaim
       * @constructor
       * @param {ununifi.incentive.ICdpMintingClaim=} [properties] Properties to set
       */
      function CdpMintingClaim(properties) {
        this.reward_indexes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * CdpMintingClaim base_claim.
       * @member {ununifi.incentive.IBaseClaim|null|undefined} base_claim
       * @memberof ununifi.incentive.CdpMintingClaim
       * @instance
       */
      CdpMintingClaim.prototype.base_claim = null;

      /**
       * CdpMintingClaim reward_indexes.
       * @member {Array.<ununifi.incentive.IRewardIndex>} reward_indexes
       * @memberof ununifi.incentive.CdpMintingClaim
       * @instance
       */
      CdpMintingClaim.prototype.reward_indexes = $util.emptyArray;

      /**
       * Encodes the specified CdpMintingClaim message. Does not implicitly {@link ununifi.incentive.CdpMintingClaim.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.CdpMintingClaim
       * @static
       * @param {ununifi.incentive.ICdpMintingClaim} message CdpMintingClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CdpMintingClaim.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.base_claim != null && Object.hasOwnProperty.call(message, 'base_claim'))
          $root.ununifi.incentive.BaseClaim.encode(message.base_claim, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.reward_indexes != null && message.reward_indexes.length)
          for (let i = 0; i < message.reward_indexes.length; ++i)
            $root.ununifi.incentive.RewardIndex.encode(
              message.reward_indexes[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified CdpMintingClaim message, length delimited. Does not implicitly {@link ununifi.incentive.CdpMintingClaim.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.CdpMintingClaim
       * @static
       * @param {ununifi.incentive.ICdpMintingClaim} message CdpMintingClaim message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CdpMintingClaim.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CdpMintingClaim message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.CdpMintingClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.CdpMintingClaim} CdpMintingClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CdpMintingClaim.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.CdpMintingClaim();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.base_claim = $root.ununifi.incentive.BaseClaim.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.reward_indexes && message.reward_indexes.length)) message.reward_indexes = [];
              message.reward_indexes.push($root.ununifi.incentive.RewardIndex.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CdpMintingClaim message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.CdpMintingClaim
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.CdpMintingClaim} CdpMintingClaim
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CdpMintingClaim.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CdpMintingClaim message.
       * @function verify
       * @memberof ununifi.incentive.CdpMintingClaim
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CdpMintingClaim.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.base_claim != null && message.hasOwnProperty('base_claim')) {
          let error = $root.ununifi.incentive.BaseClaim.verify(message.base_claim);
          if (error) return 'base_claim.' + error;
        }
        if (message.reward_indexes != null && message.hasOwnProperty('reward_indexes')) {
          if (!Array.isArray(message.reward_indexes)) return 'reward_indexes: array expected';
          for (let i = 0; i < message.reward_indexes.length; ++i) {
            let error = $root.ununifi.incentive.RewardIndex.verify(message.reward_indexes[i]);
            if (error) return 'reward_indexes.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a CdpMintingClaim message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.CdpMintingClaim
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.CdpMintingClaim} CdpMintingClaim
       */
      CdpMintingClaim.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.CdpMintingClaim) return object;
        let message = new $root.ununifi.incentive.CdpMintingClaim();
        if (object.base_claim != null) {
          if (typeof object.base_claim !== 'object') throw TypeError('.ununifi.incentive.CdpMintingClaim.base_claim: object expected');
          message.base_claim = $root.ununifi.incentive.BaseClaim.fromObject(object.base_claim);
        }
        if (object.reward_indexes) {
          if (!Array.isArray(object.reward_indexes)) throw TypeError('.ununifi.incentive.CdpMintingClaim.reward_indexes: array expected');
          message.reward_indexes = [];
          for (let i = 0; i < object.reward_indexes.length; ++i) {
            if (typeof object.reward_indexes[i] !== 'object')
              throw TypeError('.ununifi.incentive.CdpMintingClaim.reward_indexes: object expected');
            message.reward_indexes[i] = $root.ununifi.incentive.RewardIndex.fromObject(object.reward_indexes[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a CdpMintingClaim message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.CdpMintingClaim
       * @static
       * @param {ununifi.incentive.CdpMintingClaim} message CdpMintingClaim
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CdpMintingClaim.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.reward_indexes = [];
        if (options.defaults) object.base_claim = null;
        if (message.base_claim != null && message.hasOwnProperty('base_claim'))
          object.base_claim = $root.ununifi.incentive.BaseClaim.toObject(message.base_claim, options);
        if (message.reward_indexes && message.reward_indexes.length) {
          object.reward_indexes = [];
          for (let j = 0; j < message.reward_indexes.length; ++j)
            object.reward_indexes[j] = $root.ununifi.incentive.RewardIndex.toObject(message.reward_indexes[j], options);
        }
        return object;
      };

      /**
       * Converts this CdpMintingClaim to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.CdpMintingClaim
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CdpMintingClaim.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CdpMintingClaim;
    })();

    incentive.RewardIndex = (function () {
      /**
       * Properties of a RewardIndex.
       * @memberof ununifi.incentive
       * @interface IRewardIndex
       * @property {string|null} [collateral_type] RewardIndex collateral_type
       * @property {string|null} [reward_factor] RewardIndex reward_factor
       */

      /**
       * Constructs a new RewardIndex.
       * @memberof ununifi.incentive
       * @classdesc Represents a RewardIndex.
       * @implements IRewardIndex
       * @constructor
       * @param {ununifi.incentive.IRewardIndex=} [properties] Properties to set
       */
      function RewardIndex(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardIndex collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.incentive.RewardIndex
       * @instance
       */
      RewardIndex.prototype.collateral_type = '';

      /**
       * RewardIndex reward_factor.
       * @member {string} reward_factor
       * @memberof ununifi.incentive.RewardIndex
       * @instance
       */
      RewardIndex.prototype.reward_factor = '';

      /**
       * Encodes the specified RewardIndex message. Does not implicitly {@link ununifi.incentive.RewardIndex.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.RewardIndex
       * @static
       * @param {ununifi.incentive.IRewardIndex} message RewardIndex message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardIndex.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
        if (message.reward_factor != null && Object.hasOwnProperty.call(message, 'reward_factor'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reward_factor);
        return writer;
      };

      /**
       * Encodes the specified RewardIndex message, length delimited. Does not implicitly {@link ununifi.incentive.RewardIndex.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.RewardIndex
       * @static
       * @param {ununifi.incentive.IRewardIndex} message RewardIndex message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardIndex.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardIndex message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.RewardIndex
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.RewardIndex} RewardIndex
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardIndex.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.RewardIndex();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.collateral_type = reader.string();
              break;
            case 2:
              message.reward_factor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardIndex message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.RewardIndex
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.RewardIndex} RewardIndex
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardIndex.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardIndex message.
       * @function verify
       * @memberof ununifi.incentive.RewardIndex
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardIndex.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        if (message.reward_factor != null && message.hasOwnProperty('reward_factor'))
          if (!$util.isString(message.reward_factor)) return 'reward_factor: string expected';
        return null;
      };

      /**
       * Creates a RewardIndex message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.RewardIndex
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.RewardIndex} RewardIndex
       */
      RewardIndex.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.RewardIndex) return object;
        let message = new $root.ununifi.incentive.RewardIndex();
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        if (object.reward_factor != null) message.reward_factor = String(object.reward_factor);
        return message;
      };

      /**
       * Creates a plain object from a RewardIndex message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.RewardIndex
       * @static
       * @param {ununifi.incentive.RewardIndex} message RewardIndex
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardIndex.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.collateral_type = '';
          object.reward_factor = '';
        }
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        if (message.reward_factor != null && message.hasOwnProperty('reward_factor')) object.reward_factor = message.reward_factor;
        return object;
      };

      /**
       * Converts this RewardIndex to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.RewardIndex
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardIndex.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardIndex;
    })();

    incentive.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.incentive
       * @interface IParams
       * @property {Array.<ununifi.incentive.IRewardPeriod>|null} [cdp_minting_reward_periods] Params cdp_minting_reward_periods
       * @property {Array.<ununifi.incentive.IMultiplier>|null} [claim_multipliers] Params claim_multipliers
       * @property {google.protobuf.ITimestamp|null} [claim_end] Params claim_end
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.incentive
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.incentive.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.cdp_minting_reward_periods = [];
        this.claim_multipliers = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params cdp_minting_reward_periods.
       * @member {Array.<ununifi.incentive.IRewardPeriod>} cdp_minting_reward_periods
       * @memberof ununifi.incentive.Params
       * @instance
       */
      Params.prototype.cdp_minting_reward_periods = $util.emptyArray;

      /**
       * Params claim_multipliers.
       * @member {Array.<ununifi.incentive.IMultiplier>} claim_multipliers
       * @memberof ununifi.incentive.Params
       * @instance
       */
      Params.prototype.claim_multipliers = $util.emptyArray;

      /**
       * Params claim_end.
       * @member {google.protobuf.ITimestamp|null|undefined} claim_end
       * @memberof ununifi.incentive.Params
       * @instance
       */
      Params.prototype.claim_end = null;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.incentive.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.Params
       * @static
       * @param {ununifi.incentive.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.cdp_minting_reward_periods != null && message.cdp_minting_reward_periods.length)
          for (let i = 0; i < message.cdp_minting_reward_periods.length; ++i)
            $root.ununifi.incentive.RewardPeriod.encode(
              message.cdp_minting_reward_periods[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.claim_multipliers != null && message.claim_multipliers.length)
          for (let i = 0; i < message.claim_multipliers.length; ++i)
            $root.ununifi.incentive.Multiplier.encode(
              message.claim_multipliers[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.claim_end != null && Object.hasOwnProperty.call(message, 'claim_end'))
          $root.google.protobuf.Timestamp.encode(message.claim_end, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.incentive.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.Params
       * @static
       * @param {ununifi.incentive.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.cdp_minting_reward_periods && message.cdp_minting_reward_periods.length))
                message.cdp_minting_reward_periods = [];
              message.cdp_minting_reward_periods.push($root.ununifi.incentive.RewardPeriod.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.claim_multipliers && message.claim_multipliers.length)) message.claim_multipliers = [];
              message.claim_multipliers.push($root.ununifi.incentive.Multiplier.decode(reader, reader.uint32()));
              break;
            case 3:
              message.claim_end = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.incentive.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.cdp_minting_reward_periods != null && message.hasOwnProperty('cdp_minting_reward_periods')) {
          if (!Array.isArray(message.cdp_minting_reward_periods)) return 'cdp_minting_reward_periods: array expected';
          for (let i = 0; i < message.cdp_minting_reward_periods.length; ++i) {
            let error = $root.ununifi.incentive.RewardPeriod.verify(message.cdp_minting_reward_periods[i]);
            if (error) return 'cdp_minting_reward_periods.' + error;
          }
        }
        if (message.claim_multipliers != null && message.hasOwnProperty('claim_multipliers')) {
          if (!Array.isArray(message.claim_multipliers)) return 'claim_multipliers: array expected';
          for (let i = 0; i < message.claim_multipliers.length; ++i) {
            let error = $root.ununifi.incentive.Multiplier.verify(message.claim_multipliers[i]);
            if (error) return 'claim_multipliers.' + error;
          }
        }
        if (message.claim_end != null && message.hasOwnProperty('claim_end')) {
          let error = $root.google.protobuf.Timestamp.verify(message.claim_end);
          if (error) return 'claim_end.' + error;
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.Params) return object;
        let message = new $root.ununifi.incentive.Params();
        if (object.cdp_minting_reward_periods) {
          if (!Array.isArray(object.cdp_minting_reward_periods))
            throw TypeError('.ununifi.incentive.Params.cdp_minting_reward_periods: array expected');
          message.cdp_minting_reward_periods = [];
          for (let i = 0; i < object.cdp_minting_reward_periods.length; ++i) {
            if (typeof object.cdp_minting_reward_periods[i] !== 'object')
              throw TypeError('.ununifi.incentive.Params.cdp_minting_reward_periods: object expected');
            message.cdp_minting_reward_periods[i] = $root.ununifi.incentive.RewardPeriod.fromObject(object.cdp_minting_reward_periods[i]);
          }
        }
        if (object.claim_multipliers) {
          if (!Array.isArray(object.claim_multipliers)) throw TypeError('.ununifi.incentive.Params.claim_multipliers: array expected');
          message.claim_multipliers = [];
          for (let i = 0; i < object.claim_multipliers.length; ++i) {
            if (typeof object.claim_multipliers[i] !== 'object')
              throw TypeError('.ununifi.incentive.Params.claim_multipliers: object expected');
            message.claim_multipliers[i] = $root.ununifi.incentive.Multiplier.fromObject(object.claim_multipliers[i]);
          }
        }
        if (object.claim_end != null) {
          if (typeof object.claim_end !== 'object') throw TypeError('.ununifi.incentive.Params.claim_end: object expected');
          message.claim_end = $root.google.protobuf.Timestamp.fromObject(object.claim_end);
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.Params
       * @static
       * @param {ununifi.incentive.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.cdp_minting_reward_periods = [];
          object.claim_multipliers = [];
        }
        if (options.defaults) object.claim_end = null;
        if (message.cdp_minting_reward_periods && message.cdp_minting_reward_periods.length) {
          object.cdp_minting_reward_periods = [];
          for (let j = 0; j < message.cdp_minting_reward_periods.length; ++j)
            object.cdp_minting_reward_periods[j] = $root.ununifi.incentive.RewardPeriod.toObject(
              message.cdp_minting_reward_periods[j],
              options,
            );
        }
        if (message.claim_multipliers && message.claim_multipliers.length) {
          object.claim_multipliers = [];
          for (let j = 0; j < message.claim_multipliers.length; ++j)
            object.claim_multipliers[j] = $root.ununifi.incentive.Multiplier.toObject(message.claim_multipliers[j], options);
        }
        if (message.claim_end != null && message.hasOwnProperty('claim_end'))
          object.claim_end = $root.google.protobuf.Timestamp.toObject(message.claim_end, options);
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    incentive.RewardPeriod = (function () {
      /**
       * Properties of a RewardPeriod.
       * @memberof ununifi.incentive
       * @interface IRewardPeriod
       * @property {boolean|null} [active] RewardPeriod active
       * @property {string|null} [collateral_type] RewardPeriod collateral_type
       * @property {google.protobuf.ITimestamp|null} [start] RewardPeriod start
       * @property {google.protobuf.ITimestamp|null} [end] RewardPeriod end
       * @property {cosmos.base.v1beta1.ICoin|null} [rewards_per_second] RewardPeriod rewards_per_second
       */

      /**
       * Constructs a new RewardPeriod.
       * @memberof ununifi.incentive
       * @classdesc Represents a RewardPeriod.
       * @implements IRewardPeriod
       * @constructor
       * @param {ununifi.incentive.IRewardPeriod=} [properties] Properties to set
       */
      function RewardPeriod(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardPeriod active.
       * @member {boolean} active
       * @memberof ununifi.incentive.RewardPeriod
       * @instance
       */
      RewardPeriod.prototype.active = false;

      /**
       * RewardPeriod collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.incentive.RewardPeriod
       * @instance
       */
      RewardPeriod.prototype.collateral_type = '';

      /**
       * RewardPeriod start.
       * @member {google.protobuf.ITimestamp|null|undefined} start
       * @memberof ununifi.incentive.RewardPeriod
       * @instance
       */
      RewardPeriod.prototype.start = null;

      /**
       * RewardPeriod end.
       * @member {google.protobuf.ITimestamp|null|undefined} end
       * @memberof ununifi.incentive.RewardPeriod
       * @instance
       */
      RewardPeriod.prototype.end = null;

      /**
       * RewardPeriod rewards_per_second.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} rewards_per_second
       * @memberof ununifi.incentive.RewardPeriod
       * @instance
       */
      RewardPeriod.prototype.rewards_per_second = null;

      /**
       * Encodes the specified RewardPeriod message. Does not implicitly {@link ununifi.incentive.RewardPeriod.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.RewardPeriod
       * @static
       * @param {ununifi.incentive.IRewardPeriod} message RewardPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardPeriod.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.active != null && Object.hasOwnProperty.call(message, 'active'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.active);
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.collateral_type);
        if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
          $root.google.protobuf.Timestamp.encode(message.start, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
          $root.google.protobuf.Timestamp.encode(message.end, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.rewards_per_second != null && Object.hasOwnProperty.call(message, 'rewards_per_second'))
          $root.cosmos.base.v1beta1.Coin.encode(message.rewards_per_second, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified RewardPeriod message, length delimited. Does not implicitly {@link ununifi.incentive.RewardPeriod.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.RewardPeriod
       * @static
       * @param {ununifi.incentive.IRewardPeriod} message RewardPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardPeriod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardPeriod message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.RewardPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.RewardPeriod} RewardPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardPeriod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.RewardPeriod();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.active = reader.bool();
              break;
            case 2:
              message.collateral_type = reader.string();
              break;
            case 3:
              message.start = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.end = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.rewards_per_second = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardPeriod message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.RewardPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.RewardPeriod} RewardPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardPeriod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardPeriod message.
       * @function verify
       * @memberof ununifi.incentive.RewardPeriod
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardPeriod.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.active != null && message.hasOwnProperty('active'))
          if (typeof message.active !== 'boolean') return 'active: boolean expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        if (message.start != null && message.hasOwnProperty('start')) {
          let error = $root.google.protobuf.Timestamp.verify(message.start);
          if (error) return 'start.' + error;
        }
        if (message.end != null && message.hasOwnProperty('end')) {
          let error = $root.google.protobuf.Timestamp.verify(message.end);
          if (error) return 'end.' + error;
        }
        if (message.rewards_per_second != null && message.hasOwnProperty('rewards_per_second')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards_per_second);
          if (error) return 'rewards_per_second.' + error;
        }
        return null;
      };

      /**
       * Creates a RewardPeriod message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.RewardPeriod
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.RewardPeriod} RewardPeriod
       */
      RewardPeriod.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.RewardPeriod) return object;
        let message = new $root.ununifi.incentive.RewardPeriod();
        if (object.active != null) message.active = Boolean(object.active);
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        if (object.start != null) {
          if (typeof object.start !== 'object') throw TypeError('.ununifi.incentive.RewardPeriod.start: object expected');
          message.start = $root.google.protobuf.Timestamp.fromObject(object.start);
        }
        if (object.end != null) {
          if (typeof object.end !== 'object') throw TypeError('.ununifi.incentive.RewardPeriod.end: object expected');
          message.end = $root.google.protobuf.Timestamp.fromObject(object.end);
        }
        if (object.rewards_per_second != null) {
          if (typeof object.rewards_per_second !== 'object')
            throw TypeError('.ununifi.incentive.RewardPeriod.rewards_per_second: object expected');
          message.rewards_per_second = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards_per_second);
        }
        return message;
      };

      /**
       * Creates a plain object from a RewardPeriod message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.RewardPeriod
       * @static
       * @param {ununifi.incentive.RewardPeriod} message RewardPeriod
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardPeriod.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.active = false;
          object.collateral_type = '';
          object.start = null;
          object.end = null;
          object.rewards_per_second = null;
        }
        if (message.active != null && message.hasOwnProperty('active')) object.active = message.active;
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        if (message.start != null && message.hasOwnProperty('start'))
          object.start = $root.google.protobuf.Timestamp.toObject(message.start, options);
        if (message.end != null && message.hasOwnProperty('end'))
          object.end = $root.google.protobuf.Timestamp.toObject(message.end, options);
        if (message.rewards_per_second != null && message.hasOwnProperty('rewards_per_second'))
          object.rewards_per_second = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards_per_second, options);
        return object;
      };

      /**
       * Converts this RewardPeriod to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.RewardPeriod
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardPeriod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardPeriod;
    })();

    incentive.Multiplier = (function () {
      /**
       * Properties of a Multiplier.
       * @memberof ununifi.incentive
       * @interface IMultiplier
       * @property {string|null} [name] Multiplier name
       * @property {Long|null} [months_lockup] Multiplier months_lockup
       * @property {string|null} [factor] Multiplier factor
       */

      /**
       * Constructs a new Multiplier.
       * @memberof ununifi.incentive
       * @classdesc Represents a Multiplier.
       * @implements IMultiplier
       * @constructor
       * @param {ununifi.incentive.IMultiplier=} [properties] Properties to set
       */
      function Multiplier(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Multiplier name.
       * @member {string} name
       * @memberof ununifi.incentive.Multiplier
       * @instance
       */
      Multiplier.prototype.name = '';

      /**
       * Multiplier months_lockup.
       * @member {Long} months_lockup
       * @memberof ununifi.incentive.Multiplier
       * @instance
       */
      Multiplier.prototype.months_lockup = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Multiplier factor.
       * @member {string} factor
       * @memberof ununifi.incentive.Multiplier
       * @instance
       */
      Multiplier.prototype.factor = '';

      /**
       * Encodes the specified Multiplier message. Does not implicitly {@link ununifi.incentive.Multiplier.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.Multiplier
       * @static
       * @param {ununifi.incentive.IMultiplier} message Multiplier message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Multiplier.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.months_lockup != null && Object.hasOwnProperty.call(message, 'months_lockup'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.months_lockup);
        if (message.factor != null && Object.hasOwnProperty.call(message, 'factor'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.factor);
        return writer;
      };

      /**
       * Encodes the specified Multiplier message, length delimited. Does not implicitly {@link ununifi.incentive.Multiplier.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.Multiplier
       * @static
       * @param {ununifi.incentive.IMultiplier} message Multiplier message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Multiplier.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Multiplier message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.Multiplier
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.Multiplier} Multiplier
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Multiplier.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.Multiplier();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.months_lockup = reader.int64();
              break;
            case 3:
              message.factor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Multiplier message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.Multiplier
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.Multiplier} Multiplier
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Multiplier.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Multiplier message.
       * @function verify
       * @memberof ununifi.incentive.Multiplier
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Multiplier.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.months_lockup != null && message.hasOwnProperty('months_lockup'))
          if (
            !$util.isInteger(message.months_lockup) &&
            !(message.months_lockup && $util.isInteger(message.months_lockup.low) && $util.isInteger(message.months_lockup.high))
          )
            return 'months_lockup: integer|Long expected';
        if (message.factor != null && message.hasOwnProperty('factor'))
          if (!$util.isString(message.factor)) return 'factor: string expected';
        return null;
      };

      /**
       * Creates a Multiplier message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.Multiplier
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.Multiplier} Multiplier
       */
      Multiplier.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.Multiplier) return object;
        let message = new $root.ununifi.incentive.Multiplier();
        if (object.name != null) message.name = String(object.name);
        if (object.months_lockup != null)
          if ($util.Long) (message.months_lockup = $util.Long.fromValue(object.months_lockup)).unsigned = false;
          else if (typeof object.months_lockup === 'string') message.months_lockup = parseInt(object.months_lockup, 10);
          else if (typeof object.months_lockup === 'number') message.months_lockup = object.months_lockup;
          else if (typeof object.months_lockup === 'object')
            message.months_lockup = new $util.LongBits(object.months_lockup.low >>> 0, object.months_lockup.high >>> 0).toNumber();
        if (object.factor != null) message.factor = String(object.factor);
        return message;
      };

      /**
       * Creates a plain object from a Multiplier message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.Multiplier
       * @static
       * @param {ununifi.incentive.Multiplier} message Multiplier
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Multiplier.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.months_lockup = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.months_lockup = options.longs === String ? '0' : 0;
          object.factor = '';
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.months_lockup != null && message.hasOwnProperty('months_lockup'))
          if (typeof message.months_lockup === 'number')
            object.months_lockup = options.longs === String ? String(message.months_lockup) : message.months_lockup;
          else
            object.months_lockup =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.months_lockup)
                : options.longs === Number
                ? new $util.LongBits(message.months_lockup.low >>> 0, message.months_lockup.high >>> 0).toNumber()
                : message.months_lockup;
        if (message.factor != null && message.hasOwnProperty('factor')) object.factor = message.factor;
        return object;
      };

      /**
       * Converts this Multiplier to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.Multiplier
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Multiplier.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Multiplier;
    })();

    incentive.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.incentive
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.incentive.Msg#claimCdpMintingReward}.
       * @memberof ununifi.incentive.Msg
       * @typedef ClaimCdpMintingRewardCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.incentive.MsgClaimCdpMintingRewardResponse} [response] MsgClaimCdpMintingRewardResponse
       */

      /**
       * Calls ClaimCdpMintingReward.
       * @function claimCdpMintingReward
       * @memberof ununifi.incentive.Msg
       * @instance
       * @param {ununifi.incentive.IMsgClaimCdpMintingReward} request MsgClaimCdpMintingReward message or plain object
       * @param {ununifi.incentive.Msg.ClaimCdpMintingRewardCallback} callback Node-style callback called with the error, if any, and MsgClaimCdpMintingRewardResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.claimCdpMintingReward = function claimCdpMintingReward(request, callback) {
          return this.rpcCall(
            claimCdpMintingReward,
            $root.ununifi.incentive.MsgClaimCdpMintingReward,
            $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ClaimCdpMintingReward' },
      );

      /**
       * Calls ClaimCdpMintingReward.
       * @function claimCdpMintingReward
       * @memberof ununifi.incentive.Msg
       * @instance
       * @param {ununifi.incentive.IMsgClaimCdpMintingReward} request MsgClaimCdpMintingReward message or plain object
       * @returns {Promise<ununifi.incentive.MsgClaimCdpMintingRewardResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    incentive.MsgClaimCdpMintingReward = (function () {
      /**
       * Properties of a MsgClaimCdpMintingReward.
       * @memberof ununifi.incentive
       * @interface IMsgClaimCdpMintingReward
       * @property {string|null} [sender] MsgClaimCdpMintingReward sender
       * @property {string|null} [multiplier_name] MsgClaimCdpMintingReward multiplier_name
       */

      /**
       * Constructs a new MsgClaimCdpMintingReward.
       * @memberof ununifi.incentive
       * @classdesc Represents a MsgClaimCdpMintingReward.
       * @implements IMsgClaimCdpMintingReward
       * @constructor
       * @param {ununifi.incentive.IMsgClaimCdpMintingReward=} [properties] Properties to set
       */
      function MsgClaimCdpMintingReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgClaimCdpMintingReward sender.
       * @member {string} sender
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @instance
       */
      MsgClaimCdpMintingReward.prototype.sender = '';

      /**
       * MsgClaimCdpMintingReward multiplier_name.
       * @member {string} multiplier_name
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @instance
       */
      MsgClaimCdpMintingReward.prototype.multiplier_name = '';

      /**
       * Encodes the specified MsgClaimCdpMintingReward message. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @static
       * @param {ununifi.incentive.IMsgClaimCdpMintingReward} message MsgClaimCdpMintingReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClaimCdpMintingReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.multiplier_name != null && Object.hasOwnProperty.call(message, 'multiplier_name'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.multiplier_name);
        return writer;
      };

      /**
       * Encodes the specified MsgClaimCdpMintingReward message, length delimited. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @static
       * @param {ununifi.incentive.IMsgClaimCdpMintingReward} message MsgClaimCdpMintingReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClaimCdpMintingReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgClaimCdpMintingReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.MsgClaimCdpMintingReward} MsgClaimCdpMintingReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClaimCdpMintingReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.MsgClaimCdpMintingReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.multiplier_name = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgClaimCdpMintingReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.MsgClaimCdpMintingReward} MsgClaimCdpMintingReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClaimCdpMintingReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgClaimCdpMintingReward message.
       * @function verify
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgClaimCdpMintingReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.multiplier_name != null && message.hasOwnProperty('multiplier_name'))
          if (!$util.isString(message.multiplier_name)) return 'multiplier_name: string expected';
        return null;
      };

      /**
       * Creates a MsgClaimCdpMintingReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.MsgClaimCdpMintingReward} MsgClaimCdpMintingReward
       */
      MsgClaimCdpMintingReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.MsgClaimCdpMintingReward) return object;
        let message = new $root.ununifi.incentive.MsgClaimCdpMintingReward();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.multiplier_name != null) message.multiplier_name = String(object.multiplier_name);
        return message;
      };

      /**
       * Creates a plain object from a MsgClaimCdpMintingReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @static
       * @param {ununifi.incentive.MsgClaimCdpMintingReward} message MsgClaimCdpMintingReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgClaimCdpMintingReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.multiplier_name = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.multiplier_name != null && message.hasOwnProperty('multiplier_name')) object.multiplier_name = message.multiplier_name;
        return object;
      };

      /**
       * Converts this MsgClaimCdpMintingReward to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.MsgClaimCdpMintingReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgClaimCdpMintingReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgClaimCdpMintingReward;
    })();

    incentive.MsgClaimCdpMintingRewardResponse = (function () {
      /**
       * Properties of a MsgClaimCdpMintingRewardResponse.
       * @memberof ununifi.incentive
       * @interface IMsgClaimCdpMintingRewardResponse
       */

      /**
       * Constructs a new MsgClaimCdpMintingRewardResponse.
       * @memberof ununifi.incentive
       * @classdesc Represents a MsgClaimCdpMintingRewardResponse.
       * @implements IMsgClaimCdpMintingRewardResponse
       * @constructor
       * @param {ununifi.incentive.IMsgClaimCdpMintingRewardResponse=} [properties] Properties to set
       */
      function MsgClaimCdpMintingRewardResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgClaimCdpMintingRewardResponse message. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingRewardResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @static
       * @param {ununifi.incentive.IMsgClaimCdpMintingRewardResponse} message MsgClaimCdpMintingRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClaimCdpMintingRewardResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgClaimCdpMintingRewardResponse message, length delimited. Does not implicitly {@link ununifi.incentive.MsgClaimCdpMintingRewardResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @static
       * @param {ununifi.incentive.IMsgClaimCdpMintingRewardResponse} message MsgClaimCdpMintingRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClaimCdpMintingRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgClaimCdpMintingRewardResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.MsgClaimCdpMintingRewardResponse} MsgClaimCdpMintingRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClaimCdpMintingRewardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgClaimCdpMintingRewardResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.MsgClaimCdpMintingRewardResponse} MsgClaimCdpMintingRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClaimCdpMintingRewardResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgClaimCdpMintingRewardResponse message.
       * @function verify
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgClaimCdpMintingRewardResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgClaimCdpMintingRewardResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.MsgClaimCdpMintingRewardResponse} MsgClaimCdpMintingRewardResponse
       */
      MsgClaimCdpMintingRewardResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse) return object;
        return new $root.ununifi.incentive.MsgClaimCdpMintingRewardResponse();
      };

      /**
       * Creates a plain object from a MsgClaimCdpMintingRewardResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @static
       * @param {ununifi.incentive.MsgClaimCdpMintingRewardResponse} message MsgClaimCdpMintingRewardResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgClaimCdpMintingRewardResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgClaimCdpMintingRewardResponse to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.MsgClaimCdpMintingRewardResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgClaimCdpMintingRewardResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgClaimCdpMintingRewardResponse;
    })();

    incentive.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.incentive
       * @interface IGenesisState
       * @property {ununifi.incentive.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.incentive.IGenesisAccumulationTime>|null} [cdp_accumulation_times] GenesisState cdp_accumulation_times
       * @property {Array.<ununifi.incentive.ICdpMintingClaim>|null} [cdp_minting_claims] GenesisState cdp_minting_claims
       * @property {ununifi.incentive.IGenesisDenoms|null} [denoms] GenesisState denoms
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.incentive
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.incentive.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.cdp_accumulation_times = [];
        this.cdp_minting_claims = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.incentive.IParams|null|undefined} params
       * @memberof ununifi.incentive.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState cdp_accumulation_times.
       * @member {Array.<ununifi.incentive.IGenesisAccumulationTime>} cdp_accumulation_times
       * @memberof ununifi.incentive.GenesisState
       * @instance
       */
      GenesisState.prototype.cdp_accumulation_times = $util.emptyArray;

      /**
       * GenesisState cdp_minting_claims.
       * @member {Array.<ununifi.incentive.ICdpMintingClaim>} cdp_minting_claims
       * @memberof ununifi.incentive.GenesisState
       * @instance
       */
      GenesisState.prototype.cdp_minting_claims = $util.emptyArray;

      /**
       * GenesisState denoms.
       * @member {ununifi.incentive.IGenesisDenoms|null|undefined} denoms
       * @memberof ununifi.incentive.GenesisState
       * @instance
       */
      GenesisState.prototype.denoms = null;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.incentive.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.GenesisState
       * @static
       * @param {ununifi.incentive.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.incentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.cdp_accumulation_times != null && message.cdp_accumulation_times.length)
          for (let i = 0; i < message.cdp_accumulation_times.length; ++i)
            $root.ununifi.incentive.GenesisAccumulationTime.encode(
              message.cdp_accumulation_times[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.cdp_minting_claims != null && message.cdp_minting_claims.length)
          for (let i = 0; i < message.cdp_minting_claims.length; ++i)
            $root.ununifi.incentive.CdpMintingClaim.encode(
              message.cdp_minting_claims[i],
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
        if (message.denoms != null && Object.hasOwnProperty.call(message, 'denoms'))
          $root.ununifi.incentive.GenesisDenoms.encode(message.denoms, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.incentive.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.GenesisState
       * @static
       * @param {ununifi.incentive.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.incentive.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.cdp_accumulation_times && message.cdp_accumulation_times.length)) message.cdp_accumulation_times = [];
              message.cdp_accumulation_times.push($root.ununifi.incentive.GenesisAccumulationTime.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.cdp_minting_claims && message.cdp_minting_claims.length)) message.cdp_minting_claims = [];
              message.cdp_minting_claims.push($root.ununifi.incentive.CdpMintingClaim.decode(reader, reader.uint32()));
              break;
            case 4:
              message.denoms = $root.ununifi.incentive.GenesisDenoms.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.incentive.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.incentive.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.cdp_accumulation_times != null && message.hasOwnProperty('cdp_accumulation_times')) {
          if (!Array.isArray(message.cdp_accumulation_times)) return 'cdp_accumulation_times: array expected';
          for (let i = 0; i < message.cdp_accumulation_times.length; ++i) {
            let error = $root.ununifi.incentive.GenesisAccumulationTime.verify(message.cdp_accumulation_times[i]);
            if (error) return 'cdp_accumulation_times.' + error;
          }
        }
        if (message.cdp_minting_claims != null && message.hasOwnProperty('cdp_minting_claims')) {
          if (!Array.isArray(message.cdp_minting_claims)) return 'cdp_minting_claims: array expected';
          for (let i = 0; i < message.cdp_minting_claims.length; ++i) {
            let error = $root.ununifi.incentive.CdpMintingClaim.verify(message.cdp_minting_claims[i]);
            if (error) return 'cdp_minting_claims.' + error;
          }
        }
        if (message.denoms != null && message.hasOwnProperty('denoms')) {
          let error = $root.ununifi.incentive.GenesisDenoms.verify(message.denoms);
          if (error) return 'denoms.' + error;
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.GenesisState) return object;
        let message = new $root.ununifi.incentive.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.incentive.GenesisState.params: object expected');
          message.params = $root.ununifi.incentive.Params.fromObject(object.params);
        }
        if (object.cdp_accumulation_times) {
          if (!Array.isArray(object.cdp_accumulation_times))
            throw TypeError('.ununifi.incentive.GenesisState.cdp_accumulation_times: array expected');
          message.cdp_accumulation_times = [];
          for (let i = 0; i < object.cdp_accumulation_times.length; ++i) {
            if (typeof object.cdp_accumulation_times[i] !== 'object')
              throw TypeError('.ununifi.incentive.GenesisState.cdp_accumulation_times: object expected');
            message.cdp_accumulation_times[i] = $root.ununifi.incentive.GenesisAccumulationTime.fromObject(
              object.cdp_accumulation_times[i],
            );
          }
        }
        if (object.cdp_minting_claims) {
          if (!Array.isArray(object.cdp_minting_claims))
            throw TypeError('.ununifi.incentive.GenesisState.cdp_minting_claims: array expected');
          message.cdp_minting_claims = [];
          for (let i = 0; i < object.cdp_minting_claims.length; ++i) {
            if (typeof object.cdp_minting_claims[i] !== 'object')
              throw TypeError('.ununifi.incentive.GenesisState.cdp_minting_claims: object expected');
            message.cdp_minting_claims[i] = $root.ununifi.incentive.CdpMintingClaim.fromObject(object.cdp_minting_claims[i]);
          }
        }
        if (object.denoms != null) {
          if (typeof object.denoms !== 'object') throw TypeError('.ununifi.incentive.GenesisState.denoms: object expected');
          message.denoms = $root.ununifi.incentive.GenesisDenoms.fromObject(object.denoms);
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.GenesisState
       * @static
       * @param {ununifi.incentive.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.cdp_accumulation_times = [];
          object.cdp_minting_claims = [];
        }
        if (options.defaults) {
          object.params = null;
          object.denoms = null;
        }
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.incentive.Params.toObject(message.params, options);
        if (message.cdp_accumulation_times && message.cdp_accumulation_times.length) {
          object.cdp_accumulation_times = [];
          for (let j = 0; j < message.cdp_accumulation_times.length; ++j)
            object.cdp_accumulation_times[j] = $root.ununifi.incentive.GenesisAccumulationTime.toObject(
              message.cdp_accumulation_times[j],
              options,
            );
        }
        if (message.cdp_minting_claims && message.cdp_minting_claims.length) {
          object.cdp_minting_claims = [];
          for (let j = 0; j < message.cdp_minting_claims.length; ++j)
            object.cdp_minting_claims[j] = $root.ununifi.incentive.CdpMintingClaim.toObject(message.cdp_minting_claims[j], options);
        }
        if (message.denoms != null && message.hasOwnProperty('denoms'))
          object.denoms = $root.ununifi.incentive.GenesisDenoms.toObject(message.denoms, options);
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    incentive.GenesisAccumulationTime = (function () {
      /**
       * Properties of a GenesisAccumulationTime.
       * @memberof ununifi.incentive
       * @interface IGenesisAccumulationTime
       * @property {string|null} [collateral_type] GenesisAccumulationTime collateral_type
       * @property {google.protobuf.ITimestamp|null} [previous_accumulation_time] GenesisAccumulationTime previous_accumulation_time
       */

      /**
       * Constructs a new GenesisAccumulationTime.
       * @memberof ununifi.incentive
       * @classdesc Represents a GenesisAccumulationTime.
       * @implements IGenesisAccumulationTime
       * @constructor
       * @param {ununifi.incentive.IGenesisAccumulationTime=} [properties] Properties to set
       */
      function GenesisAccumulationTime(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisAccumulationTime collateral_type.
       * @member {string} collateral_type
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @instance
       */
      GenesisAccumulationTime.prototype.collateral_type = '';

      /**
       * GenesisAccumulationTime previous_accumulation_time.
       * @member {google.protobuf.ITimestamp|null|undefined} previous_accumulation_time
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @instance
       */
      GenesisAccumulationTime.prototype.previous_accumulation_time = null;

      /**
       * Encodes the specified GenesisAccumulationTime message. Does not implicitly {@link ununifi.incentive.GenesisAccumulationTime.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @static
       * @param {ununifi.incentive.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisAccumulationTime.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.collateral_type != null && Object.hasOwnProperty.call(message, 'collateral_type'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.collateral_type);
        if (message.previous_accumulation_time != null && Object.hasOwnProperty.call(message, 'previous_accumulation_time'))
          $root.google.protobuf.Timestamp.encode(
            message.previous_accumulation_time,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisAccumulationTime message, length delimited. Does not implicitly {@link ununifi.incentive.GenesisAccumulationTime.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @static
       * @param {ununifi.incentive.IGenesisAccumulationTime} message GenesisAccumulationTime message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisAccumulationTime.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisAccumulationTime message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.GenesisAccumulationTime} GenesisAccumulationTime
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisAccumulationTime.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.GenesisAccumulationTime();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.collateral_type = reader.string();
              break;
            case 2:
              message.previous_accumulation_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisAccumulationTime message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.GenesisAccumulationTime} GenesisAccumulationTime
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisAccumulationTime.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisAccumulationTime message.
       * @function verify
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisAccumulationTime.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type'))
          if (!$util.isString(message.collateral_type)) return 'collateral_type: string expected';
        if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.previous_accumulation_time);
          if (error) return 'previous_accumulation_time.' + error;
        }
        return null;
      };

      /**
       * Creates a GenesisAccumulationTime message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.GenesisAccumulationTime} GenesisAccumulationTime
       */
      GenesisAccumulationTime.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.GenesisAccumulationTime) return object;
        let message = new $root.ununifi.incentive.GenesisAccumulationTime();
        if (object.collateral_type != null) message.collateral_type = String(object.collateral_type);
        if (object.previous_accumulation_time != null) {
          if (typeof object.previous_accumulation_time !== 'object')
            throw TypeError('.ununifi.incentive.GenesisAccumulationTime.previous_accumulation_time: object expected');
          message.previous_accumulation_time = $root.google.protobuf.Timestamp.fromObject(object.previous_accumulation_time);
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisAccumulationTime message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @static
       * @param {ununifi.incentive.GenesisAccumulationTime} message GenesisAccumulationTime
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisAccumulationTime.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.collateral_type = '';
          object.previous_accumulation_time = null;
        }
        if (message.collateral_type != null && message.hasOwnProperty('collateral_type')) object.collateral_type = message.collateral_type;
        if (message.previous_accumulation_time != null && message.hasOwnProperty('previous_accumulation_time'))
          object.previous_accumulation_time = $root.google.protobuf.Timestamp.toObject(message.previous_accumulation_time, options);
        return object;
      };

      /**
       * Converts this GenesisAccumulationTime to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.GenesisAccumulationTime
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisAccumulationTime.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisAccumulationTime;
    })();

    incentive.GenesisDenoms = (function () {
      /**
       * Properties of a GenesisDenoms.
       * @memberof ununifi.incentive
       * @interface IGenesisDenoms
       * @property {string|null} [principal_denom] GenesisDenoms principal_denom
       * @property {string|null} [cdp_minting_reward_denom] GenesisDenoms cdp_minting_reward_denom
       */

      /**
       * Constructs a new GenesisDenoms.
       * @memberof ununifi.incentive
       * @classdesc Represents a GenesisDenoms.
       * @implements IGenesisDenoms
       * @constructor
       * @param {ununifi.incentive.IGenesisDenoms=} [properties] Properties to set
       */
      function GenesisDenoms(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisDenoms principal_denom.
       * @member {string} principal_denom
       * @memberof ununifi.incentive.GenesisDenoms
       * @instance
       */
      GenesisDenoms.prototype.principal_denom = '';

      /**
       * GenesisDenoms cdp_minting_reward_denom.
       * @member {string} cdp_minting_reward_denom
       * @memberof ununifi.incentive.GenesisDenoms
       * @instance
       */
      GenesisDenoms.prototype.cdp_minting_reward_denom = '';

      /**
       * Encodes the specified GenesisDenoms message. Does not implicitly {@link ununifi.incentive.GenesisDenoms.verify|verify} messages.
       * @function encode
       * @memberof ununifi.incentive.GenesisDenoms
       * @static
       * @param {ununifi.incentive.IGenesisDenoms} message GenesisDenoms message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisDenoms.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.principal_denom != null && Object.hasOwnProperty.call(message, 'principal_denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.principal_denom);
        if (message.cdp_minting_reward_denom != null && Object.hasOwnProperty.call(message, 'cdp_minting_reward_denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.cdp_minting_reward_denom);
        return writer;
      };

      /**
       * Encodes the specified GenesisDenoms message, length delimited. Does not implicitly {@link ununifi.incentive.GenesisDenoms.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.incentive.GenesisDenoms
       * @static
       * @param {ununifi.incentive.IGenesisDenoms} message GenesisDenoms message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisDenoms.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisDenoms message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.incentive.GenesisDenoms
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.incentive.GenesisDenoms} GenesisDenoms
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisDenoms.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.incentive.GenesisDenoms();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.principal_denom = reader.string();
              break;
            case 2:
              message.cdp_minting_reward_denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisDenoms message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.incentive.GenesisDenoms
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.incentive.GenesisDenoms} GenesisDenoms
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisDenoms.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisDenoms message.
       * @function verify
       * @memberof ununifi.incentive.GenesisDenoms
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisDenoms.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.principal_denom != null && message.hasOwnProperty('principal_denom'))
          if (!$util.isString(message.principal_denom)) return 'principal_denom: string expected';
        if (message.cdp_minting_reward_denom != null && message.hasOwnProperty('cdp_minting_reward_denom'))
          if (!$util.isString(message.cdp_minting_reward_denom)) return 'cdp_minting_reward_denom: string expected';
        return null;
      };

      /**
       * Creates a GenesisDenoms message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.incentive.GenesisDenoms
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.incentive.GenesisDenoms} GenesisDenoms
       */
      GenesisDenoms.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.incentive.GenesisDenoms) return object;
        let message = new $root.ununifi.incentive.GenesisDenoms();
        if (object.principal_denom != null) message.principal_denom = String(object.principal_denom);
        if (object.cdp_minting_reward_denom != null) message.cdp_minting_reward_denom = String(object.cdp_minting_reward_denom);
        return message;
      };

      /**
       * Creates a plain object from a GenesisDenoms message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.incentive.GenesisDenoms
       * @static
       * @param {ununifi.incentive.GenesisDenoms} message GenesisDenoms
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisDenoms.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.principal_denom = '';
          object.cdp_minting_reward_denom = '';
        }
        if (message.principal_denom != null && message.hasOwnProperty('principal_denom')) object.principal_denom = message.principal_denom;
        if (message.cdp_minting_reward_denom != null && message.hasOwnProperty('cdp_minting_reward_denom'))
          object.cdp_minting_reward_denom = message.cdp_minting_reward_denom;
        return object;
      };

      /**
       * Converts this GenesisDenoms to JSON.
       * @function toJSON
       * @memberof ununifi.incentive.GenesisDenoms
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisDenoms.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisDenoms;
    })();

    return incentive;
  })();

  ununifi.nftmarket = (function () {
    /**
     * Namespace nftmarket.
     * @memberof ununifi
     * @namespace
     */
    const nftmarket = {};

    nftmarket.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#params}.
       * @memberof ununifi.nftmarket.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.nftmarket.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.nftmarket.QueryParamsRequest,
            $root.ununifi.nftmarket.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#nftListing}.
       * @memberof ununifi.nftmarket.Query
       * @typedef NftListingCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryNftListingResponse} [response] QueryNftListingResponse
       */

      /**
       * Calls NftListing.
       * @function nftListing
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryNftListingRequest} request QueryNftListingRequest message or plain object
       * @param {ununifi.nftmarket.Query.NftListingCallback} callback Node-style callback called with the error, if any, and QueryNftListingResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.nftListing = function nftListing(request, callback) {
          return this.rpcCall(
            nftListing,
            $root.ununifi.nftmarket.QueryNftListingRequest,
            $root.ununifi.nftmarket.QueryNftListingResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'NftListing' },
      );

      /**
       * Calls NftListing.
       * @function nftListing
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryNftListingRequest} request QueryNftListingRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryNftListingResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#listedNfts}.
       * @memberof ununifi.nftmarket.Query
       * @typedef ListedNftsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryListedNftsResponse} [response] QueryListedNftsResponse
       */

      /**
       * Calls ListedNfts.
       * @function listedNfts
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
       * @param {ununifi.nftmarket.Query.ListedNftsCallback} callback Node-style callback called with the error, if any, and QueryListedNftsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.listedNfts = function listedNfts(request, callback) {
          return this.rpcCall(
            listedNfts,
            $root.ununifi.nftmarket.QueryListedNftsRequest,
            $root.ununifi.nftmarket.QueryListedNftsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListedNfts' },
      );

      /**
       * Calls ListedNfts.
       * @function listedNfts
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryListedNftsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#listedClasses}.
       * @memberof ununifi.nftmarket.Query
       * @typedef ListedClassesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryListedClassesResponse} [response] QueryListedClassesResponse
       */

      /**
       * Calls ListedClasses.
       * @function listedClasses
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
       * @param {ununifi.nftmarket.Query.ListedClassesCallback} callback Node-style callback called with the error, if any, and QueryListedClassesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.listedClasses = function listedClasses(request, callback) {
          return this.rpcCall(
            listedClasses,
            $root.ununifi.nftmarket.QueryListedClassesRequest,
            $root.ununifi.nftmarket.QueryListedClassesResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListedClasses' },
      );

      /**
       * Calls ListedClasses.
       * @function listedClasses
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryListedClassesResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#listedClass}.
       * @memberof ununifi.nftmarket.Query
       * @typedef ListedClassCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryListedClassResponse} [response] QueryListedClassResponse
       */

      /**
       * Calls ListedClass.
       * @function listedClass
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
       * @param {ununifi.nftmarket.Query.ListedClassCallback} callback Node-style callback called with the error, if any, and QueryListedClassResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.listedClass = function listedClass(request, callback) {
          return this.rpcCall(
            listedClass,
            $root.ununifi.nftmarket.QueryListedClassRequest,
            $root.ununifi.nftmarket.QueryListedClassResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListedClass' },
      );

      /**
       * Calls ListedClass.
       * @function listedClass
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryListedClassResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#loans}.
       * @memberof ununifi.nftmarket.Query
       * @typedef LoansCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryLoansResponse} [response] QueryLoansResponse
       */

      /**
       * Calls Loans.
       * @function loans
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryLoansRequest} request QueryLoansRequest message or plain object
       * @param {ununifi.nftmarket.Query.LoansCallback} callback Node-style callback called with the error, if any, and QueryLoansResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.loans = function loans(request, callback) {
          return this.rpcCall(
            loans,
            $root.ununifi.nftmarket.QueryLoansRequest,
            $root.ununifi.nftmarket.QueryLoansResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Loans' },
      );

      /**
       * Calls Loans.
       * @function loans
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryLoansRequest} request QueryLoansRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryLoansResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#loan}.
       * @memberof ununifi.nftmarket.Query
       * @typedef LoanCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryLoanResponse} [response] QueryLoanResponse
       */

      /**
       * Calls Loan.
       * @function loan
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryLoanRequest} request QueryLoanRequest message or plain object
       * @param {ununifi.nftmarket.Query.LoanCallback} callback Node-style callback called with the error, if any, and QueryLoanResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.loan = function loan(request, callback) {
          return this.rpcCall(loan, $root.ununifi.nftmarket.QueryLoanRequest, $root.ununifi.nftmarket.QueryLoanResponse, request, callback);
        }),
        'name',
        { value: 'Loan' },
      );

      /**
       * Calls Loan.
       * @function loan
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryLoanRequest} request QueryLoanRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryLoanResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#cDPsList}.
       * @memberof ununifi.nftmarket.Query
       * @typedef CDPsListCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryCDPsListResponse} [response] QueryCDPsListResponse
       */

      /**
       * Calls CDPsList.
       * @function cDPsList
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryCDPsListRequest} request QueryCDPsListRequest message or plain object
       * @param {ununifi.nftmarket.Query.CDPsListCallback} callback Node-style callback called with the error, if any, and QueryCDPsListResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.cDPsList = function cDPsList(request, callback) {
          return this.rpcCall(
            cDPsList,
            $root.ununifi.nftmarket.QueryCDPsListRequest,
            $root.ununifi.nftmarket.QueryCDPsListResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CDPsList' },
      );

      /**
       * Calls CDPsList.
       * @function cDPsList
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryCDPsListRequest} request QueryCDPsListRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryCDPsListResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#nftBids}.
       * @memberof ununifi.nftmarket.Query
       * @typedef NftBidsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryNftBidsResponse} [response] QueryNftBidsResponse
       */

      /**
       * Calls NftBids.
       * @function nftBids
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
       * @param {ununifi.nftmarket.Query.NftBidsCallback} callback Node-style callback called with the error, if any, and QueryNftBidsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.nftBids = function nftBids(request, callback) {
          return this.rpcCall(
            nftBids,
            $root.ununifi.nftmarket.QueryNftBidsRequest,
            $root.ununifi.nftmarket.QueryNftBidsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'NftBids' },
      );

      /**
       * Calls NftBids.
       * @function nftBids
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryNftBidsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#bidderBids}.
       * @memberof ununifi.nftmarket.Query
       * @typedef BidderBidsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryBidderBidsResponse} [response] QueryBidderBidsResponse
       */

      /**
       * Calls BidderBids.
       * @function bidderBids
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
       * @param {ununifi.nftmarket.Query.BidderBidsCallback} callback Node-style callback called with the error, if any, and QueryBidderBidsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.bidderBids = function bidderBids(request, callback) {
          return this.rpcCall(
            bidderBids,
            $root.ununifi.nftmarket.QueryBidderBidsRequest,
            $root.ununifi.nftmarket.QueryBidderBidsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'BidderBids' },
      );

      /**
       * Calls BidderBids.
       * @function bidderBids
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryBidderBidsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#paymentStatus}.
       * @memberof ununifi.nftmarket.Query
       * @typedef PaymentStatusCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryPaymentStatusResponse} [response] QueryPaymentStatusResponse
       */

      /**
       * Calls PaymentStatus.
       * @function paymentStatus
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} request QueryPaymentStatusRequest message or plain object
       * @param {ununifi.nftmarket.Query.PaymentStatusCallback} callback Node-style callback called with the error, if any, and QueryPaymentStatusResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.paymentStatus = function paymentStatus(request, callback) {
          return this.rpcCall(
            paymentStatus,
            $root.ununifi.nftmarket.QueryPaymentStatusRequest,
            $root.ununifi.nftmarket.QueryPaymentStatusResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PaymentStatus' },
      );

      /**
       * Calls PaymentStatus.
       * @function paymentStatus
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} request QueryPaymentStatusRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryPaymentStatusResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Query#rewards}.
       * @memberof ununifi.nftmarket.Query
       * @typedef RewardsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.QueryRewardsResponse} [response] QueryRewardsResponse
       */

      /**
       * Calls Rewards.
       * @function rewards
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
       * @param {ununifi.nftmarket.Query.RewardsCallback} callback Node-style callback called with the error, if any, and QueryRewardsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.rewards = function rewards(request, callback) {
          return this.rpcCall(
            rewards,
            $root.ununifi.nftmarket.QueryRewardsRequest,
            $root.ununifi.nftmarket.QueryRewardsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Rewards' },
      );

      /**
       * Calls Rewards.
       * @function rewards
       * @memberof ununifi.nftmarket.Query
       * @instance
       * @param {ununifi.nftmarket.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
       * @returns {Promise<ununifi.nftmarket.QueryRewardsResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    nftmarket.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryParamsRequest) return object;
        return new $root.ununifi.nftmarket.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @static
       * @param {ununifi.nftmarket.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    nftmarket.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryParamsResponse
       * @property {ununifi.nftmarket.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.nftmarket.IParams|null|undefined} params
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftmarket.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftmarket.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftmarket.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryParamsResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmarket.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.nftmarket.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @static
       * @param {ununifi.nftmarket.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftmarket.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    nftmarket.QueryNftListingRequest = (function () {
      /**
       * Properties of a QueryNftListingRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryNftListingRequest
       * @property {string|null} [class_id] QueryNftListingRequest class_id
       * @property {string|null} [nft_id] QueryNftListingRequest nft_id
       */

      /**
       * Constructs a new QueryNftListingRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryNftListingRequest.
       * @implements IQueryNftListingRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryNftListingRequest=} [properties] Properties to set
       */
      function QueryNftListingRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNftListingRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @instance
       */
      QueryNftListingRequest.prototype.class_id = '';

      /**
       * QueryNftListingRequest nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @instance
       */
      QueryNftListingRequest.prototype.nft_id = '';

      /**
       * Encodes the specified QueryNftListingRequest message. Does not implicitly {@link ununifi.nftmarket.QueryNftListingRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @static
       * @param {ununifi.nftmarket.IQueryNftListingRequest} message QueryNftListingRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftListingRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified QueryNftListingRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftListingRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @static
       * @param {ununifi.nftmarket.IQueryNftListingRequest} message QueryNftListingRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftListingRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNftListingRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryNftListingRequest} QueryNftListingRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftListingRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryNftListingRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNftListingRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryNftListingRequest} QueryNftListingRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftListingRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNftListingRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNftListingRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates a QueryNftListingRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryNftListingRequest} QueryNftListingRequest
       */
      QueryNftListingRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryNftListingRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryNftListingRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryNftListingRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @static
       * @param {ununifi.nftmarket.QueryNftListingRequest} message QueryNftListingRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNftListingRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this QueryNftListingRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryNftListingRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNftListingRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNftListingRequest;
    })();

    nftmarket.QueryNftListingResponse = (function () {
      /**
       * Properties of a QueryNftListingResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryNftListingResponse
       * @property {ununifi.nftmarket.INftListing|null} [listing] QueryNftListingResponse listing
       */

      /**
       * Constructs a new QueryNftListingResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryNftListingResponse.
       * @implements IQueryNftListingResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryNftListingResponse=} [properties] Properties to set
       */
      function QueryNftListingResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNftListingResponse listing.
       * @member {ununifi.nftmarket.INftListing|null|undefined} listing
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @instance
       */
      QueryNftListingResponse.prototype.listing = null;

      /**
       * Encodes the specified QueryNftListingResponse message. Does not implicitly {@link ununifi.nftmarket.QueryNftListingResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @static
       * @param {ununifi.nftmarket.IQueryNftListingResponse} message QueryNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftListingResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.listing != null && Object.hasOwnProperty.call(message, 'listing'))
          $root.ununifi.nftmarket.NftListing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftListingResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @static
       * @param {ununifi.nftmarket.IQueryNftListingResponse} message QueryNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNftListingResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryNftListingResponse} QueryNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftListingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryNftListingResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.listing = $root.ununifi.nftmarket.NftListing.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNftListingResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryNftListingResponse} QueryNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNftListingResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNftListingResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.listing != null && message.hasOwnProperty('listing')) {
          let error = $root.ununifi.nftmarket.NftListing.verify(message.listing);
          if (error) return 'listing.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryNftListingResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryNftListingResponse} QueryNftListingResponse
       */
      QueryNftListingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryNftListingResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryNftListingResponse();
        if (object.listing != null) {
          if (typeof object.listing !== 'object') throw TypeError('.ununifi.nftmarket.QueryNftListingResponse.listing: object expected');
          message.listing = $root.ununifi.nftmarket.NftListing.fromObject(object.listing);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryNftListingResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @static
       * @param {ununifi.nftmarket.QueryNftListingResponse} message QueryNftListingResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNftListingResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.listing = null;
        if (message.listing != null && message.hasOwnProperty('listing'))
          object.listing = $root.ununifi.nftmarket.NftListing.toObject(message.listing, options);
        return object;
      };

      /**
       * Converts this QueryNftListingResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryNftListingResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNftListingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNftListingResponse;
    })();

    nftmarket.QueryListedNftsRequest = (function () {
      /**
       * Properties of a QueryListedNftsRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryListedNftsRequest
       * @property {string|null} [owner] QueryListedNftsRequest owner
       */

      /**
       * Constructs a new QueryListedNftsRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryListedNftsRequest.
       * @implements IQueryListedNftsRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryListedNftsRequest=} [properties] Properties to set
       */
      function QueryListedNftsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedNftsRequest owner.
       * @member {string} owner
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @instance
       */
      QueryListedNftsRequest.prototype.owner = '';

      /**
       * Encodes the specified QueryListedNftsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        return writer;
      };

      /**
       * Encodes the specified QueryListedNftsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedNftsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryListedNftsRequest} QueryListedNftsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryListedNftsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedNftsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryListedNftsRequest} QueryListedNftsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedNftsRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedNftsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        return null;
      };

      /**
       * Creates a QueryListedNftsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryListedNftsRequest} QueryListedNftsRequest
       */
      QueryListedNftsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryListedNftsRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryListedNftsRequest();
        if (object.owner != null) message.owner = String(object.owner);
        return message;
      };

      /**
       * Creates a plain object from a QueryListedNftsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @static
       * @param {ununifi.nftmarket.QueryListedNftsRequest} message QueryListedNftsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedNftsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.owner = '';
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        return object;
      };

      /**
       * Converts this QueryListedNftsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryListedNftsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedNftsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedNftsRequest;
    })();

    nftmarket.QueryListedClassesRequest = (function () {
      /**
       * Properties of a QueryListedClassesRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryListedClassesRequest
       * @property {number|null} [nft_limit] QueryListedClassesRequest nft_limit
       */

      /**
       * Constructs a new QueryListedClassesRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryListedClassesRequest.
       * @implements IQueryListedClassesRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryListedClassesRequest=} [properties] Properties to set
       */
      function QueryListedClassesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassesRequest nft_limit.
       * @member {number} nft_limit
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @instance
       */
      QueryListedClassesRequest.prototype.nft_limit = 0;

      /**
       * Encodes the specified QueryListedClassesRequest message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_limit != null && Object.hasOwnProperty.call(message, 'nft_limit'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.nft_limit);
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassesRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryListedClassesRequest} QueryListedClassesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryListedClassesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_limit = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryListedClassesRequest} QueryListedClassesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassesRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassesRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit'))
          if (!$util.isInteger(message.nft_limit)) return 'nft_limit: integer expected';
        return null;
      };

      /**
       * Creates a QueryListedClassesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryListedClassesRequest} QueryListedClassesRequest
       */
      QueryListedClassesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryListedClassesRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryListedClassesRequest();
        if (object.nft_limit != null) message.nft_limit = object.nft_limit | 0;
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @static
       * @param {ununifi.nftmarket.QueryListedClassesRequest} message QueryListedClassesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassesRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.nft_limit = 0;
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit')) object.nft_limit = message.nft_limit;
        return object;
      };

      /**
       * Converts this QueryListedClassesRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryListedClassesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassesRequest;
    })();

    nftmarket.QueryListedClassRequest = (function () {
      /**
       * Properties of a QueryListedClassRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryListedClassRequest
       * @property {string|null} [class_id] QueryListedClassRequest class_id
       * @property {number|null} [nft_limit] QueryListedClassRequest nft_limit
       */

      /**
       * Constructs a new QueryListedClassRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryListedClassRequest.
       * @implements IQueryListedClassRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryListedClassRequest=} [properties] Properties to set
       */
      function QueryListedClassRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @instance
       */
      QueryListedClassRequest.prototype.class_id = '';

      /**
       * QueryListedClassRequest nft_limit.
       * @member {number} nft_limit
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @instance
       */
      QueryListedClassRequest.prototype.nft_limit = 0;

      /**
       * Encodes the specified QueryListedClassRequest message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_limit != null && Object.hasOwnProperty.call(message, 'nft_limit'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nft_limit);
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryListedClassRequest} QueryListedClassRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryListedClassRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_limit = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryListedClassRequest} QueryListedClassRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit'))
          if (!$util.isInteger(message.nft_limit)) return 'nft_limit: integer expected';
        return null;
      };

      /**
       * Creates a QueryListedClassRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryListedClassRequest} QueryListedClassRequest
       */
      QueryListedClassRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryListedClassRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryListedClassRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_limit != null) message.nft_limit = object.nft_limit | 0;
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @static
       * @param {ununifi.nftmarket.QueryListedClassRequest} message QueryListedClassRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_limit = 0;
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit')) object.nft_limit = message.nft_limit;
        return object;
      };

      /**
       * Converts this QueryListedClassRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryListedClassRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassRequest;
    })();

    nftmarket.QueryListedNftsResponse = (function () {
      /**
       * Properties of a QueryListedNftsResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryListedNftsResponse
       * @property {Array.<ununifi.nftmarket.INftListing>|null} [listings] QueryListedNftsResponse listings
       */

      /**
       * Constructs a new QueryListedNftsResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryListedNftsResponse.
       * @implements IQueryListedNftsResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryListedNftsResponse=} [properties] Properties to set
       */
      function QueryListedNftsResponse(properties) {
        this.listings = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedNftsResponse listings.
       * @member {Array.<ununifi.nftmarket.INftListing>} listings
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @instance
       */
      QueryListedNftsResponse.prototype.listings = $util.emptyArray;

      /**
       * Encodes the specified QueryListedNftsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.listings != null && message.listings.length)
          for (let i = 0; i < message.listings.length; ++i)
            $root.ununifi.nftmarket.NftListing.encode(message.listings[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryListedNftsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedNftsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedNftsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryListedNftsResponse} QueryListedNftsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryListedNftsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.listings && message.listings.length)) message.listings = [];
              message.listings.push($root.ununifi.nftmarket.NftListing.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedNftsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryListedNftsResponse} QueryListedNftsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedNftsResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedNftsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.listings != null && message.hasOwnProperty('listings')) {
          if (!Array.isArray(message.listings)) return 'listings: array expected';
          for (let i = 0; i < message.listings.length; ++i) {
            let error = $root.ununifi.nftmarket.NftListing.verify(message.listings[i]);
            if (error) return 'listings.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryListedNftsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryListedNftsResponse} QueryListedNftsResponse
       */
      QueryListedNftsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryListedNftsResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryListedNftsResponse();
        if (object.listings) {
          if (!Array.isArray(object.listings)) throw TypeError('.ununifi.nftmarket.QueryListedNftsResponse.listings: array expected');
          message.listings = [];
          for (let i = 0; i < object.listings.length; ++i) {
            if (typeof object.listings[i] !== 'object')
              throw TypeError('.ununifi.nftmarket.QueryListedNftsResponse.listings: object expected');
            message.listings[i] = $root.ununifi.nftmarket.NftListing.fromObject(object.listings[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryListedNftsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @static
       * @param {ununifi.nftmarket.QueryListedNftsResponse} message QueryListedNftsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedNftsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.listings = [];
        if (message.listings && message.listings.length) {
          object.listings = [];
          for (let j = 0; j < message.listings.length; ++j)
            object.listings[j] = $root.ununifi.nftmarket.NftListing.toObject(message.listings[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryListedNftsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryListedNftsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedNftsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedNftsResponse;
    })();

    nftmarket.QueryListedClassesResponse = (function () {
      /**
       * Properties of a QueryListedClassesResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryListedClassesResponse
       * @property {Array.<ununifi.nftmarket.IQueryListedClassResponse>|null} [classes] QueryListedClassesResponse classes
       */

      /**
       * Constructs a new QueryListedClassesResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryListedClassesResponse.
       * @implements IQueryListedClassesResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryListedClassesResponse=} [properties] Properties to set
       */
      function QueryListedClassesResponse(properties) {
        this.classes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassesResponse classes.
       * @member {Array.<ununifi.nftmarket.IQueryListedClassResponse>} classes
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @instance
       */
      QueryListedClassesResponse.prototype.classes = $util.emptyArray;

      /**
       * Encodes the specified QueryListedClassesResponse message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.classes != null && message.classes.length)
          for (let i = 0; i < message.classes.length; ++i)
            $root.ununifi.nftmarket.QueryListedClassResponse.encode(
              message.classes[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassesResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassesResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassesResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryListedClassesResponse} QueryListedClassesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryListedClassesResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.classes && message.classes.length)) message.classes = [];
              message.classes.push($root.ununifi.nftmarket.QueryListedClassResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassesResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryListedClassesResponse} QueryListedClassesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassesResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassesResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.classes != null && message.hasOwnProperty('classes')) {
          if (!Array.isArray(message.classes)) return 'classes: array expected';
          for (let i = 0; i < message.classes.length; ++i) {
            let error = $root.ununifi.nftmarket.QueryListedClassResponse.verify(message.classes[i]);
            if (error) return 'classes.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryListedClassesResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryListedClassesResponse} QueryListedClassesResponse
       */
      QueryListedClassesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryListedClassesResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryListedClassesResponse();
        if (object.classes) {
          if (!Array.isArray(object.classes)) throw TypeError('.ununifi.nftmarket.QueryListedClassesResponse.classes: array expected');
          message.classes = [];
          for (let i = 0; i < object.classes.length; ++i) {
            if (typeof object.classes[i] !== 'object')
              throw TypeError('.ununifi.nftmarket.QueryListedClassesResponse.classes: object expected');
            message.classes[i] = $root.ununifi.nftmarket.QueryListedClassResponse.fromObject(object.classes[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassesResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @static
       * @param {ununifi.nftmarket.QueryListedClassesResponse} message QueryListedClassesResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassesResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.classes = [];
        if (message.classes && message.classes.length) {
          object.classes = [];
          for (let j = 0; j < message.classes.length; ++j)
            object.classes[j] = $root.ununifi.nftmarket.QueryListedClassResponse.toObject(message.classes[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryListedClassesResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryListedClassesResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassesResponse;
    })();

    nftmarket.QueryListedClassResponse = (function () {
      /**
       * Properties of a QueryListedClassResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryListedClassResponse
       * @property {string|null} [class_id] QueryListedClassResponse class_id
       * @property {string|null} [name] QueryListedClassResponse name
       * @property {string|null} [description] QueryListedClassResponse description
       * @property {string|null} [symbol] QueryListedClassResponse symbol
       * @property {string|null} [uri] QueryListedClassResponse uri
       * @property {string|null} [urihash] QueryListedClassResponse urihash
       * @property {Array.<ununifi.nftmarket.IListedNft>|null} [nfts] QueryListedClassResponse nfts
       * @property {Long|null} [nft_count] QueryListedClassResponse nft_count
       */

      /**
       * Constructs a new QueryListedClassResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryListedClassResponse.
       * @implements IQueryListedClassResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryListedClassResponse=} [properties] Properties to set
       */
      function QueryListedClassResponse(properties) {
        this.nfts = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassResponse class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.class_id = '';

      /**
       * QueryListedClassResponse name.
       * @member {string} name
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.name = '';

      /**
       * QueryListedClassResponse description.
       * @member {string} description
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.description = '';

      /**
       * QueryListedClassResponse symbol.
       * @member {string} symbol
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.symbol = '';

      /**
       * QueryListedClassResponse uri.
       * @member {string} uri
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.uri = '';

      /**
       * QueryListedClassResponse urihash.
       * @member {string} urihash
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.urihash = '';

      /**
       * QueryListedClassResponse nfts.
       * @member {Array.<ununifi.nftmarket.IListedNft>} nfts
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.nfts = $util.emptyArray;

      /**
       * QueryListedClassResponse nft_count.
       * @member {Long} nft_count
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.nft_count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryListedClassResponse message. Does not implicitly {@link ununifi.nftmarket.QueryListedClassResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.description);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.symbol);
        if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.uri);
        if (message.urihash != null && Object.hasOwnProperty.call(message, 'urihash'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.urihash);
        if (message.nfts != null && message.nfts.length)
          for (let i = 0; i < message.nfts.length; ++i)
            $root.ununifi.nftmarket.ListedNft.encode(message.nfts[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.nft_count != null && Object.hasOwnProperty.call(message, 'nft_count'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).uint64(message.nft_count);
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryListedClassResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @static
       * @param {ununifi.nftmarket.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryListedClassResponse} QueryListedClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryListedClassResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.description = reader.string();
              break;
            case 4:
              message.symbol = reader.string();
              break;
            case 5:
              message.uri = reader.string();
              break;
            case 6:
              message.urihash = reader.string();
              break;
            case 7:
              if (!(message.nfts && message.nfts.length)) message.nfts = [];
              message.nfts.push($root.ununifi.nftmarket.ListedNft.decode(reader, reader.uint32()));
              break;
            case 8:
              message.nft_count = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryListedClassResponse} QueryListedClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
        if (message.urihash != null && message.hasOwnProperty('urihash'))
          if (!$util.isString(message.urihash)) return 'urihash: string expected';
        if (message.nfts != null && message.hasOwnProperty('nfts')) {
          if (!Array.isArray(message.nfts)) return 'nfts: array expected';
          for (let i = 0; i < message.nfts.length; ++i) {
            let error = $root.ununifi.nftmarket.ListedNft.verify(message.nfts[i]);
            if (error) return 'nfts.' + error;
          }
        }
        if (message.nft_count != null && message.hasOwnProperty('nft_count'))
          if (
            !$util.isInteger(message.nft_count) &&
            !(message.nft_count && $util.isInteger(message.nft_count.low) && $util.isInteger(message.nft_count.high))
          )
            return 'nft_count: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryListedClassResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryListedClassResponse} QueryListedClassResponse
       */
      QueryListedClassResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryListedClassResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryListedClassResponse();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.uri != null) message.uri = String(object.uri);
        if (object.urihash != null) message.urihash = String(object.urihash);
        if (object.nfts) {
          if (!Array.isArray(object.nfts)) throw TypeError('.ununifi.nftmarket.QueryListedClassResponse.nfts: array expected');
          message.nfts = [];
          for (let i = 0; i < object.nfts.length; ++i) {
            if (typeof object.nfts[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryListedClassResponse.nfts: object expected');
            message.nfts[i] = $root.ununifi.nftmarket.ListedNft.fromObject(object.nfts[i]);
          }
        }
        if (object.nft_count != null)
          if ($util.Long) (message.nft_count = $util.Long.fromValue(object.nft_count)).unsigned = true;
          else if (typeof object.nft_count === 'string') message.nft_count = parseInt(object.nft_count, 10);
          else if (typeof object.nft_count === 'number') message.nft_count = object.nft_count;
          else if (typeof object.nft_count === 'object')
            message.nft_count = new $util.LongBits(object.nft_count.low >>> 0, object.nft_count.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @static
       * @param {ununifi.nftmarket.QueryListedClassResponse} message QueryListedClassResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.nfts = [];
        if (options.defaults) {
          object.class_id = '';
          object.name = '';
          object.description = '';
          object.symbol = '';
          object.uri = '';
          object.urihash = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_count = options.longs === String ? '0' : 0;
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
        if (message.urihash != null && message.hasOwnProperty('urihash')) object.urihash = message.urihash;
        if (message.nfts && message.nfts.length) {
          object.nfts = [];
          for (let j = 0; j < message.nfts.length; ++j)
            object.nfts[j] = $root.ununifi.nftmarket.ListedNft.toObject(message.nfts[j], options);
        }
        if (message.nft_count != null && message.hasOwnProperty('nft_count'))
          if (typeof message.nft_count === 'number')
            object.nft_count = options.longs === String ? String(message.nft_count) : message.nft_count;
          else
            object.nft_count =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_count)
                : options.longs === Number
                ? new $util.LongBits(message.nft_count.low >>> 0, message.nft_count.high >>> 0).toNumber(true)
                : message.nft_count;
        return object;
      };

      /**
       * Converts this QueryListedClassResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryListedClassResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassResponse;
    })();

    nftmarket.QueryLoansRequest = (function () {
      /**
       * Properties of a QueryLoansRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryLoansRequest
       */

      /**
       * Constructs a new QueryLoansRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryLoansRequest.
       * @implements IQueryLoansRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryLoansRequest=} [properties] Properties to set
       */
      function QueryLoansRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryLoansRequest message. Does not implicitly {@link ununifi.nftmarket.QueryLoansRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @static
       * @param {ununifi.nftmarket.IQueryLoansRequest} message QueryLoansRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoansRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryLoansRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoansRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @static
       * @param {ununifi.nftmarket.IQueryLoansRequest} message QueryLoansRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoansRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLoansRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryLoansRequest} QueryLoansRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoansRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryLoansRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLoansRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryLoansRequest} QueryLoansRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoansRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLoansRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLoansRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryLoansRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryLoansRequest} QueryLoansRequest
       */
      QueryLoansRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryLoansRequest) return object;
        return new $root.ununifi.nftmarket.QueryLoansRequest();
      };

      /**
       * Creates a plain object from a QueryLoansRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @static
       * @param {ununifi.nftmarket.QueryLoansRequest} message QueryLoansRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLoansRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryLoansRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryLoansRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLoansRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLoansRequest;
    })();

    nftmarket.QueryLoansResponse = (function () {
      /**
       * Properties of a QueryLoansResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryLoansResponse
       * @property {Array.<ununifi.nftmarket.ILoan>|null} [loans] QueryLoansResponse loans
       */

      /**
       * Constructs a new QueryLoansResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryLoansResponse.
       * @implements IQueryLoansResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryLoansResponse=} [properties] Properties to set
       */
      function QueryLoansResponse(properties) {
        this.loans = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLoansResponse loans.
       * @member {Array.<ununifi.nftmarket.ILoan>} loans
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @instance
       */
      QueryLoansResponse.prototype.loans = $util.emptyArray;

      /**
       * Encodes the specified QueryLoansResponse message. Does not implicitly {@link ununifi.nftmarket.QueryLoansResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @static
       * @param {ununifi.nftmarket.IQueryLoansResponse} message QueryLoansResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoansResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.loans != null && message.loans.length)
          for (let i = 0; i < message.loans.length; ++i)
            $root.ununifi.nftmarket.Loan.encode(message.loans[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLoansResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoansResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @static
       * @param {ununifi.nftmarket.IQueryLoansResponse} message QueryLoansResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoansResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLoansResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryLoansResponse} QueryLoansResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoansResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryLoansResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.loans && message.loans.length)) message.loans = [];
              message.loans.push($root.ununifi.nftmarket.Loan.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLoansResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryLoansResponse} QueryLoansResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoansResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLoansResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLoansResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.loans != null && message.hasOwnProperty('loans')) {
          if (!Array.isArray(message.loans)) return 'loans: array expected';
          for (let i = 0; i < message.loans.length; ++i) {
            let error = $root.ununifi.nftmarket.Loan.verify(message.loans[i]);
            if (error) return 'loans.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryLoansResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryLoansResponse} QueryLoansResponse
       */
      QueryLoansResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryLoansResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryLoansResponse();
        if (object.loans) {
          if (!Array.isArray(object.loans)) throw TypeError('.ununifi.nftmarket.QueryLoansResponse.loans: array expected');
          message.loans = [];
          for (let i = 0; i < object.loans.length; ++i) {
            if (typeof object.loans[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryLoansResponse.loans: object expected');
            message.loans[i] = $root.ununifi.nftmarket.Loan.fromObject(object.loans[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLoansResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @static
       * @param {ununifi.nftmarket.QueryLoansResponse} message QueryLoansResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLoansResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.loans = [];
        if (message.loans && message.loans.length) {
          object.loans = [];
          for (let j = 0; j < message.loans.length; ++j) object.loans[j] = $root.ununifi.nftmarket.Loan.toObject(message.loans[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryLoansResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryLoansResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLoansResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLoansResponse;
    })();

    nftmarket.QueryLoanRequest = (function () {
      /**
       * Properties of a QueryLoanRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryLoanRequest
       * @property {string|null} [class_id] QueryLoanRequest class_id
       * @property {string|null} [nft_id] QueryLoanRequest nft_id
       */

      /**
       * Constructs a new QueryLoanRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryLoanRequest.
       * @implements IQueryLoanRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryLoanRequest=} [properties] Properties to set
       */
      function QueryLoanRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLoanRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @instance
       */
      QueryLoanRequest.prototype.class_id = '';

      /**
       * QueryLoanRequest nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @instance
       */
      QueryLoanRequest.prototype.nft_id = '';

      /**
       * Encodes the specified QueryLoanRequest message. Does not implicitly {@link ununifi.nftmarket.QueryLoanRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @static
       * @param {ununifi.nftmarket.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified QueryLoanRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoanRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @static
       * @param {ununifi.nftmarket.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLoanRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryLoanRequest} QueryLoanRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryLoanRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLoanRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryLoanRequest} QueryLoanRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLoanRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLoanRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates a QueryLoanRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryLoanRequest} QueryLoanRequest
       */
      QueryLoanRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryLoanRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryLoanRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryLoanRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @static
       * @param {ununifi.nftmarket.QueryLoanRequest} message QueryLoanRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLoanRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this QueryLoanRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryLoanRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLoanRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLoanRequest;
    })();

    nftmarket.QueryLoanResponse = (function () {
      /**
       * Properties of a QueryLoanResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryLoanResponse
       * @property {ununifi.nftmarket.ILoan|null} [loan] QueryLoanResponse loan
       * @property {string|null} [borrowing_limit] QueryLoanResponse borrowing_limit
       */

      /**
       * Constructs a new QueryLoanResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryLoanResponse.
       * @implements IQueryLoanResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryLoanResponse=} [properties] Properties to set
       */
      function QueryLoanResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLoanResponse loan.
       * @member {ununifi.nftmarket.ILoan|null|undefined} loan
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @instance
       */
      QueryLoanResponse.prototype.loan = null;

      /**
       * QueryLoanResponse borrowing_limit.
       * @member {string} borrowing_limit
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @instance
       */
      QueryLoanResponse.prototype.borrowing_limit = '';

      /**
       * Encodes the specified QueryLoanResponse message. Does not implicitly {@link ununifi.nftmarket.QueryLoanResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @static
       * @param {ununifi.nftmarket.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.loan != null && Object.hasOwnProperty.call(message, 'loan'))
          $root.ununifi.nftmarket.Loan.encode(message.loan, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.borrowing_limit != null && Object.hasOwnProperty.call(message, 'borrowing_limit'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.borrowing_limit);
        return writer;
      };

      /**
       * Encodes the specified QueryLoanResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryLoanResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @static
       * @param {ununifi.nftmarket.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLoanResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryLoanResponse} QueryLoanResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryLoanResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.loan = $root.ununifi.nftmarket.Loan.decode(reader, reader.uint32());
              break;
            case 2:
              message.borrowing_limit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLoanResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryLoanResponse} QueryLoanResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLoanResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLoanResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.loan != null && message.hasOwnProperty('loan')) {
          let error = $root.ununifi.nftmarket.Loan.verify(message.loan);
          if (error) return 'loan.' + error;
        }
        if (message.borrowing_limit != null && message.hasOwnProperty('borrowing_limit'))
          if (!$util.isString(message.borrowing_limit)) return 'borrowing_limit: string expected';
        return null;
      };

      /**
       * Creates a QueryLoanResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryLoanResponse} QueryLoanResponse
       */
      QueryLoanResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryLoanResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryLoanResponse();
        if (object.loan != null) {
          if (typeof object.loan !== 'object') throw TypeError('.ununifi.nftmarket.QueryLoanResponse.loan: object expected');
          message.loan = $root.ununifi.nftmarket.Loan.fromObject(object.loan);
        }
        if (object.borrowing_limit != null) message.borrowing_limit = String(object.borrowing_limit);
        return message;
      };

      /**
       * Creates a plain object from a QueryLoanResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @static
       * @param {ununifi.nftmarket.QueryLoanResponse} message QueryLoanResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLoanResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.loan = null;
          object.borrowing_limit = '';
        }
        if (message.loan != null && message.hasOwnProperty('loan'))
          object.loan = $root.ununifi.nftmarket.Loan.toObject(message.loan, options);
        if (message.borrowing_limit != null && message.hasOwnProperty('borrowing_limit')) object.borrowing_limit = message.borrowing_limit;
        return object;
      };

      /**
       * Converts this QueryLoanResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryLoanResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLoanResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLoanResponse;
    })();

    nftmarket.QueryCDPsListRequest = (function () {
      /**
       * Properties of a QueryCDPsListRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryCDPsListRequest
       */

      /**
       * Constructs a new QueryCDPsListRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryCDPsListRequest.
       * @implements IQueryCDPsListRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryCDPsListRequest=} [properties] Properties to set
       */
      function QueryCDPsListRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryCDPsListRequest message. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @static
       * @param {ununifi.nftmarket.IQueryCDPsListRequest} message QueryCDPsListRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCDPsListRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryCDPsListRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @static
       * @param {ununifi.nftmarket.IQueryCDPsListRequest} message QueryCDPsListRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCDPsListRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryCDPsListRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryCDPsListRequest} QueryCDPsListRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCDPsListRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryCDPsListRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryCDPsListRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryCDPsListRequest} QueryCDPsListRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCDPsListRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryCDPsListRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryCDPsListRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryCDPsListRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryCDPsListRequest} QueryCDPsListRequest
       */
      QueryCDPsListRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryCDPsListRequest) return object;
        return new $root.ununifi.nftmarket.QueryCDPsListRequest();
      };

      /**
       * Creates a plain object from a QueryCDPsListRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @static
       * @param {ununifi.nftmarket.QueryCDPsListRequest} message QueryCDPsListRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryCDPsListRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryCDPsListRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryCDPsListRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryCDPsListRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryCDPsListRequest;
    })();

    nftmarket.QueryCDPsListResponse = (function () {
      /**
       * Properties of a QueryCDPsListResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryCDPsListResponse
       */

      /**
       * Constructs a new QueryCDPsListResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryCDPsListResponse.
       * @implements IQueryCDPsListResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryCDPsListResponse=} [properties] Properties to set
       */
      function QueryCDPsListResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryCDPsListResponse message. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @static
       * @param {ununifi.nftmarket.IQueryCDPsListResponse} message QueryCDPsListResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCDPsListResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryCDPsListResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryCDPsListResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @static
       * @param {ununifi.nftmarket.IQueryCDPsListResponse} message QueryCDPsListResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCDPsListResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryCDPsListResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryCDPsListResponse} QueryCDPsListResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCDPsListResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryCDPsListResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryCDPsListResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryCDPsListResponse} QueryCDPsListResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCDPsListResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryCDPsListResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryCDPsListResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryCDPsListResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryCDPsListResponse} QueryCDPsListResponse
       */
      QueryCDPsListResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryCDPsListResponse) return object;
        return new $root.ununifi.nftmarket.QueryCDPsListResponse();
      };

      /**
       * Creates a plain object from a QueryCDPsListResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @static
       * @param {ununifi.nftmarket.QueryCDPsListResponse} message QueryCDPsListResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryCDPsListResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryCDPsListResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryCDPsListResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryCDPsListResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryCDPsListResponse;
    })();

    nftmarket.QueryNftBidsRequest = (function () {
      /**
       * Properties of a QueryNftBidsRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryNftBidsRequest
       * @property {string|null} [class_id] QueryNftBidsRequest class_id
       * @property {string|null} [nft_id] QueryNftBidsRequest nft_id
       */

      /**
       * Constructs a new QueryNftBidsRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryNftBidsRequest.
       * @implements IQueryNftBidsRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryNftBidsRequest=} [properties] Properties to set
       */
      function QueryNftBidsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNftBidsRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @instance
       */
      QueryNftBidsRequest.prototype.class_id = '';

      /**
       * QueryNftBidsRequest nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @instance
       */
      QueryNftBidsRequest.prototype.nft_id = '';

      /**
       * Encodes the specified QueryNftBidsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified QueryNftBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNftBidsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryNftBidsRequest} QueryNftBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryNftBidsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNftBidsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryNftBidsRequest} QueryNftBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNftBidsRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNftBidsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates a QueryNftBidsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryNftBidsRequest} QueryNftBidsRequest
       */
      QueryNftBidsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryNftBidsRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryNftBidsRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryNftBidsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @static
       * @param {ununifi.nftmarket.QueryNftBidsRequest} message QueryNftBidsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNftBidsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this QueryNftBidsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryNftBidsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNftBidsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNftBidsRequest;
    })();

    nftmarket.QueryNftBidsResponse = (function () {
      /**
       * Properties of a QueryNftBidsResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryNftBidsResponse
       * @property {Array.<ununifi.nftmarket.INftBid>|null} [bids] QueryNftBidsResponse bids
       */

      /**
       * Constructs a new QueryNftBidsResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryNftBidsResponse.
       * @implements IQueryNftBidsResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryNftBidsResponse=} [properties] Properties to set
       */
      function QueryNftBidsResponse(properties) {
        this.bids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNftBidsResponse bids.
       * @member {Array.<ununifi.nftmarket.INftBid>} bids
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @instance
       */
      QueryNftBidsResponse.prototype.bids = $util.emptyArray;

      /**
       * Encodes the specified QueryNftBidsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bids != null && message.bids.length)
          for (let i = 0; i < message.bids.length; ++i)
            $root.ununifi.nftmarket.NftBid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryNftBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryNftBidsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNftBidsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryNftBidsResponse} QueryNftBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryNftBidsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.bids && message.bids.length)) message.bids = [];
              message.bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNftBidsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryNftBidsResponse} QueryNftBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNftBidsResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNftBidsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bids != null && message.hasOwnProperty('bids')) {
          if (!Array.isArray(message.bids)) return 'bids: array expected';
          for (let i = 0; i < message.bids.length; ++i) {
            let error = $root.ununifi.nftmarket.NftBid.verify(message.bids[i]);
            if (error) return 'bids.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryNftBidsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryNftBidsResponse} QueryNftBidsResponse
       */
      QueryNftBidsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryNftBidsResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryNftBidsResponse();
        if (object.bids) {
          if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftmarket.QueryNftBidsResponse.bids: array expected');
          message.bids = [];
          for (let i = 0; i < object.bids.length; ++i) {
            if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryNftBidsResponse.bids: object expected');
            message.bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.bids[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryNftBidsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @static
       * @param {ununifi.nftmarket.QueryNftBidsResponse} message QueryNftBidsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNftBidsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.bids = [];
        if (message.bids && message.bids.length) {
          object.bids = [];
          for (let j = 0; j < message.bids.length; ++j) object.bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.bids[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryNftBidsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryNftBidsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNftBidsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNftBidsResponse;
    })();

    nftmarket.QueryPaymentStatusRequest = (function () {
      /**
       * Properties of a QueryPaymentStatusRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryPaymentStatusRequest
       * @property {string|null} [class_id] QueryPaymentStatusRequest class_id
       * @property {string|null} [nft_id] QueryPaymentStatusRequest nft_id
       * @property {string|null} [bidder] QueryPaymentStatusRequest bidder
       */

      /**
       * Constructs a new QueryPaymentStatusRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryPaymentStatusRequest.
       * @implements IQueryPaymentStatusRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryPaymentStatusRequest=} [properties] Properties to set
       */
      function QueryPaymentStatusRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPaymentStatusRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @instance
       */
      QueryPaymentStatusRequest.prototype.class_id = '';

      /**
       * QueryPaymentStatusRequest nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @instance
       */
      QueryPaymentStatusRequest.prototype.nft_id = '';

      /**
       * QueryPaymentStatusRequest bidder.
       * @member {string} bidder
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @instance
       */
      QueryPaymentStatusRequest.prototype.bidder = '';

      /**
       * Encodes the specified QueryPaymentStatusRequest message. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @static
       * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} message QueryPaymentStatusRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPaymentStatusRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.bidder);
        return writer;
      };

      /**
       * Encodes the specified QueryPaymentStatusRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @static
       * @param {ununifi.nftmarket.IQueryPaymentStatusRequest} message QueryPaymentStatusRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPaymentStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPaymentStatusRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryPaymentStatusRequest} QueryPaymentStatusRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPaymentStatusRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryPaymentStatusRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            case 3:
              message.bidder = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPaymentStatusRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryPaymentStatusRequest} QueryPaymentStatusRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPaymentStatusRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPaymentStatusRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPaymentStatusRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        return null;
      };

      /**
       * Creates a QueryPaymentStatusRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryPaymentStatusRequest} QueryPaymentStatusRequest
       */
      QueryPaymentStatusRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryPaymentStatusRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryPaymentStatusRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        if (object.bidder != null) message.bidder = String(object.bidder);
        return message;
      };

      /**
       * Creates a plain object from a QueryPaymentStatusRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @static
       * @param {ununifi.nftmarket.QueryPaymentStatusRequest} message QueryPaymentStatusRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPaymentStatusRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
          object.bidder = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        return object;
      };

      /**
       * Converts this QueryPaymentStatusRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryPaymentStatusRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPaymentStatusRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPaymentStatusRequest;
    })();

    nftmarket.QueryPaymentStatusResponse = (function () {
      /**
       * Properties of a QueryPaymentStatusResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryPaymentStatusResponse
       * @property {ununifi.nftmarket.IPaymentStatus|null} [paymentStatus] QueryPaymentStatusResponse paymentStatus
       */

      /**
       * Constructs a new QueryPaymentStatusResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryPaymentStatusResponse.
       * @implements IQueryPaymentStatusResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryPaymentStatusResponse=} [properties] Properties to set
       */
      function QueryPaymentStatusResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPaymentStatusResponse paymentStatus.
       * @member {ununifi.nftmarket.IPaymentStatus|null|undefined} paymentStatus
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @instance
       */
      QueryPaymentStatusResponse.prototype.paymentStatus = null;

      /**
       * Encodes the specified QueryPaymentStatusResponse message. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @static
       * @param {ununifi.nftmarket.IQueryPaymentStatusResponse} message QueryPaymentStatusResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPaymentStatusResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.paymentStatus != null && Object.hasOwnProperty.call(message, 'paymentStatus'))
          $root.ununifi.nftmarket.PaymentStatus.encode(message.paymentStatus, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryPaymentStatusResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryPaymentStatusResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @static
       * @param {ununifi.nftmarket.IQueryPaymentStatusResponse} message QueryPaymentStatusResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPaymentStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPaymentStatusResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryPaymentStatusResponse} QueryPaymentStatusResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPaymentStatusResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryPaymentStatusResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paymentStatus = $root.ununifi.nftmarket.PaymentStatus.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPaymentStatusResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryPaymentStatusResponse} QueryPaymentStatusResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPaymentStatusResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPaymentStatusResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPaymentStatusResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.paymentStatus != null && message.hasOwnProperty('paymentStatus')) {
          let error = $root.ununifi.nftmarket.PaymentStatus.verify(message.paymentStatus);
          if (error) return 'paymentStatus.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryPaymentStatusResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryPaymentStatusResponse} QueryPaymentStatusResponse
       */
      QueryPaymentStatusResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryPaymentStatusResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryPaymentStatusResponse();
        if (object.paymentStatus != null) {
          if (typeof object.paymentStatus !== 'object')
            throw TypeError('.ununifi.nftmarket.QueryPaymentStatusResponse.paymentStatus: object expected');
          message.paymentStatus = $root.ununifi.nftmarket.PaymentStatus.fromObject(object.paymentStatus);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryPaymentStatusResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @static
       * @param {ununifi.nftmarket.QueryPaymentStatusResponse} message QueryPaymentStatusResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPaymentStatusResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.paymentStatus = null;
        if (message.paymentStatus != null && message.hasOwnProperty('paymentStatus'))
          object.paymentStatus = $root.ununifi.nftmarket.PaymentStatus.toObject(message.paymentStatus, options);
        return object;
      };

      /**
       * Converts this QueryPaymentStatusResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryPaymentStatusResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPaymentStatusResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPaymentStatusResponse;
    })();

    nftmarket.QueryBidderBidsRequest = (function () {
      /**
       * Properties of a QueryBidderBidsRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryBidderBidsRequest
       * @property {string|null} [bidder] QueryBidderBidsRequest bidder
       */

      /**
       * Constructs a new QueryBidderBidsRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryBidderBidsRequest.
       * @implements IQueryBidderBidsRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryBidderBidsRequest=} [properties] Properties to set
       */
      function QueryBidderBidsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBidderBidsRequest bidder.
       * @member {string} bidder
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @instance
       */
      QueryBidderBidsRequest.prototype.bidder = '';

      /**
       * Encodes the specified QueryBidderBidsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        return writer;
      };

      /**
       * Encodes the specified QueryBidderBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBidderBidsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryBidderBidsRequest} QueryBidderBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryBidderBidsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBidderBidsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryBidderBidsRequest} QueryBidderBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBidderBidsRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBidderBidsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        return null;
      };

      /**
       * Creates a QueryBidderBidsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryBidderBidsRequest} QueryBidderBidsRequest
       */
      QueryBidderBidsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryBidderBidsRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryBidderBidsRequest();
        if (object.bidder != null) message.bidder = String(object.bidder);
        return message;
      };

      /**
       * Creates a plain object from a QueryBidderBidsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @static
       * @param {ununifi.nftmarket.QueryBidderBidsRequest} message QueryBidderBidsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBidderBidsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.bidder = '';
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        return object;
      };

      /**
       * Converts this QueryBidderBidsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryBidderBidsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBidderBidsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBidderBidsRequest;
    })();

    nftmarket.QueryBidderBidsResponse = (function () {
      /**
       * Properties of a QueryBidderBidsResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryBidderBidsResponse
       * @property {Array.<ununifi.nftmarket.INftBid>|null} [bids] QueryBidderBidsResponse bids
       */

      /**
       * Constructs a new QueryBidderBidsResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryBidderBidsResponse.
       * @implements IQueryBidderBidsResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryBidderBidsResponse=} [properties] Properties to set
       */
      function QueryBidderBidsResponse(properties) {
        this.bids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBidderBidsResponse bids.
       * @member {Array.<ununifi.nftmarket.INftBid>} bids
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @instance
       */
      QueryBidderBidsResponse.prototype.bids = $util.emptyArray;

      /**
       * Encodes the specified QueryBidderBidsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bids != null && message.bids.length)
          for (let i = 0; i < message.bids.length; ++i)
            $root.ununifi.nftmarket.NftBid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryBidderBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryBidderBidsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBidderBidsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryBidderBidsResponse} QueryBidderBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryBidderBidsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.bids && message.bids.length)) message.bids = [];
              message.bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBidderBidsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryBidderBidsResponse} QueryBidderBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBidderBidsResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBidderBidsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bids != null && message.hasOwnProperty('bids')) {
          if (!Array.isArray(message.bids)) return 'bids: array expected';
          for (let i = 0; i < message.bids.length; ++i) {
            let error = $root.ununifi.nftmarket.NftBid.verify(message.bids[i]);
            if (error) return 'bids.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryBidderBidsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryBidderBidsResponse} QueryBidderBidsResponse
       */
      QueryBidderBidsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryBidderBidsResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryBidderBidsResponse();
        if (object.bids) {
          if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftmarket.QueryBidderBidsResponse.bids: array expected');
          message.bids = [];
          for (let i = 0; i < object.bids.length; ++i) {
            if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryBidderBidsResponse.bids: object expected');
            message.bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.bids[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryBidderBidsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @static
       * @param {ununifi.nftmarket.QueryBidderBidsResponse} message QueryBidderBidsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBidderBidsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.bids = [];
        if (message.bids && message.bids.length) {
          object.bids = [];
          for (let j = 0; j < message.bids.length; ++j) object.bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.bids[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryBidderBidsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryBidderBidsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBidderBidsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBidderBidsResponse;
    })();

    nftmarket.QueryRewardsRequest = (function () {
      /**
       * Properties of a QueryRewardsRequest.
       * @memberof ununifi.nftmarket
       * @interface IQueryRewardsRequest
       * @property {Long|null} [address] QueryRewardsRequest address
       */

      /**
       * Constructs a new QueryRewardsRequest.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryRewardsRequest.
       * @implements IQueryRewardsRequest
       * @constructor
       * @param {ununifi.nftmarket.IQueryRewardsRequest=} [properties] Properties to set
       */
      function QueryRewardsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRewardsRequest address.
       * @member {Long} address
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @instance
       */
      QueryRewardsRequest.prototype.address = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryRewardsRequest message. Does not implicitly {@link ununifi.nftmarket.QueryRewardsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryRewardsRequest message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryRewardsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @static
       * @param {ununifi.nftmarket.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRewardsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryRewardsRequest} QueryRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryRewardsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRewardsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryRewardsRequest} QueryRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRewardsRequest message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRewardsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (
            !$util.isInteger(message.address) &&
            !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high))
          )
            return 'address: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryRewardsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryRewardsRequest} QueryRewardsRequest
       */
      QueryRewardsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryRewardsRequest) return object;
        let message = new $root.ununifi.nftmarket.QueryRewardsRequest();
        if (object.address != null)
          if ($util.Long) (message.address = $util.Long.fromValue(object.address)).unsigned = true;
          else if (typeof object.address === 'string') message.address = parseInt(object.address, 10);
          else if (typeof object.address === 'number') message.address = object.address;
          else if (typeof object.address === 'object')
            message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryRewardsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @static
       * @param {ununifi.nftmarket.QueryRewardsRequest} message QueryRewardsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRewardsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.address = options.longs === String ? '0' : 0;
        if (message.address != null && message.hasOwnProperty('address'))
          if (typeof message.address === 'number') object.address = options.longs === String ? String(message.address) : message.address;
          else
            object.address =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.address)
                : options.longs === Number
                ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true)
                : message.address;
        return object;
      };

      /**
       * Converts this QueryRewardsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryRewardsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRewardsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRewardsRequest;
    })();

    nftmarket.QueryRewardsResponse = (function () {
      /**
       * Properties of a QueryRewardsResponse.
       * @memberof ununifi.nftmarket
       * @interface IQueryRewardsResponse
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] QueryRewardsResponse rewards
       */

      /**
       * Constructs a new QueryRewardsResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a QueryRewardsResponse.
       * @implements IQueryRewardsResponse
       * @constructor
       * @param {ununifi.nftmarket.IQueryRewardsResponse=} [properties] Properties to set
       */
      function QueryRewardsResponse(properties) {
        this.rewards = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRewardsResponse rewards.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @instance
       */
      QueryRewardsResponse.prototype.rewards = $util.emptyArray;

      /**
       * Encodes the specified QueryRewardsResponse message. Does not implicitly {@link ununifi.nftmarket.QueryRewardsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.rewards != null && message.rewards.length)
          for (let i = 0; i < message.rewards.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryRewardsResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.QueryRewardsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @static
       * @param {ununifi.nftmarket.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRewardsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.QueryRewardsResponse} QueryRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.QueryRewardsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.rewards && message.rewards.length)) message.rewards = [];
              message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRewardsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.QueryRewardsResponse} QueryRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRewardsResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRewardsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.rewards != null && message.hasOwnProperty('rewards')) {
          if (!Array.isArray(message.rewards)) return 'rewards: array expected';
          for (let i = 0; i < message.rewards.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
            if (error) return 'rewards.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryRewardsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.QueryRewardsResponse} QueryRewardsResponse
       */
      QueryRewardsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.QueryRewardsResponse) return object;
        let message = new $root.ununifi.nftmarket.QueryRewardsResponse();
        if (object.rewards) {
          if (!Array.isArray(object.rewards)) throw TypeError('.ununifi.nftmarket.QueryRewardsResponse.rewards: array expected');
          message.rewards = [];
          for (let i = 0; i < object.rewards.length; ++i) {
            if (typeof object.rewards[i] !== 'object') throw TypeError('.ununifi.nftmarket.QueryRewardsResponse.rewards: object expected');
            message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryRewardsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @static
       * @param {ununifi.nftmarket.QueryRewardsResponse} message QueryRewardsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRewardsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rewards = [];
        if (message.rewards && message.rewards.length) {
          object.rewards = [];
          for (let j = 0; j < message.rewards.length; ++j)
            object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryRewardsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.QueryRewardsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRewardsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRewardsResponse;
    })();

    /**
     * ListingType enum.
     * @name ununifi.nftmarket.ListingType
     * @enum {number}
     * @property {number} DIRECT_ASSET_BORROW=0 DIRECT_ASSET_BORROW value
     * @property {number} SYNTHETIC_ASSET_CREATION=1 SYNTHETIC_ASSET_CREATION value
     * @property {number} LATE_SHIPPING=2 LATE_SHIPPING value
     */
    nftmarket.ListingType = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'DIRECT_ASSET_BORROW')] = 0;
      values[(valuesById[1] = 'SYNTHETIC_ASSET_CREATION')] = 1;
      values[(valuesById[2] = 'LATE_SHIPPING')] = 2;
      return values;
    })();

    /**
     * ListingState enum.
     * @name ununifi.nftmarket.ListingState
     * @enum {number}
     * @property {number} LISTING=0 LISTING value
     * @property {number} BIDDING=1 BIDDING value
     * @property {number} SELLING_DECISION=2 SELLING_DECISION value
     * @property {number} LIQUIDATION=3 LIQUIDATION value
     * @property {number} END_LISTING=4 END_LISTING value
     * @property {number} SUCCESSFUL_BID=5 SUCCESSFUL_BID value
     */
    nftmarket.ListingState = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'LISTING')] = 0;
      values[(valuesById[1] = 'BIDDING')] = 1;
      values[(valuesById[2] = 'SELLING_DECISION')] = 2;
      values[(valuesById[3] = 'LIQUIDATION')] = 3;
      values[(valuesById[4] = 'END_LISTING')] = 4;
      values[(valuesById[5] = 'SUCCESSFUL_BID')] = 5;
      return values;
    })();

    nftmarket.NftIdentifier = (function () {
      /**
       * Properties of a NftIdentifier.
       * @memberof ununifi.nftmarket
       * @interface INftIdentifier
       * @property {string|null} [class_id] NftIdentifier class_id
       * @property {string|null} [nft_id] NftIdentifier nft_id
       */

      /**
       * Constructs a new NftIdentifier.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a NftIdentifier.
       * @implements INftIdentifier
       * @constructor
       * @param {ununifi.nftmarket.INftIdentifier=} [properties] Properties to set
       */
      function NftIdentifier(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * NftIdentifier class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.NftIdentifier
       * @instance
       */
      NftIdentifier.prototype.class_id = '';

      /**
       * NftIdentifier nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.NftIdentifier
       * @instance
       */
      NftIdentifier.prototype.nft_id = '';

      /**
       * Encodes the specified NftIdentifier message. Does not implicitly {@link ununifi.nftmarket.NftIdentifier.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.NftIdentifier
       * @static
       * @param {ununifi.nftmarket.INftIdentifier} message NftIdentifier message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftIdentifier.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified NftIdentifier message, length delimited. Does not implicitly {@link ununifi.nftmarket.NftIdentifier.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.NftIdentifier
       * @static
       * @param {ununifi.nftmarket.INftIdentifier} message NftIdentifier message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a NftIdentifier message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.NftIdentifier
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.NftIdentifier} NftIdentifier
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftIdentifier.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.NftIdentifier();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a NftIdentifier message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.NftIdentifier
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.NftIdentifier} NftIdentifier
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftIdentifier.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a NftIdentifier message.
       * @function verify
       * @memberof ununifi.nftmarket.NftIdentifier
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      NftIdentifier.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates a NftIdentifier message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.NftIdentifier
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.NftIdentifier} NftIdentifier
       */
      NftIdentifier.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.NftIdentifier) return object;
        let message = new $root.ununifi.nftmarket.NftIdentifier();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from a NftIdentifier message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.NftIdentifier
       * @static
       * @param {ununifi.nftmarket.NftIdentifier} message NftIdentifier
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      NftIdentifier.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this NftIdentifier to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.NftIdentifier
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      NftIdentifier.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return NftIdentifier;
    })();

    nftmarket.Loan = (function () {
      /**
       * Properties of a Loan.
       * @memberof ununifi.nftmarket
       * @interface ILoan
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] Loan nft_id
       * @property {cosmos.base.v1beta1.ICoin|null} [loan] Loan loan
       */

      /**
       * Constructs a new Loan.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a Loan.
       * @implements ILoan
       * @constructor
       * @param {ununifi.nftmarket.ILoan=} [properties] Properties to set
       */
      function Loan(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Loan nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.Loan
       * @instance
       */
      Loan.prototype.nft_id = null;

      /**
       * Loan loan.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} loan
       * @memberof ununifi.nftmarket.Loan
       * @instance
       */
      Loan.prototype.loan = null;

      /**
       * Encodes the specified Loan message. Does not implicitly {@link ununifi.nftmarket.Loan.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.Loan
       * @static
       * @param {ununifi.nftmarket.ILoan} message Loan message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Loan.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.loan != null && Object.hasOwnProperty.call(message, 'loan'))
          $root.cosmos.base.v1beta1.Coin.encode(message.loan, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Loan message, length delimited. Does not implicitly {@link ununifi.nftmarket.Loan.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.Loan
       * @static
       * @param {ununifi.nftmarket.ILoan} message Loan message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Loan.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Loan message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.Loan
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.Loan} Loan
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Loan.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.Loan();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 2:
              message.loan = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Loan message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.Loan
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.Loan} Loan
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Loan.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Loan message.
       * @function verify
       * @memberof ununifi.nftmarket.Loan
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Loan.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.loan != null && message.hasOwnProperty('loan')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.loan);
          if (error) return 'loan.' + error;
        }
        return null;
      };

      /**
       * Creates a Loan message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.Loan
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.Loan} Loan
       */
      Loan.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.Loan) return object;
        let message = new $root.ununifi.nftmarket.Loan();
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.Loan.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        if (object.loan != null) {
          if (typeof object.loan !== 'object') throw TypeError('.ununifi.nftmarket.Loan.loan: object expected');
          message.loan = $root.cosmos.base.v1beta1.Coin.fromObject(object.loan);
        }
        return message;
      };

      /**
       * Creates a plain object from a Loan message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.Loan
       * @static
       * @param {ununifi.nftmarket.Loan} message Loan
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Loan.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.nft_id = null;
          object.loan = null;
        }
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.loan != null && message.hasOwnProperty('loan'))
          object.loan = $root.cosmos.base.v1beta1.Coin.toObject(message.loan, options);
        return object;
      };

      /**
       * Converts this Loan to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.Loan
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Loan.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Loan;
    })();

    nftmarket.ListedClass = (function () {
      /**
       * Properties of a ListedClass.
       * @memberof ununifi.nftmarket
       * @interface IListedClass
       * @property {string|null} [class_id] ListedClass class_id
       * @property {Array.<string>|null} [nft_ids] ListedClass nft_ids
       */

      /**
       * Constructs a new ListedClass.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a ListedClass.
       * @implements IListedClass
       * @constructor
       * @param {ununifi.nftmarket.IListedClass=} [properties] Properties to set
       */
      function ListedClass(properties) {
        this.nft_ids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ListedClass class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.ListedClass
       * @instance
       */
      ListedClass.prototype.class_id = '';

      /**
       * ListedClass nft_ids.
       * @member {Array.<string>} nft_ids
       * @memberof ununifi.nftmarket.ListedClass
       * @instance
       */
      ListedClass.prototype.nft_ids = $util.emptyArray;

      /**
       * Encodes the specified ListedClass message. Does not implicitly {@link ununifi.nftmarket.ListedClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.ListedClass
       * @static
       * @param {ununifi.nftmarket.IListedClass} message ListedClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_ids != null && message.nft_ids.length)
          for (let i = 0; i < message.nft_ids.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_ids[i]);
        return writer;
      };

      /**
       * Encodes the specified ListedClass message, length delimited. Does not implicitly {@link ununifi.nftmarket.ListedClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.ListedClass
       * @static
       * @param {ununifi.nftmarket.IListedClass} message ListedClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ListedClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.ListedClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.ListedClass} ListedClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.ListedClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              if (!(message.nft_ids && message.nft_ids.length)) message.nft_ids = [];
              message.nft_ids.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ListedClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.ListedClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.ListedClass} ListedClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ListedClass message.
       * @function verify
       * @memberof ununifi.nftmarket.ListedClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ListedClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_ids != null && message.hasOwnProperty('nft_ids')) {
          if (!Array.isArray(message.nft_ids)) return 'nft_ids: array expected';
          for (let i = 0; i < message.nft_ids.length; ++i) if (!$util.isString(message.nft_ids[i])) return 'nft_ids: string[] expected';
        }
        return null;
      };

      /**
       * Creates a ListedClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.ListedClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.ListedClass} ListedClass
       */
      ListedClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.ListedClass) return object;
        let message = new $root.ununifi.nftmarket.ListedClass();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_ids) {
          if (!Array.isArray(object.nft_ids)) throw TypeError('.ununifi.nftmarket.ListedClass.nft_ids: array expected');
          message.nft_ids = [];
          for (let i = 0; i < object.nft_ids.length; ++i) message.nft_ids[i] = String(object.nft_ids[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a ListedClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.ListedClass
       * @static
       * @param {ununifi.nftmarket.ListedClass} message ListedClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ListedClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.nft_ids = [];
        if (options.defaults) object.class_id = '';
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_ids && message.nft_ids.length) {
          object.nft_ids = [];
          for (let j = 0; j < message.nft_ids.length; ++j) object.nft_ids[j] = message.nft_ids[j];
        }
        return object;
      };

      /**
       * Converts this ListedClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.ListedClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ListedClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ListedClass;
    })();

    nftmarket.ListedNft = (function () {
      /**
       * Properties of a ListedNft.
       * @memberof ununifi.nftmarket
       * @interface IListedNft
       * @property {string|null} [id] ListedNft id
       * @property {string|null} [uri] ListedNft uri
       * @property {string|null} [uri_hash] ListedNft uri_hash
       */

      /**
       * Constructs a new ListedNft.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a ListedNft.
       * @implements IListedNft
       * @constructor
       * @param {ununifi.nftmarket.IListedNft=} [properties] Properties to set
       */
      function ListedNft(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ListedNft id.
       * @member {string} id
       * @memberof ununifi.nftmarket.ListedNft
       * @instance
       */
      ListedNft.prototype.id = '';

      /**
       * ListedNft uri.
       * @member {string} uri
       * @memberof ununifi.nftmarket.ListedNft
       * @instance
       */
      ListedNft.prototype.uri = '';

      /**
       * ListedNft uri_hash.
       * @member {string} uri_hash
       * @memberof ununifi.nftmarket.ListedNft
       * @instance
       */
      ListedNft.prototype.uri_hash = '';

      /**
       * Encodes the specified ListedNft message. Does not implicitly {@link ununifi.nftmarket.ListedNft.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.ListedNft
       * @static
       * @param {ununifi.nftmarket.IListedNft} message ListedNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedNft.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.uri);
        if (message.uri_hash != null && Object.hasOwnProperty.call(message, 'uri_hash'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.uri_hash);
        return writer;
      };

      /**
       * Encodes the specified ListedNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.ListedNft.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.ListedNft
       * @static
       * @param {ununifi.nftmarket.IListedNft} message ListedNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedNft.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ListedNft message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.ListedNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.ListedNft} ListedNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedNft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.ListedNft();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.uri = reader.string();
              break;
            case 3:
              message.uri_hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ListedNft message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.ListedNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.ListedNft} ListedNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedNft.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ListedNft message.
       * @function verify
       * @memberof ununifi.nftmarket.ListedNft
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ListedNft.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash'))
          if (!$util.isString(message.uri_hash)) return 'uri_hash: string expected';
        return null;
      };

      /**
       * Creates a ListedNft message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.ListedNft
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.ListedNft} ListedNft
       */
      ListedNft.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.ListedNft) return object;
        let message = new $root.ununifi.nftmarket.ListedNft();
        if (object.id != null) message.id = String(object.id);
        if (object.uri != null) message.uri = String(object.uri);
        if (object.uri_hash != null) message.uri_hash = String(object.uri_hash);
        return message;
      };

      /**
       * Creates a plain object from a ListedNft message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.ListedNft
       * @static
       * @param {ununifi.nftmarket.ListedNft} message ListedNft
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ListedNft.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.id = '';
          object.uri = '';
          object.uri_hash = '';
        }
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash')) object.uri_hash = message.uri_hash;
        return object;
      };

      /**
       * Converts this ListedNft to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.ListedNft
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ListedNft.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ListedNft;
    })();

    nftmarket.NftListing = (function () {
      /**
       * Properties of a NftListing.
       * @memberof ununifi.nftmarket
       * @interface INftListing
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] NftListing nft_id
       * @property {string|null} [owner] NftListing owner
       * @property {ununifi.nftmarket.ListingType|null} [listing_type] NftListing listing_type
       * @property {ununifi.nftmarket.ListingState|null} [state] NftListing state
       * @property {string|null} [bid_token] NftListing bid_token
       * @property {string|null} [min_bid] NftListing min_bid
       * @property {Long|null} [bid_active_rank] NftListing bid_active_rank
       * @property {google.protobuf.ITimestamp|null} [started_at] NftListing started_at
       * @property {google.protobuf.ITimestamp|null} [end_at] NftListing end_at
       * @property {google.protobuf.ITimestamp|null} [full_payment_end_at] NftListing full_payment_end_at
       * @property {google.protobuf.ITimestamp|null} [successful_bid_end_at] NftListing successful_bid_end_at
       * @property {Long|null} [auto_relisted_count] NftListing auto_relisted_count
       */

      /**
       * Constructs a new NftListing.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a NftListing.
       * @implements INftListing
       * @constructor
       * @param {ununifi.nftmarket.INftListing=} [properties] Properties to set
       */
      function NftListing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * NftListing nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.nft_id = null;

      /**
       * NftListing owner.
       * @member {string} owner
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.owner = '';

      /**
       * NftListing listing_type.
       * @member {ununifi.nftmarket.ListingType} listing_type
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.listing_type = 0;

      /**
       * NftListing state.
       * @member {ununifi.nftmarket.ListingState} state
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.state = 0;

      /**
       * NftListing bid_token.
       * @member {string} bid_token
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.bid_token = '';

      /**
       * NftListing min_bid.
       * @member {string} min_bid
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.min_bid = '';

      /**
       * NftListing bid_active_rank.
       * @member {Long} bid_active_rank
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.bid_active_rank = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * NftListing started_at.
       * @member {google.protobuf.ITimestamp|null|undefined} started_at
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.started_at = null;

      /**
       * NftListing end_at.
       * @member {google.protobuf.ITimestamp|null|undefined} end_at
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.end_at = null;

      /**
       * NftListing full_payment_end_at.
       * @member {google.protobuf.ITimestamp|null|undefined} full_payment_end_at
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.full_payment_end_at = null;

      /**
       * NftListing successful_bid_end_at.
       * @member {google.protobuf.ITimestamp|null|undefined} successful_bid_end_at
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.successful_bid_end_at = null;

      /**
       * NftListing auto_relisted_count.
       * @member {Long} auto_relisted_count
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       */
      NftListing.prototype.auto_relisted_count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified NftListing message. Does not implicitly {@link ununifi.nftmarket.NftListing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.NftListing
       * @static
       * @param {ununifi.nftmarket.INftListing} message NftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftListing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
        if (message.listing_type != null && Object.hasOwnProperty.call(message, 'listing_type'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.listing_type);
        if (message.state != null && Object.hasOwnProperty.call(message, 'state'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.state);
        if (message.bid_token != null && Object.hasOwnProperty.call(message, 'bid_token'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.bid_token);
        if (message.min_bid != null && Object.hasOwnProperty.call(message, 'min_bid'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.min_bid);
        if (message.bid_active_rank != null && Object.hasOwnProperty.call(message, 'bid_active_rank'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.bid_active_rank);
        if (message.started_at != null && Object.hasOwnProperty.call(message, 'started_at'))
          $root.google.protobuf.Timestamp.encode(message.started_at, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.end_at != null && Object.hasOwnProperty.call(message, 'end_at'))
          $root.google.protobuf.Timestamp.encode(message.end_at, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        if (message.full_payment_end_at != null && Object.hasOwnProperty.call(message, 'full_payment_end_at'))
          $root.google.protobuf.Timestamp.encode(message.full_payment_end_at, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
        if (message.successful_bid_end_at != null && Object.hasOwnProperty.call(message, 'successful_bid_end_at'))
          $root.google.protobuf.Timestamp.encode(message.successful_bid_end_at, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
        if (message.auto_relisted_count != null && Object.hasOwnProperty.call(message, 'auto_relisted_count'))
          writer.uint32(/* id 12, wireType 0 =*/ 96).uint64(message.auto_relisted_count);
        return writer;
      };

      /**
       * Encodes the specified NftListing message, length delimited. Does not implicitly {@link ununifi.nftmarket.NftListing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.NftListing
       * @static
       * @param {ununifi.nftmarket.INftListing} message NftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a NftListing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.NftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.NftListing} NftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.NftListing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 2:
              message.owner = reader.string();
              break;
            case 3:
              message.listing_type = reader.int32();
              break;
            case 4:
              message.state = reader.int32();
              break;
            case 5:
              message.bid_token = reader.string();
              break;
            case 6:
              message.min_bid = reader.string();
              break;
            case 7:
              message.bid_active_rank = reader.uint64();
              break;
            case 8:
              message.started_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.full_payment_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.successful_bid_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 12:
              message.auto_relisted_count = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a NftListing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.NftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.NftListing} NftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a NftListing message.
       * @function verify
       * @memberof ununifi.nftmarket.NftListing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      NftListing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.listing_type != null && message.hasOwnProperty('listing_type'))
          switch (message.listing_type) {
            default:
              return 'listing_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.state != null && message.hasOwnProperty('state'))
          switch (message.state) {
            default:
              return 'state: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
          }
        if (message.bid_token != null && message.hasOwnProperty('bid_token'))
          if (!$util.isString(message.bid_token)) return 'bid_token: string expected';
        if (message.min_bid != null && message.hasOwnProperty('min_bid'))
          if (!$util.isString(message.min_bid)) return 'min_bid: string expected';
        if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
          if (
            !$util.isInteger(message.bid_active_rank) &&
            !(message.bid_active_rank && $util.isInteger(message.bid_active_rank.low) && $util.isInteger(message.bid_active_rank.high))
          )
            return 'bid_active_rank: integer|Long expected';
        if (message.started_at != null && message.hasOwnProperty('started_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.started_at);
          if (error) return 'started_at.' + error;
        }
        if (message.end_at != null && message.hasOwnProperty('end_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.end_at);
          if (error) return 'end_at.' + error;
        }
        if (message.full_payment_end_at != null && message.hasOwnProperty('full_payment_end_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.full_payment_end_at);
          if (error) return 'full_payment_end_at.' + error;
        }
        if (message.successful_bid_end_at != null && message.hasOwnProperty('successful_bid_end_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.successful_bid_end_at);
          if (error) return 'successful_bid_end_at.' + error;
        }
        if (message.auto_relisted_count != null && message.hasOwnProperty('auto_relisted_count'))
          if (
            !$util.isInteger(message.auto_relisted_count) &&
            !(
              message.auto_relisted_count &&
              $util.isInteger(message.auto_relisted_count.low) &&
              $util.isInteger(message.auto_relisted_count.high)
            )
          )
            return 'auto_relisted_count: integer|Long expected';
        return null;
      };

      /**
       * Creates a NftListing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.NftListing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.NftListing} NftListing
       */
      NftListing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.NftListing) return object;
        let message = new $root.ununifi.nftmarket.NftListing();
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.NftListing.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        if (object.owner != null) message.owner = String(object.owner);
        switch (object.listing_type) {
          case 'DIRECT_ASSET_BORROW':
          case 0:
            message.listing_type = 0;
            break;
          case 'SYNTHETIC_ASSET_CREATION':
          case 1:
            message.listing_type = 1;
            break;
          case 'LATE_SHIPPING':
          case 2:
            message.listing_type = 2;
            break;
        }
        switch (object.state) {
          case 'LISTING':
          case 0:
            message.state = 0;
            break;
          case 'BIDDING':
          case 1:
            message.state = 1;
            break;
          case 'SELLING_DECISION':
          case 2:
            message.state = 2;
            break;
          case 'LIQUIDATION':
          case 3:
            message.state = 3;
            break;
          case 'END_LISTING':
          case 4:
            message.state = 4;
            break;
          case 'SUCCESSFUL_BID':
          case 5:
            message.state = 5;
            break;
        }
        if (object.bid_token != null) message.bid_token = String(object.bid_token);
        if (object.min_bid != null) message.min_bid = String(object.min_bid);
        if (object.bid_active_rank != null)
          if ($util.Long) (message.bid_active_rank = $util.Long.fromValue(object.bid_active_rank)).unsigned = true;
          else if (typeof object.bid_active_rank === 'string') message.bid_active_rank = parseInt(object.bid_active_rank, 10);
          else if (typeof object.bid_active_rank === 'number') message.bid_active_rank = object.bid_active_rank;
          else if (typeof object.bid_active_rank === 'object')
            message.bid_active_rank = new $util.LongBits(object.bid_active_rank.low >>> 0, object.bid_active_rank.high >>> 0).toNumber(
              true,
            );
        if (object.started_at != null) {
          if (typeof object.started_at !== 'object') throw TypeError('.ununifi.nftmarket.NftListing.started_at: object expected');
          message.started_at = $root.google.protobuf.Timestamp.fromObject(object.started_at);
        }
        if (object.end_at != null) {
          if (typeof object.end_at !== 'object') throw TypeError('.ununifi.nftmarket.NftListing.end_at: object expected');
          message.end_at = $root.google.protobuf.Timestamp.fromObject(object.end_at);
        }
        if (object.full_payment_end_at != null) {
          if (typeof object.full_payment_end_at !== 'object')
            throw TypeError('.ununifi.nftmarket.NftListing.full_payment_end_at: object expected');
          message.full_payment_end_at = $root.google.protobuf.Timestamp.fromObject(object.full_payment_end_at);
        }
        if (object.successful_bid_end_at != null) {
          if (typeof object.successful_bid_end_at !== 'object')
            throw TypeError('.ununifi.nftmarket.NftListing.successful_bid_end_at: object expected');
          message.successful_bid_end_at = $root.google.protobuf.Timestamp.fromObject(object.successful_bid_end_at);
        }
        if (object.auto_relisted_count != null)
          if ($util.Long) (message.auto_relisted_count = $util.Long.fromValue(object.auto_relisted_count)).unsigned = true;
          else if (typeof object.auto_relisted_count === 'string') message.auto_relisted_count = parseInt(object.auto_relisted_count, 10);
          else if (typeof object.auto_relisted_count === 'number') message.auto_relisted_count = object.auto_relisted_count;
          else if (typeof object.auto_relisted_count === 'object')
            message.auto_relisted_count = new $util.LongBits(
              object.auto_relisted_count.low >>> 0,
              object.auto_relisted_count.high >>> 0,
            ).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a NftListing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.NftListing
       * @static
       * @param {ununifi.nftmarket.NftListing} message NftListing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      NftListing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.nft_id = null;
          object.owner = '';
          object.listing_type = options.enums === String ? 'DIRECT_ASSET_BORROW' : 0;
          object.state = options.enums === String ? 'LISTING' : 0;
          object.bid_token = '';
          object.min_bid = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.bid_active_rank = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.bid_active_rank = options.longs === String ? '0' : 0;
          object.started_at = null;
          object.end_at = null;
          object.full_payment_end_at = null;
          object.successful_bid_end_at = null;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.auto_relisted_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.auto_relisted_count = options.longs === String ? '0' : 0;
        }
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.listing_type != null && message.hasOwnProperty('listing_type'))
          object.listing_type = options.enums === String ? $root.ununifi.nftmarket.ListingType[message.listing_type] : message.listing_type;
        if (message.state != null && message.hasOwnProperty('state'))
          object.state = options.enums === String ? $root.ununifi.nftmarket.ListingState[message.state] : message.state;
        if (message.bid_token != null && message.hasOwnProperty('bid_token')) object.bid_token = message.bid_token;
        if (message.min_bid != null && message.hasOwnProperty('min_bid')) object.min_bid = message.min_bid;
        if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
          if (typeof message.bid_active_rank === 'number')
            object.bid_active_rank = options.longs === String ? String(message.bid_active_rank) : message.bid_active_rank;
          else
            object.bid_active_rank =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.bid_active_rank)
                : options.longs === Number
                ? new $util.LongBits(message.bid_active_rank.low >>> 0, message.bid_active_rank.high >>> 0).toNumber(true)
                : message.bid_active_rank;
        if (message.started_at != null && message.hasOwnProperty('started_at'))
          object.started_at = $root.google.protobuf.Timestamp.toObject(message.started_at, options);
        if (message.end_at != null && message.hasOwnProperty('end_at'))
          object.end_at = $root.google.protobuf.Timestamp.toObject(message.end_at, options);
        if (message.full_payment_end_at != null && message.hasOwnProperty('full_payment_end_at'))
          object.full_payment_end_at = $root.google.protobuf.Timestamp.toObject(message.full_payment_end_at, options);
        if (message.successful_bid_end_at != null && message.hasOwnProperty('successful_bid_end_at'))
          object.successful_bid_end_at = $root.google.protobuf.Timestamp.toObject(message.successful_bid_end_at, options);
        if (message.auto_relisted_count != null && message.hasOwnProperty('auto_relisted_count'))
          if (typeof message.auto_relisted_count === 'number')
            object.auto_relisted_count = options.longs === String ? String(message.auto_relisted_count) : message.auto_relisted_count;
          else
            object.auto_relisted_count =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.auto_relisted_count)
                : options.longs === Number
                ? new $util.LongBits(message.auto_relisted_count.low >>> 0, message.auto_relisted_count.high >>> 0).toNumber(true)
                : message.auto_relisted_count;
        return object;
      };

      /**
       * Converts this NftListing to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.NftListing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      NftListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return NftListing;
    })();

    nftmarket.NftBid = (function () {
      /**
       * Properties of a NftBid.
       * @memberof ununifi.nftmarket
       * @interface INftBid
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] NftBid nft_id
       * @property {string|null} [bidder] NftBid bidder
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] NftBid amount
       * @property {boolean|null} [automatic_payment] NftBid automatic_payment
       * @property {string|null} [paid_amount] NftBid paid_amount
       * @property {google.protobuf.ITimestamp|null} [bid_time] NftBid bid_time
       */

      /**
       * Constructs a new NftBid.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a NftBid.
       * @implements INftBid
       * @constructor
       * @param {ununifi.nftmarket.INftBid=} [properties] Properties to set
       */
      function NftBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * NftBid nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.NftBid
       * @instance
       */
      NftBid.prototype.nft_id = null;

      /**
       * NftBid bidder.
       * @member {string} bidder
       * @memberof ununifi.nftmarket.NftBid
       * @instance
       */
      NftBid.prototype.bidder = '';

      /**
       * NftBid amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftmarket.NftBid
       * @instance
       */
      NftBid.prototype.amount = null;

      /**
       * NftBid automatic_payment.
       * @member {boolean} automatic_payment
       * @memberof ununifi.nftmarket.NftBid
       * @instance
       */
      NftBid.prototype.automatic_payment = false;

      /**
       * NftBid paid_amount.
       * @member {string} paid_amount
       * @memberof ununifi.nftmarket.NftBid
       * @instance
       */
      NftBid.prototype.paid_amount = '';

      /**
       * NftBid bid_time.
       * @member {google.protobuf.ITimestamp|null|undefined} bid_time
       * @memberof ununifi.nftmarket.NftBid
       * @instance
       */
      NftBid.prototype.bid_time = null;

      /**
       * Encodes the specified NftBid message. Does not implicitly {@link ununifi.nftmarket.NftBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.NftBid
       * @static
       * @param {ununifi.nftmarket.INftBid} message NftBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bidder);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.automatic_payment);
        if (message.paid_amount != null && Object.hasOwnProperty.call(message, 'paid_amount'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.paid_amount);
        if (message.bid_time != null && Object.hasOwnProperty.call(message, 'bid_time'))
          $root.google.protobuf.Timestamp.encode(message.bid_time, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified NftBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.NftBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.NftBid
       * @static
       * @param {ununifi.nftmarket.INftBid} message NftBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a NftBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.NftBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.NftBid} NftBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.NftBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 2:
              message.bidder = reader.string();
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.automatic_payment = reader.bool();
              break;
            case 5:
              message.paid_amount = reader.string();
              break;
            case 6:
              message.bid_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a NftBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.NftBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.NftBid} NftBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a NftBid message.
       * @function verify
       * @memberof ununifi.nftmarket.NftBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      NftBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
        if (message.paid_amount != null && message.hasOwnProperty('paid_amount'))
          if (!$util.isString(message.paid_amount)) return 'paid_amount: string expected';
        if (message.bid_time != null && message.hasOwnProperty('bid_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.bid_time);
          if (error) return 'bid_time.' + error;
        }
        return null;
      };

      /**
       * Creates a NftBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.NftBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.NftBid} NftBid
       */
      NftBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.NftBid) return object;
        let message = new $root.ununifi.nftmarket.NftBid();
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.NftBid.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.NftBid.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
        if (object.paid_amount != null) message.paid_amount = String(object.paid_amount);
        if (object.bid_time != null) {
          if (typeof object.bid_time !== 'object') throw TypeError('.ununifi.nftmarket.NftBid.bid_time: object expected');
          message.bid_time = $root.google.protobuf.Timestamp.fromObject(object.bid_time);
        }
        return message;
      };

      /**
       * Creates a plain object from a NftBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.NftBid
       * @static
       * @param {ununifi.nftmarket.NftBid} message NftBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      NftBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.nft_id = null;
          object.bidder = '';
          object.amount = null;
          object.automatic_payment = false;
          object.paid_amount = '';
          object.bid_time = null;
        }
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          object.automatic_payment = message.automatic_payment;
        if (message.paid_amount != null && message.hasOwnProperty('paid_amount')) object.paid_amount = message.paid_amount;
        if (message.bid_time != null && message.hasOwnProperty('bid_time'))
          object.bid_time = $root.google.protobuf.Timestamp.toObject(message.bid_time, options);
        return object;
      };

      /**
       * Converts this NftBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.NftBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      NftBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return NftBid;
    })();

    nftmarket.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.nftmarket
       * @interface IParams
       * @property {string|null} [min_staking_for_listing] Params min_staking_for_listing
       * @property {Long|null} [default_bid_active_rank] Params default_bid_active_rank
       * @property {Array.<string>|null} [bid_tokens] Params bid_tokens
       * @property {Long|null} [auto_relisting_count_if_no_bid] Params auto_relisting_count_if_no_bid
       * @property {Long|null} [nft_listing_delay_seconds] Params nft_listing_delay_seconds
       * @property {Long|null} [nft_listing_period_initial] Params nft_listing_period_initial
       * @property {Long|null} [nft_listing_cancel_required_seconds] Params nft_listing_cancel_required_seconds
       * @property {Long|null} [nft_listing_cancel_fee_percentage] Params nft_listing_cancel_fee_percentage
       * @property {Long|null} [nft_listing_gap_time] Params nft_listing_gap_time
       * @property {Long|null} [bid_cancel_required_seconds] Params bid_cancel_required_seconds
       * @property {Long|null} [bid_token_disburse_seconds_after_cancel] Params bid_token_disburse_seconds_after_cancel
       * @property {Long|null} [nft_listing_full_payment_period] Params nft_listing_full_payment_period
       * @property {Long|null} [nft_listing_nft_delivery_period] Params nft_listing_nft_delivery_period
       * @property {Long|null} [nft_creator_share_percentage] Params nft_creator_share_percentage
       * @property {string|null} [market_administrator] Params market_administrator
       * @property {Long|null} [nft_listing_commission_fee] Params nft_listing_commission_fee
       * @property {Long|null} [nft_listing_extend_seconds] Params nft_listing_extend_seconds
       * @property {cosmos.base.v1beta1.ICoin|null} [nft_listing_period_extend_fee_per_hour] Params nft_listing_period_extend_fee_per_hour
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.nftmarket.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.bid_tokens = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params min_staking_for_listing.
       * @member {string} min_staking_for_listing
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.min_staking_for_listing = '';

      /**
       * Params default_bid_active_rank.
       * @member {Long} default_bid_active_rank
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.default_bid_active_rank = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params bid_tokens.
       * @member {Array.<string>} bid_tokens
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.bid_tokens = $util.emptyArray;

      /**
       * Params auto_relisting_count_if_no_bid.
       * @member {Long} auto_relisting_count_if_no_bid
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.auto_relisting_count_if_no_bid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_delay_seconds.
       * @member {Long} nft_listing_delay_seconds
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_delay_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_period_initial.
       * @member {Long} nft_listing_period_initial
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_period_initial = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_cancel_required_seconds.
       * @member {Long} nft_listing_cancel_required_seconds
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_cancel_fee_percentage.
       * @member {Long} nft_listing_cancel_fee_percentage
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_cancel_fee_percentage = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_gap_time.
       * @member {Long} nft_listing_gap_time
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_gap_time = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params bid_cancel_required_seconds.
       * @member {Long} bid_cancel_required_seconds
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.bid_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params bid_token_disburse_seconds_after_cancel.
       * @member {Long} bid_token_disburse_seconds_after_cancel
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.bid_token_disburse_seconds_after_cancel = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_full_payment_period.
       * @member {Long} nft_listing_full_payment_period
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_full_payment_period = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_nft_delivery_period.
       * @member {Long} nft_listing_nft_delivery_period
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_nft_delivery_period = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_creator_share_percentage.
       * @member {Long} nft_creator_share_percentage
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_creator_share_percentage = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params market_administrator.
       * @member {string} market_administrator
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.market_administrator = '';

      /**
       * Params nft_listing_commission_fee.
       * @member {Long} nft_listing_commission_fee
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_commission_fee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_extend_seconds.
       * @member {Long} nft_listing_extend_seconds
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_extend_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_period_extend_fee_per_hour.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} nft_listing_period_extend_fee_per_hour
       * @memberof ununifi.nftmarket.Params
       * @instance
       */
      Params.prototype.nft_listing_period_extend_fee_per_hour = null;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.nftmarket.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.Params
       * @static
       * @param {ununifi.nftmarket.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.min_staking_for_listing != null && Object.hasOwnProperty.call(message, 'min_staking_for_listing'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.min_staking_for_listing);
        if (message.default_bid_active_rank != null && Object.hasOwnProperty.call(message, 'default_bid_active_rank'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.default_bid_active_rank);
        if (message.bid_tokens != null && message.bid_tokens.length)
          for (let i = 0; i < message.bid_tokens.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.bid_tokens[i]);
        if (message.auto_relisting_count_if_no_bid != null && Object.hasOwnProperty.call(message, 'auto_relisting_count_if_no_bid'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.auto_relisting_count_if_no_bid);
        if (message.nft_listing_delay_seconds != null && Object.hasOwnProperty.call(message, 'nft_listing_delay_seconds'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.nft_listing_delay_seconds);
        if (message.nft_listing_period_initial != null && Object.hasOwnProperty.call(message, 'nft_listing_period_initial'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.nft_listing_period_initial);
        if (
          message.nft_listing_cancel_required_seconds != null &&
          Object.hasOwnProperty.call(message, 'nft_listing_cancel_required_seconds')
        )
          writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.nft_listing_cancel_required_seconds);
        if (message.nft_listing_cancel_fee_percentage != null && Object.hasOwnProperty.call(message, 'nft_listing_cancel_fee_percentage'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).uint64(message.nft_listing_cancel_fee_percentage);
        if (message.nft_listing_gap_time != null && Object.hasOwnProperty.call(message, 'nft_listing_gap_time'))
          writer.uint32(/* id 9, wireType 0 =*/ 72).uint64(message.nft_listing_gap_time);
        if (message.bid_cancel_required_seconds != null && Object.hasOwnProperty.call(message, 'bid_cancel_required_seconds'))
          writer.uint32(/* id 10, wireType 0 =*/ 80).uint64(message.bid_cancel_required_seconds);
        if (
          message.bid_token_disburse_seconds_after_cancel != null &&
          Object.hasOwnProperty.call(message, 'bid_token_disburse_seconds_after_cancel')
        )
          writer.uint32(/* id 11, wireType 0 =*/ 88).uint64(message.bid_token_disburse_seconds_after_cancel);
        if (message.nft_listing_full_payment_period != null && Object.hasOwnProperty.call(message, 'nft_listing_full_payment_period'))
          writer.uint32(/* id 12, wireType 0 =*/ 96).uint64(message.nft_listing_full_payment_period);
        if (message.nft_listing_nft_delivery_period != null && Object.hasOwnProperty.call(message, 'nft_listing_nft_delivery_period'))
          writer.uint32(/* id 13, wireType 0 =*/ 104).uint64(message.nft_listing_nft_delivery_period);
        if (message.nft_creator_share_percentage != null && Object.hasOwnProperty.call(message, 'nft_creator_share_percentage'))
          writer.uint32(/* id 14, wireType 0 =*/ 112).uint64(message.nft_creator_share_percentage);
        if (message.market_administrator != null && Object.hasOwnProperty.call(message, 'market_administrator'))
          writer.uint32(/* id 15, wireType 2 =*/ 122).string(message.market_administrator);
        if (message.nft_listing_commission_fee != null && Object.hasOwnProperty.call(message, 'nft_listing_commission_fee'))
          writer.uint32(/* id 16, wireType 0 =*/ 128).uint64(message.nft_listing_commission_fee);
        if (message.nft_listing_extend_seconds != null && Object.hasOwnProperty.call(message, 'nft_listing_extend_seconds'))
          writer.uint32(/* id 17, wireType 0 =*/ 136).uint64(message.nft_listing_extend_seconds);
        if (
          message.nft_listing_period_extend_fee_per_hour != null &&
          Object.hasOwnProperty.call(message, 'nft_listing_period_extend_fee_per_hour')
        )
          $root.cosmos.base.v1beta1.Coin.encode(
            message.nft_listing_period_extend_fee_per_hour,
            writer.uint32(/* id 18, wireType 2 =*/ 146).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftmarket.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.Params
       * @static
       * @param {ununifi.nftmarket.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.min_staking_for_listing = reader.string();
              break;
            case 2:
              message.default_bid_active_rank = reader.uint64();
              break;
            case 3:
              if (!(message.bid_tokens && message.bid_tokens.length)) message.bid_tokens = [];
              message.bid_tokens.push(reader.string());
              break;
            case 4:
              message.auto_relisting_count_if_no_bid = reader.uint64();
              break;
            case 5:
              message.nft_listing_delay_seconds = reader.uint64();
              break;
            case 6:
              message.nft_listing_period_initial = reader.uint64();
              break;
            case 7:
              message.nft_listing_cancel_required_seconds = reader.uint64();
              break;
            case 8:
              message.nft_listing_cancel_fee_percentage = reader.uint64();
              break;
            case 9:
              message.nft_listing_gap_time = reader.uint64();
              break;
            case 10:
              message.bid_cancel_required_seconds = reader.uint64();
              break;
            case 11:
              message.bid_token_disburse_seconds_after_cancel = reader.uint64();
              break;
            case 12:
              message.nft_listing_full_payment_period = reader.uint64();
              break;
            case 13:
              message.nft_listing_nft_delivery_period = reader.uint64();
              break;
            case 14:
              message.nft_creator_share_percentage = reader.uint64();
              break;
            case 15:
              message.market_administrator = reader.string();
              break;
            case 16:
              message.nft_listing_commission_fee = reader.uint64();
              break;
            case 17:
              message.nft_listing_extend_seconds = reader.uint64();
              break;
            case 18:
              message.nft_listing_period_extend_fee_per_hour = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.nftmarket.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.min_staking_for_listing != null && message.hasOwnProperty('min_staking_for_listing'))
          if (!$util.isString(message.min_staking_for_listing)) return 'min_staking_for_listing: string expected';
        if (message.default_bid_active_rank != null && message.hasOwnProperty('default_bid_active_rank'))
          if (
            !$util.isInteger(message.default_bid_active_rank) &&
            !(
              message.default_bid_active_rank &&
              $util.isInteger(message.default_bid_active_rank.low) &&
              $util.isInteger(message.default_bid_active_rank.high)
            )
          )
            return 'default_bid_active_rank: integer|Long expected';
        if (message.bid_tokens != null && message.hasOwnProperty('bid_tokens')) {
          if (!Array.isArray(message.bid_tokens)) return 'bid_tokens: array expected';
          for (let i = 0; i < message.bid_tokens.length; ++i)
            if (!$util.isString(message.bid_tokens[i])) return 'bid_tokens: string[] expected';
        }
        if (message.auto_relisting_count_if_no_bid != null && message.hasOwnProperty('auto_relisting_count_if_no_bid'))
          if (
            !$util.isInteger(message.auto_relisting_count_if_no_bid) &&
            !(
              message.auto_relisting_count_if_no_bid &&
              $util.isInteger(message.auto_relisting_count_if_no_bid.low) &&
              $util.isInteger(message.auto_relisting_count_if_no_bid.high)
            )
          )
            return 'auto_relisting_count_if_no_bid: integer|Long expected';
        if (message.nft_listing_delay_seconds != null && message.hasOwnProperty('nft_listing_delay_seconds'))
          if (
            !$util.isInteger(message.nft_listing_delay_seconds) &&
            !(
              message.nft_listing_delay_seconds &&
              $util.isInteger(message.nft_listing_delay_seconds.low) &&
              $util.isInteger(message.nft_listing_delay_seconds.high)
            )
          )
            return 'nft_listing_delay_seconds: integer|Long expected';
        if (message.nft_listing_period_initial != null && message.hasOwnProperty('nft_listing_period_initial'))
          if (
            !$util.isInteger(message.nft_listing_period_initial) &&
            !(
              message.nft_listing_period_initial &&
              $util.isInteger(message.nft_listing_period_initial.low) &&
              $util.isInteger(message.nft_listing_period_initial.high)
            )
          )
            return 'nft_listing_period_initial: integer|Long expected';
        if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty('nft_listing_cancel_required_seconds'))
          if (
            !$util.isInteger(message.nft_listing_cancel_required_seconds) &&
            !(
              message.nft_listing_cancel_required_seconds &&
              $util.isInteger(message.nft_listing_cancel_required_seconds.low) &&
              $util.isInteger(message.nft_listing_cancel_required_seconds.high)
            )
          )
            return 'nft_listing_cancel_required_seconds: integer|Long expected';
        if (message.nft_listing_cancel_fee_percentage != null && message.hasOwnProperty('nft_listing_cancel_fee_percentage'))
          if (
            !$util.isInteger(message.nft_listing_cancel_fee_percentage) &&
            !(
              message.nft_listing_cancel_fee_percentage &&
              $util.isInteger(message.nft_listing_cancel_fee_percentage.low) &&
              $util.isInteger(message.nft_listing_cancel_fee_percentage.high)
            )
          )
            return 'nft_listing_cancel_fee_percentage: integer|Long expected';
        if (message.nft_listing_gap_time != null && message.hasOwnProperty('nft_listing_gap_time'))
          if (
            !$util.isInteger(message.nft_listing_gap_time) &&
            !(
              message.nft_listing_gap_time &&
              $util.isInteger(message.nft_listing_gap_time.low) &&
              $util.isInteger(message.nft_listing_gap_time.high)
            )
          )
            return 'nft_listing_gap_time: integer|Long expected';
        if (message.bid_cancel_required_seconds != null && message.hasOwnProperty('bid_cancel_required_seconds'))
          if (
            !$util.isInteger(message.bid_cancel_required_seconds) &&
            !(
              message.bid_cancel_required_seconds &&
              $util.isInteger(message.bid_cancel_required_seconds.low) &&
              $util.isInteger(message.bid_cancel_required_seconds.high)
            )
          )
            return 'bid_cancel_required_seconds: integer|Long expected';
        if (message.bid_token_disburse_seconds_after_cancel != null && message.hasOwnProperty('bid_token_disburse_seconds_after_cancel'))
          if (
            !$util.isInteger(message.bid_token_disburse_seconds_after_cancel) &&
            !(
              message.bid_token_disburse_seconds_after_cancel &&
              $util.isInteger(message.bid_token_disburse_seconds_after_cancel.low) &&
              $util.isInteger(message.bid_token_disburse_seconds_after_cancel.high)
            )
          )
            return 'bid_token_disburse_seconds_after_cancel: integer|Long expected';
        if (message.nft_listing_full_payment_period != null && message.hasOwnProperty('nft_listing_full_payment_period'))
          if (
            !$util.isInteger(message.nft_listing_full_payment_period) &&
            !(
              message.nft_listing_full_payment_period &&
              $util.isInteger(message.nft_listing_full_payment_period.low) &&
              $util.isInteger(message.nft_listing_full_payment_period.high)
            )
          )
            return 'nft_listing_full_payment_period: integer|Long expected';
        if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty('nft_listing_nft_delivery_period'))
          if (
            !$util.isInteger(message.nft_listing_nft_delivery_period) &&
            !(
              message.nft_listing_nft_delivery_period &&
              $util.isInteger(message.nft_listing_nft_delivery_period.low) &&
              $util.isInteger(message.nft_listing_nft_delivery_period.high)
            )
          )
            return 'nft_listing_nft_delivery_period: integer|Long expected';
        if (message.nft_creator_share_percentage != null && message.hasOwnProperty('nft_creator_share_percentage'))
          if (
            !$util.isInteger(message.nft_creator_share_percentage) &&
            !(
              message.nft_creator_share_percentage &&
              $util.isInteger(message.nft_creator_share_percentage.low) &&
              $util.isInteger(message.nft_creator_share_percentage.high)
            )
          )
            return 'nft_creator_share_percentage: integer|Long expected';
        if (message.market_administrator != null && message.hasOwnProperty('market_administrator'))
          if (!$util.isString(message.market_administrator)) return 'market_administrator: string expected';
        if (message.nft_listing_commission_fee != null && message.hasOwnProperty('nft_listing_commission_fee'))
          if (
            !$util.isInteger(message.nft_listing_commission_fee) &&
            !(
              message.nft_listing_commission_fee &&
              $util.isInteger(message.nft_listing_commission_fee.low) &&
              $util.isInteger(message.nft_listing_commission_fee.high)
            )
          )
            return 'nft_listing_commission_fee: integer|Long expected';
        if (message.nft_listing_extend_seconds != null && message.hasOwnProperty('nft_listing_extend_seconds'))
          if (
            !$util.isInteger(message.nft_listing_extend_seconds) &&
            !(
              message.nft_listing_extend_seconds &&
              $util.isInteger(message.nft_listing_extend_seconds.low) &&
              $util.isInteger(message.nft_listing_extend_seconds.high)
            )
          )
            return 'nft_listing_extend_seconds: integer|Long expected';
        if (message.nft_listing_period_extend_fee_per_hour != null && message.hasOwnProperty('nft_listing_period_extend_fee_per_hour')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.nft_listing_period_extend_fee_per_hour);
          if (error) return 'nft_listing_period_extend_fee_per_hour.' + error;
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.Params) return object;
        let message = new $root.ununifi.nftmarket.Params();
        if (object.min_staking_for_listing != null) message.min_staking_for_listing = String(object.min_staking_for_listing);
        if (object.default_bid_active_rank != null)
          if ($util.Long) (message.default_bid_active_rank = $util.Long.fromValue(object.default_bid_active_rank)).unsigned = true;
          else if (typeof object.default_bid_active_rank === 'string')
            message.default_bid_active_rank = parseInt(object.default_bid_active_rank, 10);
          else if (typeof object.default_bid_active_rank === 'number') message.default_bid_active_rank = object.default_bid_active_rank;
          else if (typeof object.default_bid_active_rank === 'object')
            message.default_bid_active_rank = new $util.LongBits(
              object.default_bid_active_rank.low >>> 0,
              object.default_bid_active_rank.high >>> 0,
            ).toNumber(true);
        if (object.bid_tokens) {
          if (!Array.isArray(object.bid_tokens)) throw TypeError('.ununifi.nftmarket.Params.bid_tokens: array expected');
          message.bid_tokens = [];
          for (let i = 0; i < object.bid_tokens.length; ++i) message.bid_tokens[i] = String(object.bid_tokens[i]);
        }
        if (object.auto_relisting_count_if_no_bid != null)
          if ($util.Long)
            (message.auto_relisting_count_if_no_bid = $util.Long.fromValue(object.auto_relisting_count_if_no_bid)).unsigned = true;
          else if (typeof object.auto_relisting_count_if_no_bid === 'string')
            message.auto_relisting_count_if_no_bid = parseInt(object.auto_relisting_count_if_no_bid, 10);
          else if (typeof object.auto_relisting_count_if_no_bid === 'number')
            message.auto_relisting_count_if_no_bid = object.auto_relisting_count_if_no_bid;
          else if (typeof object.auto_relisting_count_if_no_bid === 'object')
            message.auto_relisting_count_if_no_bid = new $util.LongBits(
              object.auto_relisting_count_if_no_bid.low >>> 0,
              object.auto_relisting_count_if_no_bid.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_delay_seconds != null)
          if ($util.Long) (message.nft_listing_delay_seconds = $util.Long.fromValue(object.nft_listing_delay_seconds)).unsigned = true;
          else if (typeof object.nft_listing_delay_seconds === 'string')
            message.nft_listing_delay_seconds = parseInt(object.nft_listing_delay_seconds, 10);
          else if (typeof object.nft_listing_delay_seconds === 'number')
            message.nft_listing_delay_seconds = object.nft_listing_delay_seconds;
          else if (typeof object.nft_listing_delay_seconds === 'object')
            message.nft_listing_delay_seconds = new $util.LongBits(
              object.nft_listing_delay_seconds.low >>> 0,
              object.nft_listing_delay_seconds.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_period_initial != null)
          if ($util.Long) (message.nft_listing_period_initial = $util.Long.fromValue(object.nft_listing_period_initial)).unsigned = true;
          else if (typeof object.nft_listing_period_initial === 'string')
            message.nft_listing_period_initial = parseInt(object.nft_listing_period_initial, 10);
          else if (typeof object.nft_listing_period_initial === 'number')
            message.nft_listing_period_initial = object.nft_listing_period_initial;
          else if (typeof object.nft_listing_period_initial === 'object')
            message.nft_listing_period_initial = new $util.LongBits(
              object.nft_listing_period_initial.low >>> 0,
              object.nft_listing_period_initial.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_cancel_required_seconds != null)
          if ($util.Long)
            (message.nft_listing_cancel_required_seconds = $util.Long.fromValue(
              object.nft_listing_cancel_required_seconds,
            )).unsigned = true;
          else if (typeof object.nft_listing_cancel_required_seconds === 'string')
            message.nft_listing_cancel_required_seconds = parseInt(object.nft_listing_cancel_required_seconds, 10);
          else if (typeof object.nft_listing_cancel_required_seconds === 'number')
            message.nft_listing_cancel_required_seconds = object.nft_listing_cancel_required_seconds;
          else if (typeof object.nft_listing_cancel_required_seconds === 'object')
            message.nft_listing_cancel_required_seconds = new $util.LongBits(
              object.nft_listing_cancel_required_seconds.low >>> 0,
              object.nft_listing_cancel_required_seconds.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_cancel_fee_percentage != null)
          if ($util.Long)
            (message.nft_listing_cancel_fee_percentage = $util.Long.fromValue(object.nft_listing_cancel_fee_percentage)).unsigned = true;
          else if (typeof object.nft_listing_cancel_fee_percentage === 'string')
            message.nft_listing_cancel_fee_percentage = parseInt(object.nft_listing_cancel_fee_percentage, 10);
          else if (typeof object.nft_listing_cancel_fee_percentage === 'number')
            message.nft_listing_cancel_fee_percentage = object.nft_listing_cancel_fee_percentage;
          else if (typeof object.nft_listing_cancel_fee_percentage === 'object')
            message.nft_listing_cancel_fee_percentage = new $util.LongBits(
              object.nft_listing_cancel_fee_percentage.low >>> 0,
              object.nft_listing_cancel_fee_percentage.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_gap_time != null)
          if ($util.Long) (message.nft_listing_gap_time = $util.Long.fromValue(object.nft_listing_gap_time)).unsigned = true;
          else if (typeof object.nft_listing_gap_time === 'string')
            message.nft_listing_gap_time = parseInt(object.nft_listing_gap_time, 10);
          else if (typeof object.nft_listing_gap_time === 'number') message.nft_listing_gap_time = object.nft_listing_gap_time;
          else if (typeof object.nft_listing_gap_time === 'object')
            message.nft_listing_gap_time = new $util.LongBits(
              object.nft_listing_gap_time.low >>> 0,
              object.nft_listing_gap_time.high >>> 0,
            ).toNumber(true);
        if (object.bid_cancel_required_seconds != null)
          if ($util.Long) (message.bid_cancel_required_seconds = $util.Long.fromValue(object.bid_cancel_required_seconds)).unsigned = true;
          else if (typeof object.bid_cancel_required_seconds === 'string')
            message.bid_cancel_required_seconds = parseInt(object.bid_cancel_required_seconds, 10);
          else if (typeof object.bid_cancel_required_seconds === 'number')
            message.bid_cancel_required_seconds = object.bid_cancel_required_seconds;
          else if (typeof object.bid_cancel_required_seconds === 'object')
            message.bid_cancel_required_seconds = new $util.LongBits(
              object.bid_cancel_required_seconds.low >>> 0,
              object.bid_cancel_required_seconds.high >>> 0,
            ).toNumber(true);
        if (object.bid_token_disburse_seconds_after_cancel != null)
          if ($util.Long)
            (message.bid_token_disburse_seconds_after_cancel = $util.Long.fromValue(
              object.bid_token_disburse_seconds_after_cancel,
            )).unsigned = true;
          else if (typeof object.bid_token_disburse_seconds_after_cancel === 'string')
            message.bid_token_disburse_seconds_after_cancel = parseInt(object.bid_token_disburse_seconds_after_cancel, 10);
          else if (typeof object.bid_token_disburse_seconds_after_cancel === 'number')
            message.bid_token_disburse_seconds_after_cancel = object.bid_token_disburse_seconds_after_cancel;
          else if (typeof object.bid_token_disburse_seconds_after_cancel === 'object')
            message.bid_token_disburse_seconds_after_cancel = new $util.LongBits(
              object.bid_token_disburse_seconds_after_cancel.low >>> 0,
              object.bid_token_disburse_seconds_after_cancel.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_full_payment_period != null)
          if ($util.Long)
            (message.nft_listing_full_payment_period = $util.Long.fromValue(object.nft_listing_full_payment_period)).unsigned = true;
          else if (typeof object.nft_listing_full_payment_period === 'string')
            message.nft_listing_full_payment_period = parseInt(object.nft_listing_full_payment_period, 10);
          else if (typeof object.nft_listing_full_payment_period === 'number')
            message.nft_listing_full_payment_period = object.nft_listing_full_payment_period;
          else if (typeof object.nft_listing_full_payment_period === 'object')
            message.nft_listing_full_payment_period = new $util.LongBits(
              object.nft_listing_full_payment_period.low >>> 0,
              object.nft_listing_full_payment_period.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_nft_delivery_period != null)
          if ($util.Long)
            (message.nft_listing_nft_delivery_period = $util.Long.fromValue(object.nft_listing_nft_delivery_period)).unsigned = true;
          else if (typeof object.nft_listing_nft_delivery_period === 'string')
            message.nft_listing_nft_delivery_period = parseInt(object.nft_listing_nft_delivery_period, 10);
          else if (typeof object.nft_listing_nft_delivery_period === 'number')
            message.nft_listing_nft_delivery_period = object.nft_listing_nft_delivery_period;
          else if (typeof object.nft_listing_nft_delivery_period === 'object')
            message.nft_listing_nft_delivery_period = new $util.LongBits(
              object.nft_listing_nft_delivery_period.low >>> 0,
              object.nft_listing_nft_delivery_period.high >>> 0,
            ).toNumber(true);
        if (object.nft_creator_share_percentage != null)
          if ($util.Long)
            (message.nft_creator_share_percentage = $util.Long.fromValue(object.nft_creator_share_percentage)).unsigned = true;
          else if (typeof object.nft_creator_share_percentage === 'string')
            message.nft_creator_share_percentage = parseInt(object.nft_creator_share_percentage, 10);
          else if (typeof object.nft_creator_share_percentage === 'number')
            message.nft_creator_share_percentage = object.nft_creator_share_percentage;
          else if (typeof object.nft_creator_share_percentage === 'object')
            message.nft_creator_share_percentage = new $util.LongBits(
              object.nft_creator_share_percentage.low >>> 0,
              object.nft_creator_share_percentage.high >>> 0,
            ).toNumber(true);
        if (object.market_administrator != null) message.market_administrator = String(object.market_administrator);
        if (object.nft_listing_commission_fee != null)
          if ($util.Long) (message.nft_listing_commission_fee = $util.Long.fromValue(object.nft_listing_commission_fee)).unsigned = true;
          else if (typeof object.nft_listing_commission_fee === 'string')
            message.nft_listing_commission_fee = parseInt(object.nft_listing_commission_fee, 10);
          else if (typeof object.nft_listing_commission_fee === 'number')
            message.nft_listing_commission_fee = object.nft_listing_commission_fee;
          else if (typeof object.nft_listing_commission_fee === 'object')
            message.nft_listing_commission_fee = new $util.LongBits(
              object.nft_listing_commission_fee.low >>> 0,
              object.nft_listing_commission_fee.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_extend_seconds != null)
          if ($util.Long) (message.nft_listing_extend_seconds = $util.Long.fromValue(object.nft_listing_extend_seconds)).unsigned = true;
          else if (typeof object.nft_listing_extend_seconds === 'string')
            message.nft_listing_extend_seconds = parseInt(object.nft_listing_extend_seconds, 10);
          else if (typeof object.nft_listing_extend_seconds === 'number')
            message.nft_listing_extend_seconds = object.nft_listing_extend_seconds;
          else if (typeof object.nft_listing_extend_seconds === 'object')
            message.nft_listing_extend_seconds = new $util.LongBits(
              object.nft_listing_extend_seconds.low >>> 0,
              object.nft_listing_extend_seconds.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_period_extend_fee_per_hour != null) {
          if (typeof object.nft_listing_period_extend_fee_per_hour !== 'object')
            throw TypeError('.ununifi.nftmarket.Params.nft_listing_period_extend_fee_per_hour: object expected');
          message.nft_listing_period_extend_fee_per_hour = $root.cosmos.base.v1beta1.Coin.fromObject(
            object.nft_listing_period_extend_fee_per_hour,
          );
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.Params
       * @static
       * @param {ununifi.nftmarket.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.bid_tokens = [];
        if (options.defaults) {
          object.min_staking_for_listing = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.default_bid_active_rank = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.default_bid_active_rank = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.auto_relisting_count_if_no_bid =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.auto_relisting_count_if_no_bid = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_delay_seconds =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_delay_seconds = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_period_initial =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_period_initial = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_cancel_required_seconds =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_cancel_required_seconds = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_cancel_fee_percentage =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_cancel_fee_percentage = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_gap_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_gap_time = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.bid_cancel_required_seconds =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.bid_cancel_required_seconds = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.bid_token_disburse_seconds_after_cancel =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.bid_token_disburse_seconds_after_cancel = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_full_payment_period =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_full_payment_period = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_nft_delivery_period =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_nft_delivery_period = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_creator_share_percentage =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_creator_share_percentage = options.longs === String ? '0' : 0;
          object.market_administrator = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_commission_fee =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_commission_fee = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_extend_seconds =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_extend_seconds = options.longs === String ? '0' : 0;
          object.nft_listing_period_extend_fee_per_hour = null;
        }
        if (message.min_staking_for_listing != null && message.hasOwnProperty('min_staking_for_listing'))
          object.min_staking_for_listing = message.min_staking_for_listing;
        if (message.default_bid_active_rank != null && message.hasOwnProperty('default_bid_active_rank'))
          if (typeof message.default_bid_active_rank === 'number')
            object.default_bid_active_rank =
              options.longs === String ? String(message.default_bid_active_rank) : message.default_bid_active_rank;
          else
            object.default_bid_active_rank =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.default_bid_active_rank)
                : options.longs === Number
                ? new $util.LongBits(message.default_bid_active_rank.low >>> 0, message.default_bid_active_rank.high >>> 0).toNumber(true)
                : message.default_bid_active_rank;
        if (message.bid_tokens && message.bid_tokens.length) {
          object.bid_tokens = [];
          for (let j = 0; j < message.bid_tokens.length; ++j) object.bid_tokens[j] = message.bid_tokens[j];
        }
        if (message.auto_relisting_count_if_no_bid != null && message.hasOwnProperty('auto_relisting_count_if_no_bid'))
          if (typeof message.auto_relisting_count_if_no_bid === 'number')
            object.auto_relisting_count_if_no_bid =
              options.longs === String ? String(message.auto_relisting_count_if_no_bid) : message.auto_relisting_count_if_no_bid;
          else
            object.auto_relisting_count_if_no_bid =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.auto_relisting_count_if_no_bid)
                : options.longs === Number
                ? new $util.LongBits(
                    message.auto_relisting_count_if_no_bid.low >>> 0,
                    message.auto_relisting_count_if_no_bid.high >>> 0,
                  ).toNumber(true)
                : message.auto_relisting_count_if_no_bid;
        if (message.nft_listing_delay_seconds != null && message.hasOwnProperty('nft_listing_delay_seconds'))
          if (typeof message.nft_listing_delay_seconds === 'number')
            object.nft_listing_delay_seconds =
              options.longs === String ? String(message.nft_listing_delay_seconds) : message.nft_listing_delay_seconds;
          else
            object.nft_listing_delay_seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_delay_seconds)
                : options.longs === Number
                ? new $util.LongBits(message.nft_listing_delay_seconds.low >>> 0, message.nft_listing_delay_seconds.high >>> 0).toNumber(
                    true,
                  )
                : message.nft_listing_delay_seconds;
        if (message.nft_listing_period_initial != null && message.hasOwnProperty('nft_listing_period_initial'))
          if (typeof message.nft_listing_period_initial === 'number')
            object.nft_listing_period_initial =
              options.longs === String ? String(message.nft_listing_period_initial) : message.nft_listing_period_initial;
          else
            object.nft_listing_period_initial =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_period_initial)
                : options.longs === Number
                ? new $util.LongBits(message.nft_listing_period_initial.low >>> 0, message.nft_listing_period_initial.high >>> 0).toNumber(
                    true,
                  )
                : message.nft_listing_period_initial;
        if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty('nft_listing_cancel_required_seconds'))
          if (typeof message.nft_listing_cancel_required_seconds === 'number')
            object.nft_listing_cancel_required_seconds =
              options.longs === String ? String(message.nft_listing_cancel_required_seconds) : message.nft_listing_cancel_required_seconds;
          else
            object.nft_listing_cancel_required_seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_cancel_required_seconds)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_listing_cancel_required_seconds.low >>> 0,
                    message.nft_listing_cancel_required_seconds.high >>> 0,
                  ).toNumber(true)
                : message.nft_listing_cancel_required_seconds;
        if (message.nft_listing_cancel_fee_percentage != null && message.hasOwnProperty('nft_listing_cancel_fee_percentage'))
          if (typeof message.nft_listing_cancel_fee_percentage === 'number')
            object.nft_listing_cancel_fee_percentage =
              options.longs === String ? String(message.nft_listing_cancel_fee_percentage) : message.nft_listing_cancel_fee_percentage;
          else
            object.nft_listing_cancel_fee_percentage =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_cancel_fee_percentage)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_listing_cancel_fee_percentage.low >>> 0,
                    message.nft_listing_cancel_fee_percentage.high >>> 0,
                  ).toNumber(true)
                : message.nft_listing_cancel_fee_percentage;
        if (message.nft_listing_gap_time != null && message.hasOwnProperty('nft_listing_gap_time'))
          if (typeof message.nft_listing_gap_time === 'number')
            object.nft_listing_gap_time = options.longs === String ? String(message.nft_listing_gap_time) : message.nft_listing_gap_time;
          else
            object.nft_listing_gap_time =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_gap_time)
                : options.longs === Number
                ? new $util.LongBits(message.nft_listing_gap_time.low >>> 0, message.nft_listing_gap_time.high >>> 0).toNumber(true)
                : message.nft_listing_gap_time;
        if (message.bid_cancel_required_seconds != null && message.hasOwnProperty('bid_cancel_required_seconds'))
          if (typeof message.bid_cancel_required_seconds === 'number')
            object.bid_cancel_required_seconds =
              options.longs === String ? String(message.bid_cancel_required_seconds) : message.bid_cancel_required_seconds;
          else
            object.bid_cancel_required_seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.bid_cancel_required_seconds)
                : options.longs === Number
                ? new $util.LongBits(
                    message.bid_cancel_required_seconds.low >>> 0,
                    message.bid_cancel_required_seconds.high >>> 0,
                  ).toNumber(true)
                : message.bid_cancel_required_seconds;
        if (message.bid_token_disburse_seconds_after_cancel != null && message.hasOwnProperty('bid_token_disburse_seconds_after_cancel'))
          if (typeof message.bid_token_disburse_seconds_after_cancel === 'number')
            object.bid_token_disburse_seconds_after_cancel =
              options.longs === String
                ? String(message.bid_token_disburse_seconds_after_cancel)
                : message.bid_token_disburse_seconds_after_cancel;
          else
            object.bid_token_disburse_seconds_after_cancel =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.bid_token_disburse_seconds_after_cancel)
                : options.longs === Number
                ? new $util.LongBits(
                    message.bid_token_disburse_seconds_after_cancel.low >>> 0,
                    message.bid_token_disburse_seconds_after_cancel.high >>> 0,
                  ).toNumber(true)
                : message.bid_token_disburse_seconds_after_cancel;
        if (message.nft_listing_full_payment_period != null && message.hasOwnProperty('nft_listing_full_payment_period'))
          if (typeof message.nft_listing_full_payment_period === 'number')
            object.nft_listing_full_payment_period =
              options.longs === String ? String(message.nft_listing_full_payment_period) : message.nft_listing_full_payment_period;
          else
            object.nft_listing_full_payment_period =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_full_payment_period)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_listing_full_payment_period.low >>> 0,
                    message.nft_listing_full_payment_period.high >>> 0,
                  ).toNumber(true)
                : message.nft_listing_full_payment_period;
        if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty('nft_listing_nft_delivery_period'))
          if (typeof message.nft_listing_nft_delivery_period === 'number')
            object.nft_listing_nft_delivery_period =
              options.longs === String ? String(message.nft_listing_nft_delivery_period) : message.nft_listing_nft_delivery_period;
          else
            object.nft_listing_nft_delivery_period =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_nft_delivery_period)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_listing_nft_delivery_period.low >>> 0,
                    message.nft_listing_nft_delivery_period.high >>> 0,
                  ).toNumber(true)
                : message.nft_listing_nft_delivery_period;
        if (message.nft_creator_share_percentage != null && message.hasOwnProperty('nft_creator_share_percentage'))
          if (typeof message.nft_creator_share_percentage === 'number')
            object.nft_creator_share_percentage =
              options.longs === String ? String(message.nft_creator_share_percentage) : message.nft_creator_share_percentage;
          else
            object.nft_creator_share_percentage =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_creator_share_percentage)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_creator_share_percentage.low >>> 0,
                    message.nft_creator_share_percentage.high >>> 0,
                  ).toNumber(true)
                : message.nft_creator_share_percentage;
        if (message.market_administrator != null && message.hasOwnProperty('market_administrator'))
          object.market_administrator = message.market_administrator;
        if (message.nft_listing_commission_fee != null && message.hasOwnProperty('nft_listing_commission_fee'))
          if (typeof message.nft_listing_commission_fee === 'number')
            object.nft_listing_commission_fee =
              options.longs === String ? String(message.nft_listing_commission_fee) : message.nft_listing_commission_fee;
          else
            object.nft_listing_commission_fee =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_commission_fee)
                : options.longs === Number
                ? new $util.LongBits(message.nft_listing_commission_fee.low >>> 0, message.nft_listing_commission_fee.high >>> 0).toNumber(
                    true,
                  )
                : message.nft_listing_commission_fee;
        if (message.nft_listing_extend_seconds != null && message.hasOwnProperty('nft_listing_extend_seconds'))
          if (typeof message.nft_listing_extend_seconds === 'number')
            object.nft_listing_extend_seconds =
              options.longs === String ? String(message.nft_listing_extend_seconds) : message.nft_listing_extend_seconds;
          else
            object.nft_listing_extend_seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_extend_seconds)
                : options.longs === Number
                ? new $util.LongBits(message.nft_listing_extend_seconds.low >>> 0, message.nft_listing_extend_seconds.high >>> 0).toNumber(
                    true,
                  )
                : message.nft_listing_extend_seconds;
        if (message.nft_listing_period_extend_fee_per_hour != null && message.hasOwnProperty('nft_listing_period_extend_fee_per_hour'))
          object.nft_listing_period_extend_fee_per_hour = $root.cosmos.base.v1beta1.Coin.toObject(
            message.nft_listing_period_extend_fee_per_hour,
            options,
          );
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    nftmarket.EventListNft = (function () {
      /**
       * Properties of an EventListNft.
       * @memberof ununifi.nftmarket
       * @interface IEventListNft
       * @property {string|null} [owner] EventListNft owner
       * @property {string|null} [class_id] EventListNft class_id
       * @property {string|null} [nft_id] EventListNft nft_id
       */

      /**
       * Constructs a new EventListNft.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventListNft.
       * @implements IEventListNft
       * @constructor
       * @param {ununifi.nftmarket.IEventListNft=} [properties] Properties to set
       */
      function EventListNft(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventListNft owner.
       * @member {string} owner
       * @memberof ununifi.nftmarket.EventListNft
       * @instance
       */
      EventListNft.prototype.owner = '';

      /**
       * EventListNft class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventListNft
       * @instance
       */
      EventListNft.prototype.class_id = '';

      /**
       * EventListNft nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventListNft
       * @instance
       */
      EventListNft.prototype.nft_id = '';

      /**
       * Encodes the specified EventListNft message. Does not implicitly {@link ununifi.nftmarket.EventListNft.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventListNft
       * @static
       * @param {ununifi.nftmarket.IEventListNft} message EventListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventListNft.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventListNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventListNft.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventListNft
       * @static
       * @param {ununifi.nftmarket.IEventListNft} message EventListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventListNft.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventListNft message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventListNft} EventListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventListNft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventListNft();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventListNft message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventListNft} EventListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventListNft.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventListNft message.
       * @function verify
       * @memberof ununifi.nftmarket.EventListNft
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventListNft.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventListNft message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventListNft
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventListNft} EventListNft
       */
      EventListNft.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventListNft) return object;
        let message = new $root.ununifi.nftmarket.EventListNft();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventListNft message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventListNft
       * @static
       * @param {ununifi.nftmarket.EventListNft} message EventListNft
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventListNft.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventListNft to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventListNft
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventListNft.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventListNft;
    })();

    nftmarket.EventCancelListNfting = (function () {
      /**
       * Properties of an EventCancelListNfting.
       * @memberof ununifi.nftmarket
       * @interface IEventCancelListNfting
       * @property {string|null} [owner] EventCancelListNfting owner
       * @property {string|null} [class_id] EventCancelListNfting class_id
       * @property {string|null} [nft_id] EventCancelListNfting nft_id
       */

      /**
       * Constructs a new EventCancelListNfting.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventCancelListNfting.
       * @implements IEventCancelListNfting
       * @constructor
       * @param {ununifi.nftmarket.IEventCancelListNfting=} [properties] Properties to set
       */
      function EventCancelListNfting(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventCancelListNfting owner.
       * @member {string} owner
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @instance
       */
      EventCancelListNfting.prototype.owner = '';

      /**
       * EventCancelListNfting class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @instance
       */
      EventCancelListNfting.prototype.class_id = '';

      /**
       * EventCancelListNfting nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @instance
       */
      EventCancelListNfting.prototype.nft_id = '';

      /**
       * Encodes the specified EventCancelListNfting message. Does not implicitly {@link ununifi.nftmarket.EventCancelListNfting.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @static
       * @param {ununifi.nftmarket.IEventCancelListNfting} message EventCancelListNfting message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelListNfting.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventCancelListNfting message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventCancelListNfting.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @static
       * @param {ununifi.nftmarket.IEventCancelListNfting} message EventCancelListNfting message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelListNfting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventCancelListNfting message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventCancelListNfting} EventCancelListNfting
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelListNfting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventCancelListNfting();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventCancelListNfting message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventCancelListNfting} EventCancelListNfting
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelListNfting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventCancelListNfting message.
       * @function verify
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventCancelListNfting.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventCancelListNfting message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventCancelListNfting} EventCancelListNfting
       */
      EventCancelListNfting.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventCancelListNfting) return object;
        let message = new $root.ununifi.nftmarket.EventCancelListNfting();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventCancelListNfting message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @static
       * @param {ununifi.nftmarket.EventCancelListNfting} message EventCancelListNfting
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventCancelListNfting.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventCancelListNfting to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventCancelListNfting
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventCancelListNfting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventCancelListNfting;
    })();

    nftmarket.EventExpandListingPeriod = (function () {
      /**
       * Properties of an EventExpandListingPeriod.
       * @memberof ununifi.nftmarket
       * @interface IEventExpandListingPeriod
       * @property {string|null} [owner] EventExpandListingPeriod owner
       * @property {string|null} [class_id] EventExpandListingPeriod class_id
       * @property {string|null} [nft_id] EventExpandListingPeriod nft_id
       */

      /**
       * Constructs a new EventExpandListingPeriod.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventExpandListingPeriod.
       * @implements IEventExpandListingPeriod
       * @constructor
       * @param {ununifi.nftmarket.IEventExpandListingPeriod=} [properties] Properties to set
       */
      function EventExpandListingPeriod(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventExpandListingPeriod owner.
       * @member {string} owner
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @instance
       */
      EventExpandListingPeriod.prototype.owner = '';

      /**
       * EventExpandListingPeriod class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @instance
       */
      EventExpandListingPeriod.prototype.class_id = '';

      /**
       * EventExpandListingPeriod nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @instance
       */
      EventExpandListingPeriod.prototype.nft_id = '';

      /**
       * Encodes the specified EventExpandListingPeriod message. Does not implicitly {@link ununifi.nftmarket.EventExpandListingPeriod.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @static
       * @param {ununifi.nftmarket.IEventExpandListingPeriod} message EventExpandListingPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventExpandListingPeriod.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventExpandListingPeriod message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventExpandListingPeriod.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @static
       * @param {ununifi.nftmarket.IEventExpandListingPeriod} message EventExpandListingPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventExpandListingPeriod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventExpandListingPeriod message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventExpandListingPeriod} EventExpandListingPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventExpandListingPeriod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventExpandListingPeriod();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventExpandListingPeriod message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventExpandListingPeriod} EventExpandListingPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventExpandListingPeriod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventExpandListingPeriod message.
       * @function verify
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventExpandListingPeriod.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventExpandListingPeriod message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventExpandListingPeriod} EventExpandListingPeriod
       */
      EventExpandListingPeriod.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventExpandListingPeriod) return object;
        let message = new $root.ununifi.nftmarket.EventExpandListingPeriod();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventExpandListingPeriod message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @static
       * @param {ununifi.nftmarket.EventExpandListingPeriod} message EventExpandListingPeriod
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventExpandListingPeriod.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventExpandListingPeriod to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventExpandListingPeriod
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventExpandListingPeriod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventExpandListingPeriod;
    })();

    nftmarket.EventSellingDecision = (function () {
      /**
       * Properties of an EventSellingDecision.
       * @memberof ununifi.nftmarket
       * @interface IEventSellingDecision
       * @property {string|null} [owner] EventSellingDecision owner
       * @property {string|null} [class_id] EventSellingDecision class_id
       * @property {string|null} [nft_id] EventSellingDecision nft_id
       */

      /**
       * Constructs a new EventSellingDecision.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventSellingDecision.
       * @implements IEventSellingDecision
       * @constructor
       * @param {ununifi.nftmarket.IEventSellingDecision=} [properties] Properties to set
       */
      function EventSellingDecision(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventSellingDecision owner.
       * @member {string} owner
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @instance
       */
      EventSellingDecision.prototype.owner = '';

      /**
       * EventSellingDecision class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @instance
       */
      EventSellingDecision.prototype.class_id = '';

      /**
       * EventSellingDecision nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @instance
       */
      EventSellingDecision.prototype.nft_id = '';

      /**
       * Encodes the specified EventSellingDecision message. Does not implicitly {@link ununifi.nftmarket.EventSellingDecision.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @static
       * @param {ununifi.nftmarket.IEventSellingDecision} message EventSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventSellingDecision.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventSellingDecision.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @static
       * @param {ununifi.nftmarket.IEventSellingDecision} message EventSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventSellingDecision message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventSellingDecision} EventSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventSellingDecision.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventSellingDecision();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventSellingDecision message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventSellingDecision} EventSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventSellingDecision.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventSellingDecision message.
       * @function verify
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventSellingDecision.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventSellingDecision message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventSellingDecision} EventSellingDecision
       */
      EventSellingDecision.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventSellingDecision) return object;
        let message = new $root.ununifi.nftmarket.EventSellingDecision();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventSellingDecision message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @static
       * @param {ununifi.nftmarket.EventSellingDecision} message EventSellingDecision
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventSellingDecision.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventSellingDecision to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventSellingDecision
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventSellingDecision.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventSellingDecision;
    })();

    nftmarket.EventEndListNfting = (function () {
      /**
       * Properties of an EventEndListNfting.
       * @memberof ununifi.nftmarket
       * @interface IEventEndListNfting
       * @property {string|null} [owner] EventEndListNfting owner
       * @property {string|null} [class_id] EventEndListNfting class_id
       * @property {string|null} [nft_id] EventEndListNfting nft_id
       */

      /**
       * Constructs a new EventEndListNfting.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventEndListNfting.
       * @implements IEventEndListNfting
       * @constructor
       * @param {ununifi.nftmarket.IEventEndListNfting=} [properties] Properties to set
       */
      function EventEndListNfting(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventEndListNfting owner.
       * @member {string} owner
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @instance
       */
      EventEndListNfting.prototype.owner = '';

      /**
       * EventEndListNfting class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @instance
       */
      EventEndListNfting.prototype.class_id = '';

      /**
       * EventEndListNfting nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @instance
       */
      EventEndListNfting.prototype.nft_id = '';

      /**
       * Encodes the specified EventEndListNfting message. Does not implicitly {@link ununifi.nftmarket.EventEndListNfting.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @static
       * @param {ununifi.nftmarket.IEventEndListNfting} message EventEndListNfting message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventEndListNfting.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventEndListNfting message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventEndListNfting.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @static
       * @param {ununifi.nftmarket.IEventEndListNfting} message EventEndListNfting message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventEndListNfting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventEndListNfting message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventEndListNfting} EventEndListNfting
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventEndListNfting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventEndListNfting();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventEndListNfting message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventEndListNfting} EventEndListNfting
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventEndListNfting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventEndListNfting message.
       * @function verify
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventEndListNfting.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventEndListNfting message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventEndListNfting} EventEndListNfting
       */
      EventEndListNfting.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventEndListNfting) return object;
        let message = new $root.ununifi.nftmarket.EventEndListNfting();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventEndListNfting message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @static
       * @param {ununifi.nftmarket.EventEndListNfting} message EventEndListNfting
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventEndListNfting.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventEndListNfting to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventEndListNfting
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventEndListNfting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventEndListNfting;
    })();

    nftmarket.EventPlaceBid = (function () {
      /**
       * Properties of an EventPlaceBid.
       * @memberof ununifi.nftmarket
       * @interface IEventPlaceBid
       * @property {string|null} [bidder] EventPlaceBid bidder
       * @property {string|null} [class_id] EventPlaceBid class_id
       * @property {string|null} [nft_id] EventPlaceBid nft_id
       * @property {string|null} [amount] EventPlaceBid amount
       */

      /**
       * Constructs a new EventPlaceBid.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventPlaceBid.
       * @implements IEventPlaceBid
       * @constructor
       * @param {ununifi.nftmarket.IEventPlaceBid=} [properties] Properties to set
       */
      function EventPlaceBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPlaceBid bidder.
       * @member {string} bidder
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.bidder = '';

      /**
       * EventPlaceBid class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.class_id = '';

      /**
       * EventPlaceBid nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.nft_id = '';

      /**
       * EventPlaceBid amount.
       * @member {string} amount
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.amount = '';

      /**
       * Encodes the specified EventPlaceBid message. Does not implicitly {@link ununifi.nftmarket.EventPlaceBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @static
       * @param {ununifi.nftmarket.IEventPlaceBid} message EventPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPlaceBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified EventPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventPlaceBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @static
       * @param {ununifi.nftmarket.IEventPlaceBid} message EventPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPlaceBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventPlaceBid} EventPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPlaceBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventPlaceBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPlaceBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventPlaceBid} EventPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPlaceBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPlaceBid message.
       * @function verify
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPlaceBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates an EventPlaceBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventPlaceBid} EventPlaceBid
       */
      EventPlaceBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventPlaceBid) return object;
        let message = new $root.ununifi.nftmarket.EventPlaceBid();
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from an EventPlaceBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @static
       * @param {ununifi.nftmarket.EventPlaceBid} message EventPlaceBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPlaceBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.bidder = '';
          object.class_id = '';
          object.nft_id = '';
          object.amount = '';
        }
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this EventPlaceBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventPlaceBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPlaceBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPlaceBid;
    })();

    nftmarket.EventCancelBid = (function () {
      /**
       * Properties of an EventCancelBid.
       * @memberof ununifi.nftmarket
       * @interface IEventCancelBid
       * @property {string|null} [bidder] EventCancelBid bidder
       * @property {string|null} [class_id] EventCancelBid class_id
       * @property {string|null} [nft_id] EventCancelBid nft_id
       */

      /**
       * Constructs a new EventCancelBid.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventCancelBid.
       * @implements IEventCancelBid
       * @constructor
       * @param {ununifi.nftmarket.IEventCancelBid=} [properties] Properties to set
       */
      function EventCancelBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventCancelBid bidder.
       * @member {string} bidder
       * @memberof ununifi.nftmarket.EventCancelBid
       * @instance
       */
      EventCancelBid.prototype.bidder = '';

      /**
       * EventCancelBid class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventCancelBid
       * @instance
       */
      EventCancelBid.prototype.class_id = '';

      /**
       * EventCancelBid nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventCancelBid
       * @instance
       */
      EventCancelBid.prototype.nft_id = '';

      /**
       * Encodes the specified EventCancelBid message. Does not implicitly {@link ununifi.nftmarket.EventCancelBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventCancelBid
       * @static
       * @param {ununifi.nftmarket.IEventCancelBid} message EventCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventCancelBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventCancelBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventCancelBid
       * @static
       * @param {ununifi.nftmarket.IEventCancelBid} message EventCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventCancelBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventCancelBid} EventCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventCancelBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventCancelBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventCancelBid} EventCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventCancelBid message.
       * @function verify
       * @memberof ununifi.nftmarket.EventCancelBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventCancelBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventCancelBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventCancelBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventCancelBid} EventCancelBid
       */
      EventCancelBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventCancelBid) return object;
        let message = new $root.ununifi.nftmarket.EventCancelBid();
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventCancelBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventCancelBid
       * @static
       * @param {ununifi.nftmarket.EventCancelBid} message EventCancelBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventCancelBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.bidder = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventCancelBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventCancelBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventCancelBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventCancelBid;
    })();

    nftmarket.EventPayFullBid = (function () {
      /**
       * Properties of an EventPayFullBid.
       * @memberof ununifi.nftmarket
       * @interface IEventPayFullBid
       * @property {string|null} [bidder] EventPayFullBid bidder
       * @property {string|null} [class_id] EventPayFullBid class_id
       * @property {string|null} [nft_id] EventPayFullBid nft_id
       */

      /**
       * Constructs a new EventPayFullBid.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventPayFullBid.
       * @implements IEventPayFullBid
       * @constructor
       * @param {ununifi.nftmarket.IEventPayFullBid=} [properties] Properties to set
       */
      function EventPayFullBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPayFullBid bidder.
       * @member {string} bidder
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @instance
       */
      EventPayFullBid.prototype.bidder = '';

      /**
       * EventPayFullBid class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @instance
       */
      EventPayFullBid.prototype.class_id = '';

      /**
       * EventPayFullBid nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @instance
       */
      EventPayFullBid.prototype.nft_id = '';

      /**
       * Encodes the specified EventPayFullBid message. Does not implicitly {@link ununifi.nftmarket.EventPayFullBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @static
       * @param {ununifi.nftmarket.IEventPayFullBid} message EventPayFullBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPayFullBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventPayFullBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventPayFullBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @static
       * @param {ununifi.nftmarket.IEventPayFullBid} message EventPayFullBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPayFullBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPayFullBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventPayFullBid} EventPayFullBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPayFullBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventPayFullBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPayFullBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventPayFullBid} EventPayFullBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPayFullBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPayFullBid message.
       * @function verify
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPayFullBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventPayFullBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventPayFullBid} EventPayFullBid
       */
      EventPayFullBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventPayFullBid) return object;
        let message = new $root.ununifi.nftmarket.EventPayFullBid();
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventPayFullBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @static
       * @param {ununifi.nftmarket.EventPayFullBid} message EventPayFullBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPayFullBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.bidder = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventPayFullBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventPayFullBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPayFullBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPayFullBid;
    })();

    nftmarket.EventBorrow = (function () {
      /**
       * Properties of an EventBorrow.
       * @memberof ununifi.nftmarket
       * @interface IEventBorrow
       * @property {string|null} [borrower] EventBorrow borrower
       * @property {string|null} [class_id] EventBorrow class_id
       * @property {string|null} [nft_id] EventBorrow nft_id
       * @property {string|null} [amount] EventBorrow amount
       */

      /**
       * Constructs a new EventBorrow.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventBorrow.
       * @implements IEventBorrow
       * @constructor
       * @param {ununifi.nftmarket.IEventBorrow=} [properties] Properties to set
       */
      function EventBorrow(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventBorrow borrower.
       * @member {string} borrower
       * @memberof ununifi.nftmarket.EventBorrow
       * @instance
       */
      EventBorrow.prototype.borrower = '';

      /**
       * EventBorrow class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventBorrow
       * @instance
       */
      EventBorrow.prototype.class_id = '';

      /**
       * EventBorrow nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventBorrow
       * @instance
       */
      EventBorrow.prototype.nft_id = '';

      /**
       * EventBorrow amount.
       * @member {string} amount
       * @memberof ununifi.nftmarket.EventBorrow
       * @instance
       */
      EventBorrow.prototype.amount = '';

      /**
       * Encodes the specified EventBorrow message. Does not implicitly {@link ununifi.nftmarket.EventBorrow.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventBorrow
       * @static
       * @param {ununifi.nftmarket.IEventBorrow} message EventBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBorrow.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.borrower != null && Object.hasOwnProperty.call(message, 'borrower'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.borrower);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified EventBorrow message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventBorrow.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventBorrow
       * @static
       * @param {ununifi.nftmarket.IEventBorrow} message EventBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBorrow.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventBorrow message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventBorrow} EventBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBorrow.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventBorrow();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.borrower = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventBorrow message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventBorrow} EventBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBorrow.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventBorrow message.
       * @function verify
       * @memberof ununifi.nftmarket.EventBorrow
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventBorrow.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.borrower != null && message.hasOwnProperty('borrower'))
          if (!$util.isString(message.borrower)) return 'borrower: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates an EventBorrow message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventBorrow
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventBorrow} EventBorrow
       */
      EventBorrow.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventBorrow) return object;
        let message = new $root.ununifi.nftmarket.EventBorrow();
        if (object.borrower != null) message.borrower = String(object.borrower);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from an EventBorrow message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventBorrow
       * @static
       * @param {ununifi.nftmarket.EventBorrow} message EventBorrow
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventBorrow.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.borrower = '';
          object.class_id = '';
          object.nft_id = '';
          object.amount = '';
        }
        if (message.borrower != null && message.hasOwnProperty('borrower')) object.borrower = message.borrower;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this EventBorrow to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventBorrow
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventBorrow.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventBorrow;
    })();

    nftmarket.EventRepay = (function () {
      /**
       * Properties of an EventRepay.
       * @memberof ununifi.nftmarket
       * @interface IEventRepay
       * @property {string|null} [repayer] EventRepay repayer
       * @property {string|null} [class_id] EventRepay class_id
       * @property {string|null} [nft_id] EventRepay nft_id
       * @property {string|null} [amount] EventRepay amount
       */

      /**
       * Constructs a new EventRepay.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventRepay.
       * @implements IEventRepay
       * @constructor
       * @param {ununifi.nftmarket.IEventRepay=} [properties] Properties to set
       */
      function EventRepay(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventRepay repayer.
       * @member {string} repayer
       * @memberof ununifi.nftmarket.EventRepay
       * @instance
       */
      EventRepay.prototype.repayer = '';

      /**
       * EventRepay class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventRepay
       * @instance
       */
      EventRepay.prototype.class_id = '';

      /**
       * EventRepay nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventRepay
       * @instance
       */
      EventRepay.prototype.nft_id = '';

      /**
       * EventRepay amount.
       * @member {string} amount
       * @memberof ununifi.nftmarket.EventRepay
       * @instance
       */
      EventRepay.prototype.amount = '';

      /**
       * Encodes the specified EventRepay message. Does not implicitly {@link ununifi.nftmarket.EventRepay.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventRepay
       * @static
       * @param {ununifi.nftmarket.IEventRepay} message EventRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRepay.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.repayer != null && Object.hasOwnProperty.call(message, 'repayer'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.repayer);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified EventRepay message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventRepay.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventRepay
       * @static
       * @param {ununifi.nftmarket.IEventRepay} message EventRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRepay.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventRepay message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventRepay} EventRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRepay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventRepay();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.repayer = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventRepay message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventRepay} EventRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRepay.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventRepay message.
       * @function verify
       * @memberof ununifi.nftmarket.EventRepay
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventRepay.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.repayer != null && message.hasOwnProperty('repayer'))
          if (!$util.isString(message.repayer)) return 'repayer: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates an EventRepay message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventRepay
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventRepay} EventRepay
       */
      EventRepay.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventRepay) return object;
        let message = new $root.ununifi.nftmarket.EventRepay();
        if (object.repayer != null) message.repayer = String(object.repayer);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from an EventRepay message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventRepay
       * @static
       * @param {ununifi.nftmarket.EventRepay} message EventRepay
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventRepay.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.repayer = '';
          object.class_id = '';
          object.nft_id = '';
          object.amount = '';
        }
        if (message.repayer != null && message.hasOwnProperty('repayer')) object.repayer = message.repayer;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this EventRepay to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventRepay
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventRepay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventRepay;
    })();

    nftmarket.EventLiquidate = (function () {
      /**
       * Properties of an EventLiquidate.
       * @memberof ununifi.nftmarket
       * @interface IEventLiquidate
       * @property {string|null} [liquidator] EventLiquidate liquidator
       * @property {string|null} [class_id] EventLiquidate class_id
       * @property {string|null} [nft_id] EventLiquidate nft_id
       */

      /**
       * Constructs a new EventLiquidate.
       * @memberof ununifi.nftmarket
       * @classdesc Represents an EventLiquidate.
       * @implements IEventLiquidate
       * @constructor
       * @param {ununifi.nftmarket.IEventLiquidate=} [properties] Properties to set
       */
      function EventLiquidate(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventLiquidate liquidator.
       * @member {string} liquidator
       * @memberof ununifi.nftmarket.EventLiquidate
       * @instance
       */
      EventLiquidate.prototype.liquidator = '';

      /**
       * EventLiquidate class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmarket.EventLiquidate
       * @instance
       */
      EventLiquidate.prototype.class_id = '';

      /**
       * EventLiquidate nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmarket.EventLiquidate
       * @instance
       */
      EventLiquidate.prototype.nft_id = '';

      /**
       * Encodes the specified EventLiquidate message. Does not implicitly {@link ununifi.nftmarket.EventLiquidate.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.EventLiquidate
       * @static
       * @param {ununifi.nftmarket.IEventLiquidate} message EventLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLiquidate.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.liquidator != null && Object.hasOwnProperty.call(message, 'liquidator'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.liquidator);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventLiquidate message, length delimited. Does not implicitly {@link ununifi.nftmarket.EventLiquidate.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.EventLiquidate
       * @static
       * @param {ununifi.nftmarket.IEventLiquidate} message EventLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventLiquidate message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.EventLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.EventLiquidate} EventLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLiquidate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.EventLiquidate();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.liquidator = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventLiquidate message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.EventLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.EventLiquidate} EventLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLiquidate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventLiquidate message.
       * @function verify
       * @memberof ununifi.nftmarket.EventLiquidate
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventLiquidate.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.liquidator != null && message.hasOwnProperty('liquidator'))
          if (!$util.isString(message.liquidator)) return 'liquidator: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventLiquidate message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.EventLiquidate
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.EventLiquidate} EventLiquidate
       */
      EventLiquidate.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.EventLiquidate) return object;
        let message = new $root.ununifi.nftmarket.EventLiquidate();
        if (object.liquidator != null) message.liquidator = String(object.liquidator);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventLiquidate message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.EventLiquidate
       * @static
       * @param {ununifi.nftmarket.EventLiquidate} message EventLiquidate
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventLiquidate.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.liquidator = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.liquidator != null && message.hasOwnProperty('liquidator')) object.liquidator = message.liquidator;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventLiquidate to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.EventLiquidate
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventLiquidate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventLiquidate;
    })();

    nftmarket.PaymentStatus = (function () {
      /**
       * Properties of a PaymentStatus.
       * @memberof ununifi.nftmarket
       * @interface IPaymentStatus
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] PaymentStatus nft_id
       * @property {string|null} [bidder] PaymentStatus bidder
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] PaymentStatus amount
       * @property {boolean|null} [automatic_payment] PaymentStatus automatic_payment
       * @property {string|null} [paid_amount] PaymentStatus paid_amount
       * @property {google.protobuf.ITimestamp|null} [bid_time] PaymentStatus bid_time
       * @property {ununifi.nftmarket.ListingState|null} [state] PaymentStatus state
       * @property {boolean|null} [all_paid] PaymentStatus all_paid
       */

      /**
       * Constructs a new PaymentStatus.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a PaymentStatus.
       * @implements IPaymentStatus
       * @constructor
       * @param {ununifi.nftmarket.IPaymentStatus=} [properties] Properties to set
       */
      function PaymentStatus(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PaymentStatus nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.nft_id = null;

      /**
       * PaymentStatus bidder.
       * @member {string} bidder
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.bidder = '';

      /**
       * PaymentStatus amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.amount = null;

      /**
       * PaymentStatus automatic_payment.
       * @member {boolean} automatic_payment
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.automatic_payment = false;

      /**
       * PaymentStatus paid_amount.
       * @member {string} paid_amount
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.paid_amount = '';

      /**
       * PaymentStatus bid_time.
       * @member {google.protobuf.ITimestamp|null|undefined} bid_time
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.bid_time = null;

      /**
       * PaymentStatus state.
       * @member {ununifi.nftmarket.ListingState} state
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.state = 0;

      /**
       * PaymentStatus all_paid.
       * @member {boolean} all_paid
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       */
      PaymentStatus.prototype.all_paid = false;

      /**
       * Encodes the specified PaymentStatus message. Does not implicitly {@link ununifi.nftmarket.PaymentStatus.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.PaymentStatus
       * @static
       * @param {ununifi.nftmarket.IPaymentStatus} message PaymentStatus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PaymentStatus.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bidder);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.automatic_payment);
        if (message.paid_amount != null && Object.hasOwnProperty.call(message, 'paid_amount'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.paid_amount);
        if (message.bid_time != null && Object.hasOwnProperty.call(message, 'bid_time'))
          $root.google.protobuf.Timestamp.encode(message.bid_time, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
        if (message.state != null && Object.hasOwnProperty.call(message, 'state'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.state);
        if (message.all_paid != null && Object.hasOwnProperty.call(message, 'all_paid'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.all_paid);
        return writer;
      };

      /**
       * Encodes the specified PaymentStatus message, length delimited. Does not implicitly {@link ununifi.nftmarket.PaymentStatus.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.PaymentStatus
       * @static
       * @param {ununifi.nftmarket.IPaymentStatus} message PaymentStatus message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PaymentStatus.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PaymentStatus message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.PaymentStatus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.PaymentStatus} PaymentStatus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PaymentStatus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.PaymentStatus();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 2:
              message.bidder = reader.string();
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.automatic_payment = reader.bool();
              break;
            case 5:
              message.paid_amount = reader.string();
              break;
            case 6:
              message.bid_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.state = reader.int32();
              break;
            case 8:
              message.all_paid = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PaymentStatus message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.PaymentStatus
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.PaymentStatus} PaymentStatus
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PaymentStatus.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PaymentStatus message.
       * @function verify
       * @memberof ununifi.nftmarket.PaymentStatus
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PaymentStatus.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
        if (message.paid_amount != null && message.hasOwnProperty('paid_amount'))
          if (!$util.isString(message.paid_amount)) return 'paid_amount: string expected';
        if (message.bid_time != null && message.hasOwnProperty('bid_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.bid_time);
          if (error) return 'bid_time.' + error;
        }
        if (message.state != null && message.hasOwnProperty('state'))
          switch (message.state) {
            default:
              return 'state: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
          }
        if (message.all_paid != null && message.hasOwnProperty('all_paid'))
          if (typeof message.all_paid !== 'boolean') return 'all_paid: boolean expected';
        return null;
      };

      /**
       * Creates a PaymentStatus message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.PaymentStatus
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.PaymentStatus} PaymentStatus
       */
      PaymentStatus.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.PaymentStatus) return object;
        let message = new $root.ununifi.nftmarket.PaymentStatus();
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.PaymentStatus.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.PaymentStatus.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
        if (object.paid_amount != null) message.paid_amount = String(object.paid_amount);
        if (object.bid_time != null) {
          if (typeof object.bid_time !== 'object') throw TypeError('.ununifi.nftmarket.PaymentStatus.bid_time: object expected');
          message.bid_time = $root.google.protobuf.Timestamp.fromObject(object.bid_time);
        }
        switch (object.state) {
          case 'LISTING':
          case 0:
            message.state = 0;
            break;
          case 'BIDDING':
          case 1:
            message.state = 1;
            break;
          case 'SELLING_DECISION':
          case 2:
            message.state = 2;
            break;
          case 'LIQUIDATION':
          case 3:
            message.state = 3;
            break;
          case 'END_LISTING':
          case 4:
            message.state = 4;
            break;
          case 'SUCCESSFUL_BID':
          case 5:
            message.state = 5;
            break;
        }
        if (object.all_paid != null) message.all_paid = Boolean(object.all_paid);
        return message;
      };

      /**
       * Creates a plain object from a PaymentStatus message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.PaymentStatus
       * @static
       * @param {ununifi.nftmarket.PaymentStatus} message PaymentStatus
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PaymentStatus.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.nft_id = null;
          object.bidder = '';
          object.amount = null;
          object.automatic_payment = false;
          object.paid_amount = '';
          object.bid_time = null;
          object.state = options.enums === String ? 'LISTING' : 0;
          object.all_paid = false;
        }
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          object.automatic_payment = message.automatic_payment;
        if (message.paid_amount != null && message.hasOwnProperty('paid_amount')) object.paid_amount = message.paid_amount;
        if (message.bid_time != null && message.hasOwnProperty('bid_time'))
          object.bid_time = $root.google.protobuf.Timestamp.toObject(message.bid_time, options);
        if (message.state != null && message.hasOwnProperty('state'))
          object.state = options.enums === String ? $root.ununifi.nftmarket.ListingState[message.state] : message.state;
        if (message.all_paid != null && message.hasOwnProperty('all_paid')) object.all_paid = message.all_paid;
        return object;
      };

      /**
       * Converts this PaymentStatus to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.PaymentStatus
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PaymentStatus.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PaymentStatus;
    })();

    nftmarket.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#mintNft}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef MintNftCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgMintNftResponse} [response] MsgMintNftResponse
       */

      /**
       * Calls MintNft.
       * @function mintNft
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgMintNft} request MsgMintNft message or plain object
       * @param {ununifi.nftmarket.Msg.MintNftCallback} callback Node-style callback called with the error, if any, and MsgMintNftResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.mintNft = function mintNft(request, callback) {
          return this.rpcCall(mintNft, $root.ununifi.nftmarket.MsgMintNft, $root.ununifi.nftmarket.MsgMintNftResponse, request, callback);
        }),
        'name',
        { value: 'MintNft' },
      );

      /**
       * Calls MintNft.
       * @function mintNft
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgMintNft} request MsgMintNft message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgMintNftResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#listNft}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef ListNftCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgListNftResponse} [response] MsgListNftResponse
       */

      /**
       * Calls ListNft.
       * @function listNft
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgListNft} request MsgListNft message or plain object
       * @param {ununifi.nftmarket.Msg.ListNftCallback} callback Node-style callback called with the error, if any, and MsgListNftResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.listNft = function listNft(request, callback) {
          return this.rpcCall(listNft, $root.ununifi.nftmarket.MsgListNft, $root.ununifi.nftmarket.MsgListNftResponse, request, callback);
        }),
        'name',
        { value: 'ListNft' },
      );

      /**
       * Calls ListNft.
       * @function listNft
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgListNft} request MsgListNft message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgListNftResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#cancelNftListing}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef CancelNftListingCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgCancelNftListingResponse} [response] MsgCancelNftListingResponse
       */

      /**
       * Calls CancelNftListing.
       * @function cancelNftListing
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgCancelNftListing} request MsgCancelNftListing message or plain object
       * @param {ununifi.nftmarket.Msg.CancelNftListingCallback} callback Node-style callback called with the error, if any, and MsgCancelNftListingResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.cancelNftListing = function cancelNftListing(request, callback) {
          return this.rpcCall(
            cancelNftListing,
            $root.ununifi.nftmarket.MsgCancelNftListing,
            $root.ununifi.nftmarket.MsgCancelNftListingResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CancelNftListing' },
      );

      /**
       * Calls CancelNftListing.
       * @function cancelNftListing
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgCancelNftListing} request MsgCancelNftListing message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgCancelNftListingResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#expandListingPeriod}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef ExpandListingPeriodCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgExpandListingPeriodResponse} [response] MsgExpandListingPeriodResponse
       */

      /**
       * Calls ExpandListingPeriod.
       * @function expandListingPeriod
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgExpandListingPeriod} request MsgExpandListingPeriod message or plain object
       * @param {ununifi.nftmarket.Msg.ExpandListingPeriodCallback} callback Node-style callback called with the error, if any, and MsgExpandListingPeriodResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.expandListingPeriod = function expandListingPeriod(request, callback) {
          return this.rpcCall(
            expandListingPeriod,
            $root.ununifi.nftmarket.MsgExpandListingPeriod,
            $root.ununifi.nftmarket.MsgExpandListingPeriodResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ExpandListingPeriod' },
      );

      /**
       * Calls ExpandListingPeriod.
       * @function expandListingPeriod
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgExpandListingPeriod} request MsgExpandListingPeriod message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgExpandListingPeriodResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#placeBid}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef PlaceBidCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgPlaceBidResponse} [response] MsgPlaceBidResponse
       */

      /**
       * Calls PlaceBid.
       * @function placeBid
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgPlaceBid} request MsgPlaceBid message or plain object
       * @param {ununifi.nftmarket.Msg.PlaceBidCallback} callback Node-style callback called with the error, if any, and MsgPlaceBidResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.placeBid = function placeBid(request, callback) {
          return this.rpcCall(
            placeBid,
            $root.ununifi.nftmarket.MsgPlaceBid,
            $root.ununifi.nftmarket.MsgPlaceBidResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PlaceBid' },
      );

      /**
       * Calls PlaceBid.
       * @function placeBid
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgPlaceBid} request MsgPlaceBid message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgPlaceBidResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#cancelBid}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef CancelBidCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgCancelBidResponse} [response] MsgCancelBidResponse
       */

      /**
       * Calls CancelBid.
       * @function cancelBid
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgCancelBid} request MsgCancelBid message or plain object
       * @param {ununifi.nftmarket.Msg.CancelBidCallback} callback Node-style callback called with the error, if any, and MsgCancelBidResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.cancelBid = function cancelBid(request, callback) {
          return this.rpcCall(
            cancelBid,
            $root.ununifi.nftmarket.MsgCancelBid,
            $root.ununifi.nftmarket.MsgCancelBidResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CancelBid' },
      );

      /**
       * Calls CancelBid.
       * @function cancelBid
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgCancelBid} request MsgCancelBid message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgCancelBidResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#sellingDecision}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef SellingDecisionCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgSellingDecisionResponse} [response] MsgSellingDecisionResponse
       */

      /**
       * Calls SellingDecision.
       * @function sellingDecision
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgSellingDecision} request MsgSellingDecision message or plain object
       * @param {ununifi.nftmarket.Msg.SellingDecisionCallback} callback Node-style callback called with the error, if any, and MsgSellingDecisionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.sellingDecision = function sellingDecision(request, callback) {
          return this.rpcCall(
            sellingDecision,
            $root.ununifi.nftmarket.MsgSellingDecision,
            $root.ununifi.nftmarket.MsgSellingDecisionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'SellingDecision' },
      );

      /**
       * Calls SellingDecision.
       * @function sellingDecision
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgSellingDecision} request MsgSellingDecision message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgSellingDecisionResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#endNftListing}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef EndNftListingCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgEndNftListingResponse} [response] MsgEndNftListingResponse
       */

      /**
       * Calls EndNftListing.
       * @function endNftListing
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgEndNftListing} request MsgEndNftListing message or plain object
       * @param {ununifi.nftmarket.Msg.EndNftListingCallback} callback Node-style callback called with the error, if any, and MsgEndNftListingResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.endNftListing = function endNftListing(request, callback) {
          return this.rpcCall(
            endNftListing,
            $root.ununifi.nftmarket.MsgEndNftListing,
            $root.ununifi.nftmarket.MsgEndNftListingResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EndNftListing' },
      );

      /**
       * Calls EndNftListing.
       * @function endNftListing
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgEndNftListing} request MsgEndNftListing message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgEndNftListingResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#payFullBid}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef PayFullBidCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgPayFullBidResponse} [response] MsgPayFullBidResponse
       */

      /**
       * Calls PayFullBid.
       * @function payFullBid
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgPayFullBid} request MsgPayFullBid message or plain object
       * @param {ununifi.nftmarket.Msg.PayFullBidCallback} callback Node-style callback called with the error, if any, and MsgPayFullBidResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.payFullBid = function payFullBid(request, callback) {
          return this.rpcCall(
            payFullBid,
            $root.ununifi.nftmarket.MsgPayFullBid,
            $root.ununifi.nftmarket.MsgPayFullBidResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PayFullBid' },
      );

      /**
       * Calls PayFullBid.
       * @function payFullBid
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgPayFullBid} request MsgPayFullBid message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgPayFullBidResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#borrow}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef BorrowCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgBorrowResponse} [response] MsgBorrowResponse
       */

      /**
       * Calls Borrow.
       * @function borrow
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgBorrow} request MsgBorrow message or plain object
       * @param {ununifi.nftmarket.Msg.BorrowCallback} callback Node-style callback called with the error, if any, and MsgBorrowResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.borrow = function borrow(request, callback) {
          return this.rpcCall(borrow, $root.ununifi.nftmarket.MsgBorrow, $root.ununifi.nftmarket.MsgBorrowResponse, request, callback);
        }),
        'name',
        { value: 'Borrow' },
      );

      /**
       * Calls Borrow.
       * @function borrow
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgBorrow} request MsgBorrow message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgBorrowResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#repay}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef RepayCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgRepayResponse} [response] MsgRepayResponse
       */

      /**
       * Calls Repay.
       * @function repay
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgRepay} request MsgRepay message or plain object
       * @param {ununifi.nftmarket.Msg.RepayCallback} callback Node-style callback called with the error, if any, and MsgRepayResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.repay = function repay(request, callback) {
          return this.rpcCall(repay, $root.ununifi.nftmarket.MsgRepay, $root.ununifi.nftmarket.MsgRepayResponse, request, callback);
        }),
        'name',
        { value: 'Repay' },
      );

      /**
       * Calls Repay.
       * @function repay
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgRepay} request MsgRepay message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgRepayResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#mintStableCoin}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef MintStableCoinCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgMintStableCoinResponse} [response] MsgMintStableCoinResponse
       */

      /**
       * Calls MintStableCoin.
       * @function mintStableCoin
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgMintStableCoin} request MsgMintStableCoin message or plain object
       * @param {ununifi.nftmarket.Msg.MintStableCoinCallback} callback Node-style callback called with the error, if any, and MsgMintStableCoinResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.mintStableCoin = function mintStableCoin(request, callback) {
          return this.rpcCall(
            mintStableCoin,
            $root.ununifi.nftmarket.MsgMintStableCoin,
            $root.ununifi.nftmarket.MsgMintStableCoinResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'MintStableCoin' },
      );

      /**
       * Calls MintStableCoin.
       * @function mintStableCoin
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgMintStableCoin} request MsgMintStableCoin message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgMintStableCoinResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#burnStableCoin}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef BurnStableCoinCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgBurnStableCoinResponse} [response] MsgBurnStableCoinResponse
       */

      /**
       * Calls BurnStableCoin.
       * @function burnStableCoin
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgBurnStableCoin} request MsgBurnStableCoin message or plain object
       * @param {ununifi.nftmarket.Msg.BurnStableCoinCallback} callback Node-style callback called with the error, if any, and MsgBurnStableCoinResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.burnStableCoin = function burnStableCoin(request, callback) {
          return this.rpcCall(
            burnStableCoin,
            $root.ununifi.nftmarket.MsgBurnStableCoin,
            $root.ununifi.nftmarket.MsgBurnStableCoinResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'BurnStableCoin' },
      );

      /**
       * Calls BurnStableCoin.
       * @function burnStableCoin
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgBurnStableCoin} request MsgBurnStableCoin message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgBurnStableCoinResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmarket.Msg#liquidate}.
       * @memberof ununifi.nftmarket.Msg
       * @typedef LiquidateCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmarket.MsgLiquidateResponse} [response] MsgLiquidateResponse
       */

      /**
       * Calls Liquidate.
       * @function liquidate
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgLiquidate} request MsgLiquidate message or plain object
       * @param {ununifi.nftmarket.Msg.LiquidateCallback} callback Node-style callback called with the error, if any, and MsgLiquidateResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.liquidate = function liquidate(request, callback) {
          return this.rpcCall(
            liquidate,
            $root.ununifi.nftmarket.MsgLiquidate,
            $root.ununifi.nftmarket.MsgLiquidateResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Liquidate' },
      );

      /**
       * Calls Liquidate.
       * @function liquidate
       * @memberof ununifi.nftmarket.Msg
       * @instance
       * @param {ununifi.nftmarket.IMsgLiquidate} request MsgLiquidate message or plain object
       * @returns {Promise<ununifi.nftmarket.MsgLiquidateResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    nftmarket.MsgMintNft = (function () {
      /**
       * Properties of a MsgMintNft.
       * @memberof ununifi.nftmarket
       * @interface IMsgMintNft
       * @property {string|null} [sender] MsgMintNft sender
       * @property {string|null} [classId] MsgMintNft classId
       * @property {string|null} [nftId] MsgMintNft nftId
       * @property {string|null} [nftUri] MsgMintNft nftUri
       * @property {string|null} [nftUriHash] MsgMintNft nftUriHash
       */

      /**
       * Constructs a new MsgMintNft.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgMintNft.
       * @implements IMsgMintNft
       * @constructor
       * @param {ununifi.nftmarket.IMsgMintNft=} [properties] Properties to set
       */
      function MsgMintNft(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgMintNft sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgMintNft
       * @instance
       */
      MsgMintNft.prototype.sender = '';

      /**
       * MsgMintNft classId.
       * @member {string} classId
       * @memberof ununifi.nftmarket.MsgMintNft
       * @instance
       */
      MsgMintNft.prototype.classId = '';

      /**
       * MsgMintNft nftId.
       * @member {string} nftId
       * @memberof ununifi.nftmarket.MsgMintNft
       * @instance
       */
      MsgMintNft.prototype.nftId = '';

      /**
       * MsgMintNft nftUri.
       * @member {string} nftUri
       * @memberof ununifi.nftmarket.MsgMintNft
       * @instance
       */
      MsgMintNft.prototype.nftUri = '';

      /**
       * MsgMintNft nftUriHash.
       * @member {string} nftUriHash
       * @memberof ununifi.nftmarket.MsgMintNft
       * @instance
       */
      MsgMintNft.prototype.nftUriHash = '';

      /**
       * Encodes the specified MsgMintNft message. Does not implicitly {@link ununifi.nftmarket.MsgMintNft.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgMintNft
       * @static
       * @param {ununifi.nftmarket.IMsgMintNft} message MsgMintNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNft.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.classId != null && Object.hasOwnProperty.call(message, 'classId'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.classId);
        if (message.nftId != null && Object.hasOwnProperty.call(message, 'nftId'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nftId);
        if (message.nftUri != null && Object.hasOwnProperty.call(message, 'nftUri'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.nftUri);
        if (message.nftUriHash != null && Object.hasOwnProperty.call(message, 'nftUriHash'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.nftUriHash);
        return writer;
      };

      /**
       * Encodes the specified MsgMintNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintNft.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgMintNft
       * @static
       * @param {ununifi.nftmarket.IMsgMintNft} message MsgMintNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNft.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintNft message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgMintNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgMintNft} MsgMintNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgMintNft();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.classId = reader.string();
              break;
            case 3:
              message.nftId = reader.string();
              break;
            case 4:
              message.nftUri = reader.string();
              break;
            case 5:
              message.nftUriHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintNft message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgMintNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgMintNft} MsgMintNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNft.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintNft message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgMintNft
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintNft.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.classId != null && message.hasOwnProperty('classId'))
          if (!$util.isString(message.classId)) return 'classId: string expected';
        if (message.nftId != null && message.hasOwnProperty('nftId')) if (!$util.isString(message.nftId)) return 'nftId: string expected';
        if (message.nftUri != null && message.hasOwnProperty('nftUri'))
          if (!$util.isString(message.nftUri)) return 'nftUri: string expected';
        if (message.nftUriHash != null && message.hasOwnProperty('nftUriHash'))
          if (!$util.isString(message.nftUriHash)) return 'nftUriHash: string expected';
        return null;
      };

      /**
       * Creates a MsgMintNft message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgMintNft
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgMintNft} MsgMintNft
       */
      MsgMintNft.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgMintNft) return object;
        let message = new $root.ununifi.nftmarket.MsgMintNft();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.classId != null) message.classId = String(object.classId);
        if (object.nftId != null) message.nftId = String(object.nftId);
        if (object.nftUri != null) message.nftUri = String(object.nftUri);
        if (object.nftUriHash != null) message.nftUriHash = String(object.nftUriHash);
        return message;
      };

      /**
       * Creates a plain object from a MsgMintNft message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgMintNft
       * @static
       * @param {ununifi.nftmarket.MsgMintNft} message MsgMintNft
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintNft.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.classId = '';
          object.nftId = '';
          object.nftUri = '';
          object.nftUriHash = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.classId != null && message.hasOwnProperty('classId')) object.classId = message.classId;
        if (message.nftId != null && message.hasOwnProperty('nftId')) object.nftId = message.nftId;
        if (message.nftUri != null && message.hasOwnProperty('nftUri')) object.nftUri = message.nftUri;
        if (message.nftUriHash != null && message.hasOwnProperty('nftUriHash')) object.nftUriHash = message.nftUriHash;
        return object;
      };

      /**
       * Converts this MsgMintNft to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgMintNft
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintNft.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintNft;
    })();

    nftmarket.MsgMintNftResponse = (function () {
      /**
       * Properties of a MsgMintNftResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgMintNftResponse
       */

      /**
       * Constructs a new MsgMintNftResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgMintNftResponse.
       * @implements IMsgMintNftResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgMintNftResponse=} [properties] Properties to set
       */
      function MsgMintNftResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgMintNftResponse message. Does not implicitly {@link ununifi.nftmarket.MsgMintNftResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @static
       * @param {ununifi.nftmarket.IMsgMintNftResponse} message MsgMintNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNftResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgMintNftResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintNftResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @static
       * @param {ununifi.nftmarket.IMsgMintNftResponse} message MsgMintNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNftResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintNftResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgMintNftResponse} MsgMintNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNftResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgMintNftResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintNftResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgMintNftResponse} MsgMintNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNftResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintNftResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintNftResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgMintNftResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgMintNftResponse} MsgMintNftResponse
       */
      MsgMintNftResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgMintNftResponse) return object;
        return new $root.ununifi.nftmarket.MsgMintNftResponse();
      };

      /**
       * Creates a plain object from a MsgMintNftResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @static
       * @param {ununifi.nftmarket.MsgMintNftResponse} message MsgMintNftResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintNftResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgMintNftResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgMintNftResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintNftResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintNftResponse;
    })();

    nftmarket.MsgListNft = (function () {
      /**
       * Properties of a MsgListNft.
       * @memberof ununifi.nftmarket
       * @interface IMsgListNft
       * @property {string|null} [sender] MsgListNft sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgListNft nft_id
       * @property {ununifi.nftmarket.ListingType|null} [listing_type] MsgListNft listing_type
       * @property {string|null} [bid_token] MsgListNft bid_token
       * @property {string|null} [min_bid] MsgListNft min_bid
       * @property {Long|null} [bid_active_rank] MsgListNft bid_active_rank
       */

      /**
       * Constructs a new MsgListNft.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgListNft.
       * @implements IMsgListNft
       * @constructor
       * @param {ununifi.nftmarket.IMsgListNft=} [properties] Properties to set
       */
      function MsgListNft(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgListNft sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgListNft
       * @instance
       */
      MsgListNft.prototype.sender = '';

      /**
       * MsgListNft nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgListNft
       * @instance
       */
      MsgListNft.prototype.nft_id = null;

      /**
       * MsgListNft listing_type.
       * @member {ununifi.nftmarket.ListingType} listing_type
       * @memberof ununifi.nftmarket.MsgListNft
       * @instance
       */
      MsgListNft.prototype.listing_type = 0;

      /**
       * MsgListNft bid_token.
       * @member {string} bid_token
       * @memberof ununifi.nftmarket.MsgListNft
       * @instance
       */
      MsgListNft.prototype.bid_token = '';

      /**
       * MsgListNft min_bid.
       * @member {string} min_bid
       * @memberof ununifi.nftmarket.MsgListNft
       * @instance
       */
      MsgListNft.prototype.min_bid = '';

      /**
       * MsgListNft bid_active_rank.
       * @member {Long} bid_active_rank
       * @memberof ununifi.nftmarket.MsgListNft
       * @instance
       */
      MsgListNft.prototype.bid_active_rank = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified MsgListNft message. Does not implicitly {@link ununifi.nftmarket.MsgListNft.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgListNft
       * @static
       * @param {ununifi.nftmarket.IMsgListNft} message MsgListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNft.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.listing_type != null && Object.hasOwnProperty.call(message, 'listing_type'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.listing_type);
        if (message.bid_token != null && Object.hasOwnProperty.call(message, 'bid_token'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.bid_token);
        if (message.min_bid != null && Object.hasOwnProperty.call(message, 'min_bid'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.min_bid);
        if (message.bid_active_rank != null && Object.hasOwnProperty.call(message, 'bid_active_rank'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.bid_active_rank);
        return writer;
      };

      /**
       * Encodes the specified MsgListNft message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgListNft.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgListNft
       * @static
       * @param {ununifi.nftmarket.IMsgListNft} message MsgListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNft.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgListNft message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgListNft} MsgListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgListNft();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 3:
              message.listing_type = reader.int32();
              break;
            case 4:
              message.bid_token = reader.string();
              break;
            case 5:
              message.min_bid = reader.string();
              break;
            case 6:
              message.bid_active_rank = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgListNft message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgListNft} MsgListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNft.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgListNft message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgListNft
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgListNft.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.listing_type != null && message.hasOwnProperty('listing_type'))
          switch (message.listing_type) {
            default:
              return 'listing_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.bid_token != null && message.hasOwnProperty('bid_token'))
          if (!$util.isString(message.bid_token)) return 'bid_token: string expected';
        if (message.min_bid != null && message.hasOwnProperty('min_bid'))
          if (!$util.isString(message.min_bid)) return 'min_bid: string expected';
        if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
          if (
            !$util.isInteger(message.bid_active_rank) &&
            !(message.bid_active_rank && $util.isInteger(message.bid_active_rank.low) && $util.isInteger(message.bid_active_rank.high))
          )
            return 'bid_active_rank: integer|Long expected';
        return null;
      };

      /**
       * Creates a MsgListNft message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgListNft
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgListNft} MsgListNft
       */
      MsgListNft.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgListNft) return object;
        let message = new $root.ununifi.nftmarket.MsgListNft();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgListNft.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        switch (object.listing_type) {
          case 'DIRECT_ASSET_BORROW':
          case 0:
            message.listing_type = 0;
            break;
          case 'SYNTHETIC_ASSET_CREATION':
          case 1:
            message.listing_type = 1;
            break;
          case 'LATE_SHIPPING':
          case 2:
            message.listing_type = 2;
            break;
        }
        if (object.bid_token != null) message.bid_token = String(object.bid_token);
        if (object.min_bid != null) message.min_bid = String(object.min_bid);
        if (object.bid_active_rank != null)
          if ($util.Long) (message.bid_active_rank = $util.Long.fromValue(object.bid_active_rank)).unsigned = true;
          else if (typeof object.bid_active_rank === 'string') message.bid_active_rank = parseInt(object.bid_active_rank, 10);
          else if (typeof object.bid_active_rank === 'number') message.bid_active_rank = object.bid_active_rank;
          else if (typeof object.bid_active_rank === 'object')
            message.bid_active_rank = new $util.LongBits(object.bid_active_rank.low >>> 0, object.bid_active_rank.high >>> 0).toNumber(
              true,
            );
        return message;
      };

      /**
       * Creates a plain object from a MsgListNft message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgListNft
       * @static
       * @param {ununifi.nftmarket.MsgListNft} message MsgListNft
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgListNft.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
          object.listing_type = options.enums === String ? 'DIRECT_ASSET_BORROW' : 0;
          object.bid_token = '';
          object.min_bid = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.bid_active_rank = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.bid_active_rank = options.longs === String ? '0' : 0;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.listing_type != null && message.hasOwnProperty('listing_type'))
          object.listing_type = options.enums === String ? $root.ununifi.nftmarket.ListingType[message.listing_type] : message.listing_type;
        if (message.bid_token != null && message.hasOwnProperty('bid_token')) object.bid_token = message.bid_token;
        if (message.min_bid != null && message.hasOwnProperty('min_bid')) object.min_bid = message.min_bid;
        if (message.bid_active_rank != null && message.hasOwnProperty('bid_active_rank'))
          if (typeof message.bid_active_rank === 'number')
            object.bid_active_rank = options.longs === String ? String(message.bid_active_rank) : message.bid_active_rank;
          else
            object.bid_active_rank =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.bid_active_rank)
                : options.longs === Number
                ? new $util.LongBits(message.bid_active_rank.low >>> 0, message.bid_active_rank.high >>> 0).toNumber(true)
                : message.bid_active_rank;
        return object;
      };

      /**
       * Converts this MsgListNft to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgListNft
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgListNft.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgListNft;
    })();

    nftmarket.MsgListNftResponse = (function () {
      /**
       * Properties of a MsgListNftResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgListNftResponse
       */

      /**
       * Constructs a new MsgListNftResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgListNftResponse.
       * @implements IMsgListNftResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgListNftResponse=} [properties] Properties to set
       */
      function MsgListNftResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgListNftResponse message. Does not implicitly {@link ununifi.nftmarket.MsgListNftResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @static
       * @param {ununifi.nftmarket.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNftResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgListNftResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgListNftResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @static
       * @param {ununifi.nftmarket.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNftResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgListNftResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgListNftResponse} MsgListNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNftResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgListNftResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgListNftResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgListNftResponse} MsgListNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNftResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgListNftResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgListNftResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgListNftResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgListNftResponse} MsgListNftResponse
       */
      MsgListNftResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgListNftResponse) return object;
        return new $root.ununifi.nftmarket.MsgListNftResponse();
      };

      /**
       * Creates a plain object from a MsgListNftResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @static
       * @param {ununifi.nftmarket.MsgListNftResponse} message MsgListNftResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgListNftResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgListNftResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgListNftResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgListNftResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgListNftResponse;
    })();

    nftmarket.MsgCancelNftListing = (function () {
      /**
       * Properties of a MsgCancelNftListing.
       * @memberof ununifi.nftmarket
       * @interface IMsgCancelNftListing
       * @property {string|null} [sender] MsgCancelNftListing sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgCancelNftListing nft_id
       */

      /**
       * Constructs a new MsgCancelNftListing.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgCancelNftListing.
       * @implements IMsgCancelNftListing
       * @constructor
       * @param {ununifi.nftmarket.IMsgCancelNftListing=} [properties] Properties to set
       */
      function MsgCancelNftListing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCancelNftListing sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @instance
       */
      MsgCancelNftListing.prototype.sender = '';

      /**
       * MsgCancelNftListing nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @instance
       */
      MsgCancelNftListing.prototype.nft_id = null;

      /**
       * Encodes the specified MsgCancelNftListing message. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @static
       * @param {ununifi.nftmarket.IMsgCancelNftListing} message MsgCancelNftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelNftListing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelNftListing message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @static
       * @param {ununifi.nftmarket.IMsgCancelNftListing} message MsgCancelNftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelNftListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelNftListing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgCancelNftListing} MsgCancelNftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelNftListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgCancelNftListing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelNftListing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgCancelNftListing} MsgCancelNftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelNftListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelNftListing message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelNftListing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgCancelNftListing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgCancelNftListing} MsgCancelNftListing
       */
      MsgCancelNftListing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgCancelNftListing) return object;
        let message = new $root.ununifi.nftmarket.MsgCancelNftListing();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgCancelNftListing.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgCancelNftListing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @static
       * @param {ununifi.nftmarket.MsgCancelNftListing} message MsgCancelNftListing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelNftListing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgCancelNftListing to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgCancelNftListing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelNftListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelNftListing;
    })();

    nftmarket.MsgCancelNftListingResponse = (function () {
      /**
       * Properties of a MsgCancelNftListingResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgCancelNftListingResponse
       */

      /**
       * Constructs a new MsgCancelNftListingResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgCancelNftListingResponse.
       * @implements IMsgCancelNftListingResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgCancelNftListingResponse=} [properties] Properties to set
       */
      function MsgCancelNftListingResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgCancelNftListingResponse message. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListingResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @static
       * @param {ununifi.nftmarket.IMsgCancelNftListingResponse} message MsgCancelNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelNftListingResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelNftListingResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @static
       * @param {ununifi.nftmarket.IMsgCancelNftListingResponse} message MsgCancelNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelNftListingResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgCancelNftListingResponse} MsgCancelNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelNftListingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgCancelNftListingResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelNftListingResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgCancelNftListingResponse} MsgCancelNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelNftListingResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelNftListingResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgCancelNftListingResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgCancelNftListingResponse} MsgCancelNftListingResponse
       */
      MsgCancelNftListingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgCancelNftListingResponse) return object;
        return new $root.ununifi.nftmarket.MsgCancelNftListingResponse();
      };

      /**
       * Creates a plain object from a MsgCancelNftListingResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @static
       * @param {ununifi.nftmarket.MsgCancelNftListingResponse} message MsgCancelNftListingResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelNftListingResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCancelNftListingResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgCancelNftListingResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelNftListingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelNftListingResponse;
    })();

    nftmarket.MsgExpandListingPeriod = (function () {
      /**
       * Properties of a MsgExpandListingPeriod.
       * @memberof ununifi.nftmarket
       * @interface IMsgExpandListingPeriod
       * @property {string|null} [sender] MsgExpandListingPeriod sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgExpandListingPeriod nft_id
       */

      /**
       * Constructs a new MsgExpandListingPeriod.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgExpandListingPeriod.
       * @implements IMsgExpandListingPeriod
       * @constructor
       * @param {ununifi.nftmarket.IMsgExpandListingPeriod=} [properties] Properties to set
       */
      function MsgExpandListingPeriod(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgExpandListingPeriod sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @instance
       */
      MsgExpandListingPeriod.prototype.sender = '';

      /**
       * MsgExpandListingPeriod nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @instance
       */
      MsgExpandListingPeriod.prototype.nft_id = null;

      /**
       * Encodes the specified MsgExpandListingPeriod message. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriod.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @static
       * @param {ununifi.nftmarket.IMsgExpandListingPeriod} message MsgExpandListingPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgExpandListingPeriod.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgExpandListingPeriod message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriod.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @static
       * @param {ununifi.nftmarket.IMsgExpandListingPeriod} message MsgExpandListingPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgExpandListingPeriod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgExpandListingPeriod message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgExpandListingPeriod} MsgExpandListingPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgExpandListingPeriod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgExpandListingPeriod();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgExpandListingPeriod message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgExpandListingPeriod} MsgExpandListingPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgExpandListingPeriod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgExpandListingPeriod message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgExpandListingPeriod.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgExpandListingPeriod message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgExpandListingPeriod} MsgExpandListingPeriod
       */
      MsgExpandListingPeriod.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgExpandListingPeriod) return object;
        let message = new $root.ununifi.nftmarket.MsgExpandListingPeriod();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgExpandListingPeriod.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgExpandListingPeriod message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @static
       * @param {ununifi.nftmarket.MsgExpandListingPeriod} message MsgExpandListingPeriod
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgExpandListingPeriod.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgExpandListingPeriod to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgExpandListingPeriod
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgExpandListingPeriod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgExpandListingPeriod;
    })();

    nftmarket.MsgExpandListingPeriodResponse = (function () {
      /**
       * Properties of a MsgExpandListingPeriodResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgExpandListingPeriodResponse
       */

      /**
       * Constructs a new MsgExpandListingPeriodResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgExpandListingPeriodResponse.
       * @implements IMsgExpandListingPeriodResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgExpandListingPeriodResponse=} [properties] Properties to set
       */
      function MsgExpandListingPeriodResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgExpandListingPeriodResponse message. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriodResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @static
       * @param {ununifi.nftmarket.IMsgExpandListingPeriodResponse} message MsgExpandListingPeriodResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgExpandListingPeriodResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgExpandListingPeriodResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgExpandListingPeriodResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @static
       * @param {ununifi.nftmarket.IMsgExpandListingPeriodResponse} message MsgExpandListingPeriodResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgExpandListingPeriodResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgExpandListingPeriodResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgExpandListingPeriodResponse} MsgExpandListingPeriodResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgExpandListingPeriodResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgExpandListingPeriodResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgExpandListingPeriodResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgExpandListingPeriodResponse} MsgExpandListingPeriodResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgExpandListingPeriodResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgExpandListingPeriodResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgExpandListingPeriodResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgExpandListingPeriodResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgExpandListingPeriodResponse} MsgExpandListingPeriodResponse
       */
      MsgExpandListingPeriodResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgExpandListingPeriodResponse) return object;
        return new $root.ununifi.nftmarket.MsgExpandListingPeriodResponse();
      };

      /**
       * Creates a plain object from a MsgExpandListingPeriodResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @static
       * @param {ununifi.nftmarket.MsgExpandListingPeriodResponse} message MsgExpandListingPeriodResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgExpandListingPeriodResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgExpandListingPeriodResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgExpandListingPeriodResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgExpandListingPeriodResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgExpandListingPeriodResponse;
    })();

    nftmarket.MsgPlaceBid = (function () {
      /**
       * Properties of a MsgPlaceBid.
       * @memberof ununifi.nftmarket
       * @interface IMsgPlaceBid
       * @property {string|null} [sender] MsgPlaceBid sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgPlaceBid nft_id
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgPlaceBid amount
       * @property {boolean|null} [automatic_payment] MsgPlaceBid automatic_payment
       */

      /**
       * Constructs a new MsgPlaceBid.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgPlaceBid.
       * @implements IMsgPlaceBid
       * @constructor
       * @param {ununifi.nftmarket.IMsgPlaceBid=} [properties] Properties to set
       */
      function MsgPlaceBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgPlaceBid sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.sender = '';

      /**
       * MsgPlaceBid nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.nft_id = null;

      /**
       * MsgPlaceBid amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.amount = null;

      /**
       * MsgPlaceBid automatic_payment.
       * @member {boolean} automatic_payment
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.automatic_payment = false;

      /**
       * Encodes the specified MsgPlaceBid message. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @static
       * @param {ununifi.nftmarket.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.automatic_payment);
        return writer;
      };

      /**
       * Encodes the specified MsgPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @static
       * @param {ununifi.nftmarket.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPlaceBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgPlaceBid} MsgPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgPlaceBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.automatic_payment = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPlaceBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgPlaceBid} MsgPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPlaceBid message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPlaceBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
        return null;
      };

      /**
       * Creates a MsgPlaceBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgPlaceBid} MsgPlaceBid
       */
      MsgPlaceBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgPlaceBid) return object;
        let message = new $root.ununifi.nftmarket.MsgPlaceBid();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgPlaceBid.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.MsgPlaceBid.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
        return message;
      };

      /**
       * Creates a plain object from a MsgPlaceBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @static
       * @param {ununifi.nftmarket.MsgPlaceBid} message MsgPlaceBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPlaceBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
          object.amount = null;
          object.automatic_payment = false;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          object.automatic_payment = message.automatic_payment;
        return object;
      };

      /**
       * Converts this MsgPlaceBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgPlaceBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPlaceBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPlaceBid;
    })();

    nftmarket.MsgPlaceBidResponse = (function () {
      /**
       * Properties of a MsgPlaceBidResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgPlaceBidResponse
       */

      /**
       * Constructs a new MsgPlaceBidResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgPlaceBidResponse.
       * @implements IMsgPlaceBidResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgPlaceBidResponse=} [properties] Properties to set
       */
      function MsgPlaceBidResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgPlaceBidResponse message. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBidResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @static
       * @param {ununifi.nftmarket.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBidResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgPlaceBidResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPlaceBidResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @static
       * @param {ununifi.nftmarket.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPlaceBidResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgPlaceBidResponse} MsgPlaceBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBidResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgPlaceBidResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPlaceBidResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgPlaceBidResponse} MsgPlaceBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBidResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPlaceBidResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPlaceBidResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgPlaceBidResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgPlaceBidResponse} MsgPlaceBidResponse
       */
      MsgPlaceBidResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgPlaceBidResponse) return object;
        return new $root.ununifi.nftmarket.MsgPlaceBidResponse();
      };

      /**
       * Creates a plain object from a MsgPlaceBidResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @static
       * @param {ununifi.nftmarket.MsgPlaceBidResponse} message MsgPlaceBidResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPlaceBidResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgPlaceBidResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgPlaceBidResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPlaceBidResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPlaceBidResponse;
    })();

    nftmarket.MsgCancelBid = (function () {
      /**
       * Properties of a MsgCancelBid.
       * @memberof ununifi.nftmarket
       * @interface IMsgCancelBid
       * @property {string|null} [sender] MsgCancelBid sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgCancelBid nft_id
       */

      /**
       * Constructs a new MsgCancelBid.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgCancelBid.
       * @implements IMsgCancelBid
       * @constructor
       * @param {ununifi.nftmarket.IMsgCancelBid=} [properties] Properties to set
       */
      function MsgCancelBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCancelBid sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @instance
       */
      MsgCancelBid.prototype.sender = '';

      /**
       * MsgCancelBid nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @instance
       */
      MsgCancelBid.prototype.nft_id = null;

      /**
       * Encodes the specified MsgCancelBid message. Does not implicitly {@link ununifi.nftmarket.MsgCancelBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @static
       * @param {ununifi.nftmarket.IMsgCancelBid} message MsgCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @static
       * @param {ununifi.nftmarket.IMsgCancelBid} message MsgCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgCancelBid} MsgCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgCancelBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgCancelBid} MsgCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelBid message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgCancelBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgCancelBid} MsgCancelBid
       */
      MsgCancelBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgCancelBid) return object;
        let message = new $root.ununifi.nftmarket.MsgCancelBid();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgCancelBid.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgCancelBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @static
       * @param {ununifi.nftmarket.MsgCancelBid} message MsgCancelBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgCancelBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgCancelBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelBid;
    })();

    nftmarket.MsgCancelBidResponse = (function () {
      /**
       * Properties of a MsgCancelBidResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgCancelBidResponse
       */

      /**
       * Constructs a new MsgCancelBidResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgCancelBidResponse.
       * @implements IMsgCancelBidResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgCancelBidResponse=} [properties] Properties to set
       */
      function MsgCancelBidResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgCancelBidResponse message. Does not implicitly {@link ununifi.nftmarket.MsgCancelBidResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @static
       * @param {ununifi.nftmarket.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBidResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelBidResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgCancelBidResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @static
       * @param {ununifi.nftmarket.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelBidResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgCancelBidResponse} MsgCancelBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBidResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgCancelBidResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelBidResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgCancelBidResponse} MsgCancelBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBidResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelBidResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelBidResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgCancelBidResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgCancelBidResponse} MsgCancelBidResponse
       */
      MsgCancelBidResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgCancelBidResponse) return object;
        return new $root.ununifi.nftmarket.MsgCancelBidResponse();
      };

      /**
       * Creates a plain object from a MsgCancelBidResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @static
       * @param {ununifi.nftmarket.MsgCancelBidResponse} message MsgCancelBidResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelBidResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCancelBidResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgCancelBidResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelBidResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelBidResponse;
    })();

    nftmarket.MsgEndNftListing = (function () {
      /**
       * Properties of a MsgEndNftListing.
       * @memberof ununifi.nftmarket
       * @interface IMsgEndNftListing
       * @property {string|null} [sender] MsgEndNftListing sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgEndNftListing nft_id
       */

      /**
       * Constructs a new MsgEndNftListing.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgEndNftListing.
       * @implements IMsgEndNftListing
       * @constructor
       * @param {ununifi.nftmarket.IMsgEndNftListing=} [properties] Properties to set
       */
      function MsgEndNftListing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgEndNftListing sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @instance
       */
      MsgEndNftListing.prototype.sender = '';

      /**
       * MsgEndNftListing nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @instance
       */
      MsgEndNftListing.prototype.nft_id = null;

      /**
       * Encodes the specified MsgEndNftListing message. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @static
       * @param {ununifi.nftmarket.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgEndNftListing message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @static
       * @param {ununifi.nftmarket.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgEndNftListing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgEndNftListing} MsgEndNftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgEndNftListing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgEndNftListing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgEndNftListing} MsgEndNftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgEndNftListing message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgEndNftListing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgEndNftListing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgEndNftListing} MsgEndNftListing
       */
      MsgEndNftListing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgEndNftListing) return object;
        let message = new $root.ununifi.nftmarket.MsgEndNftListing();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgEndNftListing.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgEndNftListing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @static
       * @param {ununifi.nftmarket.MsgEndNftListing} message MsgEndNftListing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgEndNftListing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgEndNftListing to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgEndNftListing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgEndNftListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgEndNftListing;
    })();

    nftmarket.MsgEndNftListingResponse = (function () {
      /**
       * Properties of a MsgEndNftListingResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgEndNftListingResponse
       */

      /**
       * Constructs a new MsgEndNftListingResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgEndNftListingResponse.
       * @implements IMsgEndNftListingResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgEndNftListingResponse=} [properties] Properties to set
       */
      function MsgEndNftListingResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgEndNftListingResponse message. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListingResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @static
       * @param {ununifi.nftmarket.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListingResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgEndNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgEndNftListingResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @static
       * @param {ununifi.nftmarket.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgEndNftListingResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgEndNftListingResponse} MsgEndNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgEndNftListingResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgEndNftListingResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgEndNftListingResponse} MsgEndNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgEndNftListingResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgEndNftListingResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgEndNftListingResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgEndNftListingResponse} MsgEndNftListingResponse
       */
      MsgEndNftListingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgEndNftListingResponse) return object;
        return new $root.ununifi.nftmarket.MsgEndNftListingResponse();
      };

      /**
       * Creates a plain object from a MsgEndNftListingResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @static
       * @param {ununifi.nftmarket.MsgEndNftListingResponse} message MsgEndNftListingResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgEndNftListingResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgEndNftListingResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgEndNftListingResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgEndNftListingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgEndNftListingResponse;
    })();

    nftmarket.MsgSellingDecision = (function () {
      /**
       * Properties of a MsgSellingDecision.
       * @memberof ununifi.nftmarket
       * @interface IMsgSellingDecision
       * @property {string|null} [sender] MsgSellingDecision sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgSellingDecision nft_id
       */

      /**
       * Constructs a new MsgSellingDecision.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgSellingDecision.
       * @implements IMsgSellingDecision
       * @constructor
       * @param {ununifi.nftmarket.IMsgSellingDecision=} [properties] Properties to set
       */
      function MsgSellingDecision(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSellingDecision sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @instance
       */
      MsgSellingDecision.prototype.sender = '';

      /**
       * MsgSellingDecision nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @instance
       */
      MsgSellingDecision.prototype.nft_id = null;

      /**
       * Encodes the specified MsgSellingDecision message. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecision.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @static
       * @param {ununifi.nftmarket.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecision.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecision.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @static
       * @param {ununifi.nftmarket.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSellingDecision message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgSellingDecision} MsgSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecision.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgSellingDecision();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSellingDecision message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgSellingDecision} MsgSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecision.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSellingDecision message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSellingDecision.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgSellingDecision message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgSellingDecision} MsgSellingDecision
       */
      MsgSellingDecision.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgSellingDecision) return object;
        let message = new $root.ununifi.nftmarket.MsgSellingDecision();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgSellingDecision.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgSellingDecision message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @static
       * @param {ununifi.nftmarket.MsgSellingDecision} message MsgSellingDecision
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSellingDecision.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgSellingDecision to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgSellingDecision
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSellingDecision.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSellingDecision;
    })();

    nftmarket.MsgSellingDecisionResponse = (function () {
      /**
       * Properties of a MsgSellingDecisionResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgSellingDecisionResponse
       */

      /**
       * Constructs a new MsgSellingDecisionResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgSellingDecisionResponse.
       * @implements IMsgSellingDecisionResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgSellingDecisionResponse=} [properties] Properties to set
       */
      function MsgSellingDecisionResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgSellingDecisionResponse message. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecisionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @static
       * @param {ununifi.nftmarket.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecisionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSellingDecisionResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgSellingDecisionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @static
       * @param {ununifi.nftmarket.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecisionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgSellingDecisionResponse} MsgSellingDecisionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecisionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgSellingDecisionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgSellingDecisionResponse} MsgSellingDecisionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecisionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSellingDecisionResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSellingDecisionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgSellingDecisionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgSellingDecisionResponse} MsgSellingDecisionResponse
       */
      MsgSellingDecisionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgSellingDecisionResponse) return object;
        return new $root.ununifi.nftmarket.MsgSellingDecisionResponse();
      };

      /**
       * Creates a plain object from a MsgSellingDecisionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @static
       * @param {ununifi.nftmarket.MsgSellingDecisionResponse} message MsgSellingDecisionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSellingDecisionResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSellingDecisionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgSellingDecisionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSellingDecisionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSellingDecisionResponse;
    })();

    nftmarket.MsgPayFullBid = (function () {
      /**
       * Properties of a MsgPayFullBid.
       * @memberof ununifi.nftmarket
       * @interface IMsgPayFullBid
       * @property {string|null} [sender] MsgPayFullBid sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgPayFullBid nft_id
       */

      /**
       * Constructs a new MsgPayFullBid.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgPayFullBid.
       * @implements IMsgPayFullBid
       * @constructor
       * @param {ununifi.nftmarket.IMsgPayFullBid=} [properties] Properties to set
       */
      function MsgPayFullBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgPayFullBid sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @instance
       */
      MsgPayFullBid.prototype.sender = '';

      /**
       * MsgPayFullBid nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @instance
       */
      MsgPayFullBid.prototype.nft_id = null;

      /**
       * Encodes the specified MsgPayFullBid message. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @static
       * @param {ununifi.nftmarket.IMsgPayFullBid} message MsgPayFullBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayFullBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgPayFullBid message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @static
       * @param {ununifi.nftmarket.IMsgPayFullBid} message MsgPayFullBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayFullBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPayFullBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgPayFullBid} MsgPayFullBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayFullBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgPayFullBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPayFullBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgPayFullBid} MsgPayFullBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayFullBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPayFullBid message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPayFullBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgPayFullBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgPayFullBid} MsgPayFullBid
       */
      MsgPayFullBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgPayFullBid) return object;
        let message = new $root.ununifi.nftmarket.MsgPayFullBid();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgPayFullBid.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgPayFullBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @static
       * @param {ununifi.nftmarket.MsgPayFullBid} message MsgPayFullBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPayFullBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgPayFullBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgPayFullBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPayFullBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPayFullBid;
    })();

    nftmarket.MsgPayFullBidResponse = (function () {
      /**
       * Properties of a MsgPayFullBidResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgPayFullBidResponse
       */

      /**
       * Constructs a new MsgPayFullBidResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgPayFullBidResponse.
       * @implements IMsgPayFullBidResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgPayFullBidResponse=} [properties] Properties to set
       */
      function MsgPayFullBidResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgPayFullBidResponse message. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBidResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @static
       * @param {ununifi.nftmarket.IMsgPayFullBidResponse} message MsgPayFullBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayFullBidResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgPayFullBidResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgPayFullBidResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @static
       * @param {ununifi.nftmarket.IMsgPayFullBidResponse} message MsgPayFullBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayFullBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPayFullBidResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgPayFullBidResponse} MsgPayFullBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayFullBidResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgPayFullBidResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPayFullBidResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgPayFullBidResponse} MsgPayFullBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayFullBidResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPayFullBidResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPayFullBidResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgPayFullBidResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgPayFullBidResponse} MsgPayFullBidResponse
       */
      MsgPayFullBidResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgPayFullBidResponse) return object;
        return new $root.ununifi.nftmarket.MsgPayFullBidResponse();
      };

      /**
       * Creates a plain object from a MsgPayFullBidResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @static
       * @param {ununifi.nftmarket.MsgPayFullBidResponse} message MsgPayFullBidResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPayFullBidResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgPayFullBidResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgPayFullBidResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPayFullBidResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPayFullBidResponse;
    })();

    nftmarket.MsgBorrow = (function () {
      /**
       * Properties of a MsgBorrow.
       * @memberof ununifi.nftmarket
       * @interface IMsgBorrow
       * @property {string|null} [sender] MsgBorrow sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgBorrow nft_id
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgBorrow amount
       */

      /**
       * Constructs a new MsgBorrow.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgBorrow.
       * @implements IMsgBorrow
       * @constructor
       * @param {ununifi.nftmarket.IMsgBorrow=} [properties] Properties to set
       */
      function MsgBorrow(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgBorrow sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgBorrow
       * @instance
       */
      MsgBorrow.prototype.sender = '';

      /**
       * MsgBorrow nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgBorrow
       * @instance
       */
      MsgBorrow.prototype.nft_id = null;

      /**
       * MsgBorrow amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftmarket.MsgBorrow
       * @instance
       */
      MsgBorrow.prototype.amount = null;

      /**
       * Encodes the specified MsgBorrow message. Does not implicitly {@link ununifi.nftmarket.MsgBorrow.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgBorrow
       * @static
       * @param {ununifi.nftmarket.IMsgBorrow} message MsgBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrow.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgBorrow message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBorrow.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgBorrow
       * @static
       * @param {ununifi.nftmarket.IMsgBorrow} message MsgBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrow.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBorrow message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgBorrow} MsgBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrow.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgBorrow();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBorrow message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgBorrow} MsgBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrow.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBorrow message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgBorrow
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBorrow.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgBorrow message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgBorrow
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgBorrow} MsgBorrow
       */
      MsgBorrow.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgBorrow) return object;
        let message = new $root.ununifi.nftmarket.MsgBorrow();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgBorrow.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.MsgBorrow.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgBorrow message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgBorrow
       * @static
       * @param {ununifi.nftmarket.MsgBorrow} message MsgBorrow
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBorrow.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
          object.amount = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this MsgBorrow to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgBorrow
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBorrow.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBorrow;
    })();

    nftmarket.MsgBorrowResponse = (function () {
      /**
       * Properties of a MsgBorrowResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgBorrowResponse
       */

      /**
       * Constructs a new MsgBorrowResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgBorrowResponse.
       * @implements IMsgBorrowResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgBorrowResponse=} [properties] Properties to set
       */
      function MsgBorrowResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgBorrowResponse message. Does not implicitly {@link ununifi.nftmarket.MsgBorrowResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @static
       * @param {ununifi.nftmarket.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrowResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgBorrowResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBorrowResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @static
       * @param {ununifi.nftmarket.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrowResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBorrowResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgBorrowResponse} MsgBorrowResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrowResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgBorrowResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBorrowResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgBorrowResponse} MsgBorrowResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrowResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBorrowResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBorrowResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgBorrowResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgBorrowResponse} MsgBorrowResponse
       */
      MsgBorrowResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgBorrowResponse) return object;
        return new $root.ununifi.nftmarket.MsgBorrowResponse();
      };

      /**
       * Creates a plain object from a MsgBorrowResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @static
       * @param {ununifi.nftmarket.MsgBorrowResponse} message MsgBorrowResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBorrowResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgBorrowResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgBorrowResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBorrowResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBorrowResponse;
    })();

    nftmarket.MsgRepay = (function () {
      /**
       * Properties of a MsgRepay.
       * @memberof ununifi.nftmarket
       * @interface IMsgRepay
       * @property {string|null} [sender] MsgRepay sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgRepay nft_id
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgRepay amount
       */

      /**
       * Constructs a new MsgRepay.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgRepay.
       * @implements IMsgRepay
       * @constructor
       * @param {ununifi.nftmarket.IMsgRepay=} [properties] Properties to set
       */
      function MsgRepay(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRepay sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgRepay
       * @instance
       */
      MsgRepay.prototype.sender = '';

      /**
       * MsgRepay nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgRepay
       * @instance
       */
      MsgRepay.prototype.nft_id = null;

      /**
       * MsgRepay amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftmarket.MsgRepay
       * @instance
       */
      MsgRepay.prototype.amount = null;

      /**
       * Encodes the specified MsgRepay message. Does not implicitly {@link ununifi.nftmarket.MsgRepay.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgRepay
       * @static
       * @param {ununifi.nftmarket.IMsgRepay} message MsgRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepay.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgRepay message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgRepay.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgRepay
       * @static
       * @param {ununifi.nftmarket.IMsgRepay} message MsgRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepay.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRepay message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgRepay} MsgRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgRepay();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRepay message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgRepay} MsgRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepay.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRepay message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgRepay
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRepay.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgRepay message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgRepay
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgRepay} MsgRepay
       */
      MsgRepay.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgRepay) return object;
        let message = new $root.ununifi.nftmarket.MsgRepay();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgRepay.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftmarket.MsgRepay.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgRepay message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgRepay
       * @static
       * @param {ununifi.nftmarket.MsgRepay} message MsgRepay
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRepay.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
          object.amount = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this MsgRepay to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgRepay
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRepay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRepay;
    })();

    nftmarket.MsgRepayResponse = (function () {
      /**
       * Properties of a MsgRepayResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgRepayResponse
       */

      /**
       * Constructs a new MsgRepayResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgRepayResponse.
       * @implements IMsgRepayResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgRepayResponse=} [properties] Properties to set
       */
      function MsgRepayResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRepayResponse message. Does not implicitly {@link ununifi.nftmarket.MsgRepayResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @static
       * @param {ununifi.nftmarket.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRepayResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgRepayResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @static
       * @param {ununifi.nftmarket.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRepayResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgRepayResponse} MsgRepayResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgRepayResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRepayResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgRepayResponse} MsgRepayResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRepayResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRepayResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRepayResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgRepayResponse} MsgRepayResponse
       */
      MsgRepayResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgRepayResponse) return object;
        return new $root.ununifi.nftmarket.MsgRepayResponse();
      };

      /**
       * Creates a plain object from a MsgRepayResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @static
       * @param {ununifi.nftmarket.MsgRepayResponse} message MsgRepayResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRepayResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRepayResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgRepayResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRepayResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRepayResponse;
    })();

    nftmarket.MsgMintStableCoin = (function () {
      /**
       * Properties of a MsgMintStableCoin.
       * @memberof ununifi.nftmarket
       * @interface IMsgMintStableCoin
       * @property {string|null} [sender] MsgMintStableCoin sender
       */

      /**
       * Constructs a new MsgMintStableCoin.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgMintStableCoin.
       * @implements IMsgMintStableCoin
       * @constructor
       * @param {ununifi.nftmarket.IMsgMintStableCoin=} [properties] Properties to set
       */
      function MsgMintStableCoin(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgMintStableCoin sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @instance
       */
      MsgMintStableCoin.prototype.sender = '';

      /**
       * Encodes the specified MsgMintStableCoin message. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoin.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @static
       * @param {ununifi.nftmarket.IMsgMintStableCoin} message MsgMintStableCoin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintStableCoin.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        return writer;
      };

      /**
       * Encodes the specified MsgMintStableCoin message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoin.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @static
       * @param {ununifi.nftmarket.IMsgMintStableCoin} message MsgMintStableCoin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintStableCoin.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintStableCoin message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgMintStableCoin} MsgMintStableCoin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintStableCoin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgMintStableCoin();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintStableCoin message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgMintStableCoin} MsgMintStableCoin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintStableCoin.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintStableCoin message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintStableCoin.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        return null;
      };

      /**
       * Creates a MsgMintStableCoin message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgMintStableCoin} MsgMintStableCoin
       */
      MsgMintStableCoin.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgMintStableCoin) return object;
        let message = new $root.ununifi.nftmarket.MsgMintStableCoin();
        if (object.sender != null) message.sender = String(object.sender);
        return message;
      };

      /**
       * Creates a plain object from a MsgMintStableCoin message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @static
       * @param {ununifi.nftmarket.MsgMintStableCoin} message MsgMintStableCoin
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintStableCoin.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        return object;
      };

      /**
       * Converts this MsgMintStableCoin to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgMintStableCoin
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintStableCoin.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintStableCoin;
    })();

    nftmarket.MsgMintStableCoinResponse = (function () {
      /**
       * Properties of a MsgMintStableCoinResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgMintStableCoinResponse
       */

      /**
       * Constructs a new MsgMintStableCoinResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgMintStableCoinResponse.
       * @implements IMsgMintStableCoinResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgMintStableCoinResponse=} [properties] Properties to set
       */
      function MsgMintStableCoinResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgMintStableCoinResponse message. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoinResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @static
       * @param {ununifi.nftmarket.IMsgMintStableCoinResponse} message MsgMintStableCoinResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintStableCoinResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgMintStableCoinResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgMintStableCoinResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @static
       * @param {ununifi.nftmarket.IMsgMintStableCoinResponse} message MsgMintStableCoinResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintStableCoinResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintStableCoinResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgMintStableCoinResponse} MsgMintStableCoinResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintStableCoinResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgMintStableCoinResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintStableCoinResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgMintStableCoinResponse} MsgMintStableCoinResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintStableCoinResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintStableCoinResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintStableCoinResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgMintStableCoinResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgMintStableCoinResponse} MsgMintStableCoinResponse
       */
      MsgMintStableCoinResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgMintStableCoinResponse) return object;
        return new $root.ununifi.nftmarket.MsgMintStableCoinResponse();
      };

      /**
       * Creates a plain object from a MsgMintStableCoinResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @static
       * @param {ununifi.nftmarket.MsgMintStableCoinResponse} message MsgMintStableCoinResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintStableCoinResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgMintStableCoinResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgMintStableCoinResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintStableCoinResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintStableCoinResponse;
    })();

    nftmarket.MsgBurnStableCoin = (function () {
      /**
       * Properties of a MsgBurnStableCoin.
       * @memberof ununifi.nftmarket
       * @interface IMsgBurnStableCoin
       * @property {string|null} [sender] MsgBurnStableCoin sender
       */

      /**
       * Constructs a new MsgBurnStableCoin.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgBurnStableCoin.
       * @implements IMsgBurnStableCoin
       * @constructor
       * @param {ununifi.nftmarket.IMsgBurnStableCoin=} [properties] Properties to set
       */
      function MsgBurnStableCoin(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgBurnStableCoin sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @instance
       */
      MsgBurnStableCoin.prototype.sender = '';

      /**
       * Encodes the specified MsgBurnStableCoin message. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoin.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @static
       * @param {ununifi.nftmarket.IMsgBurnStableCoin} message MsgBurnStableCoin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnStableCoin.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        return writer;
      };

      /**
       * Encodes the specified MsgBurnStableCoin message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoin.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @static
       * @param {ununifi.nftmarket.IMsgBurnStableCoin} message MsgBurnStableCoin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnStableCoin.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBurnStableCoin message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgBurnStableCoin} MsgBurnStableCoin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnStableCoin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgBurnStableCoin();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBurnStableCoin message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgBurnStableCoin} MsgBurnStableCoin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnStableCoin.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBurnStableCoin message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBurnStableCoin.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        return null;
      };

      /**
       * Creates a MsgBurnStableCoin message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgBurnStableCoin} MsgBurnStableCoin
       */
      MsgBurnStableCoin.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgBurnStableCoin) return object;
        let message = new $root.ununifi.nftmarket.MsgBurnStableCoin();
        if (object.sender != null) message.sender = String(object.sender);
        return message;
      };

      /**
       * Creates a plain object from a MsgBurnStableCoin message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @static
       * @param {ununifi.nftmarket.MsgBurnStableCoin} message MsgBurnStableCoin
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBurnStableCoin.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        return object;
      };

      /**
       * Converts this MsgBurnStableCoin to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgBurnStableCoin
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBurnStableCoin.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBurnStableCoin;
    })();

    nftmarket.MsgBurnStableCoinResponse = (function () {
      /**
       * Properties of a MsgBurnStableCoinResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgBurnStableCoinResponse
       */

      /**
       * Constructs a new MsgBurnStableCoinResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgBurnStableCoinResponse.
       * @implements IMsgBurnStableCoinResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgBurnStableCoinResponse=} [properties] Properties to set
       */
      function MsgBurnStableCoinResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgBurnStableCoinResponse message. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoinResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @static
       * @param {ununifi.nftmarket.IMsgBurnStableCoinResponse} message MsgBurnStableCoinResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnStableCoinResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgBurnStableCoinResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgBurnStableCoinResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @static
       * @param {ununifi.nftmarket.IMsgBurnStableCoinResponse} message MsgBurnStableCoinResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnStableCoinResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBurnStableCoinResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgBurnStableCoinResponse} MsgBurnStableCoinResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnStableCoinResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgBurnStableCoinResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBurnStableCoinResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgBurnStableCoinResponse} MsgBurnStableCoinResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnStableCoinResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBurnStableCoinResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBurnStableCoinResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgBurnStableCoinResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgBurnStableCoinResponse} MsgBurnStableCoinResponse
       */
      MsgBurnStableCoinResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgBurnStableCoinResponse) return object;
        return new $root.ununifi.nftmarket.MsgBurnStableCoinResponse();
      };

      /**
       * Creates a plain object from a MsgBurnStableCoinResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @static
       * @param {ununifi.nftmarket.MsgBurnStableCoinResponse} message MsgBurnStableCoinResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBurnStableCoinResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgBurnStableCoinResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgBurnStableCoinResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBurnStableCoinResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBurnStableCoinResponse;
    })();

    nftmarket.MsgLiquidate = (function () {
      /**
       * Properties of a MsgLiquidate.
       * @memberof ununifi.nftmarket
       * @interface IMsgLiquidate
       * @property {string|null} [sender] MsgLiquidate sender
       * @property {ununifi.nftmarket.INftIdentifier|null} [nft_id] MsgLiquidate nft_id
       */

      /**
       * Constructs a new MsgLiquidate.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgLiquidate.
       * @implements IMsgLiquidate
       * @constructor
       * @param {ununifi.nftmarket.IMsgLiquidate=} [properties] Properties to set
       */
      function MsgLiquidate(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgLiquidate sender.
       * @member {string} sender
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @instance
       */
      MsgLiquidate.prototype.sender = '';

      /**
       * MsgLiquidate nft_id.
       * @member {ununifi.nftmarket.INftIdentifier|null|undefined} nft_id
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @instance
       */
      MsgLiquidate.prototype.nft_id = null;

      /**
       * Encodes the specified MsgLiquidate message. Does not implicitly {@link ununifi.nftmarket.MsgLiquidate.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @static
       * @param {ununifi.nftmarket.IMsgLiquidate} message MsgLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidate.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftmarket.NftIdentifier.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgLiquidate message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgLiquidate.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @static
       * @param {ununifi.nftmarket.IMsgLiquidate} message MsgLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgLiquidate message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgLiquidate} MsgLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgLiquidate();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftmarket.NftIdentifier.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgLiquidate message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgLiquidate} MsgLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgLiquidate message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgLiquidate.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftmarket.NftIdentifier.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgLiquidate message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgLiquidate} MsgLiquidate
       */
      MsgLiquidate.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgLiquidate) return object;
        let message = new $root.ununifi.nftmarket.MsgLiquidate();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftmarket.MsgLiquidate.nft_id: object expected');
          message.nft_id = $root.ununifi.nftmarket.NftIdentifier.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgLiquidate message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @static
       * @param {ununifi.nftmarket.MsgLiquidate} message MsgLiquidate
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgLiquidate.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftmarket.NftIdentifier.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgLiquidate to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgLiquidate
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgLiquidate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgLiquidate;
    })();

    nftmarket.MsgLiquidateResponse = (function () {
      /**
       * Properties of a MsgLiquidateResponse.
       * @memberof ununifi.nftmarket
       * @interface IMsgLiquidateResponse
       */

      /**
       * Constructs a new MsgLiquidateResponse.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a MsgLiquidateResponse.
       * @implements IMsgLiquidateResponse
       * @constructor
       * @param {ununifi.nftmarket.IMsgLiquidateResponse=} [properties] Properties to set
       */
      function MsgLiquidateResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgLiquidateResponse message. Does not implicitly {@link ununifi.nftmarket.MsgLiquidateResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @static
       * @param {ununifi.nftmarket.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidateResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgLiquidateResponse message, length delimited. Does not implicitly {@link ununifi.nftmarket.MsgLiquidateResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @static
       * @param {ununifi.nftmarket.IMsgLiquidateResponse} message MsgLiquidateResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgLiquidateResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgLiquidateResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.MsgLiquidateResponse} MsgLiquidateResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.MsgLiquidateResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgLiquidateResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.MsgLiquidateResponse} MsgLiquidateResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgLiquidateResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgLiquidateResponse message.
       * @function verify
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgLiquidateResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgLiquidateResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.MsgLiquidateResponse} MsgLiquidateResponse
       */
      MsgLiquidateResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.MsgLiquidateResponse) return object;
        return new $root.ununifi.nftmarket.MsgLiquidateResponse();
      };

      /**
       * Creates a plain object from a MsgLiquidateResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @static
       * @param {ununifi.nftmarket.MsgLiquidateResponse} message MsgLiquidateResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgLiquidateResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgLiquidateResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.MsgLiquidateResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgLiquidateResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgLiquidateResponse;
    })();

    nftmarket.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.nftmarket
       * @interface IGenesisState
       * @property {ununifi.nftmarket.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.nftmarket.INftListing>|null} [listings] GenesisState listings
       * @property {Array.<ununifi.nftmarket.INftBid>|null} [bids] GenesisState bids
       * @property {Array.<ununifi.nftmarket.INftBid>|null} [cancelled_bids] GenesisState cancelled_bids
       * @property {Array.<ununifi.nftmarket.ILoan>|null} [loans] GenesisState loans
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.nftmarket
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.nftmarket.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.listings = [];
        this.bids = [];
        this.cancelled_bids = [];
        this.loans = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.nftmarket.IParams|null|undefined} params
       * @memberof ununifi.nftmarket.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState listings.
       * @member {Array.<ununifi.nftmarket.INftListing>} listings
       * @memberof ununifi.nftmarket.GenesisState
       * @instance
       */
      GenesisState.prototype.listings = $util.emptyArray;

      /**
       * GenesisState bids.
       * @member {Array.<ununifi.nftmarket.INftBid>} bids
       * @memberof ununifi.nftmarket.GenesisState
       * @instance
       */
      GenesisState.prototype.bids = $util.emptyArray;

      /**
       * GenesisState cancelled_bids.
       * @member {Array.<ununifi.nftmarket.INftBid>} cancelled_bids
       * @memberof ununifi.nftmarket.GenesisState
       * @instance
       */
      GenesisState.prototype.cancelled_bids = $util.emptyArray;

      /**
       * GenesisState loans.
       * @member {Array.<ununifi.nftmarket.ILoan>} loans
       * @memberof ununifi.nftmarket.GenesisState
       * @instance
       */
      GenesisState.prototype.loans = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftmarket.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmarket.GenesisState
       * @static
       * @param {ununifi.nftmarket.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftmarket.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.listings != null && message.listings.length)
          for (let i = 0; i < message.listings.length; ++i)
            $root.ununifi.nftmarket.NftListing.encode(message.listings[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.bids != null && message.bids.length)
          for (let i = 0; i < message.bids.length; ++i)
            $root.ununifi.nftmarket.NftBid.encode(message.bids[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.cancelled_bids != null && message.cancelled_bids.length)
          for (let i = 0; i < message.cancelled_bids.length; ++i)
            $root.ununifi.nftmarket.NftBid.encode(message.cancelled_bids[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.loans != null && message.loans.length)
          for (let i = 0; i < message.loans.length; ++i)
            $root.ununifi.nftmarket.Loan.encode(message.loans[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftmarket.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmarket.GenesisState
       * @static
       * @param {ununifi.nftmarket.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmarket.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmarket.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmarket.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftmarket.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.listings && message.listings.length)) message.listings = [];
              message.listings.push($root.ununifi.nftmarket.NftListing.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.bids && message.bids.length)) message.bids = [];
              message.bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
              break;
            case 4:
              if (!(message.cancelled_bids && message.cancelled_bids.length)) message.cancelled_bids = [];
              message.cancelled_bids.push($root.ununifi.nftmarket.NftBid.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.loans && message.loans.length)) message.loans = [];
              message.loans.push($root.ununifi.nftmarket.Loan.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmarket.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmarket.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.nftmarket.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftmarket.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.listings != null && message.hasOwnProperty('listings')) {
          if (!Array.isArray(message.listings)) return 'listings: array expected';
          for (let i = 0; i < message.listings.length; ++i) {
            let error = $root.ununifi.nftmarket.NftListing.verify(message.listings[i]);
            if (error) return 'listings.' + error;
          }
        }
        if (message.bids != null && message.hasOwnProperty('bids')) {
          if (!Array.isArray(message.bids)) return 'bids: array expected';
          for (let i = 0; i < message.bids.length; ++i) {
            let error = $root.ununifi.nftmarket.NftBid.verify(message.bids[i]);
            if (error) return 'bids.' + error;
          }
        }
        if (message.cancelled_bids != null && message.hasOwnProperty('cancelled_bids')) {
          if (!Array.isArray(message.cancelled_bids)) return 'cancelled_bids: array expected';
          for (let i = 0; i < message.cancelled_bids.length; ++i) {
            let error = $root.ununifi.nftmarket.NftBid.verify(message.cancelled_bids[i]);
            if (error) return 'cancelled_bids.' + error;
          }
        }
        if (message.loans != null && message.hasOwnProperty('loans')) {
          if (!Array.isArray(message.loans)) return 'loans: array expected';
          for (let i = 0; i < message.loans.length; ++i) {
            let error = $root.ununifi.nftmarket.Loan.verify(message.loans[i]);
            if (error) return 'loans.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmarket.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmarket.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmarket.GenesisState) return object;
        let message = new $root.ununifi.nftmarket.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.params: object expected');
          message.params = $root.ununifi.nftmarket.Params.fromObject(object.params);
        }
        if (object.listings) {
          if (!Array.isArray(object.listings)) throw TypeError('.ununifi.nftmarket.GenesisState.listings: array expected');
          message.listings = [];
          for (let i = 0; i < object.listings.length; ++i) {
            if (typeof object.listings[i] !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.listings: object expected');
            message.listings[i] = $root.ununifi.nftmarket.NftListing.fromObject(object.listings[i]);
          }
        }
        if (object.bids) {
          if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftmarket.GenesisState.bids: array expected');
          message.bids = [];
          for (let i = 0; i < object.bids.length; ++i) {
            if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.bids: object expected');
            message.bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.bids[i]);
          }
        }
        if (object.cancelled_bids) {
          if (!Array.isArray(object.cancelled_bids)) throw TypeError('.ununifi.nftmarket.GenesisState.cancelled_bids: array expected');
          message.cancelled_bids = [];
          for (let i = 0; i < object.cancelled_bids.length; ++i) {
            if (typeof object.cancelled_bids[i] !== 'object')
              throw TypeError('.ununifi.nftmarket.GenesisState.cancelled_bids: object expected');
            message.cancelled_bids[i] = $root.ununifi.nftmarket.NftBid.fromObject(object.cancelled_bids[i]);
          }
        }
        if (object.loans) {
          if (!Array.isArray(object.loans)) throw TypeError('.ununifi.nftmarket.GenesisState.loans: array expected');
          message.loans = [];
          for (let i = 0; i < object.loans.length; ++i) {
            if (typeof object.loans[i] !== 'object') throw TypeError('.ununifi.nftmarket.GenesisState.loans: object expected');
            message.loans[i] = $root.ununifi.nftmarket.Loan.fromObject(object.loans[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmarket.GenesisState
       * @static
       * @param {ununifi.nftmarket.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.listings = [];
          object.bids = [];
          object.cancelled_bids = [];
          object.loans = [];
        }
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftmarket.Params.toObject(message.params, options);
        if (message.listings && message.listings.length) {
          object.listings = [];
          for (let j = 0; j < message.listings.length; ++j)
            object.listings[j] = $root.ununifi.nftmarket.NftListing.toObject(message.listings[j], options);
        }
        if (message.bids && message.bids.length) {
          object.bids = [];
          for (let j = 0; j < message.bids.length; ++j) object.bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.bids[j], options);
        }
        if (message.cancelled_bids && message.cancelled_bids.length) {
          object.cancelled_bids = [];
          for (let j = 0; j < message.cancelled_bids.length; ++j)
            object.cancelled_bids[j] = $root.ununifi.nftmarket.NftBid.toObject(message.cancelled_bids[j], options);
        }
        if (message.loans && message.loans.length) {
          object.loans = [];
          for (let j = 0; j < message.loans.length; ++j) object.loans[j] = $root.ununifi.nftmarket.Loan.toObject(message.loans[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.nftmarket.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    return nftmarket;
  })();

  ununifi.nftmint = (function () {
    /**
     * Namespace nftmint.
     * @memberof ununifi
     * @namespace
     */
    const nftmint = {};

    nftmint.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.nftmint
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.nftmint.Query#params}.
       * @memberof ununifi.nftmint.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.nftmint.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.nftmint.QueryParamsRequest,
            $root.ununifi.nftmint.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.nftmint.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Query#classAttributes}.
       * @memberof ununifi.nftmint.Query
       * @typedef ClassAttributesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.QueryClassAttributesResponse} [response] QueryClassAttributesResponse
       */

      /**
       * Calls ClassAttributes.
       * @function classAttributes
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryClassAttributesRequest} request QueryClassAttributesRequest message or plain object
       * @param {ununifi.nftmint.Query.ClassAttributesCallback} callback Node-style callback called with the error, if any, and QueryClassAttributesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.classAttributes = function classAttributes(request, callback) {
          return this.rpcCall(
            classAttributes,
            $root.ununifi.nftmint.QueryClassAttributesRequest,
            $root.ununifi.nftmint.QueryClassAttributesResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ClassAttributes' },
      );

      /**
       * Calls ClassAttributes.
       * @function classAttributes
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryClassAttributesRequest} request QueryClassAttributesRequest message or plain object
       * @returns {Promise<ununifi.nftmint.QueryClassAttributesResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Query#nFTMinter}.
       * @memberof ununifi.nftmint.Query
       * @typedef NFTMinterCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.QueryNFTMinterResponse} [response] QueryNFTMinterResponse
       */

      /**
       * Calls NFTMinter.
       * @function nFTMinter
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryNFTMinterRequest} request QueryNFTMinterRequest message or plain object
       * @param {ununifi.nftmint.Query.NFTMinterCallback} callback Node-style callback called with the error, if any, and QueryNFTMinterResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.nFTMinter = function nFTMinter(request, callback) {
          return this.rpcCall(
            nFTMinter,
            $root.ununifi.nftmint.QueryNFTMinterRequest,
            $root.ununifi.nftmint.QueryNFTMinterResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'NFTMinter' },
      );

      /**
       * Calls NFTMinter.
       * @function nFTMinter
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryNFTMinterRequest} request QueryNFTMinterRequest message or plain object
       * @returns {Promise<ununifi.nftmint.QueryNFTMinterResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Query#classIdsByName}.
       * @memberof ununifi.nftmint.Query
       * @typedef ClassIdsByNameCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.QueryClassIdsByNameResponse} [response] QueryClassIdsByNameResponse
       */

      /**
       * Calls ClassIdsByName.
       * @function classIdsByName
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} request QueryClassIdsByNameRequest message or plain object
       * @param {ununifi.nftmint.Query.ClassIdsByNameCallback} callback Node-style callback called with the error, if any, and QueryClassIdsByNameResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.classIdsByName = function classIdsByName(request, callback) {
          return this.rpcCall(
            classIdsByName,
            $root.ununifi.nftmint.QueryClassIdsByNameRequest,
            $root.ununifi.nftmint.QueryClassIdsByNameResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ClassIdsByName' },
      );

      /**
       * Calls ClassIdsByName.
       * @function classIdsByName
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} request QueryClassIdsByNameRequest message or plain object
       * @returns {Promise<ununifi.nftmint.QueryClassIdsByNameResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Query#classIdsByOwner}.
       * @memberof ununifi.nftmint.Query
       * @typedef ClassIdsByOwnerCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.QueryClassIdsByOwnerResponse} [response] QueryClassIdsByOwnerResponse
       */

      /**
       * Calls ClassIdsByOwner.
       * @function classIdsByOwner
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} request QueryClassIdsByOwnerRequest message or plain object
       * @param {ununifi.nftmint.Query.ClassIdsByOwnerCallback} callback Node-style callback called with the error, if any, and QueryClassIdsByOwnerResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.classIdsByOwner = function classIdsByOwner(request, callback) {
          return this.rpcCall(
            classIdsByOwner,
            $root.ununifi.nftmint.QueryClassIdsByOwnerRequest,
            $root.ununifi.nftmint.QueryClassIdsByOwnerResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ClassIdsByOwner' },
      );

      /**
       * Calls ClassIdsByOwner.
       * @function classIdsByOwner
       * @memberof ununifi.nftmint.Query
       * @instance
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} request QueryClassIdsByOwnerRequest message or plain object
       * @returns {Promise<ununifi.nftmint.QueryClassIdsByOwnerResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    nftmint.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.nftmint
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.nftmint.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftmint.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @static
       * @param {ununifi.nftmint.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @static
       * @param {ununifi.nftmint.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryParamsRequest) return object;
        return new $root.ununifi.nftmint.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @static
       * @param {ununifi.nftmint.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    nftmint.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.nftmint
       * @interface IQueryParamsResponse
       * @property {ununifi.nftmint.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.nftmint.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.nftmint.IParams|null|undefined} params
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftmint.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @static
       * @param {ununifi.nftmint.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftmint.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @static
       * @param {ununifi.nftmint.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftmint.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftmint.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryParamsResponse) return object;
        let message = new $root.ununifi.nftmint.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmint.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.nftmint.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @static
       * @param {ununifi.nftmint.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftmint.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    nftmint.QueryClassAttributesRequest = (function () {
      /**
       * Properties of a QueryClassAttributesRequest.
       * @memberof ununifi.nftmint
       * @interface IQueryClassAttributesRequest
       * @property {string|null} [class_id] QueryClassAttributesRequest class_id
       */

      /**
       * Constructs a new QueryClassAttributesRequest.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryClassAttributesRequest.
       * @implements IQueryClassAttributesRequest
       * @constructor
       * @param {ununifi.nftmint.IQueryClassAttributesRequest=} [properties] Properties to set
       */
      function QueryClassAttributesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassAttributesRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @instance
       */
      QueryClassAttributesRequest.prototype.class_id = '';

      /**
       * Encodes the specified QueryClassAttributesRequest message. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @static
       * @param {ununifi.nftmint.IQueryClassAttributesRequest} message QueryClassAttributesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAttributesRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        return writer;
      };

      /**
       * Encodes the specified QueryClassAttributesRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @static
       * @param {ununifi.nftmint.IQueryClassAttributesRequest} message QueryClassAttributesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAttributesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassAttributesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryClassAttributesRequest} QueryClassAttributesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAttributesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryClassAttributesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassAttributesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryClassAttributesRequest} QueryClassAttributesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAttributesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassAttributesRequest message.
       * @function verify
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassAttributesRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        return null;
      };

      /**
       * Creates a QueryClassAttributesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryClassAttributesRequest} QueryClassAttributesRequest
       */
      QueryClassAttributesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryClassAttributesRequest) return object;
        let message = new $root.ununifi.nftmint.QueryClassAttributesRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryClassAttributesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @static
       * @param {ununifi.nftmint.QueryClassAttributesRequest} message QueryClassAttributesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassAttributesRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.class_id = '';
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        return object;
      };

      /**
       * Converts this QueryClassAttributesRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryClassAttributesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassAttributesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassAttributesRequest;
    })();

    nftmint.QueryClassAttributesResponse = (function () {
      /**
       * Properties of a QueryClassAttributesResponse.
       * @memberof ununifi.nftmint
       * @interface IQueryClassAttributesResponse
       * @property {ununifi.nftmint.IClassAttributes|null} [class_attributes] QueryClassAttributesResponse class_attributes
       */

      /**
       * Constructs a new QueryClassAttributesResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryClassAttributesResponse.
       * @implements IQueryClassAttributesResponse
       * @constructor
       * @param {ununifi.nftmint.IQueryClassAttributesResponse=} [properties] Properties to set
       */
      function QueryClassAttributesResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassAttributesResponse class_attributes.
       * @member {ununifi.nftmint.IClassAttributes|null|undefined} class_attributes
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @instance
       */
      QueryClassAttributesResponse.prototype.class_attributes = null;

      /**
       * Encodes the specified QueryClassAttributesResponse message. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @static
       * @param {ununifi.nftmint.IQueryClassAttributesResponse} message QueryClassAttributesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAttributesResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_attributes != null && Object.hasOwnProperty.call(message, 'class_attributes'))
          $root.ununifi.nftmint.ClassAttributes.encode(message.class_attributes, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryClassAttributesResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassAttributesResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @static
       * @param {ununifi.nftmint.IQueryClassAttributesResponse} message QueryClassAttributesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAttributesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassAttributesResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryClassAttributesResponse} QueryClassAttributesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAttributesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryClassAttributesResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_attributes = $root.ununifi.nftmint.ClassAttributes.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassAttributesResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryClassAttributesResponse} QueryClassAttributesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAttributesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassAttributesResponse message.
       * @function verify
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassAttributesResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_attributes != null && message.hasOwnProperty('class_attributes')) {
          let error = $root.ununifi.nftmint.ClassAttributes.verify(message.class_attributes);
          if (error) return 'class_attributes.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryClassAttributesResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryClassAttributesResponse} QueryClassAttributesResponse
       */
      QueryClassAttributesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryClassAttributesResponse) return object;
        let message = new $root.ununifi.nftmint.QueryClassAttributesResponse();
        if (object.class_attributes != null) {
          if (typeof object.class_attributes !== 'object')
            throw TypeError('.ununifi.nftmint.QueryClassAttributesResponse.class_attributes: object expected');
          message.class_attributes = $root.ununifi.nftmint.ClassAttributes.fromObject(object.class_attributes);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryClassAttributesResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @static
       * @param {ununifi.nftmint.QueryClassAttributesResponse} message QueryClassAttributesResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassAttributesResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.class_attributes = null;
        if (message.class_attributes != null && message.hasOwnProperty('class_attributes'))
          object.class_attributes = $root.ununifi.nftmint.ClassAttributes.toObject(message.class_attributes, options);
        return object;
      };

      /**
       * Converts this QueryClassAttributesResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryClassAttributesResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassAttributesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassAttributesResponse;
    })();

    nftmint.QueryNFTMinterRequest = (function () {
      /**
       * Properties of a QueryNFTMinterRequest.
       * @memberof ununifi.nftmint
       * @interface IQueryNFTMinterRequest
       * @property {string|null} [class_id] QueryNFTMinterRequest class_id
       * @property {string|null} [nft_id] QueryNFTMinterRequest nft_id
       */

      /**
       * Constructs a new QueryNFTMinterRequest.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryNFTMinterRequest.
       * @implements IQueryNFTMinterRequest
       * @constructor
       * @param {ununifi.nftmint.IQueryNFTMinterRequest=} [properties] Properties to set
       */
      function QueryNFTMinterRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNFTMinterRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @instance
       */
      QueryNFTMinterRequest.prototype.class_id = '';

      /**
       * QueryNFTMinterRequest nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @instance
       */
      QueryNFTMinterRequest.prototype.nft_id = '';

      /**
       * Encodes the specified QueryNFTMinterRequest message. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @static
       * @param {ununifi.nftmint.IQueryNFTMinterRequest} message QueryNFTMinterRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNFTMinterRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified QueryNFTMinterRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @static
       * @param {ununifi.nftmint.IQueryNFTMinterRequest} message QueryNFTMinterRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNFTMinterRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNFTMinterRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryNFTMinterRequest} QueryNFTMinterRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNFTMinterRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryNFTMinterRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNFTMinterRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryNFTMinterRequest} QueryNFTMinterRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNFTMinterRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNFTMinterRequest message.
       * @function verify
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNFTMinterRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates a QueryNFTMinterRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryNFTMinterRequest} QueryNFTMinterRequest
       */
      QueryNFTMinterRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryNFTMinterRequest) return object;
        let message = new $root.ununifi.nftmint.QueryNFTMinterRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryNFTMinterRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @static
       * @param {ununifi.nftmint.QueryNFTMinterRequest} message QueryNFTMinterRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNFTMinterRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this QueryNFTMinterRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryNFTMinterRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNFTMinterRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNFTMinterRequest;
    })();

    nftmint.QueryNFTMinterResponse = (function () {
      /**
       * Properties of a QueryNFTMinterResponse.
       * @memberof ununifi.nftmint
       * @interface IQueryNFTMinterResponse
       * @property {string|null} [minter] QueryNFTMinterResponse minter
       */

      /**
       * Constructs a new QueryNFTMinterResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryNFTMinterResponse.
       * @implements IQueryNFTMinterResponse
       * @constructor
       * @param {ununifi.nftmint.IQueryNFTMinterResponse=} [properties] Properties to set
       */
      function QueryNFTMinterResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNFTMinterResponse minter.
       * @member {string} minter
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @instance
       */
      QueryNFTMinterResponse.prototype.minter = '';

      /**
       * Encodes the specified QueryNFTMinterResponse message. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @static
       * @param {ununifi.nftmint.IQueryNFTMinterResponse} message QueryNFTMinterResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNFTMinterResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.minter != null && Object.hasOwnProperty.call(message, 'minter'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.minter);
        return writer;
      };

      /**
       * Encodes the specified QueryNFTMinterResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryNFTMinterResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @static
       * @param {ununifi.nftmint.IQueryNFTMinterResponse} message QueryNFTMinterResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNFTMinterResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNFTMinterResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryNFTMinterResponse} QueryNFTMinterResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNFTMinterResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryNFTMinterResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNFTMinterResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryNFTMinterResponse} QueryNFTMinterResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNFTMinterResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNFTMinterResponse message.
       * @function verify
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNFTMinterResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.minter != null && message.hasOwnProperty('minter'))
          if (!$util.isString(message.minter)) return 'minter: string expected';
        return null;
      };

      /**
       * Creates a QueryNFTMinterResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryNFTMinterResponse} QueryNFTMinterResponse
       */
      QueryNFTMinterResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryNFTMinterResponse) return object;
        let message = new $root.ununifi.nftmint.QueryNFTMinterResponse();
        if (object.minter != null) message.minter = String(object.minter);
        return message;
      };

      /**
       * Creates a plain object from a QueryNFTMinterResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @static
       * @param {ununifi.nftmint.QueryNFTMinterResponse} message QueryNFTMinterResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNFTMinterResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.minter = '';
        if (message.minter != null && message.hasOwnProperty('minter')) object.minter = message.minter;
        return object;
      };

      /**
       * Converts this QueryNFTMinterResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryNFTMinterResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNFTMinterResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNFTMinterResponse;
    })();

    nftmint.QueryClassIdsByNameRequest = (function () {
      /**
       * Properties of a QueryClassIdsByNameRequest.
       * @memberof ununifi.nftmint
       * @interface IQueryClassIdsByNameRequest
       * @property {string|null} [class_name] QueryClassIdsByNameRequest class_name
       */

      /**
       * Constructs a new QueryClassIdsByNameRequest.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryClassIdsByNameRequest.
       * @implements IQueryClassIdsByNameRequest
       * @constructor
       * @param {ununifi.nftmint.IQueryClassIdsByNameRequest=} [properties] Properties to set
       */
      function QueryClassIdsByNameRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassIdsByNameRequest class_name.
       * @member {string} class_name
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @instance
       */
      QueryClassIdsByNameRequest.prototype.class_name = '';

      /**
       * Encodes the specified QueryClassIdsByNameRequest message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} message QueryClassIdsByNameRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByNameRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_name != null && Object.hasOwnProperty.call(message, 'class_name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_name);
        return writer;
      };

      /**
       * Encodes the specified QueryClassIdsByNameRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByNameRequest} message QueryClassIdsByNameRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassIdsByNameRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryClassIdsByNameRequest} QueryClassIdsByNameRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByNameRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryClassIdsByNameRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_name = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassIdsByNameRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryClassIdsByNameRequest} QueryClassIdsByNameRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByNameRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassIdsByNameRequest message.
       * @function verify
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassIdsByNameRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_name != null && message.hasOwnProperty('class_name'))
          if (!$util.isString(message.class_name)) return 'class_name: string expected';
        return null;
      };

      /**
       * Creates a QueryClassIdsByNameRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryClassIdsByNameRequest} QueryClassIdsByNameRequest
       */
      QueryClassIdsByNameRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryClassIdsByNameRequest) return object;
        let message = new $root.ununifi.nftmint.QueryClassIdsByNameRequest();
        if (object.class_name != null) message.class_name = String(object.class_name);
        return message;
      };

      /**
       * Creates a plain object from a QueryClassIdsByNameRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @static
       * @param {ununifi.nftmint.QueryClassIdsByNameRequest} message QueryClassIdsByNameRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassIdsByNameRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.class_name = '';
        if (message.class_name != null && message.hasOwnProperty('class_name')) object.class_name = message.class_name;
        return object;
      };

      /**
       * Converts this QueryClassIdsByNameRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryClassIdsByNameRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassIdsByNameRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassIdsByNameRequest;
    })();

    nftmint.QueryClassIdsByNameResponse = (function () {
      /**
       * Properties of a QueryClassIdsByNameResponse.
       * @memberof ununifi.nftmint
       * @interface IQueryClassIdsByNameResponse
       * @property {ununifi.nftmint.IClassNameIdList|null} [class_name_id_list] QueryClassIdsByNameResponse class_name_id_list
       */

      /**
       * Constructs a new QueryClassIdsByNameResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryClassIdsByNameResponse.
       * @implements IQueryClassIdsByNameResponse
       * @constructor
       * @param {ununifi.nftmint.IQueryClassIdsByNameResponse=} [properties] Properties to set
       */
      function QueryClassIdsByNameResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassIdsByNameResponse class_name_id_list.
       * @member {ununifi.nftmint.IClassNameIdList|null|undefined} class_name_id_list
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @instance
       */
      QueryClassIdsByNameResponse.prototype.class_name_id_list = null;

      /**
       * Encodes the specified QueryClassIdsByNameResponse message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByNameResponse} message QueryClassIdsByNameResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByNameResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_name_id_list != null && Object.hasOwnProperty.call(message, 'class_name_id_list'))
          $root.ununifi.nftmint.ClassNameIdList.encode(
            message.class_name_id_list,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryClassIdsByNameResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByNameResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByNameResponse} message QueryClassIdsByNameResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassIdsByNameResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryClassIdsByNameResponse} QueryClassIdsByNameResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByNameResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryClassIdsByNameResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_name_id_list = $root.ununifi.nftmint.ClassNameIdList.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassIdsByNameResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryClassIdsByNameResponse} QueryClassIdsByNameResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByNameResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassIdsByNameResponse message.
       * @function verify
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassIdsByNameResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_name_id_list != null && message.hasOwnProperty('class_name_id_list')) {
          let error = $root.ununifi.nftmint.ClassNameIdList.verify(message.class_name_id_list);
          if (error) return 'class_name_id_list.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryClassIdsByNameResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryClassIdsByNameResponse} QueryClassIdsByNameResponse
       */
      QueryClassIdsByNameResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryClassIdsByNameResponse) return object;
        let message = new $root.ununifi.nftmint.QueryClassIdsByNameResponse();
        if (object.class_name_id_list != null) {
          if (typeof object.class_name_id_list !== 'object')
            throw TypeError('.ununifi.nftmint.QueryClassIdsByNameResponse.class_name_id_list: object expected');
          message.class_name_id_list = $root.ununifi.nftmint.ClassNameIdList.fromObject(object.class_name_id_list);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryClassIdsByNameResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @static
       * @param {ununifi.nftmint.QueryClassIdsByNameResponse} message QueryClassIdsByNameResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassIdsByNameResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.class_name_id_list = null;
        if (message.class_name_id_list != null && message.hasOwnProperty('class_name_id_list'))
          object.class_name_id_list = $root.ununifi.nftmint.ClassNameIdList.toObject(message.class_name_id_list, options);
        return object;
      };

      /**
       * Converts this QueryClassIdsByNameResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryClassIdsByNameResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassIdsByNameResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassIdsByNameResponse;
    })();

    nftmint.QueryClassIdsByOwnerRequest = (function () {
      /**
       * Properties of a QueryClassIdsByOwnerRequest.
       * @memberof ununifi.nftmint
       * @interface IQueryClassIdsByOwnerRequest
       * @property {string|null} [owner] QueryClassIdsByOwnerRequest owner
       */

      /**
       * Constructs a new QueryClassIdsByOwnerRequest.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryClassIdsByOwnerRequest.
       * @implements IQueryClassIdsByOwnerRequest
       * @constructor
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest=} [properties] Properties to set
       */
      function QueryClassIdsByOwnerRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassIdsByOwnerRequest owner.
       * @member {string} owner
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @instance
       */
      QueryClassIdsByOwnerRequest.prototype.owner = '';

      /**
       * Encodes the specified QueryClassIdsByOwnerRequest message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} message QueryClassIdsByOwnerRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByOwnerRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        return writer;
      };

      /**
       * Encodes the specified QueryClassIdsByOwnerRequest message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerRequest} message QueryClassIdsByOwnerRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByOwnerRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassIdsByOwnerRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryClassIdsByOwnerRequest} QueryClassIdsByOwnerRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByOwnerRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryClassIdsByOwnerRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassIdsByOwnerRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryClassIdsByOwnerRequest} QueryClassIdsByOwnerRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByOwnerRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassIdsByOwnerRequest message.
       * @function verify
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassIdsByOwnerRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        return null;
      };

      /**
       * Creates a QueryClassIdsByOwnerRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryClassIdsByOwnerRequest} QueryClassIdsByOwnerRequest
       */
      QueryClassIdsByOwnerRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryClassIdsByOwnerRequest) return object;
        let message = new $root.ununifi.nftmint.QueryClassIdsByOwnerRequest();
        if (object.owner != null) message.owner = String(object.owner);
        return message;
      };

      /**
       * Creates a plain object from a QueryClassIdsByOwnerRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @static
       * @param {ununifi.nftmint.QueryClassIdsByOwnerRequest} message QueryClassIdsByOwnerRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassIdsByOwnerRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.owner = '';
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        return object;
      };

      /**
       * Converts this QueryClassIdsByOwnerRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassIdsByOwnerRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassIdsByOwnerRequest;
    })();

    nftmint.QueryClassIdsByOwnerResponse = (function () {
      /**
       * Properties of a QueryClassIdsByOwnerResponse.
       * @memberof ununifi.nftmint
       * @interface IQueryClassIdsByOwnerResponse
       * @property {ununifi.nftmint.IOwningClassIdList|null} [owning_class_id_list] QueryClassIdsByOwnerResponse owning_class_id_list
       */

      /**
       * Constructs a new QueryClassIdsByOwnerResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a QueryClassIdsByOwnerResponse.
       * @implements IQueryClassIdsByOwnerResponse
       * @constructor
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerResponse=} [properties] Properties to set
       */
      function QueryClassIdsByOwnerResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassIdsByOwnerResponse owning_class_id_list.
       * @member {ununifi.nftmint.IOwningClassIdList|null|undefined} owning_class_id_list
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @instance
       */
      QueryClassIdsByOwnerResponse.prototype.owning_class_id_list = null;

      /**
       * Encodes the specified QueryClassIdsByOwnerResponse message. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerResponse} message QueryClassIdsByOwnerResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByOwnerResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owning_class_id_list != null && Object.hasOwnProperty.call(message, 'owning_class_id_list'))
          $root.ununifi.nftmint.OwningClassIdList.encode(
            message.owning_class_id_list,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryClassIdsByOwnerResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.QueryClassIdsByOwnerResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @static
       * @param {ununifi.nftmint.IQueryClassIdsByOwnerResponse} message QueryClassIdsByOwnerResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassIdsByOwnerResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassIdsByOwnerResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.QueryClassIdsByOwnerResponse} QueryClassIdsByOwnerResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByOwnerResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.QueryClassIdsByOwnerResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owning_class_id_list = $root.ununifi.nftmint.OwningClassIdList.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassIdsByOwnerResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.QueryClassIdsByOwnerResponse} QueryClassIdsByOwnerResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassIdsByOwnerResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassIdsByOwnerResponse message.
       * @function verify
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassIdsByOwnerResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owning_class_id_list != null && message.hasOwnProperty('owning_class_id_list')) {
          let error = $root.ununifi.nftmint.OwningClassIdList.verify(message.owning_class_id_list);
          if (error) return 'owning_class_id_list.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryClassIdsByOwnerResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.QueryClassIdsByOwnerResponse} QueryClassIdsByOwnerResponse
       */
      QueryClassIdsByOwnerResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.QueryClassIdsByOwnerResponse) return object;
        let message = new $root.ununifi.nftmint.QueryClassIdsByOwnerResponse();
        if (object.owning_class_id_list != null) {
          if (typeof object.owning_class_id_list !== 'object')
            throw TypeError('.ununifi.nftmint.QueryClassIdsByOwnerResponse.owning_class_id_list: object expected');
          message.owning_class_id_list = $root.ununifi.nftmint.OwningClassIdList.fromObject(object.owning_class_id_list);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryClassIdsByOwnerResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @static
       * @param {ununifi.nftmint.QueryClassIdsByOwnerResponse} message QueryClassIdsByOwnerResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassIdsByOwnerResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.owning_class_id_list = null;
        if (message.owning_class_id_list != null && message.hasOwnProperty('owning_class_id_list'))
          object.owning_class_id_list = $root.ununifi.nftmint.OwningClassIdList.toObject(message.owning_class_id_list, options);
        return object;
      };

      /**
       * Converts this QueryClassIdsByOwnerResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.QueryClassIdsByOwnerResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassIdsByOwnerResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassIdsByOwnerResponse;
    })();

    /**
     * MintingPermission enum.
     * @name ununifi.nftmint.MintingPermission
     * @enum {number}
     * @property {number} OnlyOwner=0 OnlyOwner value
     * @property {number} Anyone=1 Anyone value
     */
    nftmint.MintingPermission = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'OnlyOwner')] = 0;
      values[(valuesById[1] = 'Anyone')] = 1;
      return values;
    })();

    nftmint.ClassAttributes = (function () {
      /**
       * Properties of a ClassAttributes.
       * @memberof ununifi.nftmint
       * @interface IClassAttributes
       * @property {string|null} [class_id] ClassAttributes class_id
       * @property {string|null} [owner] ClassAttributes owner
       * @property {string|null} [base_token_uri] ClassAttributes base_token_uri
       * @property {ununifi.nftmint.MintingPermission|null} [minting_permission] ClassAttributes minting_permission
       * @property {Long|null} [token_supply_cap] ClassAttributes token_supply_cap
       */

      /**
       * Constructs a new ClassAttributes.
       * @memberof ununifi.nftmint
       * @classdesc Represents a ClassAttributes.
       * @implements IClassAttributes
       * @constructor
       * @param {ununifi.nftmint.IClassAttributes=} [properties] Properties to set
       */
      function ClassAttributes(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ClassAttributes class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.ClassAttributes
       * @instance
       */
      ClassAttributes.prototype.class_id = '';

      /**
       * ClassAttributes owner.
       * @member {string} owner
       * @memberof ununifi.nftmint.ClassAttributes
       * @instance
       */
      ClassAttributes.prototype.owner = '';

      /**
       * ClassAttributes base_token_uri.
       * @member {string} base_token_uri
       * @memberof ununifi.nftmint.ClassAttributes
       * @instance
       */
      ClassAttributes.prototype.base_token_uri = '';

      /**
       * ClassAttributes minting_permission.
       * @member {ununifi.nftmint.MintingPermission} minting_permission
       * @memberof ununifi.nftmint.ClassAttributes
       * @instance
       */
      ClassAttributes.prototype.minting_permission = 0;

      /**
       * ClassAttributes token_supply_cap.
       * @member {Long} token_supply_cap
       * @memberof ununifi.nftmint.ClassAttributes
       * @instance
       */
      ClassAttributes.prototype.token_supply_cap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified ClassAttributes message. Does not implicitly {@link ununifi.nftmint.ClassAttributes.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.ClassAttributes
       * @static
       * @param {ununifi.nftmint.IClassAttributes} message ClassAttributes message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassAttributes.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
        if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
        if (message.minting_permission != null && Object.hasOwnProperty.call(message, 'minting_permission'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.minting_permission);
        if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.token_supply_cap);
        return writer;
      };

      /**
       * Encodes the specified ClassAttributes message, length delimited. Does not implicitly {@link ununifi.nftmint.ClassAttributes.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.ClassAttributes
       * @static
       * @param {ununifi.nftmint.IClassAttributes} message ClassAttributes message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassAttributes.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ClassAttributes message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.ClassAttributes
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.ClassAttributes} ClassAttributes
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassAttributes.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.ClassAttributes();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.owner = reader.string();
              break;
            case 3:
              message.base_token_uri = reader.string();
              break;
            case 4:
              message.minting_permission = reader.int32();
              break;
            case 5:
              message.token_supply_cap = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ClassAttributes message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.ClassAttributes
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.ClassAttributes} ClassAttributes
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassAttributes.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ClassAttributes message.
       * @function verify
       * @memberof ununifi.nftmint.ClassAttributes
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ClassAttributes.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
          if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
        if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
          switch (message.minting_permission) {
            default:
              return 'minting_permission: enum value expected';
            case 0:
            case 1:
              break;
          }
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (
            !$util.isInteger(message.token_supply_cap) &&
            !(message.token_supply_cap && $util.isInteger(message.token_supply_cap.low) && $util.isInteger(message.token_supply_cap.high))
          )
            return 'token_supply_cap: integer|Long expected';
        return null;
      };

      /**
       * Creates a ClassAttributes message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.ClassAttributes
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.ClassAttributes} ClassAttributes
       */
      ClassAttributes.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.ClassAttributes) return object;
        let message = new $root.ununifi.nftmint.ClassAttributes();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.owner != null) message.owner = String(object.owner);
        if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
        switch (object.minting_permission) {
          case 'OnlyOwner':
          case 0:
            message.minting_permission = 0;
            break;
          case 'Anyone':
          case 1:
            message.minting_permission = 1;
            break;
        }
        if (object.token_supply_cap != null)
          if ($util.Long) (message.token_supply_cap = $util.Long.fromValue(object.token_supply_cap)).unsigned = true;
          else if (typeof object.token_supply_cap === 'string') message.token_supply_cap = parseInt(object.token_supply_cap, 10);
          else if (typeof object.token_supply_cap === 'number') message.token_supply_cap = object.token_supply_cap;
          else if (typeof object.token_supply_cap === 'object')
            message.token_supply_cap = new $util.LongBits(object.token_supply_cap.low >>> 0, object.token_supply_cap.high >>> 0).toNumber(
              true,
            );
        return message;
      };

      /**
       * Creates a plain object from a ClassAttributes message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.ClassAttributes
       * @static
       * @param {ununifi.nftmint.ClassAttributes} message ClassAttributes
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ClassAttributes.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.owner = '';
          object.base_token_uri = '';
          object.minting_permission = options.enums === String ? 'OnlyOwner' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.token_supply_cap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.token_supply_cap = options.longs === String ? '0' : 0;
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
        if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
          object.minting_permission =
            options.enums === String ? $root.ununifi.nftmint.MintingPermission[message.minting_permission] : message.minting_permission;
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (typeof message.token_supply_cap === 'number')
            object.token_supply_cap = options.longs === String ? String(message.token_supply_cap) : message.token_supply_cap;
          else
            object.token_supply_cap =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.token_supply_cap)
                : options.longs === Number
                ? new $util.LongBits(message.token_supply_cap.low >>> 0, message.token_supply_cap.high >>> 0).toNumber(true)
                : message.token_supply_cap;
        return object;
      };

      /**
       * Converts this ClassAttributes to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.ClassAttributes
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ClassAttributes.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ClassAttributes;
    })();

    nftmint.OwningClassIdList = (function () {
      /**
       * Properties of an OwningClassIdList.
       * @memberof ununifi.nftmint
       * @interface IOwningClassIdList
       * @property {string|null} [owner] OwningClassIdList owner
       * @property {Array.<string>|null} [class_id] OwningClassIdList class_id
       */

      /**
       * Constructs a new OwningClassIdList.
       * @memberof ununifi.nftmint
       * @classdesc Represents an OwningClassIdList.
       * @implements IOwningClassIdList
       * @constructor
       * @param {ununifi.nftmint.IOwningClassIdList=} [properties] Properties to set
       */
      function OwningClassIdList(properties) {
        this.class_id = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * OwningClassIdList owner.
       * @member {string} owner
       * @memberof ununifi.nftmint.OwningClassIdList
       * @instance
       */
      OwningClassIdList.prototype.owner = '';

      /**
       * OwningClassIdList class_id.
       * @member {Array.<string>} class_id
       * @memberof ununifi.nftmint.OwningClassIdList
       * @instance
       */
      OwningClassIdList.prototype.class_id = $util.emptyArray;

      /**
       * Encodes the specified OwningClassIdList message. Does not implicitly {@link ununifi.nftmint.OwningClassIdList.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.OwningClassIdList
       * @static
       * @param {ununifi.nftmint.IOwningClassIdList} message OwningClassIdList message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OwningClassIdList.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && message.class_id.length)
          for (let i = 0; i < message.class_id.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id[i]);
        return writer;
      };

      /**
       * Encodes the specified OwningClassIdList message, length delimited. Does not implicitly {@link ununifi.nftmint.OwningClassIdList.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.OwningClassIdList
       * @static
       * @param {ununifi.nftmint.IOwningClassIdList} message OwningClassIdList message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OwningClassIdList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OwningClassIdList message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.OwningClassIdList
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.OwningClassIdList} OwningClassIdList
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OwningClassIdList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.OwningClassIdList();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              if (!(message.class_id && message.class_id.length)) message.class_id = [];
              message.class_id.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OwningClassIdList message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.OwningClassIdList
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.OwningClassIdList} OwningClassIdList
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OwningClassIdList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OwningClassIdList message.
       * @function verify
       * @memberof ununifi.nftmint.OwningClassIdList
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OwningClassIdList.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id')) {
          if (!Array.isArray(message.class_id)) return 'class_id: array expected';
          for (let i = 0; i < message.class_id.length; ++i) if (!$util.isString(message.class_id[i])) return 'class_id: string[] expected';
        }
        return null;
      };

      /**
       * Creates an OwningClassIdList message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.OwningClassIdList
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.OwningClassIdList} OwningClassIdList
       */
      OwningClassIdList.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.OwningClassIdList) return object;
        let message = new $root.ununifi.nftmint.OwningClassIdList();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id) {
          if (!Array.isArray(object.class_id)) throw TypeError('.ununifi.nftmint.OwningClassIdList.class_id: array expected');
          message.class_id = [];
          for (let i = 0; i < object.class_id.length; ++i) message.class_id[i] = String(object.class_id[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from an OwningClassIdList message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.OwningClassIdList
       * @static
       * @param {ununifi.nftmint.OwningClassIdList} message OwningClassIdList
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OwningClassIdList.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.class_id = [];
        if (options.defaults) object.owner = '';
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id && message.class_id.length) {
          object.class_id = [];
          for (let j = 0; j < message.class_id.length; ++j) object.class_id[j] = message.class_id[j];
        }
        return object;
      };

      /**
       * Converts this OwningClassIdList to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.OwningClassIdList
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OwningClassIdList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OwningClassIdList;
    })();

    nftmint.ClassNameIdList = (function () {
      /**
       * Properties of a ClassNameIdList.
       * @memberof ununifi.nftmint
       * @interface IClassNameIdList
       * @property {string|null} [class_name] ClassNameIdList class_name
       * @property {Array.<string>|null} [class_id] ClassNameIdList class_id
       */

      /**
       * Constructs a new ClassNameIdList.
       * @memberof ununifi.nftmint
       * @classdesc Represents a ClassNameIdList.
       * @implements IClassNameIdList
       * @constructor
       * @param {ununifi.nftmint.IClassNameIdList=} [properties] Properties to set
       */
      function ClassNameIdList(properties) {
        this.class_id = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ClassNameIdList class_name.
       * @member {string} class_name
       * @memberof ununifi.nftmint.ClassNameIdList
       * @instance
       */
      ClassNameIdList.prototype.class_name = '';

      /**
       * ClassNameIdList class_id.
       * @member {Array.<string>} class_id
       * @memberof ununifi.nftmint.ClassNameIdList
       * @instance
       */
      ClassNameIdList.prototype.class_id = $util.emptyArray;

      /**
       * Encodes the specified ClassNameIdList message. Does not implicitly {@link ununifi.nftmint.ClassNameIdList.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.ClassNameIdList
       * @static
       * @param {ununifi.nftmint.IClassNameIdList} message ClassNameIdList message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassNameIdList.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_name != null && Object.hasOwnProperty.call(message, 'class_name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_name);
        if (message.class_id != null && message.class_id.length)
          for (let i = 0; i < message.class_id.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id[i]);
        return writer;
      };

      /**
       * Encodes the specified ClassNameIdList message, length delimited. Does not implicitly {@link ununifi.nftmint.ClassNameIdList.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.ClassNameIdList
       * @static
       * @param {ununifi.nftmint.IClassNameIdList} message ClassNameIdList message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassNameIdList.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ClassNameIdList message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.ClassNameIdList
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.ClassNameIdList} ClassNameIdList
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassNameIdList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.ClassNameIdList();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_name = reader.string();
              break;
            case 2:
              if (!(message.class_id && message.class_id.length)) message.class_id = [];
              message.class_id.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ClassNameIdList message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.ClassNameIdList
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.ClassNameIdList} ClassNameIdList
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassNameIdList.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ClassNameIdList message.
       * @function verify
       * @memberof ununifi.nftmint.ClassNameIdList
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ClassNameIdList.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_name != null && message.hasOwnProperty('class_name'))
          if (!$util.isString(message.class_name)) return 'class_name: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id')) {
          if (!Array.isArray(message.class_id)) return 'class_id: array expected';
          for (let i = 0; i < message.class_id.length; ++i) if (!$util.isString(message.class_id[i])) return 'class_id: string[] expected';
        }
        return null;
      };

      /**
       * Creates a ClassNameIdList message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.ClassNameIdList
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.ClassNameIdList} ClassNameIdList
       */
      ClassNameIdList.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.ClassNameIdList) return object;
        let message = new $root.ununifi.nftmint.ClassNameIdList();
        if (object.class_name != null) message.class_name = String(object.class_name);
        if (object.class_id) {
          if (!Array.isArray(object.class_id)) throw TypeError('.ununifi.nftmint.ClassNameIdList.class_id: array expected');
          message.class_id = [];
          for (let i = 0; i < object.class_id.length; ++i) message.class_id[i] = String(object.class_id[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a ClassNameIdList message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.ClassNameIdList
       * @static
       * @param {ununifi.nftmint.ClassNameIdList} message ClassNameIdList
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ClassNameIdList.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.class_id = [];
        if (options.defaults) object.class_name = '';
        if (message.class_name != null && message.hasOwnProperty('class_name')) object.class_name = message.class_name;
        if (message.class_id && message.class_id.length) {
          object.class_id = [];
          for (let j = 0; j < message.class_id.length; ++j) object.class_id[j] = message.class_id[j];
        }
        return object;
      };

      /**
       * Converts this ClassNameIdList to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.ClassNameIdList
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ClassNameIdList.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ClassNameIdList;
    })();

    nftmint.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.nftmint
       * @interface IParams
       * @property {Long|null} [MaxNFTSupplyCap] Params MaxNFTSupplyCap
       * @property {Long|null} [MinClassNameLen] Params MinClassNameLen
       * @property {Long|null} [MaxClassNameLen] Params MaxClassNameLen
       * @property {Long|null} [MinUriLen] Params MinUriLen
       * @property {Long|null} [MaxUriLen] Params MaxUriLen
       * @property {Long|null} [MaxSymbolLen] Params MaxSymbolLen
       * @property {Long|null} [MaxDescriptionLen] Params MaxDescriptionLen
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.nftmint
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.nftmint.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params MaxNFTSupplyCap.
       * @member {Long} MaxNFTSupplyCap
       * @memberof ununifi.nftmint.Params
       * @instance
       */
      Params.prototype.MaxNFTSupplyCap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params MinClassNameLen.
       * @member {Long} MinClassNameLen
       * @memberof ununifi.nftmint.Params
       * @instance
       */
      Params.prototype.MinClassNameLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params MaxClassNameLen.
       * @member {Long} MaxClassNameLen
       * @memberof ununifi.nftmint.Params
       * @instance
       */
      Params.prototype.MaxClassNameLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params MinUriLen.
       * @member {Long} MinUriLen
       * @memberof ununifi.nftmint.Params
       * @instance
       */
      Params.prototype.MinUriLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params MaxUriLen.
       * @member {Long} MaxUriLen
       * @memberof ununifi.nftmint.Params
       * @instance
       */
      Params.prototype.MaxUriLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params MaxSymbolLen.
       * @member {Long} MaxSymbolLen
       * @memberof ununifi.nftmint.Params
       * @instance
       */
      Params.prototype.MaxSymbolLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params MaxDescriptionLen.
       * @member {Long} MaxDescriptionLen
       * @memberof ununifi.nftmint.Params
       * @instance
       */
      Params.prototype.MaxDescriptionLen = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.nftmint.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.Params
       * @static
       * @param {ununifi.nftmint.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.MaxNFTSupplyCap != null && Object.hasOwnProperty.call(message, 'MaxNFTSupplyCap'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.MaxNFTSupplyCap);
        if (message.MinClassNameLen != null && Object.hasOwnProperty.call(message, 'MinClassNameLen'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.MinClassNameLen);
        if (message.MaxClassNameLen != null && Object.hasOwnProperty.call(message, 'MaxClassNameLen'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.MaxClassNameLen);
        if (message.MinUriLen != null && Object.hasOwnProperty.call(message, 'MinUriLen'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.MinUriLen);
        if (message.MaxUriLen != null && Object.hasOwnProperty.call(message, 'MaxUriLen'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.MaxUriLen);
        if (message.MaxSymbolLen != null && Object.hasOwnProperty.call(message, 'MaxSymbolLen'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.MaxSymbolLen);
        if (message.MaxDescriptionLen != null && Object.hasOwnProperty.call(message, 'MaxDescriptionLen'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.MaxDescriptionLen);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftmint.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.Params
       * @static
       * @param {ununifi.nftmint.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.MaxNFTSupplyCap = reader.uint64();
              break;
            case 2:
              message.MinClassNameLen = reader.uint64();
              break;
            case 3:
              message.MaxClassNameLen = reader.uint64();
              break;
            case 4:
              message.MinUriLen = reader.uint64();
              break;
            case 5:
              message.MaxUriLen = reader.uint64();
              break;
            case 6:
              message.MaxSymbolLen = reader.uint64();
              break;
            case 7:
              message.MaxDescriptionLen = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.nftmint.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.MaxNFTSupplyCap != null && message.hasOwnProperty('MaxNFTSupplyCap'))
          if (
            !$util.isInteger(message.MaxNFTSupplyCap) &&
            !(message.MaxNFTSupplyCap && $util.isInteger(message.MaxNFTSupplyCap.low) && $util.isInteger(message.MaxNFTSupplyCap.high))
          )
            return 'MaxNFTSupplyCap: integer|Long expected';
        if (message.MinClassNameLen != null && message.hasOwnProperty('MinClassNameLen'))
          if (
            !$util.isInteger(message.MinClassNameLen) &&
            !(message.MinClassNameLen && $util.isInteger(message.MinClassNameLen.low) && $util.isInteger(message.MinClassNameLen.high))
          )
            return 'MinClassNameLen: integer|Long expected';
        if (message.MaxClassNameLen != null && message.hasOwnProperty('MaxClassNameLen'))
          if (
            !$util.isInteger(message.MaxClassNameLen) &&
            !(message.MaxClassNameLen && $util.isInteger(message.MaxClassNameLen.low) && $util.isInteger(message.MaxClassNameLen.high))
          )
            return 'MaxClassNameLen: integer|Long expected';
        if (message.MinUriLen != null && message.hasOwnProperty('MinUriLen'))
          if (
            !$util.isInteger(message.MinUriLen) &&
            !(message.MinUriLen && $util.isInteger(message.MinUriLen.low) && $util.isInteger(message.MinUriLen.high))
          )
            return 'MinUriLen: integer|Long expected';
        if (message.MaxUriLen != null && message.hasOwnProperty('MaxUriLen'))
          if (
            !$util.isInteger(message.MaxUriLen) &&
            !(message.MaxUriLen && $util.isInteger(message.MaxUriLen.low) && $util.isInteger(message.MaxUriLen.high))
          )
            return 'MaxUriLen: integer|Long expected';
        if (message.MaxSymbolLen != null && message.hasOwnProperty('MaxSymbolLen'))
          if (
            !$util.isInteger(message.MaxSymbolLen) &&
            !(message.MaxSymbolLen && $util.isInteger(message.MaxSymbolLen.low) && $util.isInteger(message.MaxSymbolLen.high))
          )
            return 'MaxSymbolLen: integer|Long expected';
        if (message.MaxDescriptionLen != null && message.hasOwnProperty('MaxDescriptionLen'))
          if (
            !$util.isInteger(message.MaxDescriptionLen) &&
            !(
              message.MaxDescriptionLen &&
              $util.isInteger(message.MaxDescriptionLen.low) &&
              $util.isInteger(message.MaxDescriptionLen.high)
            )
          )
            return 'MaxDescriptionLen: integer|Long expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.Params) return object;
        let message = new $root.ununifi.nftmint.Params();
        if (object.MaxNFTSupplyCap != null)
          if ($util.Long) (message.MaxNFTSupplyCap = $util.Long.fromValue(object.MaxNFTSupplyCap)).unsigned = true;
          else if (typeof object.MaxNFTSupplyCap === 'string') message.MaxNFTSupplyCap = parseInt(object.MaxNFTSupplyCap, 10);
          else if (typeof object.MaxNFTSupplyCap === 'number') message.MaxNFTSupplyCap = object.MaxNFTSupplyCap;
          else if (typeof object.MaxNFTSupplyCap === 'object')
            message.MaxNFTSupplyCap = new $util.LongBits(object.MaxNFTSupplyCap.low >>> 0, object.MaxNFTSupplyCap.high >>> 0).toNumber(
              true,
            );
        if (object.MinClassNameLen != null)
          if ($util.Long) (message.MinClassNameLen = $util.Long.fromValue(object.MinClassNameLen)).unsigned = true;
          else if (typeof object.MinClassNameLen === 'string') message.MinClassNameLen = parseInt(object.MinClassNameLen, 10);
          else if (typeof object.MinClassNameLen === 'number') message.MinClassNameLen = object.MinClassNameLen;
          else if (typeof object.MinClassNameLen === 'object')
            message.MinClassNameLen = new $util.LongBits(object.MinClassNameLen.low >>> 0, object.MinClassNameLen.high >>> 0).toNumber(
              true,
            );
        if (object.MaxClassNameLen != null)
          if ($util.Long) (message.MaxClassNameLen = $util.Long.fromValue(object.MaxClassNameLen)).unsigned = true;
          else if (typeof object.MaxClassNameLen === 'string') message.MaxClassNameLen = parseInt(object.MaxClassNameLen, 10);
          else if (typeof object.MaxClassNameLen === 'number') message.MaxClassNameLen = object.MaxClassNameLen;
          else if (typeof object.MaxClassNameLen === 'object')
            message.MaxClassNameLen = new $util.LongBits(object.MaxClassNameLen.low >>> 0, object.MaxClassNameLen.high >>> 0).toNumber(
              true,
            );
        if (object.MinUriLen != null)
          if ($util.Long) (message.MinUriLen = $util.Long.fromValue(object.MinUriLen)).unsigned = true;
          else if (typeof object.MinUriLen === 'string') message.MinUriLen = parseInt(object.MinUriLen, 10);
          else if (typeof object.MinUriLen === 'number') message.MinUriLen = object.MinUriLen;
          else if (typeof object.MinUriLen === 'object')
            message.MinUriLen = new $util.LongBits(object.MinUriLen.low >>> 0, object.MinUriLen.high >>> 0).toNumber(true);
        if (object.MaxUriLen != null)
          if ($util.Long) (message.MaxUriLen = $util.Long.fromValue(object.MaxUriLen)).unsigned = true;
          else if (typeof object.MaxUriLen === 'string') message.MaxUriLen = parseInt(object.MaxUriLen, 10);
          else if (typeof object.MaxUriLen === 'number') message.MaxUriLen = object.MaxUriLen;
          else if (typeof object.MaxUriLen === 'object')
            message.MaxUriLen = new $util.LongBits(object.MaxUriLen.low >>> 0, object.MaxUriLen.high >>> 0).toNumber(true);
        if (object.MaxSymbolLen != null)
          if ($util.Long) (message.MaxSymbolLen = $util.Long.fromValue(object.MaxSymbolLen)).unsigned = true;
          else if (typeof object.MaxSymbolLen === 'string') message.MaxSymbolLen = parseInt(object.MaxSymbolLen, 10);
          else if (typeof object.MaxSymbolLen === 'number') message.MaxSymbolLen = object.MaxSymbolLen;
          else if (typeof object.MaxSymbolLen === 'object')
            message.MaxSymbolLen = new $util.LongBits(object.MaxSymbolLen.low >>> 0, object.MaxSymbolLen.high >>> 0).toNumber(true);
        if (object.MaxDescriptionLen != null)
          if ($util.Long) (message.MaxDescriptionLen = $util.Long.fromValue(object.MaxDescriptionLen)).unsigned = true;
          else if (typeof object.MaxDescriptionLen === 'string') message.MaxDescriptionLen = parseInt(object.MaxDescriptionLen, 10);
          else if (typeof object.MaxDescriptionLen === 'number') message.MaxDescriptionLen = object.MaxDescriptionLen;
          else if (typeof object.MaxDescriptionLen === 'object')
            message.MaxDescriptionLen = new $util.LongBits(
              object.MaxDescriptionLen.low >>> 0,
              object.MaxDescriptionLen.high >>> 0,
            ).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.Params
       * @static
       * @param {ununifi.nftmint.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.MaxNFTSupplyCap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.MaxNFTSupplyCap = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.MinClassNameLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.MinClassNameLen = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.MaxClassNameLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.MaxClassNameLen = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.MinUriLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.MinUriLen = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.MaxUriLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.MaxUriLen = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.MaxSymbolLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.MaxSymbolLen = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.MaxDescriptionLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.MaxDescriptionLen = options.longs === String ? '0' : 0;
        }
        if (message.MaxNFTSupplyCap != null && message.hasOwnProperty('MaxNFTSupplyCap'))
          if (typeof message.MaxNFTSupplyCap === 'number')
            object.MaxNFTSupplyCap = options.longs === String ? String(message.MaxNFTSupplyCap) : message.MaxNFTSupplyCap;
          else
            object.MaxNFTSupplyCap =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.MaxNFTSupplyCap)
                : options.longs === Number
                ? new $util.LongBits(message.MaxNFTSupplyCap.low >>> 0, message.MaxNFTSupplyCap.high >>> 0).toNumber(true)
                : message.MaxNFTSupplyCap;
        if (message.MinClassNameLen != null && message.hasOwnProperty('MinClassNameLen'))
          if (typeof message.MinClassNameLen === 'number')
            object.MinClassNameLen = options.longs === String ? String(message.MinClassNameLen) : message.MinClassNameLen;
          else
            object.MinClassNameLen =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.MinClassNameLen)
                : options.longs === Number
                ? new $util.LongBits(message.MinClassNameLen.low >>> 0, message.MinClassNameLen.high >>> 0).toNumber(true)
                : message.MinClassNameLen;
        if (message.MaxClassNameLen != null && message.hasOwnProperty('MaxClassNameLen'))
          if (typeof message.MaxClassNameLen === 'number')
            object.MaxClassNameLen = options.longs === String ? String(message.MaxClassNameLen) : message.MaxClassNameLen;
          else
            object.MaxClassNameLen =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.MaxClassNameLen)
                : options.longs === Number
                ? new $util.LongBits(message.MaxClassNameLen.low >>> 0, message.MaxClassNameLen.high >>> 0).toNumber(true)
                : message.MaxClassNameLen;
        if (message.MinUriLen != null && message.hasOwnProperty('MinUriLen'))
          if (typeof message.MinUriLen === 'number')
            object.MinUriLen = options.longs === String ? String(message.MinUriLen) : message.MinUriLen;
          else
            object.MinUriLen =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.MinUriLen)
                : options.longs === Number
                ? new $util.LongBits(message.MinUriLen.low >>> 0, message.MinUriLen.high >>> 0).toNumber(true)
                : message.MinUriLen;
        if (message.MaxUriLen != null && message.hasOwnProperty('MaxUriLen'))
          if (typeof message.MaxUriLen === 'number')
            object.MaxUriLen = options.longs === String ? String(message.MaxUriLen) : message.MaxUriLen;
          else
            object.MaxUriLen =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.MaxUriLen)
                : options.longs === Number
                ? new $util.LongBits(message.MaxUriLen.low >>> 0, message.MaxUriLen.high >>> 0).toNumber(true)
                : message.MaxUriLen;
        if (message.MaxSymbolLen != null && message.hasOwnProperty('MaxSymbolLen'))
          if (typeof message.MaxSymbolLen === 'number')
            object.MaxSymbolLen = options.longs === String ? String(message.MaxSymbolLen) : message.MaxSymbolLen;
          else
            object.MaxSymbolLen =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.MaxSymbolLen)
                : options.longs === Number
                ? new $util.LongBits(message.MaxSymbolLen.low >>> 0, message.MaxSymbolLen.high >>> 0).toNumber(true)
                : message.MaxSymbolLen;
        if (message.MaxDescriptionLen != null && message.hasOwnProperty('MaxDescriptionLen'))
          if (typeof message.MaxDescriptionLen === 'number')
            object.MaxDescriptionLen = options.longs === String ? String(message.MaxDescriptionLen) : message.MaxDescriptionLen;
          else
            object.MaxDescriptionLen =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.MaxDescriptionLen)
                : options.longs === Number
                ? new $util.LongBits(message.MaxDescriptionLen.low >>> 0, message.MaxDescriptionLen.high >>> 0).toNumber(true)
                : message.MaxDescriptionLen;
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    nftmint.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.nftmint
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.nftmint.Msg#createClass}.
       * @memberof ununifi.nftmint.Msg
       * @typedef CreateClassCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.MsgCreateClassResponse} [response] MsgCreateClassResponse
       */

      /**
       * Calls CreateClass.
       * @function createClass
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgCreateClass} request MsgCreateClass message or plain object
       * @param {ununifi.nftmint.Msg.CreateClassCallback} callback Node-style callback called with the error, if any, and MsgCreateClassResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.createClass = function createClass(request, callback) {
          return this.rpcCall(
            createClass,
            $root.ununifi.nftmint.MsgCreateClass,
            $root.ununifi.nftmint.MsgCreateClassResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CreateClass' },
      );

      /**
       * Calls CreateClass.
       * @function createClass
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgCreateClass} request MsgCreateClass message or plain object
       * @returns {Promise<ununifi.nftmint.MsgCreateClassResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Msg#sendClassOwnership}.
       * @memberof ununifi.nftmint.Msg
       * @typedef SendClassOwnershipCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.MsgSendClassOwnershipResponse} [response] MsgSendClassOwnershipResponse
       */

      /**
       * Calls SendClassOwnership.
       * @function sendClassOwnership
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgSendClassOwnership} request MsgSendClassOwnership message or plain object
       * @param {ununifi.nftmint.Msg.SendClassOwnershipCallback} callback Node-style callback called with the error, if any, and MsgSendClassOwnershipResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.sendClassOwnership = function sendClassOwnership(request, callback) {
          return this.rpcCall(
            sendClassOwnership,
            $root.ununifi.nftmint.MsgSendClassOwnership,
            $root.ununifi.nftmint.MsgSendClassOwnershipResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'SendClassOwnership' },
      );

      /**
       * Calls SendClassOwnership.
       * @function sendClassOwnership
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgSendClassOwnership} request MsgSendClassOwnership message or plain object
       * @returns {Promise<ununifi.nftmint.MsgSendClassOwnershipResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Msg#updateBaseTokenUri}.
       * @memberof ununifi.nftmint.Msg
       * @typedef UpdateBaseTokenUriCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} [response] MsgUpdateBaseTokenUriResponse
       */

      /**
       * Calls UpdateBaseTokenUri.
       * @function updateBaseTokenUri
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} request MsgUpdateBaseTokenUri message or plain object
       * @param {ununifi.nftmint.Msg.UpdateBaseTokenUriCallback} callback Node-style callback called with the error, if any, and MsgUpdateBaseTokenUriResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateBaseTokenUri = function updateBaseTokenUri(request, callback) {
          return this.rpcCall(
            updateBaseTokenUri,
            $root.ununifi.nftmint.MsgUpdateBaseTokenUri,
            $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateBaseTokenUri' },
      );

      /**
       * Calls UpdateBaseTokenUri.
       * @function updateBaseTokenUri
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} request MsgUpdateBaseTokenUri message or plain object
       * @returns {Promise<ununifi.nftmint.MsgUpdateBaseTokenUriResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Msg#updateTokenSupplyCap}.
       * @memberof ununifi.nftmint.Msg
       * @typedef UpdateTokenSupplyCapCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} [response] MsgUpdateTokenSupplyCapResponse
       */

      /**
       * Calls UpdateTokenSupplyCap.
       * @function updateTokenSupplyCap
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} request MsgUpdateTokenSupplyCap message or plain object
       * @param {ununifi.nftmint.Msg.UpdateTokenSupplyCapCallback} callback Node-style callback called with the error, if any, and MsgUpdateTokenSupplyCapResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateTokenSupplyCap = function updateTokenSupplyCap(request, callback) {
          return this.rpcCall(
            updateTokenSupplyCap,
            $root.ununifi.nftmint.MsgUpdateTokenSupplyCap,
            $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateTokenSupplyCap' },
      );

      /**
       * Calls UpdateTokenSupplyCap.
       * @function updateTokenSupplyCap
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} request MsgUpdateTokenSupplyCap message or plain object
       * @returns {Promise<ununifi.nftmint.MsgUpdateTokenSupplyCapResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Msg#mintNFT}.
       * @memberof ununifi.nftmint.Msg
       * @typedef MintNFTCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.MsgMintNFTResponse} [response] MsgMintNFTResponse
       */

      /**
       * Calls MintNFT.
       * @function mintNFT
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgMintNFT} request MsgMintNFT message or plain object
       * @param {ununifi.nftmint.Msg.MintNFTCallback} callback Node-style callback called with the error, if any, and MsgMintNFTResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.mintNFT = function mintNFT(request, callback) {
          return this.rpcCall(mintNFT, $root.ununifi.nftmint.MsgMintNFT, $root.ununifi.nftmint.MsgMintNFTResponse, request, callback);
        }),
        'name',
        { value: 'MintNFT' },
      );

      /**
       * Calls MintNFT.
       * @function mintNFT
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgMintNFT} request MsgMintNFT message or plain object
       * @returns {Promise<ununifi.nftmint.MsgMintNFTResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftmint.Msg#burnNFT}.
       * @memberof ununifi.nftmint.Msg
       * @typedef BurnNFTCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftmint.MsgBurnNFTResponse} [response] MsgBurnNFTResponse
       */

      /**
       * Calls BurnNFT.
       * @function burnNFT
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgBurnNFT} request MsgBurnNFT message or plain object
       * @param {ununifi.nftmint.Msg.BurnNFTCallback} callback Node-style callback called with the error, if any, and MsgBurnNFTResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.burnNFT = function burnNFT(request, callback) {
          return this.rpcCall(burnNFT, $root.ununifi.nftmint.MsgBurnNFT, $root.ununifi.nftmint.MsgBurnNFTResponse, request, callback);
        }),
        'name',
        { value: 'BurnNFT' },
      );

      /**
       * Calls BurnNFT.
       * @function burnNFT
       * @memberof ununifi.nftmint.Msg
       * @instance
       * @param {ununifi.nftmint.IMsgBurnNFT} request MsgBurnNFT message or plain object
       * @returns {Promise<ununifi.nftmint.MsgBurnNFTResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    nftmint.MsgCreateClass = (function () {
      /**
       * Properties of a MsgCreateClass.
       * @memberof ununifi.nftmint
       * @interface IMsgCreateClass
       * @property {string|null} [sender] MsgCreateClass sender
       * @property {string|null} [name] MsgCreateClass name
       * @property {string|null} [base_token_uri] MsgCreateClass base_token_uri
       * @property {Long|null} [token_supply_cap] MsgCreateClass token_supply_cap
       * @property {ununifi.nftmint.MintingPermission|null} [minting_permission] MsgCreateClass minting_permission
       * @property {string|null} [symbol] MsgCreateClass symbol
       * @property {string|null} [description] MsgCreateClass description
       * @property {string|null} [class_uri] MsgCreateClass class_uri
       */

      /**
       * Constructs a new MsgCreateClass.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgCreateClass.
       * @implements IMsgCreateClass
       * @constructor
       * @param {ununifi.nftmint.IMsgCreateClass=} [properties] Properties to set
       */
      function MsgCreateClass(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCreateClass sender.
       * @member {string} sender
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.sender = '';

      /**
       * MsgCreateClass name.
       * @member {string} name
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.name = '';

      /**
       * MsgCreateClass base_token_uri.
       * @member {string} base_token_uri
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.base_token_uri = '';

      /**
       * MsgCreateClass token_supply_cap.
       * @member {Long} token_supply_cap
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.token_supply_cap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgCreateClass minting_permission.
       * @member {ununifi.nftmint.MintingPermission} minting_permission
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.minting_permission = 0;

      /**
       * MsgCreateClass symbol.
       * @member {string} symbol
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.symbol = '';

      /**
       * MsgCreateClass description.
       * @member {string} description
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.description = '';

      /**
       * MsgCreateClass class_uri.
       * @member {string} class_uri
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.class_uri = '';

      /**
       * Encodes the specified MsgCreateClass message. Does not implicitly {@link ununifi.nftmint.MsgCreateClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgCreateClass
       * @static
       * @param {ununifi.nftmint.IMsgCreateClass} message MsgCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
        if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
        if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.token_supply_cap);
        if (message.minting_permission != null && Object.hasOwnProperty.call(message, 'minting_permission'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.minting_permission);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.symbol);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.description);
        if (message.class_uri != null && Object.hasOwnProperty.call(message, 'class_uri'))
          writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.class_uri);
        return writer;
      };

      /**
       * Encodes the specified MsgCreateClass message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgCreateClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgCreateClass
       * @static
       * @param {ununifi.nftmint.IMsgCreateClass} message MsgCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgCreateClass} MsgCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgCreateClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.base_token_uri = reader.string();
              break;
            case 4:
              message.token_supply_cap = reader.uint64();
              break;
            case 5:
              message.minting_permission = reader.int32();
              break;
            case 7:
              message.symbol = reader.string();
              break;
            case 8:
              message.description = reader.string();
              break;
            case 9:
              message.class_uri = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgCreateClass} MsgCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateClass message.
       * @function verify
       * @memberof ununifi.nftmint.MsgCreateClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
          if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (
            !$util.isInteger(message.token_supply_cap) &&
            !(message.token_supply_cap && $util.isInteger(message.token_supply_cap.low) && $util.isInteger(message.token_supply_cap.high))
          )
            return 'token_supply_cap: integer|Long expected';
        if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
          switch (message.minting_permission) {
            default:
              return 'minting_permission: enum value expected';
            case 0:
            case 1:
              break;
          }
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.class_uri != null && message.hasOwnProperty('class_uri'))
          if (!$util.isString(message.class_uri)) return 'class_uri: string expected';
        return null;
      };

      /**
       * Creates a MsgCreateClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgCreateClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgCreateClass} MsgCreateClass
       */
      MsgCreateClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgCreateClass) return object;
        let message = new $root.ununifi.nftmint.MsgCreateClass();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.name != null) message.name = String(object.name);
        if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
        if (object.token_supply_cap != null)
          if ($util.Long) (message.token_supply_cap = $util.Long.fromValue(object.token_supply_cap)).unsigned = true;
          else if (typeof object.token_supply_cap === 'string') message.token_supply_cap = parseInt(object.token_supply_cap, 10);
          else if (typeof object.token_supply_cap === 'number') message.token_supply_cap = object.token_supply_cap;
          else if (typeof object.token_supply_cap === 'object')
            message.token_supply_cap = new $util.LongBits(object.token_supply_cap.low >>> 0, object.token_supply_cap.high >>> 0).toNumber(
              true,
            );
        switch (object.minting_permission) {
          case 'OnlyOwner':
          case 0:
            message.minting_permission = 0;
            break;
          case 'Anyone':
          case 1:
            message.minting_permission = 1;
            break;
        }
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.description != null) message.description = String(object.description);
        if (object.class_uri != null) message.class_uri = String(object.class_uri);
        return message;
      };

      /**
       * Creates a plain object from a MsgCreateClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgCreateClass
       * @static
       * @param {ununifi.nftmint.MsgCreateClass} message MsgCreateClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.name = '';
          object.base_token_uri = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.token_supply_cap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.token_supply_cap = options.longs === String ? '0' : 0;
          object.minting_permission = options.enums === String ? 'OnlyOwner' : 0;
          object.symbol = '';
          object.description = '';
          object.class_uri = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (typeof message.token_supply_cap === 'number')
            object.token_supply_cap = options.longs === String ? String(message.token_supply_cap) : message.token_supply_cap;
          else
            object.token_supply_cap =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.token_supply_cap)
                : options.longs === Number
                ? new $util.LongBits(message.token_supply_cap.low >>> 0, message.token_supply_cap.high >>> 0).toNumber(true)
                : message.token_supply_cap;
        if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
          object.minting_permission =
            options.enums === String ? $root.ununifi.nftmint.MintingPermission[message.minting_permission] : message.minting_permission;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.class_uri != null && message.hasOwnProperty('class_uri')) object.class_uri = message.class_uri;
        return object;
      };

      /**
       * Converts this MsgCreateClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgCreateClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateClass;
    })();

    nftmint.MsgCreateClassResponse = (function () {
      /**
       * Properties of a MsgCreateClassResponse.
       * @memberof ununifi.nftmint
       * @interface IMsgCreateClassResponse
       */

      /**
       * Constructs a new MsgCreateClassResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgCreateClassResponse.
       * @implements IMsgCreateClassResponse
       * @constructor
       * @param {ununifi.nftmint.IMsgCreateClassResponse=} [properties] Properties to set
       */
      function MsgCreateClassResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgCreateClassResponse message. Does not implicitly {@link ununifi.nftmint.MsgCreateClassResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @static
       * @param {ununifi.nftmint.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClassResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCreateClassResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgCreateClassResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @static
       * @param {ununifi.nftmint.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateClassResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgCreateClassResponse} MsgCreateClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClassResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgCreateClassResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateClassResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgCreateClassResponse} MsgCreateClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClassResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateClassResponse message.
       * @function verify
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateClassResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgCreateClassResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgCreateClassResponse} MsgCreateClassResponse
       */
      MsgCreateClassResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgCreateClassResponse) return object;
        return new $root.ununifi.nftmint.MsgCreateClassResponse();
      };

      /**
       * Creates a plain object from a MsgCreateClassResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @static
       * @param {ununifi.nftmint.MsgCreateClassResponse} message MsgCreateClassResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateClassResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCreateClassResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgCreateClassResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateClassResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateClassResponse;
    })();

    nftmint.MsgSendClassOwnership = (function () {
      /**
       * Properties of a MsgSendClassOwnership.
       * @memberof ununifi.nftmint
       * @interface IMsgSendClassOwnership
       * @property {string|null} [sender] MsgSendClassOwnership sender
       * @property {string|null} [class_id] MsgSendClassOwnership class_id
       * @property {string|null} [recipient] MsgSendClassOwnership recipient
       */

      /**
       * Constructs a new MsgSendClassOwnership.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgSendClassOwnership.
       * @implements IMsgSendClassOwnership
       * @constructor
       * @param {ununifi.nftmint.IMsgSendClassOwnership=} [properties] Properties to set
       */
      function MsgSendClassOwnership(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSendClassOwnership sender.
       * @member {string} sender
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @instance
       */
      MsgSendClassOwnership.prototype.sender = '';

      /**
       * MsgSendClassOwnership class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @instance
       */
      MsgSendClassOwnership.prototype.class_id = '';

      /**
       * MsgSendClassOwnership recipient.
       * @member {string} recipient
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @instance
       */
      MsgSendClassOwnership.prototype.recipient = '';

      /**
       * Encodes the specified MsgSendClassOwnership message. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnership.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @static
       * @param {ununifi.nftmint.IMsgSendClassOwnership} message MsgSendClassOwnership message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendClassOwnership.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.recipient);
        return writer;
      };

      /**
       * Encodes the specified MsgSendClassOwnership message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnership.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @static
       * @param {ununifi.nftmint.IMsgSendClassOwnership} message MsgSendClassOwnership message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendClassOwnership.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSendClassOwnership message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgSendClassOwnership} MsgSendClassOwnership
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendClassOwnership.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgSendClassOwnership();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSendClassOwnership message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgSendClassOwnership} MsgSendClassOwnership
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendClassOwnership.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSendClassOwnership message.
       * @function verify
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSendClassOwnership.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        return null;
      };

      /**
       * Creates a MsgSendClassOwnership message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgSendClassOwnership} MsgSendClassOwnership
       */
      MsgSendClassOwnership.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgSendClassOwnership) return object;
        let message = new $root.ununifi.nftmint.MsgSendClassOwnership();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.recipient != null) message.recipient = String(object.recipient);
        return message;
      };

      /**
       * Creates a plain object from a MsgSendClassOwnership message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @static
       * @param {ununifi.nftmint.MsgSendClassOwnership} message MsgSendClassOwnership
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSendClassOwnership.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.recipient = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        return object;
      };

      /**
       * Converts this MsgSendClassOwnership to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgSendClassOwnership
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSendClassOwnership.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSendClassOwnership;
    })();

    nftmint.MsgSendClassOwnershipResponse = (function () {
      /**
       * Properties of a MsgSendClassOwnershipResponse.
       * @memberof ununifi.nftmint
       * @interface IMsgSendClassOwnershipResponse
       */

      /**
       * Constructs a new MsgSendClassOwnershipResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgSendClassOwnershipResponse.
       * @implements IMsgSendClassOwnershipResponse
       * @constructor
       * @param {ununifi.nftmint.IMsgSendClassOwnershipResponse=} [properties] Properties to set
       */
      function MsgSendClassOwnershipResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgSendClassOwnershipResponse message. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnershipResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @static
       * @param {ununifi.nftmint.IMsgSendClassOwnershipResponse} message MsgSendClassOwnershipResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendClassOwnershipResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSendClassOwnershipResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgSendClassOwnershipResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @static
       * @param {ununifi.nftmint.IMsgSendClassOwnershipResponse} message MsgSendClassOwnershipResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSendClassOwnershipResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSendClassOwnershipResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgSendClassOwnershipResponse} MsgSendClassOwnershipResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendClassOwnershipResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgSendClassOwnershipResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSendClassOwnershipResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgSendClassOwnershipResponse} MsgSendClassOwnershipResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSendClassOwnershipResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSendClassOwnershipResponse message.
       * @function verify
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSendClassOwnershipResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgSendClassOwnershipResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgSendClassOwnershipResponse} MsgSendClassOwnershipResponse
       */
      MsgSendClassOwnershipResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgSendClassOwnershipResponse) return object;
        return new $root.ununifi.nftmint.MsgSendClassOwnershipResponse();
      };

      /**
       * Creates a plain object from a MsgSendClassOwnershipResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @static
       * @param {ununifi.nftmint.MsgSendClassOwnershipResponse} message MsgSendClassOwnershipResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSendClassOwnershipResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSendClassOwnershipResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgSendClassOwnershipResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSendClassOwnershipResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSendClassOwnershipResponse;
    })();

    nftmint.MsgUpdateBaseTokenUri = (function () {
      /**
       * Properties of a MsgUpdateBaseTokenUri.
       * @memberof ununifi.nftmint
       * @interface IMsgUpdateBaseTokenUri
       * @property {string|null} [sender] MsgUpdateBaseTokenUri sender
       * @property {string|null} [class_id] MsgUpdateBaseTokenUri class_id
       * @property {string|null} [base_token_uri] MsgUpdateBaseTokenUri base_token_uri
       */

      /**
       * Constructs a new MsgUpdateBaseTokenUri.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgUpdateBaseTokenUri.
       * @implements IMsgUpdateBaseTokenUri
       * @constructor
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri=} [properties] Properties to set
       */
      function MsgUpdateBaseTokenUri(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateBaseTokenUri sender.
       * @member {string} sender
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @instance
       */
      MsgUpdateBaseTokenUri.prototype.sender = '';

      /**
       * MsgUpdateBaseTokenUri class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @instance
       */
      MsgUpdateBaseTokenUri.prototype.class_id = '';

      /**
       * MsgUpdateBaseTokenUri base_token_uri.
       * @member {string} base_token_uri
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @instance
       */
      MsgUpdateBaseTokenUri.prototype.base_token_uri = '';

      /**
       * Encodes the specified MsgUpdateBaseTokenUri message. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUri.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @static
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} message MsgUpdateBaseTokenUri message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateBaseTokenUri.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateBaseTokenUri message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUri.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @static
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUri} message MsgUpdateBaseTokenUri message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateBaseTokenUri.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateBaseTokenUri message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgUpdateBaseTokenUri} MsgUpdateBaseTokenUri
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateBaseTokenUri.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgUpdateBaseTokenUri();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.base_token_uri = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateBaseTokenUri message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgUpdateBaseTokenUri} MsgUpdateBaseTokenUri
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateBaseTokenUri.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateBaseTokenUri message.
       * @function verify
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateBaseTokenUri.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
          if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
        return null;
      };

      /**
       * Creates a MsgUpdateBaseTokenUri message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgUpdateBaseTokenUri} MsgUpdateBaseTokenUri
       */
      MsgUpdateBaseTokenUri.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgUpdateBaseTokenUri) return object;
        let message = new $root.ununifi.nftmint.MsgUpdateBaseTokenUri();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateBaseTokenUri message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @static
       * @param {ununifi.nftmint.MsgUpdateBaseTokenUri} message MsgUpdateBaseTokenUri
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateBaseTokenUri.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.base_token_uri = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
        return object;
      };

      /**
       * Converts this MsgUpdateBaseTokenUri to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUri
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateBaseTokenUri.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateBaseTokenUri;
    })();

    nftmint.MsgUpdateBaseTokenUriResponse = (function () {
      /**
       * Properties of a MsgUpdateBaseTokenUriResponse.
       * @memberof ununifi.nftmint
       * @interface IMsgUpdateBaseTokenUriResponse
       */

      /**
       * Constructs a new MsgUpdateBaseTokenUriResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgUpdateBaseTokenUriResponse.
       * @implements IMsgUpdateBaseTokenUriResponse
       * @constructor
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUriResponse=} [properties] Properties to set
       */
      function MsgUpdateBaseTokenUriResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateBaseTokenUriResponse message. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUriResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @static
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUriResponse} message MsgUpdateBaseTokenUriResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateBaseTokenUriResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateBaseTokenUriResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateBaseTokenUriResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @static
       * @param {ununifi.nftmint.IMsgUpdateBaseTokenUriResponse} message MsgUpdateBaseTokenUriResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateBaseTokenUriResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateBaseTokenUriResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} MsgUpdateBaseTokenUriResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateBaseTokenUriResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateBaseTokenUriResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} MsgUpdateBaseTokenUriResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateBaseTokenUriResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateBaseTokenUriResponse message.
       * @function verify
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateBaseTokenUriResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateBaseTokenUriResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} MsgUpdateBaseTokenUriResponse
       */
      MsgUpdateBaseTokenUriResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse) return object;
        return new $root.ununifi.nftmint.MsgUpdateBaseTokenUriResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateBaseTokenUriResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @static
       * @param {ununifi.nftmint.MsgUpdateBaseTokenUriResponse} message MsgUpdateBaseTokenUriResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateBaseTokenUriResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateBaseTokenUriResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgUpdateBaseTokenUriResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateBaseTokenUriResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateBaseTokenUriResponse;
    })();

    nftmint.MsgUpdateTokenSupplyCap = (function () {
      /**
       * Properties of a MsgUpdateTokenSupplyCap.
       * @memberof ununifi.nftmint
       * @interface IMsgUpdateTokenSupplyCap
       * @property {string|null} [sender] MsgUpdateTokenSupplyCap sender
       * @property {string|null} [class_id] MsgUpdateTokenSupplyCap class_id
       * @property {Long|null} [token_supply_cap] MsgUpdateTokenSupplyCap token_supply_cap
       */

      /**
       * Constructs a new MsgUpdateTokenSupplyCap.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgUpdateTokenSupplyCap.
       * @implements IMsgUpdateTokenSupplyCap
       * @constructor
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap=} [properties] Properties to set
       */
      function MsgUpdateTokenSupplyCap(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateTokenSupplyCap sender.
       * @member {string} sender
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @instance
       */
      MsgUpdateTokenSupplyCap.prototype.sender = '';

      /**
       * MsgUpdateTokenSupplyCap class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @instance
       */
      MsgUpdateTokenSupplyCap.prototype.class_id = '';

      /**
       * MsgUpdateTokenSupplyCap token_supply_cap.
       * @member {Long} token_supply_cap
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @instance
       */
      MsgUpdateTokenSupplyCap.prototype.token_supply_cap = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified MsgUpdateTokenSupplyCap message. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCap.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @static
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} message MsgUpdateTokenSupplyCap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateTokenSupplyCap.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.token_supply_cap);
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateTokenSupplyCap message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCap.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @static
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCap} message MsgUpdateTokenSupplyCap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateTokenSupplyCap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateTokenSupplyCap message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCap} MsgUpdateTokenSupplyCap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateTokenSupplyCap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgUpdateTokenSupplyCap();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_supply_cap = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateTokenSupplyCap message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCap} MsgUpdateTokenSupplyCap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateTokenSupplyCap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateTokenSupplyCap message.
       * @function verify
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateTokenSupplyCap.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (
            !$util.isInteger(message.token_supply_cap) &&
            !(message.token_supply_cap && $util.isInteger(message.token_supply_cap.low) && $util.isInteger(message.token_supply_cap.high))
          )
            return 'token_supply_cap: integer|Long expected';
        return null;
      };

      /**
       * Creates a MsgUpdateTokenSupplyCap message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCap} MsgUpdateTokenSupplyCap
       */
      MsgUpdateTokenSupplyCap.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgUpdateTokenSupplyCap) return object;
        let message = new $root.ununifi.nftmint.MsgUpdateTokenSupplyCap();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_supply_cap != null)
          if ($util.Long) (message.token_supply_cap = $util.Long.fromValue(object.token_supply_cap)).unsigned = true;
          else if (typeof object.token_supply_cap === 'string') message.token_supply_cap = parseInt(object.token_supply_cap, 10);
          else if (typeof object.token_supply_cap === 'number') message.token_supply_cap = object.token_supply_cap;
          else if (typeof object.token_supply_cap === 'object')
            message.token_supply_cap = new $util.LongBits(object.token_supply_cap.low >>> 0, object.token_supply_cap.high >>> 0).toNumber(
              true,
            );
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateTokenSupplyCap message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @static
       * @param {ununifi.nftmint.MsgUpdateTokenSupplyCap} message MsgUpdateTokenSupplyCap
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateTokenSupplyCap.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.token_supply_cap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.token_supply_cap = options.longs === String ? '0' : 0;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (typeof message.token_supply_cap === 'number')
            object.token_supply_cap = options.longs === String ? String(message.token_supply_cap) : message.token_supply_cap;
          else
            object.token_supply_cap =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.token_supply_cap)
                : options.longs === Number
                ? new $util.LongBits(message.token_supply_cap.low >>> 0, message.token_supply_cap.high >>> 0).toNumber(true)
                : message.token_supply_cap;
        return object;
      };

      /**
       * Converts this MsgUpdateTokenSupplyCap to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCap
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateTokenSupplyCap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateTokenSupplyCap;
    })();

    nftmint.MsgUpdateTokenSupplyCapResponse = (function () {
      /**
       * Properties of a MsgUpdateTokenSupplyCapResponse.
       * @memberof ununifi.nftmint
       * @interface IMsgUpdateTokenSupplyCapResponse
       */

      /**
       * Constructs a new MsgUpdateTokenSupplyCapResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgUpdateTokenSupplyCapResponse.
       * @implements IMsgUpdateTokenSupplyCapResponse
       * @constructor
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCapResponse=} [properties] Properties to set
       */
      function MsgUpdateTokenSupplyCapResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateTokenSupplyCapResponse message. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCapResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @static
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCapResponse} message MsgUpdateTokenSupplyCapResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateTokenSupplyCapResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateTokenSupplyCapResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgUpdateTokenSupplyCapResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @static
       * @param {ununifi.nftmint.IMsgUpdateTokenSupplyCapResponse} message MsgUpdateTokenSupplyCapResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateTokenSupplyCapResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateTokenSupplyCapResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} MsgUpdateTokenSupplyCapResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateTokenSupplyCapResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateTokenSupplyCapResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} MsgUpdateTokenSupplyCapResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateTokenSupplyCapResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateTokenSupplyCapResponse message.
       * @function verify
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateTokenSupplyCapResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateTokenSupplyCapResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} MsgUpdateTokenSupplyCapResponse
       */
      MsgUpdateTokenSupplyCapResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse) return object;
        return new $root.ununifi.nftmint.MsgUpdateTokenSupplyCapResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateTokenSupplyCapResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @static
       * @param {ununifi.nftmint.MsgUpdateTokenSupplyCapResponse} message MsgUpdateTokenSupplyCapResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateTokenSupplyCapResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateTokenSupplyCapResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgUpdateTokenSupplyCapResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateTokenSupplyCapResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateTokenSupplyCapResponse;
    })();

    nftmint.MsgMintNFT = (function () {
      /**
       * Properties of a MsgMintNFT.
       * @memberof ununifi.nftmint
       * @interface IMsgMintNFT
       * @property {string|null} [sender] MsgMintNFT sender
       * @property {string|null} [class_id] MsgMintNFT class_id
       * @property {string|null} [nft_id] MsgMintNFT nft_id
       * @property {string|null} [recipient] MsgMintNFT recipient
       */

      /**
       * Constructs a new MsgMintNFT.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgMintNFT.
       * @implements IMsgMintNFT
       * @constructor
       * @param {ununifi.nftmint.IMsgMintNFT=} [properties] Properties to set
       */
      function MsgMintNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgMintNFT sender.
       * @member {string} sender
       * @memberof ununifi.nftmint.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.sender = '';

      /**
       * MsgMintNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.class_id = '';

      /**
       * MsgMintNFT nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmint.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.nft_id = '';

      /**
       * MsgMintNFT recipient.
       * @member {string} recipient
       * @memberof ununifi.nftmint.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.recipient = '';

      /**
       * Encodes the specified MsgMintNFT message. Does not implicitly {@link ununifi.nftmint.MsgMintNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgMintNFT
       * @static
       * @param {ununifi.nftmint.IMsgMintNFT} message MsgMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.recipient);
        return writer;
      };

      /**
       * Encodes the specified MsgMintNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgMintNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgMintNFT
       * @static
       * @param {ununifi.nftmint.IMsgMintNFT} message MsgMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgMintNFT} MsgMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgMintNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            case 4:
              message.recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgMintNFT} MsgMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintNFT message.
       * @function verify
       * @memberof ununifi.nftmint.MsgMintNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        return null;
      };

      /**
       * Creates a MsgMintNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgMintNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgMintNFT} MsgMintNFT
       */
      MsgMintNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgMintNFT) return object;
        let message = new $root.ununifi.nftmint.MsgMintNFT();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        if (object.recipient != null) message.recipient = String(object.recipient);
        return message;
      };

      /**
       * Creates a plain object from a MsgMintNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgMintNFT
       * @static
       * @param {ununifi.nftmint.MsgMintNFT} message MsgMintNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.nft_id = '';
          object.recipient = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        return object;
      };

      /**
       * Converts this MsgMintNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgMintNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintNFT;
    })();

    nftmint.MsgMintNFTResponse = (function () {
      /**
       * Properties of a MsgMintNFTResponse.
       * @memberof ununifi.nftmint
       * @interface IMsgMintNFTResponse
       */

      /**
       * Constructs a new MsgMintNFTResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgMintNFTResponse.
       * @implements IMsgMintNFTResponse
       * @constructor
       * @param {ununifi.nftmint.IMsgMintNFTResponse=} [properties] Properties to set
       */
      function MsgMintNFTResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgMintNFTResponse message. Does not implicitly {@link ununifi.nftmint.MsgMintNFTResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @static
       * @param {ununifi.nftmint.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFTResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgMintNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgMintNFTResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @static
       * @param {ununifi.nftmint.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintNFTResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgMintNFTResponse} MsgMintNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFTResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgMintNFTResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintNFTResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgMintNFTResponse} MsgMintNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFTResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintNFTResponse message.
       * @function verify
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintNFTResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgMintNFTResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgMintNFTResponse} MsgMintNFTResponse
       */
      MsgMintNFTResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgMintNFTResponse) return object;
        return new $root.ununifi.nftmint.MsgMintNFTResponse();
      };

      /**
       * Creates a plain object from a MsgMintNFTResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @static
       * @param {ununifi.nftmint.MsgMintNFTResponse} message MsgMintNFTResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintNFTResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgMintNFTResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgMintNFTResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintNFTResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintNFTResponse;
    })();

    nftmint.MsgBurnNFT = (function () {
      /**
       * Properties of a MsgBurnNFT.
       * @memberof ununifi.nftmint
       * @interface IMsgBurnNFT
       * @property {string|null} [sender] MsgBurnNFT sender
       * @property {string|null} [class_id] MsgBurnNFT class_id
       * @property {string|null} [nft_id] MsgBurnNFT nft_id
       */

      /**
       * Constructs a new MsgBurnNFT.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgBurnNFT.
       * @implements IMsgBurnNFT
       * @constructor
       * @param {ununifi.nftmint.IMsgBurnNFT=} [properties] Properties to set
       */
      function MsgBurnNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgBurnNFT sender.
       * @member {string} sender
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @instance
       */
      MsgBurnNFT.prototype.sender = '';

      /**
       * MsgBurnNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @instance
       */
      MsgBurnNFT.prototype.class_id = '';

      /**
       * MsgBurnNFT nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @instance
       */
      MsgBurnNFT.prototype.nft_id = '';

      /**
       * Encodes the specified MsgBurnNFT message. Does not implicitly {@link ununifi.nftmint.MsgBurnNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @static
       * @param {ununifi.nftmint.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified MsgBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgBurnNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @static
       * @param {ununifi.nftmint.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBurnNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgBurnNFT} MsgBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgBurnNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBurnNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgBurnNFT} MsgBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBurnNFT message.
       * @function verify
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBurnNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates a MsgBurnNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgBurnNFT} MsgBurnNFT
       */
      MsgBurnNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgBurnNFT) return object;
        let message = new $root.ununifi.nftmint.MsgBurnNFT();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from a MsgBurnNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @static
       * @param {ununifi.nftmint.MsgBurnNFT} message MsgBurnNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBurnNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this MsgBurnNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgBurnNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBurnNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBurnNFT;
    })();

    nftmint.MsgBurnNFTResponse = (function () {
      /**
       * Properties of a MsgBurnNFTResponse.
       * @memberof ununifi.nftmint
       * @interface IMsgBurnNFTResponse
       */

      /**
       * Constructs a new MsgBurnNFTResponse.
       * @memberof ununifi.nftmint
       * @classdesc Represents a MsgBurnNFTResponse.
       * @implements IMsgBurnNFTResponse
       * @constructor
       * @param {ununifi.nftmint.IMsgBurnNFTResponse=} [properties] Properties to set
       */
      function MsgBurnNFTResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgBurnNFTResponse message. Does not implicitly {@link ununifi.nftmint.MsgBurnNFTResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @static
       * @param {ununifi.nftmint.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFTResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgBurnNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftmint.MsgBurnNFTResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @static
       * @param {ununifi.nftmint.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBurnNFTResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.MsgBurnNFTResponse} MsgBurnNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFTResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.MsgBurnNFTResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBurnNFTResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.MsgBurnNFTResponse} MsgBurnNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFTResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBurnNFTResponse message.
       * @function verify
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBurnNFTResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgBurnNFTResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.MsgBurnNFTResponse} MsgBurnNFTResponse
       */
      MsgBurnNFTResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.MsgBurnNFTResponse) return object;
        return new $root.ununifi.nftmint.MsgBurnNFTResponse();
      };

      /**
       * Creates a plain object from a MsgBurnNFTResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @static
       * @param {ununifi.nftmint.MsgBurnNFTResponse} message MsgBurnNFTResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBurnNFTResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgBurnNFTResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.MsgBurnNFTResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBurnNFTResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBurnNFTResponse;
    })();

    nftmint.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.nftmint
       * @interface IGenesisState
       * @property {ununifi.nftmint.IParams|null} [params] GenesisState params
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.nftmint
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.nftmint.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.nftmint.IParams|null|undefined} params
       * @memberof ununifi.nftmint.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftmint.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.GenesisState
       * @static
       * @param {ununifi.nftmint.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftmint.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftmint.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.GenesisState
       * @static
       * @param {ununifi.nftmint.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftmint.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.nftmint.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftmint.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.GenesisState) return object;
        let message = new $root.ununifi.nftmint.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftmint.GenesisState.params: object expected');
          message.params = $root.ununifi.nftmint.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.GenesisState
       * @static
       * @param {ununifi.nftmint.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftmint.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    nftmint.EventCreateClass = (function () {
      /**
       * Properties of an EventCreateClass.
       * @memberof ununifi.nftmint
       * @interface IEventCreateClass
       * @property {string|null} [owner] EventCreateClass owner
       * @property {string|null} [class_id] EventCreateClass class_id
       * @property {string|null} [base_token_uri] EventCreateClass base_token_uri
       * @property {string|null} [token_supply_cap] EventCreateClass token_supply_cap
       * @property {ununifi.nftmint.MintingPermission|null} [minting_permission] EventCreateClass minting_permission
       */

      /**
       * Constructs a new EventCreateClass.
       * @memberof ununifi.nftmint
       * @classdesc Represents an EventCreateClass.
       * @implements IEventCreateClass
       * @constructor
       * @param {ununifi.nftmint.IEventCreateClass=} [properties] Properties to set
       */
      function EventCreateClass(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventCreateClass owner.
       * @member {string} owner
       * @memberof ununifi.nftmint.EventCreateClass
       * @instance
       */
      EventCreateClass.prototype.owner = '';

      /**
       * EventCreateClass class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.EventCreateClass
       * @instance
       */
      EventCreateClass.prototype.class_id = '';

      /**
       * EventCreateClass base_token_uri.
       * @member {string} base_token_uri
       * @memberof ununifi.nftmint.EventCreateClass
       * @instance
       */
      EventCreateClass.prototype.base_token_uri = '';

      /**
       * EventCreateClass token_supply_cap.
       * @member {string} token_supply_cap
       * @memberof ununifi.nftmint.EventCreateClass
       * @instance
       */
      EventCreateClass.prototype.token_supply_cap = '';

      /**
       * EventCreateClass minting_permission.
       * @member {ununifi.nftmint.MintingPermission} minting_permission
       * @memberof ununifi.nftmint.EventCreateClass
       * @instance
       */
      EventCreateClass.prototype.minting_permission = 0;

      /**
       * Encodes the specified EventCreateClass message. Does not implicitly {@link ununifi.nftmint.EventCreateClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.EventCreateClass
       * @static
       * @param {ununifi.nftmint.IEventCreateClass} message EventCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCreateClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
        if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.token_supply_cap);
        if (message.minting_permission != null && Object.hasOwnProperty.call(message, 'minting_permission'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.minting_permission);
        return writer;
      };

      /**
       * Encodes the specified EventCreateClass message, length delimited. Does not implicitly {@link ununifi.nftmint.EventCreateClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.EventCreateClass
       * @static
       * @param {ununifi.nftmint.IEventCreateClass} message EventCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventCreateClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.EventCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.EventCreateClass} EventCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCreateClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.EventCreateClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.base_token_uri = reader.string();
              break;
            case 4:
              message.token_supply_cap = reader.string();
              break;
            case 5:
              message.minting_permission = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventCreateClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.EventCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.EventCreateClass} EventCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCreateClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventCreateClass message.
       * @function verify
       * @memberof ununifi.nftmint.EventCreateClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventCreateClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
          if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (!$util.isString(message.token_supply_cap)) return 'token_supply_cap: string expected';
        if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
          switch (message.minting_permission) {
            default:
              return 'minting_permission: enum value expected';
            case 0:
            case 1:
              break;
          }
        return null;
      };

      /**
       * Creates an EventCreateClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.EventCreateClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.EventCreateClass} EventCreateClass
       */
      EventCreateClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.EventCreateClass) return object;
        let message = new $root.ununifi.nftmint.EventCreateClass();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
        if (object.token_supply_cap != null) message.token_supply_cap = String(object.token_supply_cap);
        switch (object.minting_permission) {
          case 'OnlyOwner':
          case 0:
            message.minting_permission = 0;
            break;
          case 'Anyone':
          case 1:
            message.minting_permission = 1;
            break;
        }
        return message;
      };

      /**
       * Creates a plain object from an EventCreateClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.EventCreateClass
       * @static
       * @param {ununifi.nftmint.EventCreateClass} message EventCreateClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventCreateClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.base_token_uri = '';
          object.token_supply_cap = '';
          object.minting_permission = options.enums === String ? 'OnlyOwner' : 0;
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          object.token_supply_cap = message.token_supply_cap;
        if (message.minting_permission != null && message.hasOwnProperty('minting_permission'))
          object.minting_permission =
            options.enums === String ? $root.ununifi.nftmint.MintingPermission[message.minting_permission] : message.minting_permission;
        return object;
      };

      /**
       * Converts this EventCreateClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.EventCreateClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventCreateClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventCreateClass;
    })();

    nftmint.EventSendClassOwnership = (function () {
      /**
       * Properties of an EventSendClassOwnership.
       * @memberof ununifi.nftmint
       * @interface IEventSendClassOwnership
       * @property {string|null} [sender] EventSendClassOwnership sender
       * @property {string|null} [receiver] EventSendClassOwnership receiver
       * @property {string|null} [class_id] EventSendClassOwnership class_id
       */

      /**
       * Constructs a new EventSendClassOwnership.
       * @memberof ununifi.nftmint
       * @classdesc Represents an EventSendClassOwnership.
       * @implements IEventSendClassOwnership
       * @constructor
       * @param {ununifi.nftmint.IEventSendClassOwnership=} [properties] Properties to set
       */
      function EventSendClassOwnership(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventSendClassOwnership sender.
       * @member {string} sender
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @instance
       */
      EventSendClassOwnership.prototype.sender = '';

      /**
       * EventSendClassOwnership receiver.
       * @member {string} receiver
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @instance
       */
      EventSendClassOwnership.prototype.receiver = '';

      /**
       * EventSendClassOwnership class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @instance
       */
      EventSendClassOwnership.prototype.class_id = '';

      /**
       * Encodes the specified EventSendClassOwnership message. Does not implicitly {@link ununifi.nftmint.EventSendClassOwnership.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @static
       * @param {ununifi.nftmint.IEventSendClassOwnership} message EventSendClassOwnership message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventSendClassOwnership.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.receiver != null && Object.hasOwnProperty.call(message, 'receiver'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.receiver);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.class_id);
        return writer;
      };

      /**
       * Encodes the specified EventSendClassOwnership message, length delimited. Does not implicitly {@link ununifi.nftmint.EventSendClassOwnership.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @static
       * @param {ununifi.nftmint.IEventSendClassOwnership} message EventSendClassOwnership message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventSendClassOwnership.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventSendClassOwnership message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.EventSendClassOwnership} EventSendClassOwnership
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventSendClassOwnership.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.EventSendClassOwnership();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.receiver = reader.string();
              break;
            case 3:
              message.class_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventSendClassOwnership message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.EventSendClassOwnership} EventSendClassOwnership
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventSendClassOwnership.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventSendClassOwnership message.
       * @function verify
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventSendClassOwnership.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.receiver != null && message.hasOwnProperty('receiver'))
          if (!$util.isString(message.receiver)) return 'receiver: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        return null;
      };

      /**
       * Creates an EventSendClassOwnership message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.EventSendClassOwnership} EventSendClassOwnership
       */
      EventSendClassOwnership.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.EventSendClassOwnership) return object;
        let message = new $root.ununifi.nftmint.EventSendClassOwnership();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.receiver != null) message.receiver = String(object.receiver);
        if (object.class_id != null) message.class_id = String(object.class_id);
        return message;
      };

      /**
       * Creates a plain object from an EventSendClassOwnership message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @static
       * @param {ununifi.nftmint.EventSendClassOwnership} message EventSendClassOwnership
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventSendClassOwnership.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.receiver = '';
          object.class_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.receiver != null && message.hasOwnProperty('receiver')) object.receiver = message.receiver;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        return object;
      };

      /**
       * Converts this EventSendClassOwnership to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.EventSendClassOwnership
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventSendClassOwnership.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventSendClassOwnership;
    })();

    nftmint.EventUpdateBaseTokenUri = (function () {
      /**
       * Properties of an EventUpdateBaseTokenUri.
       * @memberof ununifi.nftmint
       * @interface IEventUpdateBaseTokenUri
       * @property {string|null} [owner] EventUpdateBaseTokenUri owner
       * @property {string|null} [class_id] EventUpdateBaseTokenUri class_id
       * @property {string|null} [base_token_uri] EventUpdateBaseTokenUri base_token_uri
       */

      /**
       * Constructs a new EventUpdateBaseTokenUri.
       * @memberof ununifi.nftmint
       * @classdesc Represents an EventUpdateBaseTokenUri.
       * @implements IEventUpdateBaseTokenUri
       * @constructor
       * @param {ununifi.nftmint.IEventUpdateBaseTokenUri=} [properties] Properties to set
       */
      function EventUpdateBaseTokenUri(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventUpdateBaseTokenUri owner.
       * @member {string} owner
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @instance
       */
      EventUpdateBaseTokenUri.prototype.owner = '';

      /**
       * EventUpdateBaseTokenUri class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @instance
       */
      EventUpdateBaseTokenUri.prototype.class_id = '';

      /**
       * EventUpdateBaseTokenUri base_token_uri.
       * @member {string} base_token_uri
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @instance
       */
      EventUpdateBaseTokenUri.prototype.base_token_uri = '';

      /**
       * Encodes the specified EventUpdateBaseTokenUri message. Does not implicitly {@link ununifi.nftmint.EventUpdateBaseTokenUri.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @static
       * @param {ununifi.nftmint.IEventUpdateBaseTokenUri} message EventUpdateBaseTokenUri message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdateBaseTokenUri.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.base_token_uri != null && Object.hasOwnProperty.call(message, 'base_token_uri'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_token_uri);
        return writer;
      };

      /**
       * Encodes the specified EventUpdateBaseTokenUri message, length delimited. Does not implicitly {@link ununifi.nftmint.EventUpdateBaseTokenUri.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @static
       * @param {ununifi.nftmint.IEventUpdateBaseTokenUri} message EventUpdateBaseTokenUri message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdateBaseTokenUri.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventUpdateBaseTokenUri message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.EventUpdateBaseTokenUri} EventUpdateBaseTokenUri
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdateBaseTokenUri.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.EventUpdateBaseTokenUri();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.base_token_uri = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventUpdateBaseTokenUri message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.EventUpdateBaseTokenUri} EventUpdateBaseTokenUri
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdateBaseTokenUri.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventUpdateBaseTokenUri message.
       * @function verify
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventUpdateBaseTokenUri.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri'))
          if (!$util.isString(message.base_token_uri)) return 'base_token_uri: string expected';
        return null;
      };

      /**
       * Creates an EventUpdateBaseTokenUri message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.EventUpdateBaseTokenUri} EventUpdateBaseTokenUri
       */
      EventUpdateBaseTokenUri.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.EventUpdateBaseTokenUri) return object;
        let message = new $root.ununifi.nftmint.EventUpdateBaseTokenUri();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.base_token_uri != null) message.base_token_uri = String(object.base_token_uri);
        return message;
      };

      /**
       * Creates a plain object from an EventUpdateBaseTokenUri message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @static
       * @param {ununifi.nftmint.EventUpdateBaseTokenUri} message EventUpdateBaseTokenUri
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventUpdateBaseTokenUri.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.base_token_uri = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.base_token_uri != null && message.hasOwnProperty('base_token_uri')) object.base_token_uri = message.base_token_uri;
        return object;
      };

      /**
       * Converts this EventUpdateBaseTokenUri to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.EventUpdateBaseTokenUri
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventUpdateBaseTokenUri.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventUpdateBaseTokenUri;
    })();

    nftmint.EventUpdateTokenSupplyCap = (function () {
      /**
       * Properties of an EventUpdateTokenSupplyCap.
       * @memberof ununifi.nftmint
       * @interface IEventUpdateTokenSupplyCap
       * @property {string|null} [owner] EventUpdateTokenSupplyCap owner
       * @property {string|null} [class_id] EventUpdateTokenSupplyCap class_id
       * @property {string|null} [token_supply_cap] EventUpdateTokenSupplyCap token_supply_cap
       */

      /**
       * Constructs a new EventUpdateTokenSupplyCap.
       * @memberof ununifi.nftmint
       * @classdesc Represents an EventUpdateTokenSupplyCap.
       * @implements IEventUpdateTokenSupplyCap
       * @constructor
       * @param {ununifi.nftmint.IEventUpdateTokenSupplyCap=} [properties] Properties to set
       */
      function EventUpdateTokenSupplyCap(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventUpdateTokenSupplyCap owner.
       * @member {string} owner
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @instance
       */
      EventUpdateTokenSupplyCap.prototype.owner = '';

      /**
       * EventUpdateTokenSupplyCap class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @instance
       */
      EventUpdateTokenSupplyCap.prototype.class_id = '';

      /**
       * EventUpdateTokenSupplyCap token_supply_cap.
       * @member {string} token_supply_cap
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @instance
       */
      EventUpdateTokenSupplyCap.prototype.token_supply_cap = '';

      /**
       * Encodes the specified EventUpdateTokenSupplyCap message. Does not implicitly {@link ununifi.nftmint.EventUpdateTokenSupplyCap.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @static
       * @param {ununifi.nftmint.IEventUpdateTokenSupplyCap} message EventUpdateTokenSupplyCap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdateTokenSupplyCap.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_supply_cap != null && Object.hasOwnProperty.call(message, 'token_supply_cap'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_supply_cap);
        return writer;
      };

      /**
       * Encodes the specified EventUpdateTokenSupplyCap message, length delimited. Does not implicitly {@link ununifi.nftmint.EventUpdateTokenSupplyCap.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @static
       * @param {ununifi.nftmint.IEventUpdateTokenSupplyCap} message EventUpdateTokenSupplyCap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdateTokenSupplyCap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventUpdateTokenSupplyCap message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.EventUpdateTokenSupplyCap} EventUpdateTokenSupplyCap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdateTokenSupplyCap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.EventUpdateTokenSupplyCap();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_supply_cap = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventUpdateTokenSupplyCap message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.EventUpdateTokenSupplyCap} EventUpdateTokenSupplyCap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdateTokenSupplyCap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventUpdateTokenSupplyCap message.
       * @function verify
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventUpdateTokenSupplyCap.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          if (!$util.isString(message.token_supply_cap)) return 'token_supply_cap: string expected';
        return null;
      };

      /**
       * Creates an EventUpdateTokenSupplyCap message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.EventUpdateTokenSupplyCap} EventUpdateTokenSupplyCap
       */
      EventUpdateTokenSupplyCap.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.EventUpdateTokenSupplyCap) return object;
        let message = new $root.ununifi.nftmint.EventUpdateTokenSupplyCap();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_supply_cap != null) message.token_supply_cap = String(object.token_supply_cap);
        return message;
      };

      /**
       * Creates a plain object from an EventUpdateTokenSupplyCap message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @static
       * @param {ununifi.nftmint.EventUpdateTokenSupplyCap} message EventUpdateTokenSupplyCap
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventUpdateTokenSupplyCap.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.token_supply_cap = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_supply_cap != null && message.hasOwnProperty('token_supply_cap'))
          object.token_supply_cap = message.token_supply_cap;
        return object;
      };

      /**
       * Converts this EventUpdateTokenSupplyCap to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.EventUpdateTokenSupplyCap
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventUpdateTokenSupplyCap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventUpdateTokenSupplyCap;
    })();

    nftmint.EventMintNFT = (function () {
      /**
       * Properties of an EventMintNFT.
       * @memberof ununifi.nftmint
       * @interface IEventMintNFT
       * @property {string|null} [class_id] EventMintNFT class_id
       * @property {string|null} [nft_id] EventMintNFT nft_id
       * @property {string|null} [owner] EventMintNFT owner
       * @property {string|null} [minter] EventMintNFT minter
       */

      /**
       * Constructs a new EventMintNFT.
       * @memberof ununifi.nftmint
       * @classdesc Represents an EventMintNFT.
       * @implements IEventMintNFT
       * @constructor
       * @param {ununifi.nftmint.IEventMintNFT=} [properties] Properties to set
       */
      function EventMintNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventMintNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.class_id = '';

      /**
       * EventMintNFT nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmint.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.nft_id = '';

      /**
       * EventMintNFT owner.
       * @member {string} owner
       * @memberof ununifi.nftmint.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.owner = '';

      /**
       * EventMintNFT minter.
       * @member {string} minter
       * @memberof ununifi.nftmint.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.minter = '';

      /**
       * Encodes the specified EventMintNFT message. Does not implicitly {@link ununifi.nftmint.EventMintNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.EventMintNFT
       * @static
       * @param {ununifi.nftmint.IEventMintNFT} message EventMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventMintNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.nft_id);
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.owner);
        if (message.minter != null && Object.hasOwnProperty.call(message, 'minter'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.minter);
        return writer;
      };

      /**
       * Encodes the specified EventMintNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.EventMintNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.EventMintNFT
       * @static
       * @param {ununifi.nftmint.IEventMintNFT} message EventMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventMintNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.EventMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.EventMintNFT} EventMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventMintNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.EventMintNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_id = reader.string();
              break;
            case 3:
              message.owner = reader.string();
              break;
            case 4:
              message.minter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventMintNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.EventMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.EventMintNFT} EventMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventMintNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventMintNFT message.
       * @function verify
       * @memberof ununifi.nftmint.EventMintNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventMintNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.minter != null && message.hasOwnProperty('minter'))
          if (!$util.isString(message.minter)) return 'minter: string expected';
        return null;
      };

      /**
       * Creates an EventMintNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.EventMintNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.EventMintNFT} EventMintNFT
       */
      EventMintNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.EventMintNFT) return object;
        let message = new $root.ununifi.nftmint.EventMintNFT();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        if (object.owner != null) message.owner = String(object.owner);
        if (object.minter != null) message.minter = String(object.minter);
        return message;
      };

      /**
       * Creates a plain object from an EventMintNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.EventMintNFT
       * @static
       * @param {ununifi.nftmint.EventMintNFT} message EventMintNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventMintNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_id = '';
          object.owner = '';
          object.minter = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.minter != null && message.hasOwnProperty('minter')) object.minter = message.minter;
        return object;
      };

      /**
       * Converts this EventMintNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.EventMintNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventMintNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventMintNFT;
    })();

    nftmint.EventBurnNFT = (function () {
      /**
       * Properties of an EventBurnNFT.
       * @memberof ununifi.nftmint
       * @interface IEventBurnNFT
       * @property {string|null} [burner] EventBurnNFT burner
       * @property {string|null} [class_id] EventBurnNFT class_id
       * @property {string|null} [nft_id] EventBurnNFT nft_id
       */

      /**
       * Constructs a new EventBurnNFT.
       * @memberof ununifi.nftmint
       * @classdesc Represents an EventBurnNFT.
       * @implements IEventBurnNFT
       * @constructor
       * @param {ununifi.nftmint.IEventBurnNFT=} [properties] Properties to set
       */
      function EventBurnNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventBurnNFT burner.
       * @member {string} burner
       * @memberof ununifi.nftmint.EventBurnNFT
       * @instance
       */
      EventBurnNFT.prototype.burner = '';

      /**
       * EventBurnNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftmint.EventBurnNFT
       * @instance
       */
      EventBurnNFT.prototype.class_id = '';

      /**
       * EventBurnNFT nft_id.
       * @member {string} nft_id
       * @memberof ununifi.nftmint.EventBurnNFT
       * @instance
       */
      EventBurnNFT.prototype.nft_id = '';

      /**
       * Encodes the specified EventBurnNFT message. Does not implicitly {@link ununifi.nftmint.EventBurnNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftmint.EventBurnNFT
       * @static
       * @param {ununifi.nftmint.IEventBurnNFT} message EventBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBurnNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.burner != null && Object.hasOwnProperty.call(message, 'burner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.burner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.nft_id);
        return writer;
      };

      /**
       * Encodes the specified EventBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftmint.EventBurnNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftmint.EventBurnNFT
       * @static
       * @param {ununifi.nftmint.IEventBurnNFT} message EventBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventBurnNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftmint.EventBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftmint.EventBurnNFT} EventBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBurnNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftmint.EventBurnNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.burner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.nft_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventBurnNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftmint.EventBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftmint.EventBurnNFT} EventBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBurnNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventBurnNFT message.
       * @function verify
       * @memberof ununifi.nftmint.EventBurnNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventBurnNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.burner != null && message.hasOwnProperty('burner'))
          if (!$util.isString(message.burner)) return 'burner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          if (!$util.isString(message.nft_id)) return 'nft_id: string expected';
        return null;
      };

      /**
       * Creates an EventBurnNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftmint.EventBurnNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftmint.EventBurnNFT} EventBurnNFT
       */
      EventBurnNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftmint.EventBurnNFT) return object;
        let message = new $root.ununifi.nftmint.EventBurnNFT();
        if (object.burner != null) message.burner = String(object.burner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_id != null) message.nft_id = String(object.nft_id);
        return message;
      };

      /**
       * Creates a plain object from an EventBurnNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftmint.EventBurnNFT
       * @static
       * @param {ununifi.nftmint.EventBurnNFT} message EventBurnNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventBurnNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.burner = '';
          object.class_id = '';
          object.nft_id = '';
        }
        if (message.burner != null && message.hasOwnProperty('burner')) object.burner = message.burner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) object.nft_id = message.nft_id;
        return object;
      };

      /**
       * Converts this EventBurnNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftmint.EventBurnNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventBurnNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventBurnNFT;
    })();

    return nftmint;
  })();

  ununifi.pricefeed = (function () {
    /**
     * Namespace pricefeed.
     * @memberof ununifi
     * @namespace
     */
    const pricefeed = {};

    pricefeed.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#params}.
       * @memberof ununifi.pricefeed.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.pricefeed.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.pricefeed.QueryParamsRequest,
            $root.ununifi.pricefeed.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#marketAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef MarketAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllMarketResponse} [response] QueryAllMarketResponse
       */

      /**
       * Calls MarketAll.
       * @function marketAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
       * @param {ununifi.pricefeed.Query.MarketAllCallback} callback Node-style callback called with the error, if any, and QueryAllMarketResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.marketAll = function marketAll(request, callback) {
          return this.rpcCall(
            marketAll,
            $root.ununifi.pricefeed.QueryAllMarketRequest,
            $root.ununifi.pricefeed.QueryAllMarketResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'MarketAll' },
      );

      /**
       * Calls MarketAll.
       * @function marketAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllMarketResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#oracleAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef OracleAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllOracleResponse} [response] QueryAllOracleResponse
       */

      /**
       * Calls OracleAll.
       * @function oracleAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
       * @param {ununifi.pricefeed.Query.OracleAllCallback} callback Node-style callback called with the error, if any, and QueryAllOracleResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.oracleAll = function oracleAll(request, callback) {
          return this.rpcCall(
            oracleAll,
            $root.ununifi.pricefeed.QueryAllOracleRequest,
            $root.ununifi.pricefeed.QueryAllOracleResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'OracleAll' },
      );

      /**
       * Calls OracleAll.
       * @function oracleAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllOracleResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#price}.
       * @memberof ununifi.pricefeed.Query
       * @typedef PriceCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryGetPriceResponse} [response] QueryGetPriceResponse
       */

      /**
       * Calls Price.
       * @function price
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
       * @param {ununifi.pricefeed.Query.PriceCallback} callback Node-style callback called with the error, if any, and QueryGetPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.price = function price(request, callback) {
          return this.rpcCall(
            price,
            $root.ununifi.pricefeed.QueryGetPriceRequest,
            $root.ununifi.pricefeed.QueryGetPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Price' },
      );

      /**
       * Calls Price.
       * @function price
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryGetPriceResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#priceAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef PriceAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllPriceResponse} [response] QueryAllPriceResponse
       */

      /**
       * Calls PriceAll.
       * @function priceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
       * @param {ununifi.pricefeed.Query.PriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.priceAll = function priceAll(request, callback) {
          return this.rpcCall(
            priceAll,
            $root.ununifi.pricefeed.QueryAllPriceRequest,
            $root.ununifi.pricefeed.QueryAllPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PriceAll' },
      );

      /**
       * Calls PriceAll.
       * @function priceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllPriceResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#rawPriceAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef RawPriceAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllRawPriceResponse} [response] QueryAllRawPriceResponse
       */

      /**
       * Calls RawPriceAll.
       * @function rawPriceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
       * @param {ununifi.pricefeed.Query.RawPriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllRawPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.rawPriceAll = function rawPriceAll(request, callback) {
          return this.rpcCall(
            rawPriceAll,
            $root.ununifi.pricefeed.QueryAllRawPriceRequest,
            $root.ununifi.pricefeed.QueryAllRawPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RawPriceAll' },
      );

      /**
       * Calls RawPriceAll.
       * @function rawPriceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllRawPriceResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    pricefeed.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryParamsRequest) return object;
        return new $root.ununifi.pricefeed.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {ununifi.pricefeed.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    pricefeed.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryParamsResponse
       * @property {ununifi.pricefeed.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.pricefeed.IParams|null|undefined} params
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.pricefeed.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryParamsResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.pricefeed.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {ununifi.pricefeed.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    pricefeed.QueryAllMarketRequest = (function () {
      /**
       * Properties of a QueryAllMarketRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllMarketRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllMarketRequest pagination
       */

      /**
       * Constructs a new QueryAllMarketRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllMarketRequest.
       * @implements IQueryAllMarketRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllMarketRequest=} [properties] Properties to set
       */
      function QueryAllMarketRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllMarketRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @instance
       */
      QueryAllMarketRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllMarketRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllMarketRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllMarketRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllMarketRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllMarketRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllMarketRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllMarketRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
       */
      QueryAllMarketRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllMarketRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllMarketRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllMarketRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllMarketRequest} message QueryAllMarketRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllMarketRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllMarketRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllMarketRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllMarketRequest;
    })();

    pricefeed.QueryAllMarketResponse = (function () {
      /**
       * Properties of a QueryAllMarketResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllMarketResponse
       * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] QueryAllMarketResponse markets
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllMarketResponse pagination
       */

      /**
       * Constructs a new QueryAllMarketResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllMarketResponse.
       * @implements IQueryAllMarketResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllMarketResponse=} [properties] Properties to set
       */
      function QueryAllMarketResponse(properties) {
        this.markets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllMarketResponse markets.
       * @member {Array.<ununifi.pricefeed.IMarket>} markets
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @instance
       */
      QueryAllMarketResponse.prototype.markets = $util.emptyArray;

      /**
       * QueryAllMarketResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @instance
       */
      QueryAllMarketResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllMarketResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.markets != null && message.markets.length)
          for (let i = 0; i < message.markets.length; ++i)
            $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllMarketResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllMarketResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.markets && message.markets.length)) message.markets = [];
              message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllMarketResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllMarketResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllMarketResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.markets != null && message.hasOwnProperty('markets')) {
          if (!Array.isArray(message.markets)) return 'markets: array expected';
          for (let i = 0; i < message.markets.length; ++i) {
            let error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
            if (error) return 'markets.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllMarketResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
       */
      QueryAllMarketResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllMarketResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
        if (object.markets) {
          if (!Array.isArray(object.markets)) throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.markets: array expected');
          message.markets = [];
          for (let i = 0; i < object.markets.length; ++i) {
            if (typeof object.markets[i] !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.markets: object expected');
            message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllMarketResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllMarketResponse} message QueryAllMarketResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllMarketResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.markets = [];
        if (options.defaults) object.pagination = null;
        if (message.markets && message.markets.length) {
          object.markets = [];
          for (let j = 0; j < message.markets.length; ++j)
            object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllMarketResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllMarketResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllMarketResponse;
    })();

    pricefeed.QueryAllOracleRequest = (function () {
      /**
       * Properties of a QueryAllOracleRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllOracleRequest
       * @property {string|null} [market_id] QueryAllOracleRequest market_id
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllOracleRequest pagination
       */

      /**
       * Constructs a new QueryAllOracleRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllOracleRequest.
       * @implements IQueryAllOracleRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllOracleRequest=} [properties] Properties to set
       */
      function QueryAllOracleRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllOracleRequest market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @instance
       */
      QueryAllOracleRequest.prototype.market_id = '';

      /**
       * QueryAllOracleRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @instance
       */
      QueryAllOracleRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllOracleRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllOracleRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllOracleRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllOracleRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllOracleRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllOracleRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllOracleRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
       */
      QueryAllOracleRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllOracleRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllOracleRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllOracleRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllOracleRequest} message QueryAllOracleRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllOracleRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.pagination = null;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllOracleRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllOracleRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllOracleRequest;
    })();

    pricefeed.QueryAllOracleResponse = (function () {
      /**
       * Properties of a QueryAllOracleResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllOracleResponse
       * @property {Array.<string>|null} [oracles] QueryAllOracleResponse oracles
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllOracleResponse pagination
       */

      /**
       * Constructs a new QueryAllOracleResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllOracleResponse.
       * @implements IQueryAllOracleResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllOracleResponse=} [properties] Properties to set
       */
      function QueryAllOracleResponse(properties) {
        this.oracles = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllOracleResponse oracles.
       * @member {Array.<string>} oracles
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @instance
       */
      QueryAllOracleResponse.prototype.oracles = $util.emptyArray;

      /**
       * QueryAllOracleResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @instance
       */
      QueryAllOracleResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllOracleResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.oracles != null && message.oracles.length)
          for (let i = 0; i < message.oracles.length; ++i) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.oracles[i]);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllOracleResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllOracleResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.oracles && message.oracles.length)) message.oracles = [];
              message.oracles.push(reader.string());
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllOracleResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllOracleResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllOracleResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.oracles != null && message.hasOwnProperty('oracles')) {
          if (!Array.isArray(message.oracles)) return 'oracles: array expected';
          for (let i = 0; i < message.oracles.length; ++i) if (!$util.isString(message.oracles[i])) return 'oracles: string[] expected';
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllOracleResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
       */
      QueryAllOracleResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllOracleResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
        if (object.oracles) {
          if (!Array.isArray(object.oracles)) throw TypeError('.ununifi.pricefeed.QueryAllOracleResponse.oracles: array expected');
          message.oracles = [];
          for (let i = 0; i < object.oracles.length; ++i) message.oracles[i] = String(object.oracles[i]);
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllOracleResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllOracleResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllOracleResponse} message QueryAllOracleResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllOracleResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.oracles = [];
        if (options.defaults) object.pagination = null;
        if (message.oracles && message.oracles.length) {
          object.oracles = [];
          for (let j = 0; j < message.oracles.length; ++j) object.oracles[j] = message.oracles[j];
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllOracleResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllOracleResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllOracleResponse;
    })();

    pricefeed.QueryGetPriceRequest = (function () {
      /**
       * Properties of a QueryGetPriceRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryGetPriceRequest
       * @property {string|null} [market_id] QueryGetPriceRequest market_id
       */

      /**
       * Constructs a new QueryGetPriceRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryGetPriceRequest.
       * @implements IQueryGetPriceRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryGetPriceRequest=} [properties] Properties to set
       */
      function QueryGetPriceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetPriceRequest market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @instance
       */
      QueryGetPriceRequest.prototype.market_id = '';

      /**
       * Encodes the specified QueryGetPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetPriceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetPriceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetPriceRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetPriceRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        return null;
      };

      /**
       * Creates a QueryGetPriceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
       */
      QueryGetPriceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryGetPriceRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
        if (object.market_id != null) message.market_id = String(object.market_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetPriceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {ununifi.pricefeed.QueryGetPriceRequest} message QueryGetPriceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetPriceRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.market_id = '';
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        return object;
      };

      /**
       * Converts this QueryGetPriceRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetPriceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetPriceRequest;
    })();

    pricefeed.QueryGetPriceResponse = (function () {
      /**
       * Properties of a QueryGetPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryGetPriceResponse
       * @property {ununifi.pricefeed.ICurrentPrice|null} [price] QueryGetPriceResponse price
       */

      /**
       * Constructs a new QueryGetPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryGetPriceResponse.
       * @implements IQueryGetPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryGetPriceResponse=} [properties] Properties to set
       */
      function QueryGetPriceResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetPriceResponse price.
       * @member {ununifi.pricefeed.ICurrentPrice|null|undefined} price
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @instance
       */
      QueryGetPriceResponse.prototype.price = null;

      /**
       * Encodes the specified QueryGetPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          $root.ununifi.pricefeed.CurrentPrice.encode(message.price, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.price = $root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.price != null && message.hasOwnProperty('price')) {
          let error = $root.ununifi.pricefeed.CurrentPrice.verify(message.price);
          if (error) return 'price.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
       */
      QueryGetPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryGetPriceResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
        if (object.price != null) {
          if (typeof object.price !== 'object') throw TypeError('.ununifi.pricefeed.QueryGetPriceResponse.price: object expected');
          message.price = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.price);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {ununifi.pricefeed.QueryGetPriceResponse} message QueryGetPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetPriceResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.price = null;
        if (message.price != null && message.hasOwnProperty('price'))
          object.price = $root.ununifi.pricefeed.CurrentPrice.toObject(message.price, options);
        return object;
      };

      /**
       * Converts this QueryGetPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetPriceResponse;
    })();

    pricefeed.QueryAllPriceRequest = (function () {
      /**
       * Properties of a QueryAllPriceRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllPriceRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllPriceRequest pagination
       */

      /**
       * Constructs a new QueryAllPriceRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllPriceRequest.
       * @implements IQueryAllPriceRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllPriceRequest=} [properties] Properties to set
       */
      function QueryAllPriceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllPriceRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @instance
       */
      QueryAllPriceRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPriceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPriceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPriceRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPriceRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllPriceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
       */
      QueryAllPriceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllPriceRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.ununifi.pricefeed.QueryAllPriceRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllPriceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllPriceRequest} message QueryAllPriceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPriceRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllPriceRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPriceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPriceRequest;
    })();

    pricefeed.QueryAllPriceResponse = (function () {
      /**
       * Properties of a QueryAllPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllPriceResponse
       * @property {Array.<ununifi.pricefeed.ICurrentPrice>|null} [prices] QueryAllPriceResponse prices
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllPriceResponse pagination
       */

      /**
       * Constructs a new QueryAllPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllPriceResponse.
       * @implements IQueryAllPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllPriceResponse=} [properties] Properties to set
       */
      function QueryAllPriceResponse(properties) {
        this.prices = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllPriceResponse prices.
       * @member {Array.<ununifi.pricefeed.ICurrentPrice>} prices
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @instance
       */
      QueryAllPriceResponse.prototype.prices = $util.emptyArray;

      /**
       * QueryAllPriceResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @instance
       */
      QueryAllPriceResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.prices != null && message.prices.length)
          for (let i = 0; i < message.prices.length; ++i)
            $root.ununifi.pricefeed.CurrentPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.prices && message.prices.length)) message.prices = [];
              message.prices.push($root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.prices != null && message.hasOwnProperty('prices')) {
          if (!Array.isArray(message.prices)) return 'prices: array expected';
          for (let i = 0; i < message.prices.length; ++i) {
            let error = $root.ununifi.pricefeed.CurrentPrice.verify(message.prices[i]);
            if (error) return 'prices.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
       */
      QueryAllPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllPriceResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
        if (object.prices) {
          if (!Array.isArray(object.prices)) throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.prices: array expected');
          message.prices = [];
          for (let i = 0; i < object.prices.length; ++i) {
            if (typeof object.prices[i] !== 'object') throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.prices: object expected');
            message.prices[i] = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.prices[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllPriceResponse} message QueryAllPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPriceResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.prices = [];
        if (options.defaults) object.pagination = null;
        if (message.prices && message.prices.length) {
          object.prices = [];
          for (let j = 0; j < message.prices.length; ++j)
            object.prices[j] = $root.ununifi.pricefeed.CurrentPrice.toObject(message.prices[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPriceResponse;
    })();

    pricefeed.QueryAllRawPriceRequest = (function () {
      /**
       * Properties of a QueryAllRawPriceRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllRawPriceRequest
       * @property {string|null} [market_id] QueryAllRawPriceRequest market_id
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllRawPriceRequest pagination
       */

      /**
       * Constructs a new QueryAllRawPriceRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllRawPriceRequest.
       * @implements IQueryAllRawPriceRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest=} [properties] Properties to set
       */
      function QueryAllRawPriceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllRawPriceRequest market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @instance
       */
      QueryAllRawPriceRequest.prototype.market_id = '';

      /**
       * QueryAllRawPriceRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @instance
       */
      QueryAllRawPriceRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllRawPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllRawPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllRawPriceRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllRawPriceRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllRawPriceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
       */
      QueryAllRawPriceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllRawPriceRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllRawPriceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllRawPriceRequest} message QueryAllRawPriceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllRawPriceRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.pagination = null;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllRawPriceRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllRawPriceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllRawPriceRequest;
    })();

    pricefeed.QueryAllRawPriceResponse = (function () {
      /**
       * Properties of a QueryAllRawPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllRawPriceResponse
       * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [prices] QueryAllRawPriceResponse prices
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllRawPriceResponse pagination
       */

      /**
       * Constructs a new QueryAllRawPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllRawPriceResponse.
       * @implements IQueryAllRawPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllRawPriceResponse=} [properties] Properties to set
       */
      function QueryAllRawPriceResponse(properties) {
        this.prices = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllRawPriceResponse prices.
       * @member {Array.<ununifi.pricefeed.IPostedPrice>} prices
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @instance
       */
      QueryAllRawPriceResponse.prototype.prices = $util.emptyArray;

      /**
       * QueryAllRawPriceResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @instance
       */
      QueryAllRawPriceResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllRawPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.prices != null && message.prices.length)
          for (let i = 0; i < message.prices.length; ++i)
            $root.ununifi.pricefeed.PostedPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllRawPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.prices && message.prices.length)) message.prices = [];
              message.prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllRawPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllRawPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.prices != null && message.hasOwnProperty('prices')) {
          if (!Array.isArray(message.prices)) return 'prices: array expected';
          for (let i = 0; i < message.prices.length; ++i) {
            let error = $root.ununifi.pricefeed.PostedPrice.verify(message.prices[i]);
            if (error) return 'prices.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllRawPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
       */
      QueryAllRawPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
        if (object.prices) {
          if (!Array.isArray(object.prices)) throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.prices: array expected');
          message.prices = [];
          for (let i = 0; i < object.prices.length; ++i) {
            if (typeof object.prices[i] !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.prices: object expected');
            message.prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.prices[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllRawPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllRawPriceResponse} message QueryAllRawPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllRawPriceResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.prices = [];
        if (options.defaults) object.pagination = null;
        if (message.prices && message.prices.length) {
          object.prices = [];
          for (let j = 0; j < message.prices.length; ++j)
            object.prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.prices[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllRawPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllRawPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllRawPriceResponse;
    })();

    pricefeed.Market = (function () {
      /**
       * Properties of a Market.
       * @memberof ununifi.pricefeed
       * @interface IMarket
       * @property {string|null} [market_id] Market market_id
       * @property {string|null} [base_asset] Market base_asset
       * @property {string|null} [quote_asset] Market quote_asset
       * @property {Array.<string>|null} [oracles] Market oracles
       * @property {boolean|null} [active] Market active
       */

      /**
       * Constructs a new Market.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Market.
       * @implements IMarket
       * @constructor
       * @param {ununifi.pricefeed.IMarket=} [properties] Properties to set
       */
      function Market(properties) {
        this.oracles = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Market market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.market_id = '';

      /**
       * Market base_asset.
       * @member {string} base_asset
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.base_asset = '';

      /**
       * Market quote_asset.
       * @member {string} quote_asset
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.quote_asset = '';

      /**
       * Market oracles.
       * @member {Array.<string>} oracles
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.oracles = $util.emptyArray;

      /**
       * Market active.
       * @member {boolean} active
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.active = false;

      /**
       * Encodes the specified Market message. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Market.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.base_asset != null && Object.hasOwnProperty.call(message, 'base_asset'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.base_asset);
        if (message.quote_asset != null && Object.hasOwnProperty.call(message, 'quote_asset'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.quote_asset);
        if (message.oracles != null && message.oracles.length)
          for (let i = 0; i < message.oracles.length; ++i) writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.oracles[i]);
        if (message.active != null && Object.hasOwnProperty.call(message, 'active'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.active);
        return writer;
      };

      /**
       * Encodes the specified Market message, length delimited. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Market.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Market message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.Market} Market
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Market.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.Market();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.base_asset = reader.string();
              break;
            case 3:
              message.quote_asset = reader.string();
              break;
            case 4:
              if (!(message.oracles && message.oracles.length)) message.oracles = [];
              message.oracles.push(reader.string());
              break;
            case 5:
              message.active = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Market message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.Market} Market
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Market.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Market message.
       * @function verify
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Market.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.base_asset != null && message.hasOwnProperty('base_asset'))
          if (!$util.isString(message.base_asset)) return 'base_asset: string expected';
        if (message.quote_asset != null && message.hasOwnProperty('quote_asset'))
          if (!$util.isString(message.quote_asset)) return 'quote_asset: string expected';
        if (message.oracles != null && message.hasOwnProperty('oracles')) {
          if (!Array.isArray(message.oracles)) return 'oracles: array expected';
          for (let i = 0; i < message.oracles.length; ++i) if (!$util.isString(message.oracles[i])) return 'oracles: string[] expected';
        }
        if (message.active != null && message.hasOwnProperty('active'))
          if (typeof message.active !== 'boolean') return 'active: boolean expected';
        return null;
      };

      /**
       * Creates a Market message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.Market} Market
       */
      Market.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.Market) return object;
        let message = new $root.ununifi.pricefeed.Market();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.base_asset != null) message.base_asset = String(object.base_asset);
        if (object.quote_asset != null) message.quote_asset = String(object.quote_asset);
        if (object.oracles) {
          if (!Array.isArray(object.oracles)) throw TypeError('.ununifi.pricefeed.Market.oracles: array expected');
          message.oracles = [];
          for (let i = 0; i < object.oracles.length; ++i) message.oracles[i] = String(object.oracles[i]);
        }
        if (object.active != null) message.active = Boolean(object.active);
        return message;
      };

      /**
       * Creates a plain object from a Market message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {ununifi.pricefeed.Market} message Market
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Market.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.oracles = [];
        if (options.defaults) {
          object.market_id = '';
          object.base_asset = '';
          object.quote_asset = '';
          object.active = false;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.base_asset != null && message.hasOwnProperty('base_asset')) object.base_asset = message.base_asset;
        if (message.quote_asset != null && message.hasOwnProperty('quote_asset')) object.quote_asset = message.quote_asset;
        if (message.oracles && message.oracles.length) {
          object.oracles = [];
          for (let j = 0; j < message.oracles.length; ++j) object.oracles[j] = message.oracles[j];
        }
        if (message.active != null && message.hasOwnProperty('active')) object.active = message.active;
        return object;
      };

      /**
       * Converts this Market to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.Market
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Market.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Market;
    })();

    pricefeed.CurrentPrice = (function () {
      /**
       * Properties of a CurrentPrice.
       * @memberof ununifi.pricefeed
       * @interface ICurrentPrice
       * @property {string|null} [market_id] CurrentPrice market_id
       * @property {string|null} [price] CurrentPrice price
       */

      /**
       * Constructs a new CurrentPrice.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a CurrentPrice.
       * @implements ICurrentPrice
       * @constructor
       * @param {ununifi.pricefeed.ICurrentPrice=} [properties] Properties to set
       */
      function CurrentPrice(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * CurrentPrice market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.CurrentPrice
       * @instance
       */
      CurrentPrice.prototype.market_id = '';

      /**
       * CurrentPrice price.
       * @member {string} price
       * @memberof ununifi.pricefeed.CurrentPrice
       * @instance
       */
      CurrentPrice.prototype.price = '';

      /**
       * Encodes the specified CurrentPrice message. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CurrentPrice.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.price);
        return writer;
      };

      /**
       * Encodes the specified CurrentPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CurrentPrice.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CurrentPrice message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CurrentPrice.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.CurrentPrice();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.price = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CurrentPrice message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CurrentPrice.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CurrentPrice message.
       * @function verify
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CurrentPrice.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
        return null;
      };

      /**
       * Creates a CurrentPrice message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
       */
      CurrentPrice.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.CurrentPrice) return object;
        let message = new $root.ununifi.pricefeed.CurrentPrice();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.price != null) message.price = String(object.price);
        return message;
      };

      /**
       * Creates a plain object from a CurrentPrice message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {ununifi.pricefeed.CurrentPrice} message CurrentPrice
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CurrentPrice.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.price = '';
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
        return object;
      };

      /**
       * Converts this CurrentPrice to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.CurrentPrice
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CurrentPrice.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CurrentPrice;
    })();

    pricefeed.PostedPrice = (function () {
      /**
       * Properties of a PostedPrice.
       * @memberof ununifi.pricefeed
       * @interface IPostedPrice
       * @property {string|null} [market_id] PostedPrice market_id
       * @property {string|null} [oracle_address] PostedPrice oracle_address
       * @property {string|null} [price] PostedPrice price
       * @property {google.protobuf.ITimestamp|null} [expiry] PostedPrice expiry
       */

      /**
       * Constructs a new PostedPrice.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a PostedPrice.
       * @implements IPostedPrice
       * @constructor
       * @param {ununifi.pricefeed.IPostedPrice=} [properties] Properties to set
       */
      function PostedPrice(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PostedPrice market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.market_id = '';

      /**
       * PostedPrice oracle_address.
       * @member {string} oracle_address
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.oracle_address = '';

      /**
       * PostedPrice price.
       * @member {string} price
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.price = '';

      /**
       * PostedPrice expiry.
       * @member {google.protobuf.ITimestamp|null|undefined} expiry
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.expiry = null;

      /**
       * Encodes the specified PostedPrice message. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PostedPrice.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.oracle_address != null && Object.hasOwnProperty.call(message, 'oracle_address'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.oracle_address);
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
        if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
          $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified PostedPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PostedPrice.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PostedPrice message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PostedPrice.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.PostedPrice();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.oracle_address = reader.string();
              break;
            case 3:
              message.price = reader.string();
              break;
            case 4:
              message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PostedPrice message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PostedPrice.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PostedPrice message.
       * @function verify
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PostedPrice.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.oracle_address != null && message.hasOwnProperty('oracle_address'))
          if (!$util.isString(message.oracle_address)) return 'oracle_address: string expected';
        if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
        if (message.expiry != null && message.hasOwnProperty('expiry')) {
          let error = $root.google.protobuf.Timestamp.verify(message.expiry);
          if (error) return 'expiry.' + error;
        }
        return null;
      };

      /**
       * Creates a PostedPrice message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
       */
      PostedPrice.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.PostedPrice) return object;
        let message = new $root.ununifi.pricefeed.PostedPrice();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.oracle_address != null) message.oracle_address = String(object.oracle_address);
        if (object.price != null) message.price = String(object.price);
        if (object.expiry != null) {
          if (typeof object.expiry !== 'object') throw TypeError('.ununifi.pricefeed.PostedPrice.expiry: object expected');
          message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
        }
        return message;
      };

      /**
       * Creates a plain object from a PostedPrice message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {ununifi.pricefeed.PostedPrice} message PostedPrice
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PostedPrice.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.oracle_address = '';
          object.price = '';
          object.expiry = null;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.oracle_address != null && message.hasOwnProperty('oracle_address')) object.oracle_address = message.oracle_address;
        if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
        if (message.expiry != null && message.hasOwnProperty('expiry'))
          object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
        return object;
      };

      /**
       * Converts this PostedPrice to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PostedPrice.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PostedPrice;
    })();

    pricefeed.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.pricefeed
       * @interface IParams
       * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] Params markets
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.pricefeed.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.markets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params markets.
       * @member {Array.<ununifi.pricefeed.IMarket>} markets
       * @memberof ununifi.pricefeed.Params
       * @instance
       */
      Params.prototype.markets = $util.emptyArray;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.markets != null && message.markets.length)
          for (let i = 0; i < message.markets.length; ++i)
            $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.markets && message.markets.length)) message.markets = [];
              message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.markets != null && message.hasOwnProperty('markets')) {
          if (!Array.isArray(message.markets)) return 'markets: array expected';
          for (let i = 0; i < message.markets.length; ++i) {
            let error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
            if (error) return 'markets.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.Params) return object;
        let message = new $root.ununifi.pricefeed.Params();
        if (object.markets) {
          if (!Array.isArray(object.markets)) throw TypeError('.ununifi.pricefeed.Params.markets: array expected');
          message.markets = [];
          for (let i = 0; i < object.markets.length; ++i) {
            if (typeof object.markets[i] !== 'object') throw TypeError('.ununifi.pricefeed.Params.markets: object expected');
            message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {ununifi.pricefeed.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.markets = [];
        if (message.markets && message.markets.length) {
          object.markets = [];
          for (let j = 0; j < message.markets.length; ++j)
            object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
        }
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    pricefeed.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.pricefeed.Msg#postPrice}.
       * @memberof ununifi.pricefeed.Msg
       * @typedef PostPriceCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.MsgPostPriceResponse} [response] MsgPostPriceResponse
       */

      /**
       * Calls PostPrice.
       * @function postPrice
       * @memberof ununifi.pricefeed.Msg
       * @instance
       * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
       * @param {ununifi.pricefeed.Msg.PostPriceCallback} callback Node-style callback called with the error, if any, and MsgPostPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.postPrice = function postPrice(request, callback) {
          return this.rpcCall(
            postPrice,
            $root.ununifi.pricefeed.MsgPostPrice,
            $root.ununifi.pricefeed.MsgPostPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PostPrice' },
      );

      /**
       * Calls PostPrice.
       * @function postPrice
       * @memberof ununifi.pricefeed.Msg
       * @instance
       * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
       * @returns {Promise<ununifi.pricefeed.MsgPostPriceResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    pricefeed.MsgPostPrice = (function () {
      /**
       * Properties of a MsgPostPrice.
       * @memberof ununifi.pricefeed
       * @interface IMsgPostPrice
       * @property {string|null} [from] MsgPostPrice from
       * @property {string|null} [market_id] MsgPostPrice market_id
       * @property {string|null} [price] MsgPostPrice price
       * @property {google.protobuf.ITimestamp|null} [expiry] MsgPostPrice expiry
       */

      /**
       * Constructs a new MsgPostPrice.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a MsgPostPrice.
       * @implements IMsgPostPrice
       * @constructor
       * @param {ununifi.pricefeed.IMsgPostPrice=} [properties] Properties to set
       */
      function MsgPostPrice(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgPostPrice from.
       * @member {string} from
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.from = '';

      /**
       * MsgPostPrice market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.market_id = '';

      /**
       * MsgPostPrice price.
       * @member {string} price
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.price = '';

      /**
       * MsgPostPrice expiry.
       * @member {google.protobuf.ITimestamp|null|undefined} expiry
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.expiry = null;

      /**
       * Encodes the specified MsgPostPrice message. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPrice.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.from != null && Object.hasOwnProperty.call(message, 'from'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.from);
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.market_id);
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
        if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
          $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgPostPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPrice.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPostPrice message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPrice.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.MsgPostPrice();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.from = reader.string();
              break;
            case 2:
              message.market_id = reader.string();
              break;
            case 3:
              message.price = reader.string();
              break;
            case 4:
              message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPostPrice message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPrice.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPostPrice message.
       * @function verify
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPostPrice.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.from != null && message.hasOwnProperty('from')) if (!$util.isString(message.from)) return 'from: string expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
        if (message.expiry != null && message.hasOwnProperty('expiry')) {
          let error = $root.google.protobuf.Timestamp.verify(message.expiry);
          if (error) return 'expiry.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgPostPrice message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
       */
      MsgPostPrice.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.MsgPostPrice) return object;
        let message = new $root.ununifi.pricefeed.MsgPostPrice();
        if (object.from != null) message.from = String(object.from);
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.price != null) message.price = String(object.price);
        if (object.expiry != null) {
          if (typeof object.expiry !== 'object') throw TypeError('.ununifi.pricefeed.MsgPostPrice.expiry: object expected');
          message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgPostPrice message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {ununifi.pricefeed.MsgPostPrice} message MsgPostPrice
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPostPrice.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.from = '';
          object.market_id = '';
          object.price = '';
          object.expiry = null;
        }
        if (message.from != null && message.hasOwnProperty('from')) object.from = message.from;
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
        if (message.expiry != null && message.hasOwnProperty('expiry'))
          object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
        return object;
      };

      /**
       * Converts this MsgPostPrice to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPostPrice.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPostPrice;
    })();

    pricefeed.MsgPostPriceResponse = (function () {
      /**
       * Properties of a MsgPostPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IMsgPostPriceResponse
       */

      /**
       * Constructs a new MsgPostPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a MsgPostPriceResponse.
       * @implements IMsgPostPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IMsgPostPriceResponse=} [properties] Properties to set
       */
      function MsgPostPriceResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgPostPriceResponse message. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgPostPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPostPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.MsgPostPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPostPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPostPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPostPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgPostPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
       */
      MsgPostPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.MsgPostPriceResponse) return object;
        return new $root.ununifi.pricefeed.MsgPostPriceResponse();
      };

      /**
       * Creates a plain object from a MsgPostPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {ununifi.pricefeed.MsgPostPriceResponse} message MsgPostPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPostPriceResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgPostPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPostPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPostPriceResponse;
    })();

    pricefeed.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.pricefeed
       * @interface IGenesisState
       * @property {ununifi.pricefeed.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [posted_prices] GenesisState posted_prices
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.pricefeed.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.posted_prices = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.pricefeed.IParams|null|undefined} params
       * @memberof ununifi.pricefeed.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState posted_prices.
       * @member {Array.<ununifi.pricefeed.IPostedPrice>} posted_prices
       * @memberof ununifi.pricefeed.GenesisState
       * @instance
       */
      GenesisState.prototype.posted_prices = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.posted_prices != null && message.posted_prices.length)
          for (let i = 0; i < message.posted_prices.length; ++i)
            $root.ununifi.pricefeed.PostedPrice.encode(message.posted_prices[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.posted_prices && message.posted_prices.length)) message.posted_prices = [];
              message.posted_prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.pricefeed.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.posted_prices != null && message.hasOwnProperty('posted_prices')) {
          if (!Array.isArray(message.posted_prices)) return 'posted_prices: array expected';
          for (let i = 0; i < message.posted_prices.length; ++i) {
            let error = $root.ununifi.pricefeed.PostedPrice.verify(message.posted_prices[i]);
            if (error) return 'posted_prices.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.GenesisState) return object;
        let message = new $root.ununifi.pricefeed.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.pricefeed.GenesisState.params: object expected');
          message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
        }
        if (object.posted_prices) {
          if (!Array.isArray(object.posted_prices)) throw TypeError('.ununifi.pricefeed.GenesisState.posted_prices: array expected');
          message.posted_prices = [];
          for (let i = 0; i < object.posted_prices.length; ++i) {
            if (typeof object.posted_prices[i] !== 'object')
              throw TypeError('.ununifi.pricefeed.GenesisState.posted_prices: object expected');
            message.posted_prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.posted_prices[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {ununifi.pricefeed.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.posted_prices = [];
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
        if (message.posted_prices && message.posted_prices.length) {
          object.posted_prices = [];
          for (let j = 0; j < message.posted_prices.length; ++j)
            object.posted_prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.posted_prices[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    return pricefeed;
  })();

  ununifi.ununifidist = (function () {
    /**
     * Namespace ununifidist.
     * @memberof ununifi
     * @namespace
     */
    const ununifidist = {};

    ununifidist.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.ununifidist.Query#params}.
       * @memberof ununifi.ununifidist.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ununifidist.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.ununifidist.Query
       * @instance
       * @param {ununifi.ununifidist.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.ununifidist.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.ununifidist.QueryParamsRequest,
            $root.ununifi.ununifidist.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.ununifidist.Query
       * @instance
       * @param {ununifi.ununifidist.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.ununifidist.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ununifidist.Query#balances}.
       * @memberof ununifi.ununifidist.Query
       * @typedef BalancesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ununifidist.QueryGetBalancesResponse} [response] QueryGetBalancesResponse
       */

      /**
       * Calls Balances.
       * @function balances
       * @memberof ununifi.ununifidist.Query
       * @instance
       * @param {ununifi.ununifidist.IQueryGetBalancesRequest} request QueryGetBalancesRequest message or plain object
       * @param {ununifi.ununifidist.Query.BalancesCallback} callback Node-style callback called with the error, if any, and QueryGetBalancesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.balances = function balances(request, callback) {
          return this.rpcCall(
            balances,
            $root.ununifi.ununifidist.QueryGetBalancesRequest,
            $root.ununifi.ununifidist.QueryGetBalancesResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Balances' },
      );

      /**
       * Calls Balances.
       * @function balances
       * @memberof ununifi.ununifidist.Query
       * @instance
       * @param {ununifi.ununifidist.IQueryGetBalancesRequest} request QueryGetBalancesRequest message or plain object
       * @returns {Promise<ununifi.ununifidist.QueryGetBalancesResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    ununifidist.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.ununifidist
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.ununifidist.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.ununifidist.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @static
       * @param {ununifi.ununifidist.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @static
       * @param {ununifi.ununifidist.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ununifidist.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ununifidist.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ununifidist.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ununifidist.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ununifidist.QueryParamsRequest) return object;
        return new $root.ununifi.ununifidist.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @static
       * @param {ununifi.ununifidist.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ununifidist.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    ununifidist.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.ununifidist
       * @interface IQueryParamsResponse
       * @property {ununifi.ununifidist.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.ununifidist.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.ununifidist.IParams|null|undefined} params
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.ununifidist.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @static
       * @param {ununifi.ununifidist.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.ununifidist.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @static
       * @param {ununifi.ununifidist.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ununifidist.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ununifidist.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.ununifidist.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ununifidist.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.ununifidist.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ununifidist.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ununifidist.QueryParamsResponse) return object;
        let message = new $root.ununifi.ununifidist.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.ununifidist.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.ununifidist.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @static
       * @param {ununifi.ununifidist.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.ununifidist.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ununifidist.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    ununifidist.QueryGetBalancesRequest = (function () {
      /**
       * Properties of a QueryGetBalancesRequest.
       * @memberof ununifi.ununifidist
       * @interface IQueryGetBalancesRequest
       */

      /**
       * Constructs a new QueryGetBalancesRequest.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a QueryGetBalancesRequest.
       * @implements IQueryGetBalancesRequest
       * @constructor
       * @param {ununifi.ununifidist.IQueryGetBalancesRequest=} [properties] Properties to set
       */
      function QueryGetBalancesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryGetBalancesRequest message. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @static
       * @param {ununifi.ununifidist.IQueryGetBalancesRequest} message QueryGetBalancesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetBalancesRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryGetBalancesRequest message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @static
       * @param {ununifi.ununifidist.IQueryGetBalancesRequest} message QueryGetBalancesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetBalancesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetBalancesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ununifidist.QueryGetBalancesRequest} QueryGetBalancesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetBalancesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ununifidist.QueryGetBalancesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetBalancesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ununifidist.QueryGetBalancesRequest} QueryGetBalancesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetBalancesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetBalancesRequest message.
       * @function verify
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetBalancesRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryGetBalancesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ununifidist.QueryGetBalancesRequest} QueryGetBalancesRequest
       */
      QueryGetBalancesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ununifidist.QueryGetBalancesRequest) return object;
        return new $root.ununifi.ununifidist.QueryGetBalancesRequest();
      };

      /**
       * Creates a plain object from a QueryGetBalancesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @static
       * @param {ununifi.ununifidist.QueryGetBalancesRequest} message QueryGetBalancesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetBalancesRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryGetBalancesRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ununifidist.QueryGetBalancesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetBalancesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetBalancesRequest;
    })();

    ununifidist.QueryGetBalancesResponse = (function () {
      /**
       * Properties of a QueryGetBalancesResponse.
       * @memberof ununifi.ununifidist
       * @interface IQueryGetBalancesResponse
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [balances] QueryGetBalancesResponse balances
       */

      /**
       * Constructs a new QueryGetBalancesResponse.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a QueryGetBalancesResponse.
       * @implements IQueryGetBalancesResponse
       * @constructor
       * @param {ununifi.ununifidist.IQueryGetBalancesResponse=} [properties] Properties to set
       */
      function QueryGetBalancesResponse(properties) {
        this.balances = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetBalancesResponse balances.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} balances
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @instance
       */
      QueryGetBalancesResponse.prototype.balances = $util.emptyArray;

      /**
       * Encodes the specified QueryGetBalancesResponse message. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @static
       * @param {ununifi.ununifidist.IQueryGetBalancesResponse} message QueryGetBalancesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetBalancesResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.balances != null && message.balances.length)
          for (let i = 0; i < message.balances.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.balances[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetBalancesResponse message, length delimited. Does not implicitly {@link ununifi.ununifidist.QueryGetBalancesResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @static
       * @param {ununifi.ununifidist.IQueryGetBalancesResponse} message QueryGetBalancesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetBalancesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetBalancesResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ununifidist.QueryGetBalancesResponse} QueryGetBalancesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetBalancesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ununifidist.QueryGetBalancesResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.balances && message.balances.length)) message.balances = [];
              message.balances.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetBalancesResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ununifidist.QueryGetBalancesResponse} QueryGetBalancesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetBalancesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetBalancesResponse message.
       * @function verify
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetBalancesResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.balances != null && message.hasOwnProperty('balances')) {
          if (!Array.isArray(message.balances)) return 'balances: array expected';
          for (let i = 0; i < message.balances.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.balances[i]);
            if (error) return 'balances.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryGetBalancesResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ununifidist.QueryGetBalancesResponse} QueryGetBalancesResponse
       */
      QueryGetBalancesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ununifidist.QueryGetBalancesResponse) return object;
        let message = new $root.ununifi.ununifidist.QueryGetBalancesResponse();
        if (object.balances) {
          if (!Array.isArray(object.balances)) throw TypeError('.ununifi.ununifidist.QueryGetBalancesResponse.balances: array expected');
          message.balances = [];
          for (let i = 0; i < object.balances.length; ++i) {
            if (typeof object.balances[i] !== 'object')
              throw TypeError('.ununifi.ununifidist.QueryGetBalancesResponse.balances: object expected');
            message.balances[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.balances[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetBalancesResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @static
       * @param {ununifi.ununifidist.QueryGetBalancesResponse} message QueryGetBalancesResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetBalancesResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.balances = [];
        if (message.balances && message.balances.length) {
          object.balances = [];
          for (let j = 0; j < message.balances.length; ++j)
            object.balances[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.balances[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryGetBalancesResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ununifidist.QueryGetBalancesResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetBalancesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetBalancesResponse;
    })();

    ununifidist.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.ununifidist
       * @interface IParams
       * @property {boolean|null} [active] Params active
       * @property {Array.<ununifi.ununifidist.IPeriod>|null} [periods] Params periods
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.ununifidist.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.periods = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params active.
       * @member {boolean} active
       * @memberof ununifi.ununifidist.Params
       * @instance
       */
      Params.prototype.active = false;

      /**
       * Params periods.
       * @member {Array.<ununifi.ununifidist.IPeriod>} periods
       * @memberof ununifi.ununifidist.Params
       * @instance
       */
      Params.prototype.periods = $util.emptyArray;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.ununifidist.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ununifidist.Params
       * @static
       * @param {ununifi.ununifidist.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.active != null && Object.hasOwnProperty.call(message, 'active'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.active);
        if (message.periods != null && message.periods.length)
          for (let i = 0; i < message.periods.length; ++i)
            $root.ununifi.ununifidist.Period.encode(message.periods[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.ununifidist.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ununifidist.Params
       * @static
       * @param {ununifi.ununifidist.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ununifidist.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ununifidist.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ununifidist.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.active = reader.bool();
              break;
            case 2:
              if (!(message.periods && message.periods.length)) message.periods = [];
              message.periods.push($root.ununifi.ununifidist.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ununifidist.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ununifidist.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.ununifidist.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.active != null && message.hasOwnProperty('active'))
          if (typeof message.active !== 'boolean') return 'active: boolean expected';
        if (message.periods != null && message.hasOwnProperty('periods')) {
          if (!Array.isArray(message.periods)) return 'periods: array expected';
          for (let i = 0; i < message.periods.length; ++i) {
            let error = $root.ununifi.ununifidist.Period.verify(message.periods[i]);
            if (error) return 'periods.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ununifidist.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ununifidist.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ununifidist.Params) return object;
        let message = new $root.ununifi.ununifidist.Params();
        if (object.active != null) message.active = Boolean(object.active);
        if (object.periods) {
          if (!Array.isArray(object.periods)) throw TypeError('.ununifi.ununifidist.Params.periods: array expected');
          message.periods = [];
          for (let i = 0; i < object.periods.length; ++i) {
            if (typeof object.periods[i] !== 'object') throw TypeError('.ununifi.ununifidist.Params.periods: object expected');
            message.periods[i] = $root.ununifi.ununifidist.Period.fromObject(object.periods[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ununifidist.Params
       * @static
       * @param {ununifi.ununifidist.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.periods = [];
        if (options.defaults) object.active = false;
        if (message.active != null && message.hasOwnProperty('active')) object.active = message.active;
        if (message.periods && message.periods.length) {
          object.periods = [];
          for (let j = 0; j < message.periods.length; ++j)
            object.periods[j] = $root.ununifi.ununifidist.Period.toObject(message.periods[j], options);
        }
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.ununifidist.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    ununifidist.Period = (function () {
      /**
       * Properties of a Period.
       * @memberof ununifi.ununifidist
       * @interface IPeriod
       * @property {google.protobuf.ITimestamp|null} [start] Period start
       * @property {google.protobuf.ITimestamp|null} [end] Period end
       * @property {string|null} [inflation] Period inflation
       */

      /**
       * Constructs a new Period.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a Period.
       * @implements IPeriod
       * @constructor
       * @param {ununifi.ununifidist.IPeriod=} [properties] Properties to set
       */
      function Period(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Period start.
       * @member {google.protobuf.ITimestamp|null|undefined} start
       * @memberof ununifi.ununifidist.Period
       * @instance
       */
      Period.prototype.start = null;

      /**
       * Period end.
       * @member {google.protobuf.ITimestamp|null|undefined} end
       * @memberof ununifi.ununifidist.Period
       * @instance
       */
      Period.prototype.end = null;

      /**
       * Period inflation.
       * @member {string} inflation
       * @memberof ununifi.ununifidist.Period
       * @instance
       */
      Period.prototype.inflation = '';

      /**
       * Encodes the specified Period message. Does not implicitly {@link ununifi.ununifidist.Period.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ununifidist.Period
       * @static
       * @param {ununifi.ununifidist.IPeriod} message Period message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Period.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
          $root.google.protobuf.Timestamp.encode(message.start, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
          $root.google.protobuf.Timestamp.encode(message.end, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.inflation != null && Object.hasOwnProperty.call(message, 'inflation'))
          writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.inflation);
        return writer;
      };

      /**
       * Encodes the specified Period message, length delimited. Does not implicitly {@link ununifi.ununifidist.Period.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ununifidist.Period
       * @static
       * @param {ununifi.ununifidist.IPeriod} message Period message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Period.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Period message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ununifidist.Period
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ununifidist.Period} Period
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Period.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ununifidist.Period();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.start = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.end = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.inflation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Period message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ununifidist.Period
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ununifidist.Period} Period
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Period.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Period message.
       * @function verify
       * @memberof ununifi.ununifidist.Period
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Period.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.start != null && message.hasOwnProperty('start')) {
          let error = $root.google.protobuf.Timestamp.verify(message.start);
          if (error) return 'start.' + error;
        }
        if (message.end != null && message.hasOwnProperty('end')) {
          let error = $root.google.protobuf.Timestamp.verify(message.end);
          if (error) return 'end.' + error;
        }
        if (message.inflation != null && message.hasOwnProperty('inflation'))
          if (!$util.isString(message.inflation)) return 'inflation: string expected';
        return null;
      };

      /**
       * Creates a Period message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ununifidist.Period
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ununifidist.Period} Period
       */
      Period.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ununifidist.Period) return object;
        let message = new $root.ununifi.ununifidist.Period();
        if (object.start != null) {
          if (typeof object.start !== 'object') throw TypeError('.ununifi.ununifidist.Period.start: object expected');
          message.start = $root.google.protobuf.Timestamp.fromObject(object.start);
        }
        if (object.end != null) {
          if (typeof object.end !== 'object') throw TypeError('.ununifi.ununifidist.Period.end: object expected');
          message.end = $root.google.protobuf.Timestamp.fromObject(object.end);
        }
        if (object.inflation != null) message.inflation = String(object.inflation);
        return message;
      };

      /**
       * Creates a plain object from a Period message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ununifidist.Period
       * @static
       * @param {ununifi.ununifidist.Period} message Period
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Period.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.start = null;
          object.end = null;
          object.inflation = '';
        }
        if (message.start != null && message.hasOwnProperty('start'))
          object.start = $root.google.protobuf.Timestamp.toObject(message.start, options);
        if (message.end != null && message.hasOwnProperty('end'))
          object.end = $root.google.protobuf.Timestamp.toObject(message.end, options);
        if (message.inflation != null && message.hasOwnProperty('inflation')) object.inflation = message.inflation;
        return object;
      };

      /**
       * Converts this Period to JSON.
       * @function toJSON
       * @memberof ununifi.ununifidist.Period
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Period.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Period;
    })();

    ununifidist.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.ununifidist
       * @interface IGenesisState
       * @property {ununifi.ununifidist.IParams|null} [params] GenesisState params
       * @property {google.protobuf.ITimestamp|null} [previous_block_time] GenesisState previous_block_time
       * @property {string|null} [gov_denom] GenesisState gov_denom
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.ununifidist
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.ununifidist.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.ununifidist.IParams|null|undefined} params
       * @memberof ununifi.ununifidist.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState previous_block_time.
       * @member {google.protobuf.ITimestamp|null|undefined} previous_block_time
       * @memberof ununifi.ununifidist.GenesisState
       * @instance
       */
      GenesisState.prototype.previous_block_time = null;

      /**
       * GenesisState gov_denom.
       * @member {string} gov_denom
       * @memberof ununifi.ununifidist.GenesisState
       * @instance
       */
      GenesisState.prototype.gov_denom = '';

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.ununifidist.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ununifidist.GenesisState
       * @static
       * @param {ununifi.ununifidist.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.ununifidist.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.previous_block_time != null && Object.hasOwnProperty.call(message, 'previous_block_time'))
          $root.google.protobuf.Timestamp.encode(message.previous_block_time, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.gov_denom != null && Object.hasOwnProperty.call(message, 'gov_denom'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.gov_denom);
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.ununifidist.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ununifidist.GenesisState
       * @static
       * @param {ununifi.ununifidist.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ununifidist.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ununifidist.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ununifidist.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.ununifidist.Params.decode(reader, reader.uint32());
              break;
            case 2:
              message.previous_block_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.gov_denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ununifidist.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ununifidist.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.ununifidist.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.ununifidist.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.previous_block_time != null && message.hasOwnProperty('previous_block_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.previous_block_time);
          if (error) return 'previous_block_time.' + error;
        }
        if (message.gov_denom != null && message.hasOwnProperty('gov_denom'))
          if (!$util.isString(message.gov_denom)) return 'gov_denom: string expected';
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ununifidist.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ununifidist.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ununifidist.GenesisState) return object;
        let message = new $root.ununifi.ununifidist.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.ununifidist.GenesisState.params: object expected');
          message.params = $root.ununifi.ununifidist.Params.fromObject(object.params);
        }
        if (object.previous_block_time != null) {
          if (typeof object.previous_block_time !== 'object')
            throw TypeError('.ununifi.ununifidist.GenesisState.previous_block_time: object expected');
          message.previous_block_time = $root.google.protobuf.Timestamp.fromObject(object.previous_block_time);
        }
        if (object.gov_denom != null) message.gov_denom = String(object.gov_denom);
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ununifidist.GenesisState
       * @static
       * @param {ununifi.ununifidist.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.params = null;
          object.previous_block_time = null;
          object.gov_denom = '';
        }
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.ununifidist.Params.toObject(message.params, options);
        if (message.previous_block_time != null && message.hasOwnProperty('previous_block_time'))
          object.previous_block_time = $root.google.protobuf.Timestamp.toObject(message.previous_block_time, options);
        if (message.gov_denom != null && message.hasOwnProperty('gov_denom')) object.gov_denom = message.gov_denom;
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.ununifidist.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    return ununifidist;
  })();

  return ununifi;
})());

export const cosmos = ($root.cosmos = (() => {
  /**
   * Namespace cosmos.
   * @exports cosmos
   * @namespace
   */
  const cosmos = {};

  cosmos.base = (function () {
    /**
     * Namespace base.
     * @memberof cosmos
     * @namespace
     */
    const base = {};

    base.query = (function () {
      /**
       * Namespace query.
       * @memberof cosmos.base
       * @namespace
       */
      const query = {};

      query.v1beta1 = (function () {
        /**
         * Namespace v1beta1.
         * @memberof cosmos.base.query
         * @namespace
         */
        const v1beta1 = {};

        v1beta1.PageRequest = (function () {
          /**
           * Properties of a PageRequest.
           * @memberof cosmos.base.query.v1beta1
           * @interface IPageRequest
           * @property {Uint8Array|null} [key] PageRequest key
           * @property {Long|null} [offset] PageRequest offset
           * @property {Long|null} [limit] PageRequest limit
           * @property {boolean|null} [count_total] PageRequest count_total
           */

          /**
           * Constructs a new PageRequest.
           * @memberof cosmos.base.query.v1beta1
           * @classdesc Represents a PageRequest.
           * @implements IPageRequest
           * @constructor
           * @param {cosmos.base.query.v1beta1.IPageRequest=} [properties] Properties to set
           */
          function PageRequest(properties) {
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * PageRequest key.
           * @member {Uint8Array} key
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.key = $util.newBuffer([]);

          /**
           * PageRequest offset.
           * @member {Long} offset
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * PageRequest limit.
           * @member {Long} limit
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * PageRequest count_total.
           * @member {boolean} count_total
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.count_total = false;

          /**
           * Encodes the specified PageRequest message. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageRequest.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, 'key'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.key);
            if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))
              writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.offset);
            if (message.limit != null && Object.hasOwnProperty.call(message, 'limit'))
              writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.limit);
            if (message.count_total != null && Object.hasOwnProperty.call(message, 'count_total'))
              writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.count_total);
            return writer;
          };

          /**
           * Encodes the specified PageRequest message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a PageRequest message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.query.v1beta1.PageRequest();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.key = reader.bytes();
                  break;
                case 2:
                  message.offset = reader.uint64();
                  break;
                case 3:
                  message.limit = reader.uint64();
                  break;
                case 4:
                  message.count_total = reader.bool();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a PageRequest message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a PageRequest message.
           * @function verify
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          PageRequest.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.key != null && message.hasOwnProperty('key'))
              if (!((message.key && typeof message.key.length === 'number') || $util.isString(message.key))) return 'key: buffer expected';
            if (message.offset != null && message.hasOwnProperty('offset'))
              if (
                !$util.isInteger(message.offset) &&
                !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high))
              )
                return 'offset: integer|Long expected';
            if (message.limit != null && message.hasOwnProperty('limit'))
              if (
                !$util.isInteger(message.limit) &&
                !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high))
              )
                return 'limit: integer|Long expected';
            if (message.count_total != null && message.hasOwnProperty('count_total'))
              if (typeof message.count_total !== 'boolean') return 'count_total: boolean expected';
            return null;
          };

          /**
           * Creates a PageRequest message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
           */
          PageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.query.v1beta1.PageRequest) return object;
            let message = new $root.cosmos.base.query.v1beta1.PageRequest();
            if (object.key != null)
              if (typeof object.key === 'string')
                $util.base64.decode(object.key, (message.key = $util.newBuffer($util.base64.length(object.key))), 0);
              else if (object.key.length) message.key = object.key;
            if (object.offset != null)
              if ($util.Long) (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
              else if (typeof object.offset === 'string') message.offset = parseInt(object.offset, 10);
              else if (typeof object.offset === 'number') message.offset = object.offset;
              else if (typeof object.offset === 'object')
                message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
            if (object.limit != null)
              if ($util.Long) (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
              else if (typeof object.limit === 'string') message.limit = parseInt(object.limit, 10);
              else if (typeof object.limit === 'number') message.limit = object.limit;
              else if (typeof object.limit === 'object')
                message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
            if (object.count_total != null) message.count_total = Boolean(object.count_total);
            return message;
          };

          /**
           * Creates a plain object from a PageRequest message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {cosmos.base.query.v1beta1.PageRequest} message PageRequest
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          PageRequest.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              if (options.bytes === String) object.key = '';
              else {
                object.key = [];
                if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
              }
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.offset = options.longs === String ? '0' : 0;
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.limit = options.longs === String ? '0' : 0;
              object.count_total = false;
            }
            if (message.key != null && message.hasOwnProperty('key'))
              object.key =
                options.bytes === String
                  ? $util.base64.encode(message.key, 0, message.key.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.key)
                  : message.key;
            if (message.offset != null && message.hasOwnProperty('offset'))
              if (typeof message.offset === 'number') object.offset = options.longs === String ? String(message.offset) : message.offset;
              else
                object.offset =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.offset)
                    : options.longs === Number
                    ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true)
                    : message.offset;
            if (message.limit != null && message.hasOwnProperty('limit'))
              if (typeof message.limit === 'number') object.limit = options.longs === String ? String(message.limit) : message.limit;
              else
                object.limit =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.limit)
                    : options.longs === Number
                    ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true)
                    : message.limit;
            if (message.count_total != null && message.hasOwnProperty('count_total')) object.count_total = message.count_total;
            return object;
          };

          /**
           * Converts this PageRequest to JSON.
           * @function toJSON
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          PageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return PageRequest;
        })();

        v1beta1.PageResponse = (function () {
          /**
           * Properties of a PageResponse.
           * @memberof cosmos.base.query.v1beta1
           * @interface IPageResponse
           * @property {Uint8Array|null} [next_key] PageResponse next_key
           * @property {Long|null} [total] PageResponse total
           */

          /**
           * Constructs a new PageResponse.
           * @memberof cosmos.base.query.v1beta1
           * @classdesc Represents a PageResponse.
           * @implements IPageResponse
           * @constructor
           * @param {cosmos.base.query.v1beta1.IPageResponse=} [properties] Properties to set
           */
          function PageResponse(properties) {
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * PageResponse next_key.
           * @member {Uint8Array} next_key
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @instance
           */
          PageResponse.prototype.next_key = $util.newBuffer([]);

          /**
           * PageResponse total.
           * @member {Long} total
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @instance
           */
          PageResponse.prototype.total = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * Encodes the specified PageResponse message. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageResponse.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.next_key != null && Object.hasOwnProperty.call(message, 'next_key'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.next_key);
            if (message.total != null && Object.hasOwnProperty.call(message, 'total'))
              writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.total);
            return writer;
          };

          /**
           * Encodes the specified PageResponse message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a PageResponse message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.query.v1beta1.PageResponse();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.next_key = reader.bytes();
                  break;
                case 2:
                  message.total = reader.uint64();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a PageResponse message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a PageResponse message.
           * @function verify
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          PageResponse.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.next_key != null && message.hasOwnProperty('next_key'))
              if (!((message.next_key && typeof message.next_key.length === 'number') || $util.isString(message.next_key)))
                return 'next_key: buffer expected';
            if (message.total != null && message.hasOwnProperty('total'))
              if (
                !$util.isInteger(message.total) &&
                !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high))
              )
                return 'total: integer|Long expected';
            return null;
          };

          /**
           * Creates a PageResponse message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
           */
          PageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.query.v1beta1.PageResponse) return object;
            let message = new $root.cosmos.base.query.v1beta1.PageResponse();
            if (object.next_key != null)
              if (typeof object.next_key === 'string')
                $util.base64.decode(object.next_key, (message.next_key = $util.newBuffer($util.base64.length(object.next_key))), 0);
              else if (object.next_key.length) message.next_key = object.next_key;
            if (object.total != null)
              if ($util.Long) (message.total = $util.Long.fromValue(object.total)).unsigned = true;
              else if (typeof object.total === 'string') message.total = parseInt(object.total, 10);
              else if (typeof object.total === 'number') message.total = object.total;
              else if (typeof object.total === 'object')
                message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
            return message;
          };

          /**
           * Creates a plain object from a PageResponse message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {cosmos.base.query.v1beta1.PageResponse} message PageResponse
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          PageResponse.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              if (options.bytes === String) object.next_key = '';
              else {
                object.next_key = [];
                if (options.bytes !== Array) object.next_key = $util.newBuffer(object.next_key);
              }
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.total = options.longs === String ? '0' : 0;
            }
            if (message.next_key != null && message.hasOwnProperty('next_key'))
              object.next_key =
                options.bytes === String
                  ? $util.base64.encode(message.next_key, 0, message.next_key.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.next_key)
                  : message.next_key;
            if (message.total != null && message.hasOwnProperty('total'))
              if (typeof message.total === 'number') object.total = options.longs === String ? String(message.total) : message.total;
              else
                object.total =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.total)
                    : options.longs === Number
                    ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true)
                    : message.total;
            return object;
          };

          /**
           * Converts this PageResponse to JSON.
           * @function toJSON
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          PageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return PageResponse;
        })();

        return v1beta1;
      })();

      return query;
    })();

    base.v1beta1 = (function () {
      /**
       * Namespace v1beta1.
       * @memberof cosmos.base
       * @namespace
       */
      const v1beta1 = {};

      v1beta1.Coin = (function () {
        /**
         * Properties of a Coin.
         * @memberof cosmos.base.v1beta1
         * @interface ICoin
         * @property {string|null} [denom] Coin denom
         * @property {string|null} [amount] Coin amount
         */

        /**
         * Constructs a new Coin.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a Coin.
         * @implements ICoin
         * @constructor
         * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set
         */
        function Coin(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coin denom.
         * @member {string} denom
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         */
        Coin.prototype.denom = '';

        /**
         * Coin amount.
         * @member {string} amount
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         */
        Coin.prototype.amount = '';

        /**
         * Encodes the specified Coin message. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified Coin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coin message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.Coin();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Coin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coin message.
         * @function verify
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coin.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          return null;
        };

        /**
         * Creates a Coin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.Coin} Coin
         */
        Coin.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.Coin) return object;
          let message = new $root.cosmos.base.v1beta1.Coin();
          if (object.denom != null) message.denom = String(object.denom);
          if (object.amount != null) message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from a Coin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.Coin} message Coin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coin.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.denom = '';
            object.amount = '';
          }
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          return object;
        };

        /**
         * Converts this Coin to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coin;
      })();

      v1beta1.DecCoin = (function () {
        /**
         * Properties of a DecCoin.
         * @memberof cosmos.base.v1beta1
         * @interface IDecCoin
         * @property {string|null} [denom] DecCoin denom
         * @property {string|null} [amount] DecCoin amount
         */

        /**
         * Constructs a new DecCoin.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a DecCoin.
         * @implements IDecCoin
         * @constructor
         * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set
         */
        function DecCoin(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecCoin denom.
         * @member {string} denom
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         */
        DecCoin.prototype.denom = '';

        /**
         * DecCoin amount.
         * @member {string} amount
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         */
        DecCoin.prototype.amount = '';

        /**
         * Encodes the specified DecCoin message. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecCoin.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified DecCoin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecCoin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecCoin message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecCoin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.DecCoin();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DecCoin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecCoin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecCoin message.
         * @function verify
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecCoin.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          return null;
        };

        /**
         * Creates a DecCoin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         */
        DecCoin.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.DecCoin) return object;
          let message = new $root.cosmos.base.v1beta1.DecCoin();
          if (object.denom != null) message.denom = String(object.denom);
          if (object.amount != null) message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from a DecCoin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.DecCoin} message DecCoin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecCoin.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.denom = '';
            object.amount = '';
          }
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          return object;
        };

        /**
         * Converts this DecCoin to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecCoin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecCoin;
      })();

      v1beta1.IntProto = (function () {
        /**
         * Properties of an IntProto.
         * @memberof cosmos.base.v1beta1
         * @interface IIntProto
         * @property {string|null} [int] IntProto int
         */

        /**
         * Constructs a new IntProto.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents an IntProto.
         * @implements IIntProto
         * @constructor
         * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set
         */
        function IntProto(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntProto int.
         * @member {string} int
         * @memberof cosmos.base.v1beta1.IntProto
         * @instance
         */
        IntProto.prototype.int = '';

        /**
         * Encodes the specified IntProto message. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.int != null && Object.hasOwnProperty.call(message, 'int'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.int);
          return writer;
        };

        /**
         * Encodes the specified IntProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IntProto message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.IntProto();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.int = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an IntProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IntProto message.
         * @function verify
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IntProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.int != null && message.hasOwnProperty('int')) if (!$util.isString(message.int)) return 'int: string expected';
          return null;
        };

        /**
         * Creates an IntProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         */
        IntProto.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.IntProto) return object;
          let message = new $root.cosmos.base.v1beta1.IntProto();
          if (object.int != null) message.int = String(object.int);
          return message;
        };

        /**
         * Creates a plain object from an IntProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IntProto} message IntProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IntProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) object.int = '';
          if (message.int != null && message.hasOwnProperty('int')) object.int = message.int;
          return object;
        };

        /**
         * Converts this IntProto to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.IntProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IntProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IntProto;
      })();

      v1beta1.DecProto = (function () {
        /**
         * Properties of a DecProto.
         * @memberof cosmos.base.v1beta1
         * @interface IDecProto
         * @property {string|null} [dec] DecProto dec
         */

        /**
         * Constructs a new DecProto.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a DecProto.
         * @implements IDecProto
         * @constructor
         * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set
         */
        function DecProto(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecProto dec.
         * @member {string} dec
         * @memberof cosmos.base.v1beta1.DecProto
         * @instance
         */
        DecProto.prototype.dec = '';

        /**
         * Encodes the specified DecProto message. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.dec != null && Object.hasOwnProperty.call(message, 'dec'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.dec);
          return writer;
        };

        /**
         * Encodes the specified DecProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecProto message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.DecProto();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.dec = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DecProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecProto message.
         * @function verify
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.dec != null && message.hasOwnProperty('dec')) if (!$util.isString(message.dec)) return 'dec: string expected';
          return null;
        };

        /**
         * Creates a DecProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         */
        DecProto.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.DecProto) return object;
          let message = new $root.cosmos.base.v1beta1.DecProto();
          if (object.dec != null) message.dec = String(object.dec);
          return message;
        };

        /**
         * Creates a plain object from a DecProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.DecProto} message DecProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) object.dec = '';
          if (message.dec != null && message.hasOwnProperty('dec')) object.dec = message.dec;
          return object;
        };

        /**
         * Converts this DecProto to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.DecProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecProto;
      })();

      return v1beta1;
    })();

    return base;
  })();

  cosmos.tx = (function () {
    /**
     * Namespace tx.
     * @memberof cosmos
     * @namespace
     */
    const tx = {};

    tx.v1beta1 = (function () {
      /**
       * Namespace v1beta1.
       * @memberof cosmos.tx
       * @namespace
       */
      const v1beta1 = {};

      v1beta1.Tx = (function () {
        /**
         * Properties of a Tx.
         * @memberof cosmos.tx.v1beta1
         * @interface ITx
         * @property {cosmos.tx.v1beta1.ITxBody|null} [body] Tx body
         * @property {cosmos.tx.v1beta1.IAuthInfo|null} [auth_info] Tx auth_info
         * @property {Array.<Uint8Array>|null} [signatures] Tx signatures
         */

        /**
         * Constructs a new Tx.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a Tx.
         * @implements ITx
         * @constructor
         * @param {cosmos.tx.v1beta1.ITx=} [properties] Properties to set
         */
        function Tx(properties) {
          this.signatures = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tx body.
         * @member {cosmos.tx.v1beta1.ITxBody|null|undefined} body
         * @memberof cosmos.tx.v1beta1.Tx
         * @instance
         */
        Tx.prototype.body = null;

        /**
         * Tx auth_info.
         * @member {cosmos.tx.v1beta1.IAuthInfo|null|undefined} auth_info
         * @memberof cosmos.tx.v1beta1.Tx
         * @instance
         */
        Tx.prototype.auth_info = null;

        /**
         * Tx signatures.
         * @member {Array.<Uint8Array>} signatures
         * @memberof cosmos.tx.v1beta1.Tx
         * @instance
         */
        Tx.prototype.signatures = $util.emptyArray;

        /**
         * Encodes the specified Tx message. Does not implicitly {@link cosmos.tx.v1beta1.Tx.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.Tx
         * @static
         * @param {cosmos.tx.v1beta1.ITx} message Tx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tx.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.body != null && Object.hasOwnProperty.call(message, 'body'))
            $root.cosmos.tx.v1beta1.TxBody.encode(message.body, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.auth_info != null && Object.hasOwnProperty.call(message, 'auth_info'))
            $root.cosmos.tx.v1beta1.AuthInfo.encode(message.auth_info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.signatures != null && message.signatures.length)
            for (let i = 0; i < message.signatures.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.signatures[i]);
          return writer;
        };

        /**
         * Encodes the specified Tx message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.Tx.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.Tx
         * @static
         * @param {cosmos.tx.v1beta1.ITx} message Tx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tx.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tx message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.Tx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.Tx} Tx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tx.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.Tx();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.body = $root.cosmos.tx.v1beta1.TxBody.decode(reader, reader.uint32());
                break;
              case 2:
                message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.decode(reader, reader.uint32());
                break;
              case 3:
                if (!(message.signatures && message.signatures.length)) message.signatures = [];
                message.signatures.push(reader.bytes());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Tx message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.Tx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.Tx} Tx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tx.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tx message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.Tx
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tx.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.body != null && message.hasOwnProperty('body')) {
            let error = $root.cosmos.tx.v1beta1.TxBody.verify(message.body);
            if (error) return 'body.' + error;
          }
          if (message.auth_info != null && message.hasOwnProperty('auth_info')) {
            let error = $root.cosmos.tx.v1beta1.AuthInfo.verify(message.auth_info);
            if (error) return 'auth_info.' + error;
          }
          if (message.signatures != null && message.hasOwnProperty('signatures')) {
            if (!Array.isArray(message.signatures)) return 'signatures: array expected';
            for (let i = 0; i < message.signatures.length; ++i)
              if (!((message.signatures[i] && typeof message.signatures[i].length === 'number') || $util.isString(message.signatures[i])))
                return 'signatures: buffer[] expected';
          }
          return null;
        };

        /**
         * Creates a Tx message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.Tx
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.Tx} Tx
         */
        Tx.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.Tx) return object;
          let message = new $root.cosmos.tx.v1beta1.Tx();
          if (object.body != null) {
            if (typeof object.body !== 'object') throw TypeError('.cosmos.tx.v1beta1.Tx.body: object expected');
            message.body = $root.cosmos.tx.v1beta1.TxBody.fromObject(object.body);
          }
          if (object.auth_info != null) {
            if (typeof object.auth_info !== 'object') throw TypeError('.cosmos.tx.v1beta1.Tx.auth_info: object expected');
            message.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.fromObject(object.auth_info);
          }
          if (object.signatures) {
            if (!Array.isArray(object.signatures)) throw TypeError('.cosmos.tx.v1beta1.Tx.signatures: array expected');
            message.signatures = [];
            for (let i = 0; i < object.signatures.length; ++i)
              if (typeof object.signatures[i] === 'string')
                $util.base64.decode(
                  object.signatures[i],
                  (message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i]))),
                  0,
                );
              else if (object.signatures[i].length) message.signatures[i] = object.signatures[i];
          }
          return message;
        };

        /**
         * Creates a plain object from a Tx message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.Tx
         * @static
         * @param {cosmos.tx.v1beta1.Tx} message Tx
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tx.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) object.signatures = [];
          if (options.defaults) {
            object.body = null;
            object.auth_info = null;
          }
          if (message.body != null && message.hasOwnProperty('body'))
            object.body = $root.cosmos.tx.v1beta1.TxBody.toObject(message.body, options);
          if (message.auth_info != null && message.hasOwnProperty('auth_info'))
            object.auth_info = $root.cosmos.tx.v1beta1.AuthInfo.toObject(message.auth_info, options);
          if (message.signatures && message.signatures.length) {
            object.signatures = [];
            for (let j = 0; j < message.signatures.length; ++j)
              object.signatures[j] =
                options.bytes === String
                  ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.signatures[j])
                  : message.signatures[j];
          }
          return object;
        };

        /**
         * Converts this Tx to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.Tx
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tx.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tx;
      })();

      v1beta1.TxRaw = (function () {
        /**
         * Properties of a TxRaw.
         * @memberof cosmos.tx.v1beta1
         * @interface ITxRaw
         * @property {Uint8Array|null} [body_bytes] TxRaw body_bytes
         * @property {Uint8Array|null} [auth_info_bytes] TxRaw auth_info_bytes
         * @property {Array.<Uint8Array>|null} [signatures] TxRaw signatures
         */

        /**
         * Constructs a new TxRaw.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a TxRaw.
         * @implements ITxRaw
         * @constructor
         * @param {cosmos.tx.v1beta1.ITxRaw=} [properties] Properties to set
         */
        function TxRaw(properties) {
          this.signatures = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * TxRaw body_bytes.
         * @member {Uint8Array} body_bytes
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @instance
         */
        TxRaw.prototype.body_bytes = $util.newBuffer([]);

        /**
         * TxRaw auth_info_bytes.
         * @member {Uint8Array} auth_info_bytes
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @instance
         */
        TxRaw.prototype.auth_info_bytes = $util.newBuffer([]);

        /**
         * TxRaw signatures.
         * @member {Array.<Uint8Array>} signatures
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @instance
         */
        TxRaw.prototype.signatures = $util.emptyArray;

        /**
         * Encodes the specified TxRaw message. Does not implicitly {@link cosmos.tx.v1beta1.TxRaw.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @static
         * @param {cosmos.tx.v1beta1.ITxRaw} message TxRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxRaw.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.body_bytes != null && Object.hasOwnProperty.call(message, 'body_bytes'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.body_bytes);
          if (message.auth_info_bytes != null && Object.hasOwnProperty.call(message, 'auth_info_bytes'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.auth_info_bytes);
          if (message.signatures != null && message.signatures.length)
            for (let i = 0; i < message.signatures.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.signatures[i]);
          return writer;
        };

        /**
         * Encodes the specified TxRaw message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.TxRaw.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @static
         * @param {cosmos.tx.v1beta1.ITxRaw} message TxRaw message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxRaw.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TxRaw message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.TxRaw} TxRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxRaw.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.TxRaw();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.body_bytes = reader.bytes();
                break;
              case 2:
                message.auth_info_bytes = reader.bytes();
                break;
              case 3:
                if (!(message.signatures && message.signatures.length)) message.signatures = [];
                message.signatures.push(reader.bytes());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a TxRaw message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.TxRaw} TxRaw
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxRaw.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TxRaw message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TxRaw.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
            if (!((message.body_bytes && typeof message.body_bytes.length === 'number') || $util.isString(message.body_bytes)))
              return 'body_bytes: buffer expected';
          if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
            if (
              !((message.auth_info_bytes && typeof message.auth_info_bytes.length === 'number') || $util.isString(message.auth_info_bytes))
            )
              return 'auth_info_bytes: buffer expected';
          if (message.signatures != null && message.hasOwnProperty('signatures')) {
            if (!Array.isArray(message.signatures)) return 'signatures: array expected';
            for (let i = 0; i < message.signatures.length; ++i)
              if (!((message.signatures[i] && typeof message.signatures[i].length === 'number') || $util.isString(message.signatures[i])))
                return 'signatures: buffer[] expected';
          }
          return null;
        };

        /**
         * Creates a TxRaw message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.TxRaw} TxRaw
         */
        TxRaw.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.TxRaw) return object;
          let message = new $root.cosmos.tx.v1beta1.TxRaw();
          if (object.body_bytes != null)
            if (typeof object.body_bytes === 'string')
              $util.base64.decode(object.body_bytes, (message.body_bytes = $util.newBuffer($util.base64.length(object.body_bytes))), 0);
            else if (object.body_bytes.length) message.body_bytes = object.body_bytes;
          if (object.auth_info_bytes != null)
            if (typeof object.auth_info_bytes === 'string')
              $util.base64.decode(
                object.auth_info_bytes,
                (message.auth_info_bytes = $util.newBuffer($util.base64.length(object.auth_info_bytes))),
                0,
              );
            else if (object.auth_info_bytes.length) message.auth_info_bytes = object.auth_info_bytes;
          if (object.signatures) {
            if (!Array.isArray(object.signatures)) throw TypeError('.cosmos.tx.v1beta1.TxRaw.signatures: array expected');
            message.signatures = [];
            for (let i = 0; i < object.signatures.length; ++i)
              if (typeof object.signatures[i] === 'string')
                $util.base64.decode(
                  object.signatures[i],
                  (message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i]))),
                  0,
                );
              else if (object.signatures[i].length) message.signatures[i] = object.signatures[i];
          }
          return message;
        };

        /**
         * Creates a plain object from a TxRaw message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @static
         * @param {cosmos.tx.v1beta1.TxRaw} message TxRaw
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TxRaw.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) object.signatures = [];
          if (options.defaults) {
            if (options.bytes === String) object.body_bytes = '';
            else {
              object.body_bytes = [];
              if (options.bytes !== Array) object.body_bytes = $util.newBuffer(object.body_bytes);
            }
            if (options.bytes === String) object.auth_info_bytes = '';
            else {
              object.auth_info_bytes = [];
              if (options.bytes !== Array) object.auth_info_bytes = $util.newBuffer(object.auth_info_bytes);
            }
          }
          if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
            object.body_bytes =
              options.bytes === String
                ? $util.base64.encode(message.body_bytes, 0, message.body_bytes.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.body_bytes)
                : message.body_bytes;
          if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
            object.auth_info_bytes =
              options.bytes === String
                ? $util.base64.encode(message.auth_info_bytes, 0, message.auth_info_bytes.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.auth_info_bytes)
                : message.auth_info_bytes;
          if (message.signatures && message.signatures.length) {
            object.signatures = [];
            for (let j = 0; j < message.signatures.length; ++j)
              object.signatures[j] =
                options.bytes === String
                  ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.signatures[j])
                  : message.signatures[j];
          }
          return object;
        };

        /**
         * Converts this TxRaw to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.TxRaw
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TxRaw.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TxRaw;
      })();

      v1beta1.SignDoc = (function () {
        /**
         * Properties of a SignDoc.
         * @memberof cosmos.tx.v1beta1
         * @interface ISignDoc
         * @property {Uint8Array|null} [body_bytes] SignDoc body_bytes
         * @property {Uint8Array|null} [auth_info_bytes] SignDoc auth_info_bytes
         * @property {string|null} [chain_id] SignDoc chain_id
         * @property {Long|null} [account_number] SignDoc account_number
         */

        /**
         * Constructs a new SignDoc.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a SignDoc.
         * @implements ISignDoc
         * @constructor
         * @param {cosmos.tx.v1beta1.ISignDoc=} [properties] Properties to set
         */
        function SignDoc(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignDoc body_bytes.
         * @member {Uint8Array} body_bytes
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @instance
         */
        SignDoc.prototype.body_bytes = $util.newBuffer([]);

        /**
         * SignDoc auth_info_bytes.
         * @member {Uint8Array} auth_info_bytes
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @instance
         */
        SignDoc.prototype.auth_info_bytes = $util.newBuffer([]);

        /**
         * SignDoc chain_id.
         * @member {string} chain_id
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @instance
         */
        SignDoc.prototype.chain_id = '';

        /**
         * SignDoc account_number.
         * @member {Long} account_number
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @instance
         */
        SignDoc.prototype.account_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified SignDoc message. Does not implicitly {@link cosmos.tx.v1beta1.SignDoc.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @static
         * @param {cosmos.tx.v1beta1.ISignDoc} message SignDoc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignDoc.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.body_bytes != null && Object.hasOwnProperty.call(message, 'body_bytes'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.body_bytes);
          if (message.auth_info_bytes != null && Object.hasOwnProperty.call(message, 'auth_info_bytes'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.auth_info_bytes);
          if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.chain_id);
          if (message.account_number != null && Object.hasOwnProperty.call(message, 'account_number'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.account_number);
          return writer;
        };

        /**
         * Encodes the specified SignDoc message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.SignDoc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @static
         * @param {cosmos.tx.v1beta1.ISignDoc} message SignDoc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignDoc.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignDoc message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.SignDoc} SignDoc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignDoc.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.SignDoc();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.body_bytes = reader.bytes();
                break;
              case 2:
                message.auth_info_bytes = reader.bytes();
                break;
              case 3:
                message.chain_id = reader.string();
                break;
              case 4:
                message.account_number = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SignDoc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.SignDoc} SignDoc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignDoc.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignDoc message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignDoc.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
            if (!((message.body_bytes && typeof message.body_bytes.length === 'number') || $util.isString(message.body_bytes)))
              return 'body_bytes: buffer expected';
          if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
            if (
              !((message.auth_info_bytes && typeof message.auth_info_bytes.length === 'number') || $util.isString(message.auth_info_bytes))
            )
              return 'auth_info_bytes: buffer expected';
          if (message.chain_id != null && message.hasOwnProperty('chain_id'))
            if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
          if (message.account_number != null && message.hasOwnProperty('account_number'))
            if (
              !$util.isInteger(message.account_number) &&
              !(message.account_number && $util.isInteger(message.account_number.low) && $util.isInteger(message.account_number.high))
            )
              return 'account_number: integer|Long expected';
          return null;
        };

        /**
         * Creates a SignDoc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.SignDoc} SignDoc
         */
        SignDoc.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.SignDoc) return object;
          let message = new $root.cosmos.tx.v1beta1.SignDoc();
          if (object.body_bytes != null)
            if (typeof object.body_bytes === 'string')
              $util.base64.decode(object.body_bytes, (message.body_bytes = $util.newBuffer($util.base64.length(object.body_bytes))), 0);
            else if (object.body_bytes.length) message.body_bytes = object.body_bytes;
          if (object.auth_info_bytes != null)
            if (typeof object.auth_info_bytes === 'string')
              $util.base64.decode(
                object.auth_info_bytes,
                (message.auth_info_bytes = $util.newBuffer($util.base64.length(object.auth_info_bytes))),
                0,
              );
            else if (object.auth_info_bytes.length) message.auth_info_bytes = object.auth_info_bytes;
          if (object.chain_id != null) message.chain_id = String(object.chain_id);
          if (object.account_number != null)
            if ($util.Long) (message.account_number = $util.Long.fromValue(object.account_number)).unsigned = true;
            else if (typeof object.account_number === 'string') message.account_number = parseInt(object.account_number, 10);
            else if (typeof object.account_number === 'number') message.account_number = object.account_number;
            else if (typeof object.account_number === 'object')
              message.account_number = new $util.LongBits(object.account_number.low >>> 0, object.account_number.high >>> 0).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a SignDoc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @static
         * @param {cosmos.tx.v1beta1.SignDoc} message SignDoc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignDoc.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            if (options.bytes === String) object.body_bytes = '';
            else {
              object.body_bytes = [];
              if (options.bytes !== Array) object.body_bytes = $util.newBuffer(object.body_bytes);
            }
            if (options.bytes === String) object.auth_info_bytes = '';
            else {
              object.auth_info_bytes = [];
              if (options.bytes !== Array) object.auth_info_bytes = $util.newBuffer(object.auth_info_bytes);
            }
            object.chain_id = '';
            if ($util.Long) {
              let long = new $util.Long(0, 0, true);
              object.account_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.account_number = options.longs === String ? '0' : 0;
          }
          if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
            object.body_bytes =
              options.bytes === String
                ? $util.base64.encode(message.body_bytes, 0, message.body_bytes.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.body_bytes)
                : message.body_bytes;
          if (message.auth_info_bytes != null && message.hasOwnProperty('auth_info_bytes'))
            object.auth_info_bytes =
              options.bytes === String
                ? $util.base64.encode(message.auth_info_bytes, 0, message.auth_info_bytes.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.auth_info_bytes)
                : message.auth_info_bytes;
          if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
          if (message.account_number != null && message.hasOwnProperty('account_number'))
            if (typeof message.account_number === 'number')
              object.account_number = options.longs === String ? String(message.account_number) : message.account_number;
            else
              object.account_number =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.account_number)
                  : options.longs === Number
                  ? new $util.LongBits(message.account_number.low >>> 0, message.account_number.high >>> 0).toNumber(true)
                  : message.account_number;
          return object;
        };

        /**
         * Converts this SignDoc to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.SignDoc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignDoc.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignDoc;
      })();

      v1beta1.SignDocDirectAux = (function () {
        /**
         * Properties of a SignDocDirectAux.
         * @memberof cosmos.tx.v1beta1
         * @interface ISignDocDirectAux
         * @property {Uint8Array|null} [body_bytes] SignDocDirectAux body_bytes
         * @property {google.protobuf.IAny|null} [public_key] SignDocDirectAux public_key
         * @property {string|null} [chain_id] SignDocDirectAux chain_id
         * @property {Long|null} [account_number] SignDocDirectAux account_number
         * @property {Long|null} [sequence] SignDocDirectAux sequence
         * @property {cosmos.tx.v1beta1.ITip|null} [tip] SignDocDirectAux tip
         */

        /**
         * Constructs a new SignDocDirectAux.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a SignDocDirectAux.
         * @implements ISignDocDirectAux
         * @constructor
         * @param {cosmos.tx.v1beta1.ISignDocDirectAux=} [properties] Properties to set
         */
        function SignDocDirectAux(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignDocDirectAux body_bytes.
         * @member {Uint8Array} body_bytes
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @instance
         */
        SignDocDirectAux.prototype.body_bytes = $util.newBuffer([]);

        /**
         * SignDocDirectAux public_key.
         * @member {google.protobuf.IAny|null|undefined} public_key
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @instance
         */
        SignDocDirectAux.prototype.public_key = null;

        /**
         * SignDocDirectAux chain_id.
         * @member {string} chain_id
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @instance
         */
        SignDocDirectAux.prototype.chain_id = '';

        /**
         * SignDocDirectAux account_number.
         * @member {Long} account_number
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @instance
         */
        SignDocDirectAux.prototype.account_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * SignDocDirectAux sequence.
         * @member {Long} sequence
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @instance
         */
        SignDocDirectAux.prototype.sequence = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * SignDocDirectAux tip.
         * @member {cosmos.tx.v1beta1.ITip|null|undefined} tip
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @instance
         */
        SignDocDirectAux.prototype.tip = null;

        /**
         * Encodes the specified SignDocDirectAux message. Does not implicitly {@link cosmos.tx.v1beta1.SignDocDirectAux.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @static
         * @param {cosmos.tx.v1beta1.ISignDocDirectAux} message SignDocDirectAux message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignDocDirectAux.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.body_bytes != null && Object.hasOwnProperty.call(message, 'body_bytes'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.body_bytes);
          if (message.public_key != null && Object.hasOwnProperty.call(message, 'public_key'))
            $root.google.protobuf.Any.encode(message.public_key, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.chain_id);
          if (message.account_number != null && Object.hasOwnProperty.call(message, 'account_number'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.account_number);
          if (message.sequence != null && Object.hasOwnProperty.call(message, 'sequence'))
            writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.sequence);
          if (message.tip != null && Object.hasOwnProperty.call(message, 'tip'))
            $root.cosmos.tx.v1beta1.Tip.encode(message.tip, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified SignDocDirectAux message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.SignDocDirectAux.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @static
         * @param {cosmos.tx.v1beta1.ISignDocDirectAux} message SignDocDirectAux message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignDocDirectAux.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignDocDirectAux message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.SignDocDirectAux} SignDocDirectAux
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignDocDirectAux.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.SignDocDirectAux();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.body_bytes = reader.bytes();
                break;
              case 2:
                message.public_key = $root.google.protobuf.Any.decode(reader, reader.uint32());
                break;
              case 3:
                message.chain_id = reader.string();
                break;
              case 4:
                message.account_number = reader.uint64();
                break;
              case 5:
                message.sequence = reader.uint64();
                break;
              case 6:
                message.tip = $root.cosmos.tx.v1beta1.Tip.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SignDocDirectAux message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.SignDocDirectAux} SignDocDirectAux
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignDocDirectAux.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignDocDirectAux message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignDocDirectAux.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
            if (!((message.body_bytes && typeof message.body_bytes.length === 'number') || $util.isString(message.body_bytes)))
              return 'body_bytes: buffer expected';
          if (message.public_key != null && message.hasOwnProperty('public_key')) {
            let error = $root.google.protobuf.Any.verify(message.public_key);
            if (error) return 'public_key.' + error;
          }
          if (message.chain_id != null && message.hasOwnProperty('chain_id'))
            if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
          if (message.account_number != null && message.hasOwnProperty('account_number'))
            if (
              !$util.isInteger(message.account_number) &&
              !(message.account_number && $util.isInteger(message.account_number.low) && $util.isInteger(message.account_number.high))
            )
              return 'account_number: integer|Long expected';
          if (message.sequence != null && message.hasOwnProperty('sequence'))
            if (
              !$util.isInteger(message.sequence) &&
              !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high))
            )
              return 'sequence: integer|Long expected';
          if (message.tip != null && message.hasOwnProperty('tip')) {
            let error = $root.cosmos.tx.v1beta1.Tip.verify(message.tip);
            if (error) return 'tip.' + error;
          }
          return null;
        };

        /**
         * Creates a SignDocDirectAux message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.SignDocDirectAux} SignDocDirectAux
         */
        SignDocDirectAux.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.SignDocDirectAux) return object;
          let message = new $root.cosmos.tx.v1beta1.SignDocDirectAux();
          if (object.body_bytes != null)
            if (typeof object.body_bytes === 'string')
              $util.base64.decode(object.body_bytes, (message.body_bytes = $util.newBuffer($util.base64.length(object.body_bytes))), 0);
            else if (object.body_bytes.length) message.body_bytes = object.body_bytes;
          if (object.public_key != null) {
            if (typeof object.public_key !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignDocDirectAux.public_key: object expected');
            message.public_key = $root.google.protobuf.Any.fromObject(object.public_key);
          }
          if (object.chain_id != null) message.chain_id = String(object.chain_id);
          if (object.account_number != null)
            if ($util.Long) (message.account_number = $util.Long.fromValue(object.account_number)).unsigned = true;
            else if (typeof object.account_number === 'string') message.account_number = parseInt(object.account_number, 10);
            else if (typeof object.account_number === 'number') message.account_number = object.account_number;
            else if (typeof object.account_number === 'object')
              message.account_number = new $util.LongBits(object.account_number.low >>> 0, object.account_number.high >>> 0).toNumber(true);
          if (object.sequence != null)
            if ($util.Long) (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
            else if (typeof object.sequence === 'string') message.sequence = parseInt(object.sequence, 10);
            else if (typeof object.sequence === 'number') message.sequence = object.sequence;
            else if (typeof object.sequence === 'object')
              message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
          if (object.tip != null) {
            if (typeof object.tip !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignDocDirectAux.tip: object expected');
            message.tip = $root.cosmos.tx.v1beta1.Tip.fromObject(object.tip);
          }
          return message;
        };

        /**
         * Creates a plain object from a SignDocDirectAux message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @static
         * @param {cosmos.tx.v1beta1.SignDocDirectAux} message SignDocDirectAux
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignDocDirectAux.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            if (options.bytes === String) object.body_bytes = '';
            else {
              object.body_bytes = [];
              if (options.bytes !== Array) object.body_bytes = $util.newBuffer(object.body_bytes);
            }
            object.public_key = null;
            object.chain_id = '';
            if ($util.Long) {
              let long = new $util.Long(0, 0, true);
              object.account_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.account_number = options.longs === String ? '0' : 0;
            if ($util.Long) {
              let long = new $util.Long(0, 0, true);
              object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.sequence = options.longs === String ? '0' : 0;
            object.tip = null;
          }
          if (message.body_bytes != null && message.hasOwnProperty('body_bytes'))
            object.body_bytes =
              options.bytes === String
                ? $util.base64.encode(message.body_bytes, 0, message.body_bytes.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.body_bytes)
                : message.body_bytes;
          if (message.public_key != null && message.hasOwnProperty('public_key'))
            object.public_key = $root.google.protobuf.Any.toObject(message.public_key, options);
          if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
          if (message.account_number != null && message.hasOwnProperty('account_number'))
            if (typeof message.account_number === 'number')
              object.account_number = options.longs === String ? String(message.account_number) : message.account_number;
            else
              object.account_number =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.account_number)
                  : options.longs === Number
                  ? new $util.LongBits(message.account_number.low >>> 0, message.account_number.high >>> 0).toNumber(true)
                  : message.account_number;
          if (message.sequence != null && message.hasOwnProperty('sequence'))
            if (typeof message.sequence === 'number')
              object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
            else
              object.sequence =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.sequence)
                  : options.longs === Number
                  ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true)
                  : message.sequence;
          if (message.tip != null && message.hasOwnProperty('tip')) object.tip = $root.cosmos.tx.v1beta1.Tip.toObject(message.tip, options);
          return object;
        };

        /**
         * Converts this SignDocDirectAux to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.SignDocDirectAux
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignDocDirectAux.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignDocDirectAux;
      })();

      v1beta1.TxBody = (function () {
        /**
         * Properties of a TxBody.
         * @memberof cosmos.tx.v1beta1
         * @interface ITxBody
         * @property {Array.<google.protobuf.IAny>|null} [messages] TxBody messages
         * @property {string|null} [memo] TxBody memo
         * @property {Long|null} [timeout_height] TxBody timeout_height
         * @property {Array.<google.protobuf.IAny>|null} [extension_options] TxBody extension_options
         * @property {Array.<google.protobuf.IAny>|null} [non_critical_extension_options] TxBody non_critical_extension_options
         */

        /**
         * Constructs a new TxBody.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a TxBody.
         * @implements ITxBody
         * @constructor
         * @param {cosmos.tx.v1beta1.ITxBody=} [properties] Properties to set
         */
        function TxBody(properties) {
          this.messages = [];
          this.extension_options = [];
          this.non_critical_extension_options = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * TxBody messages.
         * @member {Array.<google.protobuf.IAny>} messages
         * @memberof cosmos.tx.v1beta1.TxBody
         * @instance
         */
        TxBody.prototype.messages = $util.emptyArray;

        /**
         * TxBody memo.
         * @member {string} memo
         * @memberof cosmos.tx.v1beta1.TxBody
         * @instance
         */
        TxBody.prototype.memo = '';

        /**
         * TxBody timeout_height.
         * @member {Long} timeout_height
         * @memberof cosmos.tx.v1beta1.TxBody
         * @instance
         */
        TxBody.prototype.timeout_height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * TxBody extension_options.
         * @member {Array.<google.protobuf.IAny>} extension_options
         * @memberof cosmos.tx.v1beta1.TxBody
         * @instance
         */
        TxBody.prototype.extension_options = $util.emptyArray;

        /**
         * TxBody non_critical_extension_options.
         * @member {Array.<google.protobuf.IAny>} non_critical_extension_options
         * @memberof cosmos.tx.v1beta1.TxBody
         * @instance
         */
        TxBody.prototype.non_critical_extension_options = $util.emptyArray;

        /**
         * Encodes the specified TxBody message. Does not implicitly {@link cosmos.tx.v1beta1.TxBody.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.TxBody
         * @static
         * @param {cosmos.tx.v1beta1.ITxBody} message TxBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxBody.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.messages != null && message.messages.length)
            for (let i = 0; i < message.messages.length; ++i)
              $root.google.protobuf.Any.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.memo != null && Object.hasOwnProperty.call(message, 'memo'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.memo);
          if (message.timeout_height != null && Object.hasOwnProperty.call(message, 'timeout_height'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.timeout_height);
          if (message.extension_options != null && message.extension_options.length)
            for (let i = 0; i < message.extension_options.length; ++i)
              $root.google.protobuf.Any.encode(
                message.extension_options[i],
                writer.uint32(/* id 1023, wireType 2 =*/ 8186).fork(),
              ).ldelim();
          if (message.non_critical_extension_options != null && message.non_critical_extension_options.length)
            for (let i = 0; i < message.non_critical_extension_options.length; ++i)
              $root.google.protobuf.Any.encode(
                message.non_critical_extension_options[i],
                writer.uint32(/* id 2047, wireType 2 =*/ 16378).fork(),
              ).ldelim();
          return writer;
        };

        /**
         * Encodes the specified TxBody message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.TxBody.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.TxBody
         * @static
         * @param {cosmos.tx.v1beta1.ITxBody} message TxBody message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TxBody.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TxBody message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.TxBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.TxBody} TxBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxBody.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.TxBody();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.messages && message.messages.length)) message.messages = [];
                message.messages.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                break;
              case 2:
                message.memo = reader.string();
                break;
              case 3:
                message.timeout_height = reader.uint64();
                break;
              case 1023:
                if (!(message.extension_options && message.extension_options.length)) message.extension_options = [];
                message.extension_options.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                break;
              case 2047:
                if (!(message.non_critical_extension_options && message.non_critical_extension_options.length))
                  message.non_critical_extension_options = [];
                message.non_critical_extension_options.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a TxBody message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.TxBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.TxBody} TxBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TxBody.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TxBody message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.TxBody
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TxBody.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.messages != null && message.hasOwnProperty('messages')) {
            if (!Array.isArray(message.messages)) return 'messages: array expected';
            for (let i = 0; i < message.messages.length; ++i) {
              let error = $root.google.protobuf.Any.verify(message.messages[i]);
              if (error) return 'messages.' + error;
            }
          }
          if (message.memo != null && message.hasOwnProperty('memo')) if (!$util.isString(message.memo)) return 'memo: string expected';
          if (message.timeout_height != null && message.hasOwnProperty('timeout_height'))
            if (
              !$util.isInteger(message.timeout_height) &&
              !(message.timeout_height && $util.isInteger(message.timeout_height.low) && $util.isInteger(message.timeout_height.high))
            )
              return 'timeout_height: integer|Long expected';
          if (message.extension_options != null && message.hasOwnProperty('extension_options')) {
            if (!Array.isArray(message.extension_options)) return 'extension_options: array expected';
            for (let i = 0; i < message.extension_options.length; ++i) {
              let error = $root.google.protobuf.Any.verify(message.extension_options[i]);
              if (error) return 'extension_options.' + error;
            }
          }
          if (message.non_critical_extension_options != null && message.hasOwnProperty('non_critical_extension_options')) {
            if (!Array.isArray(message.non_critical_extension_options)) return 'non_critical_extension_options: array expected';
            for (let i = 0; i < message.non_critical_extension_options.length; ++i) {
              let error = $root.google.protobuf.Any.verify(message.non_critical_extension_options[i]);
              if (error) return 'non_critical_extension_options.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a TxBody message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.TxBody
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.TxBody} TxBody
         */
        TxBody.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.TxBody) return object;
          let message = new $root.cosmos.tx.v1beta1.TxBody();
          if (object.messages) {
            if (!Array.isArray(object.messages)) throw TypeError('.cosmos.tx.v1beta1.TxBody.messages: array expected');
            message.messages = [];
            for (let i = 0; i < object.messages.length; ++i) {
              if (typeof object.messages[i] !== 'object') throw TypeError('.cosmos.tx.v1beta1.TxBody.messages: object expected');
              message.messages[i] = $root.google.protobuf.Any.fromObject(object.messages[i]);
            }
          }
          if (object.memo != null) message.memo = String(object.memo);
          if (object.timeout_height != null)
            if ($util.Long) (message.timeout_height = $util.Long.fromValue(object.timeout_height)).unsigned = true;
            else if (typeof object.timeout_height === 'string') message.timeout_height = parseInt(object.timeout_height, 10);
            else if (typeof object.timeout_height === 'number') message.timeout_height = object.timeout_height;
            else if (typeof object.timeout_height === 'object')
              message.timeout_height = new $util.LongBits(object.timeout_height.low >>> 0, object.timeout_height.high >>> 0).toNumber(true);
          if (object.extension_options) {
            if (!Array.isArray(object.extension_options)) throw TypeError('.cosmos.tx.v1beta1.TxBody.extension_options: array expected');
            message.extension_options = [];
            for (let i = 0; i < object.extension_options.length; ++i) {
              if (typeof object.extension_options[i] !== 'object')
                throw TypeError('.cosmos.tx.v1beta1.TxBody.extension_options: object expected');
              message.extension_options[i] = $root.google.protobuf.Any.fromObject(object.extension_options[i]);
            }
          }
          if (object.non_critical_extension_options) {
            if (!Array.isArray(object.non_critical_extension_options))
              throw TypeError('.cosmos.tx.v1beta1.TxBody.non_critical_extension_options: array expected');
            message.non_critical_extension_options = [];
            for (let i = 0; i < object.non_critical_extension_options.length; ++i) {
              if (typeof object.non_critical_extension_options[i] !== 'object')
                throw TypeError('.cosmos.tx.v1beta1.TxBody.non_critical_extension_options: object expected');
              message.non_critical_extension_options[i] = $root.google.protobuf.Any.fromObject(object.non_critical_extension_options[i]);
            }
          }
          return message;
        };

        /**
         * Creates a plain object from a TxBody message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.TxBody
         * @static
         * @param {cosmos.tx.v1beta1.TxBody} message TxBody
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TxBody.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) {
            object.messages = [];
            object.extension_options = [];
            object.non_critical_extension_options = [];
          }
          if (options.defaults) {
            object.memo = '';
            if ($util.Long) {
              let long = new $util.Long(0, 0, true);
              object.timeout_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.timeout_height = options.longs === String ? '0' : 0;
          }
          if (message.messages && message.messages.length) {
            object.messages = [];
            for (let j = 0; j < message.messages.length; ++j)
              object.messages[j] = $root.google.protobuf.Any.toObject(message.messages[j], options);
          }
          if (message.memo != null && message.hasOwnProperty('memo')) object.memo = message.memo;
          if (message.timeout_height != null && message.hasOwnProperty('timeout_height'))
            if (typeof message.timeout_height === 'number')
              object.timeout_height = options.longs === String ? String(message.timeout_height) : message.timeout_height;
            else
              object.timeout_height =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.timeout_height)
                  : options.longs === Number
                  ? new $util.LongBits(message.timeout_height.low >>> 0, message.timeout_height.high >>> 0).toNumber(true)
                  : message.timeout_height;
          if (message.extension_options && message.extension_options.length) {
            object.extension_options = [];
            for (let j = 0; j < message.extension_options.length; ++j)
              object.extension_options[j] = $root.google.protobuf.Any.toObject(message.extension_options[j], options);
          }
          if (message.non_critical_extension_options && message.non_critical_extension_options.length) {
            object.non_critical_extension_options = [];
            for (let j = 0; j < message.non_critical_extension_options.length; ++j)
              object.non_critical_extension_options[j] = $root.google.protobuf.Any.toObject(
                message.non_critical_extension_options[j],
                options,
              );
          }
          return object;
        };

        /**
         * Converts this TxBody to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.TxBody
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TxBody.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TxBody;
      })();

      v1beta1.AuthInfo = (function () {
        /**
         * Properties of an AuthInfo.
         * @memberof cosmos.tx.v1beta1
         * @interface IAuthInfo
         * @property {Array.<cosmos.tx.v1beta1.ISignerInfo>|null} [signer_infos] AuthInfo signer_infos
         * @property {cosmos.tx.v1beta1.IFee|null} [fee] AuthInfo fee
         * @property {cosmos.tx.v1beta1.ITip|null} [tip] AuthInfo tip
         */

        /**
         * Constructs a new AuthInfo.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents an AuthInfo.
         * @implements IAuthInfo
         * @constructor
         * @param {cosmos.tx.v1beta1.IAuthInfo=} [properties] Properties to set
         */
        function AuthInfo(properties) {
          this.signer_infos = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthInfo signer_infos.
         * @member {Array.<cosmos.tx.v1beta1.ISignerInfo>} signer_infos
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @instance
         */
        AuthInfo.prototype.signer_infos = $util.emptyArray;

        /**
         * AuthInfo fee.
         * @member {cosmos.tx.v1beta1.IFee|null|undefined} fee
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @instance
         */
        AuthInfo.prototype.fee = null;

        /**
         * AuthInfo tip.
         * @member {cosmos.tx.v1beta1.ITip|null|undefined} tip
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @instance
         */
        AuthInfo.prototype.tip = null;

        /**
         * Encodes the specified AuthInfo message. Does not implicitly {@link cosmos.tx.v1beta1.AuthInfo.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @static
         * @param {cosmos.tx.v1beta1.IAuthInfo} message AuthInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.signer_infos != null && message.signer_infos.length)
            for (let i = 0; i < message.signer_infos.length; ++i)
              $root.cosmos.tx.v1beta1.SignerInfo.encode(message.signer_infos[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
            $root.cosmos.tx.v1beta1.Fee.encode(message.fee, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.tip != null && Object.hasOwnProperty.call(message, 'tip'))
            $root.cosmos.tx.v1beta1.Tip.encode(message.tip, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified AuthInfo message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.AuthInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @static
         * @param {cosmos.tx.v1beta1.IAuthInfo} message AuthInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthInfo message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.AuthInfo} AuthInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.AuthInfo();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.signer_infos && message.signer_infos.length)) message.signer_infos = [];
                message.signer_infos.push($root.cosmos.tx.v1beta1.SignerInfo.decode(reader, reader.uint32()));
                break;
              case 2:
                message.fee = $root.cosmos.tx.v1beta1.Fee.decode(reader, reader.uint32());
                break;
              case 3:
                message.tip = $root.cosmos.tx.v1beta1.Tip.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an AuthInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.AuthInfo} AuthInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthInfo message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthInfo.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.signer_infos != null && message.hasOwnProperty('signer_infos')) {
            if (!Array.isArray(message.signer_infos)) return 'signer_infos: array expected';
            for (let i = 0; i < message.signer_infos.length; ++i) {
              let error = $root.cosmos.tx.v1beta1.SignerInfo.verify(message.signer_infos[i]);
              if (error) return 'signer_infos.' + error;
            }
          }
          if (message.fee != null && message.hasOwnProperty('fee')) {
            let error = $root.cosmos.tx.v1beta1.Fee.verify(message.fee);
            if (error) return 'fee.' + error;
          }
          if (message.tip != null && message.hasOwnProperty('tip')) {
            let error = $root.cosmos.tx.v1beta1.Tip.verify(message.tip);
            if (error) return 'tip.' + error;
          }
          return null;
        };

        /**
         * Creates an AuthInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.AuthInfo} AuthInfo
         */
        AuthInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.AuthInfo) return object;
          let message = new $root.cosmos.tx.v1beta1.AuthInfo();
          if (object.signer_infos) {
            if (!Array.isArray(object.signer_infos)) throw TypeError('.cosmos.tx.v1beta1.AuthInfo.signer_infos: array expected');
            message.signer_infos = [];
            for (let i = 0; i < object.signer_infos.length; ++i) {
              if (typeof object.signer_infos[i] !== 'object') throw TypeError('.cosmos.tx.v1beta1.AuthInfo.signer_infos: object expected');
              message.signer_infos[i] = $root.cosmos.tx.v1beta1.SignerInfo.fromObject(object.signer_infos[i]);
            }
          }
          if (object.fee != null) {
            if (typeof object.fee !== 'object') throw TypeError('.cosmos.tx.v1beta1.AuthInfo.fee: object expected');
            message.fee = $root.cosmos.tx.v1beta1.Fee.fromObject(object.fee);
          }
          if (object.tip != null) {
            if (typeof object.tip !== 'object') throw TypeError('.cosmos.tx.v1beta1.AuthInfo.tip: object expected');
            message.tip = $root.cosmos.tx.v1beta1.Tip.fromObject(object.tip);
          }
          return message;
        };

        /**
         * Creates a plain object from an AuthInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @static
         * @param {cosmos.tx.v1beta1.AuthInfo} message AuthInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) object.signer_infos = [];
          if (options.defaults) {
            object.fee = null;
            object.tip = null;
          }
          if (message.signer_infos && message.signer_infos.length) {
            object.signer_infos = [];
            for (let j = 0; j < message.signer_infos.length; ++j)
              object.signer_infos[j] = $root.cosmos.tx.v1beta1.SignerInfo.toObject(message.signer_infos[j], options);
          }
          if (message.fee != null && message.hasOwnProperty('fee')) object.fee = $root.cosmos.tx.v1beta1.Fee.toObject(message.fee, options);
          if (message.tip != null && message.hasOwnProperty('tip')) object.tip = $root.cosmos.tx.v1beta1.Tip.toObject(message.tip, options);
          return object;
        };

        /**
         * Converts this AuthInfo to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.AuthInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthInfo;
      })();

      v1beta1.SignerInfo = (function () {
        /**
         * Properties of a SignerInfo.
         * @memberof cosmos.tx.v1beta1
         * @interface ISignerInfo
         * @property {google.protobuf.IAny|null} [public_key] SignerInfo public_key
         * @property {cosmos.tx.v1beta1.IModeInfo|null} [mode_info] SignerInfo mode_info
         * @property {Long|null} [sequence] SignerInfo sequence
         */

        /**
         * Constructs a new SignerInfo.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a SignerInfo.
         * @implements ISignerInfo
         * @constructor
         * @param {cosmos.tx.v1beta1.ISignerInfo=} [properties] Properties to set
         */
        function SignerInfo(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignerInfo public_key.
         * @member {google.protobuf.IAny|null|undefined} public_key
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @instance
         */
        SignerInfo.prototype.public_key = null;

        /**
         * SignerInfo mode_info.
         * @member {cosmos.tx.v1beta1.IModeInfo|null|undefined} mode_info
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @instance
         */
        SignerInfo.prototype.mode_info = null;

        /**
         * SignerInfo sequence.
         * @member {Long} sequence
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @instance
         */
        SignerInfo.prototype.sequence = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Encodes the specified SignerInfo message. Does not implicitly {@link cosmos.tx.v1beta1.SignerInfo.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @static
         * @param {cosmos.tx.v1beta1.ISignerInfo} message SignerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignerInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.public_key != null && Object.hasOwnProperty.call(message, 'public_key'))
            $root.google.protobuf.Any.encode(message.public_key, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.mode_info != null && Object.hasOwnProperty.call(message, 'mode_info'))
            $root.cosmos.tx.v1beta1.ModeInfo.encode(message.mode_info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.sequence != null && Object.hasOwnProperty.call(message, 'sequence'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.sequence);
          return writer;
        };

        /**
         * Encodes the specified SignerInfo message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.SignerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @static
         * @param {cosmos.tx.v1beta1.ISignerInfo} message SignerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignerInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.SignerInfo} SignerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignerInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.SignerInfo();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.public_key = $root.google.protobuf.Any.decode(reader, reader.uint32());
                break;
              case 2:
                message.mode_info = $root.cosmos.tx.v1beta1.ModeInfo.decode(reader, reader.uint32());
                break;
              case 3:
                message.sequence = reader.uint64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a SignerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.SignerInfo} SignerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignerInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignerInfo message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignerInfo.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.public_key != null && message.hasOwnProperty('public_key')) {
            let error = $root.google.protobuf.Any.verify(message.public_key);
            if (error) return 'public_key.' + error;
          }
          if (message.mode_info != null && message.hasOwnProperty('mode_info')) {
            let error = $root.cosmos.tx.v1beta1.ModeInfo.verify(message.mode_info);
            if (error) return 'mode_info.' + error;
          }
          if (message.sequence != null && message.hasOwnProperty('sequence'))
            if (
              !$util.isInteger(message.sequence) &&
              !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high))
            )
              return 'sequence: integer|Long expected';
          return null;
        };

        /**
         * Creates a SignerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.SignerInfo} SignerInfo
         */
        SignerInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.SignerInfo) return object;
          let message = new $root.cosmos.tx.v1beta1.SignerInfo();
          if (object.public_key != null) {
            if (typeof object.public_key !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignerInfo.public_key: object expected');
            message.public_key = $root.google.protobuf.Any.fromObject(object.public_key);
          }
          if (object.mode_info != null) {
            if (typeof object.mode_info !== 'object') throw TypeError('.cosmos.tx.v1beta1.SignerInfo.mode_info: object expected');
            message.mode_info = $root.cosmos.tx.v1beta1.ModeInfo.fromObject(object.mode_info);
          }
          if (object.sequence != null)
            if ($util.Long) (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
            else if (typeof object.sequence === 'string') message.sequence = parseInt(object.sequence, 10);
            else if (typeof object.sequence === 'number') message.sequence = object.sequence;
            else if (typeof object.sequence === 'object')
              message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
          return message;
        };

        /**
         * Creates a plain object from a SignerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @static
         * @param {cosmos.tx.v1beta1.SignerInfo} message SignerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignerInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.public_key = null;
            object.mode_info = null;
            if ($util.Long) {
              let long = new $util.Long(0, 0, true);
              object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.sequence = options.longs === String ? '0' : 0;
          }
          if (message.public_key != null && message.hasOwnProperty('public_key'))
            object.public_key = $root.google.protobuf.Any.toObject(message.public_key, options);
          if (message.mode_info != null && message.hasOwnProperty('mode_info'))
            object.mode_info = $root.cosmos.tx.v1beta1.ModeInfo.toObject(message.mode_info, options);
          if (message.sequence != null && message.hasOwnProperty('sequence'))
            if (typeof message.sequence === 'number')
              object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
            else
              object.sequence =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.sequence)
                  : options.longs === Number
                  ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true)
                  : message.sequence;
          return object;
        };

        /**
         * Converts this SignerInfo to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.SignerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignerInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignerInfo;
      })();

      v1beta1.ModeInfo = (function () {
        /**
         * Properties of a ModeInfo.
         * @memberof cosmos.tx.v1beta1
         * @interface IModeInfo
         * @property {cosmos.tx.v1beta1.ModeInfo.ISingle|null} [single] ModeInfo single
         * @property {cosmos.tx.v1beta1.ModeInfo.IMulti|null} [multi] ModeInfo multi
         */

        /**
         * Constructs a new ModeInfo.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a ModeInfo.
         * @implements IModeInfo
         * @constructor
         * @param {cosmos.tx.v1beta1.IModeInfo=} [properties] Properties to set
         */
        function ModeInfo(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModeInfo single.
         * @member {cosmos.tx.v1beta1.ModeInfo.ISingle|null|undefined} single
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @instance
         */
        ModeInfo.prototype.single = null;

        /**
         * ModeInfo multi.
         * @member {cosmos.tx.v1beta1.ModeInfo.IMulti|null|undefined} multi
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @instance
         */
        ModeInfo.prototype.multi = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ModeInfo sum.
         * @member {"single"|"multi"|undefined} sum
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @instance
         */
        Object.defineProperty(ModeInfo.prototype, 'sum', {
          get: $util.oneOfGetter(($oneOfFields = ['single', 'multi'])),
          set: $util.oneOfSetter($oneOfFields),
        });

        /**
         * Encodes the specified ModeInfo message. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @static
         * @param {cosmos.tx.v1beta1.IModeInfo} message ModeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModeInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.single != null && Object.hasOwnProperty.call(message, 'single'))
            $root.cosmos.tx.v1beta1.ModeInfo.Single.encode(message.single, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.multi != null && Object.hasOwnProperty.call(message, 'multi'))
            $root.cosmos.tx.v1beta1.ModeInfo.Multi.encode(message.multi, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          return writer;
        };

        /**
         * Encodes the specified ModeInfo message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @static
         * @param {cosmos.tx.v1beta1.IModeInfo} message ModeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModeInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.ModeInfo} ModeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModeInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.ModeInfo();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.single = $root.cosmos.tx.v1beta1.ModeInfo.Single.decode(reader, reader.uint32());
                break;
              case 2:
                message.multi = $root.cosmos.tx.v1beta1.ModeInfo.Multi.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ModeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.ModeInfo} ModeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModeInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModeInfo message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModeInfo.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          let properties = {};
          if (message.single != null && message.hasOwnProperty('single')) {
            properties.sum = 1;
            {
              let error = $root.cosmos.tx.v1beta1.ModeInfo.Single.verify(message.single);
              if (error) return 'single.' + error;
            }
          }
          if (message.multi != null && message.hasOwnProperty('multi')) {
            if (properties.sum === 1) return 'sum: multiple values';
            properties.sum = 1;
            {
              let error = $root.cosmos.tx.v1beta1.ModeInfo.Multi.verify(message.multi);
              if (error) return 'multi.' + error;
            }
          }
          return null;
        };

        /**
         * Creates a ModeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.ModeInfo} ModeInfo
         */
        ModeInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.ModeInfo) return object;
          let message = new $root.cosmos.tx.v1beta1.ModeInfo();
          if (object.single != null) {
            if (typeof object.single !== 'object') throw TypeError('.cosmos.tx.v1beta1.ModeInfo.single: object expected');
            message.single = $root.cosmos.tx.v1beta1.ModeInfo.Single.fromObject(object.single);
          }
          if (object.multi != null) {
            if (typeof object.multi !== 'object') throw TypeError('.cosmos.tx.v1beta1.ModeInfo.multi: object expected');
            message.multi = $root.cosmos.tx.v1beta1.ModeInfo.Multi.fromObject(object.multi);
          }
          return message;
        };

        /**
         * Creates a plain object from a ModeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @static
         * @param {cosmos.tx.v1beta1.ModeInfo} message ModeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModeInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (message.single != null && message.hasOwnProperty('single')) {
            object.single = $root.cosmos.tx.v1beta1.ModeInfo.Single.toObject(message.single, options);
            if (options.oneofs) object.sum = 'single';
          }
          if (message.multi != null && message.hasOwnProperty('multi')) {
            object.multi = $root.cosmos.tx.v1beta1.ModeInfo.Multi.toObject(message.multi, options);
            if (options.oneofs) object.sum = 'multi';
          }
          return object;
        };

        /**
         * Converts this ModeInfo to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.ModeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModeInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ModeInfo.Single = (function () {
          /**
           * Properties of a Single.
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @interface ISingle
           * @property {cosmos.tx.signing.v1beta1.SignMode|null} [mode] Single mode
           */

          /**
           * Constructs a new Single.
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @classdesc Represents a Single.
           * @implements ISingle
           * @constructor
           * @param {cosmos.tx.v1beta1.ModeInfo.ISingle=} [properties] Properties to set
           */
          function Single(properties) {
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Single mode.
           * @member {cosmos.tx.signing.v1beta1.SignMode} mode
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @instance
           */
          Single.prototype.mode = 0;

          /**
           * Encodes the specified Single message. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Single.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @static
           * @param {cosmos.tx.v1beta1.ModeInfo.ISingle} message Single message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Single.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.mode != null && Object.hasOwnProperty.call(message, 'mode'))
              writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.mode);
            return writer;
          };

          /**
           * Encodes the specified Single message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Single.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @static
           * @param {cosmos.tx.v1beta1.ModeInfo.ISingle} message Single message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Single.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Single message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.ModeInfo.Single} Single
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Single.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.ModeInfo.Single();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.mode = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Single message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.ModeInfo.Single} Single
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Single.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Single message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Single.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.mode != null && message.hasOwnProperty('mode'))
              switch (message.mode) {
                default:
                  return 'mode: enum value expected';
                case 0:
                case 1:
                case 2:
                case 3:
                case 127:
                case 191:
                  break;
              }
            return null;
          };

          /**
           * Creates a Single message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.ModeInfo.Single} Single
           */
          Single.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.ModeInfo.Single) return object;
            let message = new $root.cosmos.tx.v1beta1.ModeInfo.Single();
            switch (object.mode) {
              case 'SIGN_MODE_UNSPECIFIED':
              case 0:
                message.mode = 0;
                break;
              case 'SIGN_MODE_DIRECT':
              case 1:
                message.mode = 1;
                break;
              case 'SIGN_MODE_TEXTUAL':
              case 2:
                message.mode = 2;
                break;
              case 'SIGN_MODE_DIRECT_AUX':
              case 3:
                message.mode = 3;
                break;
              case 'SIGN_MODE_LEGACY_AMINO_JSON':
              case 127:
                message.mode = 127;
                break;
              case 'SIGN_MODE_EIP_191':
              case 191:
                message.mode = 191;
                break;
            }
            return message;
          };

          /**
           * Creates a plain object from a Single message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @static
           * @param {cosmos.tx.v1beta1.ModeInfo.Single} message Single
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Single.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) object.mode = options.enums === String ? 'SIGN_MODE_UNSPECIFIED' : 0;
            if (message.mode != null && message.hasOwnProperty('mode'))
              object.mode = options.enums === String ? $root.cosmos.tx.signing.v1beta1.SignMode[message.mode] : message.mode;
            return object;
          };

          /**
           * Converts this Single to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.ModeInfo.Single
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Single.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Single;
        })();

        ModeInfo.Multi = (function () {
          /**
           * Properties of a Multi.
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @interface IMulti
           * @property {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null} [bitarray] Multi bitarray
           * @property {Array.<cosmos.tx.v1beta1.IModeInfo>|null} [mode_infos] Multi mode_infos
           */

          /**
           * Constructs a new Multi.
           * @memberof cosmos.tx.v1beta1.ModeInfo
           * @classdesc Represents a Multi.
           * @implements IMulti
           * @constructor
           * @param {cosmos.tx.v1beta1.ModeInfo.IMulti=} [properties] Properties to set
           */
          function Multi(properties) {
            this.mode_infos = [];
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * Multi bitarray.
           * @member {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null|undefined} bitarray
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @instance
           */
          Multi.prototype.bitarray = null;

          /**
           * Multi mode_infos.
           * @member {Array.<cosmos.tx.v1beta1.IModeInfo>} mode_infos
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @instance
           */
          Multi.prototype.mode_infos = $util.emptyArray;

          /**
           * Encodes the specified Multi message. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Multi.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @static
           * @param {cosmos.tx.v1beta1.ModeInfo.IMulti} message Multi message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Multi.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.bitarray != null && Object.hasOwnProperty.call(message, 'bitarray'))
              $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.encode(
                message.bitarray,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (message.mode_infos != null && message.mode_infos.length)
              for (let i = 0; i < message.mode_infos.length; ++i)
                $root.cosmos.tx.v1beta1.ModeInfo.encode(message.mode_infos[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Multi message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.ModeInfo.Multi.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @static
           * @param {cosmos.tx.v1beta1.ModeInfo.IMulti} message Multi message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Multi.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Multi message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.v1beta1.ModeInfo.Multi} Multi
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Multi.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.v1beta1.ModeInfo.Multi();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.mode_infos && message.mode_infos.length)) message.mode_infos = [];
                  message.mode_infos.push($root.cosmos.tx.v1beta1.ModeInfo.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Multi message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.v1beta1.ModeInfo.Multi} Multi
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Multi.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Multi message.
           * @function verify
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Multi.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.bitarray != null && message.hasOwnProperty('bitarray')) {
              let error = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.verify(message.bitarray);
              if (error) return 'bitarray.' + error;
            }
            if (message.mode_infos != null && message.hasOwnProperty('mode_infos')) {
              if (!Array.isArray(message.mode_infos)) return 'mode_infos: array expected';
              for (let i = 0; i < message.mode_infos.length; ++i) {
                let error = $root.cosmos.tx.v1beta1.ModeInfo.verify(message.mode_infos[i]);
                if (error) return 'mode_infos.' + error;
              }
            }
            return null;
          };

          /**
           * Creates a Multi message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.v1beta1.ModeInfo.Multi} Multi
           */
          Multi.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.v1beta1.ModeInfo.Multi) return object;
            let message = new $root.cosmos.tx.v1beta1.ModeInfo.Multi();
            if (object.bitarray != null) {
              if (typeof object.bitarray !== 'object') throw TypeError('.cosmos.tx.v1beta1.ModeInfo.Multi.bitarray: object expected');
              message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.fromObject(object.bitarray);
            }
            if (object.mode_infos) {
              if (!Array.isArray(object.mode_infos)) throw TypeError('.cosmos.tx.v1beta1.ModeInfo.Multi.mode_infos: array expected');
              message.mode_infos = [];
              for (let i = 0; i < object.mode_infos.length; ++i) {
                if (typeof object.mode_infos[i] !== 'object')
                  throw TypeError('.cosmos.tx.v1beta1.ModeInfo.Multi.mode_infos: object expected');
                message.mode_infos[i] = $root.cosmos.tx.v1beta1.ModeInfo.fromObject(object.mode_infos[i]);
              }
            }
            return message;
          };

          /**
           * Creates a plain object from a Multi message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @static
           * @param {cosmos.tx.v1beta1.ModeInfo.Multi} message Multi
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Multi.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) object.mode_infos = [];
            if (options.defaults) object.bitarray = null;
            if (message.bitarray != null && message.hasOwnProperty('bitarray'))
              object.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.toObject(message.bitarray, options);
            if (message.mode_infos && message.mode_infos.length) {
              object.mode_infos = [];
              for (let j = 0; j < message.mode_infos.length; ++j)
                object.mode_infos[j] = $root.cosmos.tx.v1beta1.ModeInfo.toObject(message.mode_infos[j], options);
            }
            return object;
          };

          /**
           * Converts this Multi to JSON.
           * @function toJSON
           * @memberof cosmos.tx.v1beta1.ModeInfo.Multi
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Multi.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return Multi;
        })();

        return ModeInfo;
      })();

      v1beta1.Fee = (function () {
        /**
         * Properties of a Fee.
         * @memberof cosmos.tx.v1beta1
         * @interface IFee
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [amount] Fee amount
         * @property {Long|null} [gas_limit] Fee gas_limit
         * @property {string|null} [payer] Fee payer
         * @property {string|null} [granter] Fee granter
         */

        /**
         * Constructs a new Fee.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a Fee.
         * @implements IFee
         * @constructor
         * @param {cosmos.tx.v1beta1.IFee=} [properties] Properties to set
         */
        function Fee(properties) {
          this.amount = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fee amount.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} amount
         * @memberof cosmos.tx.v1beta1.Fee
         * @instance
         */
        Fee.prototype.amount = $util.emptyArray;

        /**
         * Fee gas_limit.
         * @member {Long} gas_limit
         * @memberof cosmos.tx.v1beta1.Fee
         * @instance
         */
        Fee.prototype.gas_limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

        /**
         * Fee payer.
         * @member {string} payer
         * @memberof cosmos.tx.v1beta1.Fee
         * @instance
         */
        Fee.prototype.payer = '';

        /**
         * Fee granter.
         * @member {string} granter
         * @memberof cosmos.tx.v1beta1.Fee
         * @instance
         */
        Fee.prototype.granter = '';

        /**
         * Encodes the specified Fee message. Does not implicitly {@link cosmos.tx.v1beta1.Fee.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.Fee
         * @static
         * @param {cosmos.tx.v1beta1.IFee} message Fee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fee.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.amount != null && message.amount.length)
            for (let i = 0; i < message.amount.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.amount[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.gas_limit != null && Object.hasOwnProperty.call(message, 'gas_limit'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.gas_limit);
          if (message.payer != null && Object.hasOwnProperty.call(message, 'payer'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.payer);
          if (message.granter != null && Object.hasOwnProperty.call(message, 'granter'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.granter);
          return writer;
        };

        /**
         * Encodes the specified Fee message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.Fee.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.Fee
         * @static
         * @param {cosmos.tx.v1beta1.IFee} message Fee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fee.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fee message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.Fee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.Fee} Fee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fee.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.Fee();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.amount && message.amount.length)) message.amount = [];
                message.amount.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              case 2:
                message.gas_limit = reader.uint64();
                break;
              case 3:
                message.payer = reader.string();
                break;
              case 4:
                message.granter = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Fee message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.Fee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.Fee} Fee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fee.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fee message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.Fee
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fee.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.amount != null && message.hasOwnProperty('amount')) {
            if (!Array.isArray(message.amount)) return 'amount: array expected';
            for (let i = 0; i < message.amount.length; ++i) {
              let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount[i]);
              if (error) return 'amount.' + error;
            }
          }
          if (message.gas_limit != null && message.hasOwnProperty('gas_limit'))
            if (
              !$util.isInteger(message.gas_limit) &&
              !(message.gas_limit && $util.isInteger(message.gas_limit.low) && $util.isInteger(message.gas_limit.high))
            )
              return 'gas_limit: integer|Long expected';
          if (message.payer != null && message.hasOwnProperty('payer')) if (!$util.isString(message.payer)) return 'payer: string expected';
          if (message.granter != null && message.hasOwnProperty('granter'))
            if (!$util.isString(message.granter)) return 'granter: string expected';
          return null;
        };

        /**
         * Creates a Fee message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.Fee
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.Fee} Fee
         */
        Fee.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.Fee) return object;
          let message = new $root.cosmos.tx.v1beta1.Fee();
          if (object.amount) {
            if (!Array.isArray(object.amount)) throw TypeError('.cosmos.tx.v1beta1.Fee.amount: array expected');
            message.amount = [];
            for (let i = 0; i < object.amount.length; ++i) {
              if (typeof object.amount[i] !== 'object') throw TypeError('.cosmos.tx.v1beta1.Fee.amount: object expected');
              message.amount[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount[i]);
            }
          }
          if (object.gas_limit != null)
            if ($util.Long) (message.gas_limit = $util.Long.fromValue(object.gas_limit)).unsigned = true;
            else if (typeof object.gas_limit === 'string') message.gas_limit = parseInt(object.gas_limit, 10);
            else if (typeof object.gas_limit === 'number') message.gas_limit = object.gas_limit;
            else if (typeof object.gas_limit === 'object')
              message.gas_limit = new $util.LongBits(object.gas_limit.low >>> 0, object.gas_limit.high >>> 0).toNumber(true);
          if (object.payer != null) message.payer = String(object.payer);
          if (object.granter != null) message.granter = String(object.granter);
          return message;
        };

        /**
         * Creates a plain object from a Fee message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.Fee
         * @static
         * @param {cosmos.tx.v1beta1.Fee} message Fee
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fee.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) object.amount = [];
          if (options.defaults) {
            if ($util.Long) {
              let long = new $util.Long(0, 0, true);
              object.gas_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else object.gas_limit = options.longs === String ? '0' : 0;
            object.payer = '';
            object.granter = '';
          }
          if (message.amount && message.amount.length) {
            object.amount = [];
            for (let j = 0; j < message.amount.length; ++j)
              object.amount[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.amount[j], options);
          }
          if (message.gas_limit != null && message.hasOwnProperty('gas_limit'))
            if (typeof message.gas_limit === 'number')
              object.gas_limit = options.longs === String ? String(message.gas_limit) : message.gas_limit;
            else
              object.gas_limit =
                options.longs === String
                  ? $util.Long.prototype.toString.call(message.gas_limit)
                  : options.longs === Number
                  ? new $util.LongBits(message.gas_limit.low >>> 0, message.gas_limit.high >>> 0).toNumber(true)
                  : message.gas_limit;
          if (message.payer != null && message.hasOwnProperty('payer')) object.payer = message.payer;
          if (message.granter != null && message.hasOwnProperty('granter')) object.granter = message.granter;
          return object;
        };

        /**
         * Converts this Fee to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.Fee
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fee.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fee;
      })();

      v1beta1.Tip = (function () {
        /**
         * Properties of a Tip.
         * @memberof cosmos.tx.v1beta1
         * @interface ITip
         * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [amount] Tip amount
         * @property {string|null} [tipper] Tip tipper
         */

        /**
         * Constructs a new Tip.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents a Tip.
         * @implements ITip
         * @constructor
         * @param {cosmos.tx.v1beta1.ITip=} [properties] Properties to set
         */
        function Tip(properties) {
          this.amount = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tip amount.
         * @member {Array.<cosmos.base.v1beta1.ICoin>} amount
         * @memberof cosmos.tx.v1beta1.Tip
         * @instance
         */
        Tip.prototype.amount = $util.emptyArray;

        /**
         * Tip tipper.
         * @member {string} tipper
         * @memberof cosmos.tx.v1beta1.Tip
         * @instance
         */
        Tip.prototype.tipper = '';

        /**
         * Encodes the specified Tip message. Does not implicitly {@link cosmos.tx.v1beta1.Tip.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.Tip
         * @static
         * @param {cosmos.tx.v1beta1.ITip} message Tip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tip.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.amount != null && message.amount.length)
            for (let i = 0; i < message.amount.length; ++i)
              $root.cosmos.base.v1beta1.Coin.encode(message.amount[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
          if (message.tipper != null && Object.hasOwnProperty.call(message, 'tipper'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.tipper);
          return writer;
        };

        /**
         * Encodes the specified Tip message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.Tip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.Tip
         * @static
         * @param {cosmos.tx.v1beta1.ITip} message Tip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tip.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tip message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.Tip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.Tip} Tip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tip.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.Tip();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.amount && message.amount.length)) message.amount = [];
                message.amount.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
                break;
              case 2:
                message.tipper = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Tip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.Tip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.Tip} Tip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tip.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tip message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.Tip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tip.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.amount != null && message.hasOwnProperty('amount')) {
            if (!Array.isArray(message.amount)) return 'amount: array expected';
            for (let i = 0; i < message.amount.length; ++i) {
              let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount[i]);
              if (error) return 'amount.' + error;
            }
          }
          if (message.tipper != null && message.hasOwnProperty('tipper'))
            if (!$util.isString(message.tipper)) return 'tipper: string expected';
          return null;
        };

        /**
         * Creates a Tip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.Tip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.Tip} Tip
         */
        Tip.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.Tip) return object;
          let message = new $root.cosmos.tx.v1beta1.Tip();
          if (object.amount) {
            if (!Array.isArray(object.amount)) throw TypeError('.cosmos.tx.v1beta1.Tip.amount: array expected');
            message.amount = [];
            for (let i = 0; i < object.amount.length; ++i) {
              if (typeof object.amount[i] !== 'object') throw TypeError('.cosmos.tx.v1beta1.Tip.amount: object expected');
              message.amount[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount[i]);
            }
          }
          if (object.tipper != null) message.tipper = String(object.tipper);
          return message;
        };

        /**
         * Creates a plain object from a Tip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.Tip
         * @static
         * @param {cosmos.tx.v1beta1.Tip} message Tip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tip.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) object.amount = [];
          if (options.defaults) object.tipper = '';
          if (message.amount && message.amount.length) {
            object.amount = [];
            for (let j = 0; j < message.amount.length; ++j)
              object.amount[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.amount[j], options);
          }
          if (message.tipper != null && message.hasOwnProperty('tipper')) object.tipper = message.tipper;
          return object;
        };

        /**
         * Converts this Tip to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.Tip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tip.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tip;
      })();

      v1beta1.AuxSignerData = (function () {
        /**
         * Properties of an AuxSignerData.
         * @memberof cosmos.tx.v1beta1
         * @interface IAuxSignerData
         * @property {string|null} [address] AuxSignerData address
         * @property {cosmos.tx.v1beta1.ISignDocDirectAux|null} [sign_doc] AuxSignerData sign_doc
         * @property {cosmos.tx.signing.v1beta1.SignMode|null} [mode] AuxSignerData mode
         * @property {Uint8Array|null} [sig] AuxSignerData sig
         */

        /**
         * Constructs a new AuxSignerData.
         * @memberof cosmos.tx.v1beta1
         * @classdesc Represents an AuxSignerData.
         * @implements IAuxSignerData
         * @constructor
         * @param {cosmos.tx.v1beta1.IAuxSignerData=} [properties] Properties to set
         */
        function AuxSignerData(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuxSignerData address.
         * @member {string} address
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @instance
         */
        AuxSignerData.prototype.address = '';

        /**
         * AuxSignerData sign_doc.
         * @member {cosmos.tx.v1beta1.ISignDocDirectAux|null|undefined} sign_doc
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @instance
         */
        AuxSignerData.prototype.sign_doc = null;

        /**
         * AuxSignerData mode.
         * @member {cosmos.tx.signing.v1beta1.SignMode} mode
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @instance
         */
        AuxSignerData.prototype.mode = 0;

        /**
         * AuxSignerData sig.
         * @member {Uint8Array} sig
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @instance
         */
        AuxSignerData.prototype.sig = $util.newBuffer([]);

        /**
         * Encodes the specified AuxSignerData message. Does not implicitly {@link cosmos.tx.v1beta1.AuxSignerData.verify|verify} messages.
         * @function encode
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @static
         * @param {cosmos.tx.v1beta1.IAuxSignerData} message AuxSignerData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuxSignerData.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
          if (message.sign_doc != null && Object.hasOwnProperty.call(message, 'sign_doc'))
            $root.cosmos.tx.v1beta1.SignDocDirectAux.encode(message.sign_doc, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
          if (message.mode != null && Object.hasOwnProperty.call(message, 'mode'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.mode);
          if (message.sig != null && Object.hasOwnProperty.call(message, 'sig'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.sig);
          return writer;
        };

        /**
         * Encodes the specified AuxSignerData message, length delimited. Does not implicitly {@link cosmos.tx.v1beta1.AuxSignerData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @static
         * @param {cosmos.tx.v1beta1.IAuxSignerData} message AuxSignerData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuxSignerData.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuxSignerData message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.tx.v1beta1.AuxSignerData} AuxSignerData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuxSignerData.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.tx.v1beta1.AuxSignerData();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.address = reader.string();
                break;
              case 2:
                message.sign_doc = $root.cosmos.tx.v1beta1.SignDocDirectAux.decode(reader, reader.uint32());
                break;
              case 3:
                message.mode = reader.int32();
                break;
              case 4:
                message.sig = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an AuxSignerData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.tx.v1beta1.AuxSignerData} AuxSignerData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuxSignerData.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuxSignerData message.
         * @function verify
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuxSignerData.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.address != null && message.hasOwnProperty('address'))
            if (!$util.isString(message.address)) return 'address: string expected';
          if (message.sign_doc != null && message.hasOwnProperty('sign_doc')) {
            let error = $root.cosmos.tx.v1beta1.SignDocDirectAux.verify(message.sign_doc);
            if (error) return 'sign_doc.' + error;
          }
          if (message.mode != null && message.hasOwnProperty('mode'))
            switch (message.mode) {
              default:
                return 'mode: enum value expected';
              case 0:
              case 1:
              case 2:
              case 3:
              case 127:
              case 191:
                break;
            }
          if (message.sig != null && message.hasOwnProperty('sig'))
            if (!((message.sig && typeof message.sig.length === 'number') || $util.isString(message.sig))) return 'sig: buffer expected';
          return null;
        };

        /**
         * Creates an AuxSignerData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.tx.v1beta1.AuxSignerData} AuxSignerData
         */
        AuxSignerData.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.tx.v1beta1.AuxSignerData) return object;
          let message = new $root.cosmos.tx.v1beta1.AuxSignerData();
          if (object.address != null) message.address = String(object.address);
          if (object.sign_doc != null) {
            if (typeof object.sign_doc !== 'object') throw TypeError('.cosmos.tx.v1beta1.AuxSignerData.sign_doc: object expected');
            message.sign_doc = $root.cosmos.tx.v1beta1.SignDocDirectAux.fromObject(object.sign_doc);
          }
          switch (object.mode) {
            case 'SIGN_MODE_UNSPECIFIED':
            case 0:
              message.mode = 0;
              break;
            case 'SIGN_MODE_DIRECT':
            case 1:
              message.mode = 1;
              break;
            case 'SIGN_MODE_TEXTUAL':
            case 2:
              message.mode = 2;
              break;
            case 'SIGN_MODE_DIRECT_AUX':
            case 3:
              message.mode = 3;
              break;
            case 'SIGN_MODE_LEGACY_AMINO_JSON':
            case 127:
              message.mode = 127;
              break;
            case 'SIGN_MODE_EIP_191':
            case 191:
              message.mode = 191;
              break;
          }
          if (object.sig != null)
            if (typeof object.sig === 'string')
              $util.base64.decode(object.sig, (message.sig = $util.newBuffer($util.base64.length(object.sig))), 0);
            else if (object.sig.length) message.sig = object.sig;
          return message;
        };

        /**
         * Creates a plain object from an AuxSignerData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @static
         * @param {cosmos.tx.v1beta1.AuxSignerData} message AuxSignerData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuxSignerData.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.address = '';
            object.sign_doc = null;
            object.mode = options.enums === String ? 'SIGN_MODE_UNSPECIFIED' : 0;
            if (options.bytes === String) object.sig = '';
            else {
              object.sig = [];
              if (options.bytes !== Array) object.sig = $util.newBuffer(object.sig);
            }
          }
          if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
          if (message.sign_doc != null && message.hasOwnProperty('sign_doc'))
            object.sign_doc = $root.cosmos.tx.v1beta1.SignDocDirectAux.toObject(message.sign_doc, options);
          if (message.mode != null && message.hasOwnProperty('mode'))
            object.mode = options.enums === String ? $root.cosmos.tx.signing.v1beta1.SignMode[message.mode] : message.mode;
          if (message.sig != null && message.hasOwnProperty('sig'))
            object.sig =
              options.bytes === String
                ? $util.base64.encode(message.sig, 0, message.sig.length)
                : options.bytes === Array
                ? Array.prototype.slice.call(message.sig)
                : message.sig;
          return object;
        };

        /**
         * Converts this AuxSignerData to JSON.
         * @function toJSON
         * @memberof cosmos.tx.v1beta1.AuxSignerData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuxSignerData.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuxSignerData;
      })();

      return v1beta1;
    })();

    tx.signing = (function () {
      /**
       * Namespace signing.
       * @memberof cosmos.tx
       * @namespace
       */
      const signing = {};

      signing.v1beta1 = (function () {
        /**
         * Namespace v1beta1.
         * @memberof cosmos.tx.signing
         * @namespace
         */
        const v1beta1 = {};

        /**
         * SignMode enum.
         * @name cosmos.tx.signing.v1beta1.SignMode
         * @enum {number}
         * @property {number} SIGN_MODE_UNSPECIFIED=0 SIGN_MODE_UNSPECIFIED value
         * @property {number} SIGN_MODE_DIRECT=1 SIGN_MODE_DIRECT value
         * @property {number} SIGN_MODE_TEXTUAL=2 SIGN_MODE_TEXTUAL value
         * @property {number} SIGN_MODE_DIRECT_AUX=3 SIGN_MODE_DIRECT_AUX value
         * @property {number} SIGN_MODE_LEGACY_AMINO_JSON=127 SIGN_MODE_LEGACY_AMINO_JSON value
         * @property {number} SIGN_MODE_EIP_191=191 SIGN_MODE_EIP_191 value
         */
        v1beta1.SignMode = (function () {
          const valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = 'SIGN_MODE_UNSPECIFIED')] = 0;
          values[(valuesById[1] = 'SIGN_MODE_DIRECT')] = 1;
          values[(valuesById[2] = 'SIGN_MODE_TEXTUAL')] = 2;
          values[(valuesById[3] = 'SIGN_MODE_DIRECT_AUX')] = 3;
          values[(valuesById[127] = 'SIGN_MODE_LEGACY_AMINO_JSON')] = 127;
          values[(valuesById[191] = 'SIGN_MODE_EIP_191')] = 191;
          return values;
        })();

        v1beta1.SignatureDescriptors = (function () {
          /**
           * Properties of a SignatureDescriptors.
           * @memberof cosmos.tx.signing.v1beta1
           * @interface ISignatureDescriptors
           * @property {Array.<cosmos.tx.signing.v1beta1.ISignatureDescriptor>|null} [signatures] SignatureDescriptors signatures
           */

          /**
           * Constructs a new SignatureDescriptors.
           * @memberof cosmos.tx.signing.v1beta1
           * @classdesc Represents a SignatureDescriptors.
           * @implements ISignatureDescriptors
           * @constructor
           * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptors=} [properties] Properties to set
           */
          function SignatureDescriptors(properties) {
            this.signatures = [];
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * SignatureDescriptors signatures.
           * @member {Array.<cosmos.tx.signing.v1beta1.ISignatureDescriptor>} signatures
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @instance
           */
          SignatureDescriptors.prototype.signatures = $util.emptyArray;

          /**
           * Encodes the specified SignatureDescriptors message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptors.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @static
           * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptors} message SignatureDescriptors message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignatureDescriptors.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.signatures != null && message.signatures.length)
              for (let i = 0; i < message.signatures.length; ++i)
                $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.encode(
                  message.signatures[i],
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified SignatureDescriptors message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptors.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @static
           * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptors} message SignatureDescriptors message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignatureDescriptors.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SignatureDescriptors message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptors} SignatureDescriptors
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignatureDescriptors.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptors();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.signatures && message.signatures.length)) message.signatures = [];
                  message.signatures.push($root.cosmos.tx.signing.v1beta1.SignatureDescriptor.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SignatureDescriptors message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptors} SignatureDescriptors
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignatureDescriptors.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SignatureDescriptors message.
           * @function verify
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SignatureDescriptors.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.signatures != null && message.hasOwnProperty('signatures')) {
              if (!Array.isArray(message.signatures)) return 'signatures: array expected';
              for (let i = 0; i < message.signatures.length; ++i) {
                let error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.verify(message.signatures[i]);
                if (error) return 'signatures.' + error;
              }
            }
            return null;
          };

          /**
           * Creates a SignatureDescriptors message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptors} SignatureDescriptors
           */
          SignatureDescriptors.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptors) return object;
            let message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptors();
            if (object.signatures) {
              if (!Array.isArray(object.signatures))
                throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptors.signatures: array expected');
              message.signatures = [];
              for (let i = 0; i < object.signatures.length; ++i) {
                if (typeof object.signatures[i] !== 'object')
                  throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptors.signatures: object expected');
                message.signatures[i] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.fromObject(object.signatures[i]);
              }
            }
            return message;
          };

          /**
           * Creates a plain object from a SignatureDescriptors message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @static
           * @param {cosmos.tx.signing.v1beta1.SignatureDescriptors} message SignatureDescriptors
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SignatureDescriptors.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) object.signatures = [];
            if (message.signatures && message.signatures.length) {
              object.signatures = [];
              for (let j = 0; j < message.signatures.length; ++j)
                object.signatures[j] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.toObject(message.signatures[j], options);
            }
            return object;
          };

          /**
           * Converts this SignatureDescriptors to JSON.
           * @function toJSON
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptors
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SignatureDescriptors.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return SignatureDescriptors;
        })();

        v1beta1.SignatureDescriptor = (function () {
          /**
           * Properties of a SignatureDescriptor.
           * @memberof cosmos.tx.signing.v1beta1
           * @interface ISignatureDescriptor
           * @property {google.protobuf.IAny|null} [public_key] SignatureDescriptor public_key
           * @property {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData|null} [data] SignatureDescriptor data
           * @property {Long|null} [sequence] SignatureDescriptor sequence
           */

          /**
           * Constructs a new SignatureDescriptor.
           * @memberof cosmos.tx.signing.v1beta1
           * @classdesc Represents a SignatureDescriptor.
           * @implements ISignatureDescriptor
           * @constructor
           * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptor=} [properties] Properties to set
           */
          function SignatureDescriptor(properties) {
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * SignatureDescriptor public_key.
           * @member {google.protobuf.IAny|null|undefined} public_key
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @instance
           */
          SignatureDescriptor.prototype.public_key = null;

          /**
           * SignatureDescriptor data.
           * @member {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData|null|undefined} data
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @instance
           */
          SignatureDescriptor.prototype.data = null;

          /**
           * SignatureDescriptor sequence.
           * @member {Long} sequence
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @instance
           */
          SignatureDescriptor.prototype.sequence = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * Encodes the specified SignatureDescriptor message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.verify|verify} messages.
           * @function encode
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @static
           * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptor} message SignatureDescriptor message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignatureDescriptor.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.public_key != null && Object.hasOwnProperty.call(message, 'public_key'))
              $root.google.protobuf.Any.encode(message.public_key, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
            if (message.data != null && Object.hasOwnProperty.call(message, 'data'))
              $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.encode(
                message.data,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (message.sequence != null && Object.hasOwnProperty.call(message, 'sequence'))
              writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.sequence);
            return writer;
          };

          /**
           * Encodes the specified SignatureDescriptor message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @static
           * @param {cosmos.tx.signing.v1beta1.ISignatureDescriptor} message SignatureDescriptor message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SignatureDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SignatureDescriptor message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor} SignatureDescriptor
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignatureDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.public_key = $root.google.protobuf.Any.decode(reader, reader.uint32());
                  break;
                case 2:
                  message.data = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.sequence = reader.uint64();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SignatureDescriptor message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor} SignatureDescriptor
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SignatureDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SignatureDescriptor message.
           * @function verify
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SignatureDescriptor.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.public_key != null && message.hasOwnProperty('public_key')) {
              let error = $root.google.protobuf.Any.verify(message.public_key);
              if (error) return 'public_key.' + error;
            }
            if (message.data != null && message.hasOwnProperty('data')) {
              let error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify(message.data);
              if (error) return 'data.' + error;
            }
            if (message.sequence != null && message.hasOwnProperty('sequence'))
              if (
                !$util.isInteger(message.sequence) &&
                !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high))
              )
                return 'sequence: integer|Long expected';
            return null;
          };

          /**
           * Creates a SignatureDescriptor message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor} SignatureDescriptor
           */
          SignatureDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor) return object;
            let message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor();
            if (object.public_key != null) {
              if (typeof object.public_key !== 'object')
                throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.public_key: object expected');
              message.public_key = $root.google.protobuf.Any.fromObject(object.public_key);
            }
            if (object.data != null) {
              if (typeof object.data !== 'object') throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.data: object expected');
              message.data = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.fromObject(object.data);
            }
            if (object.sequence != null)
              if ($util.Long) (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
              else if (typeof object.sequence === 'string') message.sequence = parseInt(object.sequence, 10);
              else if (typeof object.sequence === 'number') message.sequence = object.sequence;
              else if (typeof object.sequence === 'object')
                message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
            return message;
          };

          /**
           * Creates a plain object from a SignatureDescriptor message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @static
           * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor} message SignatureDescriptor
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SignatureDescriptor.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object.public_key = null;
              object.data = null;
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.sequence = options.longs === String ? '0' : 0;
            }
            if (message.public_key != null && message.hasOwnProperty('public_key'))
              object.public_key = $root.google.protobuf.Any.toObject(message.public_key, options);
            if (message.data != null && message.hasOwnProperty('data'))
              object.data = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.toObject(message.data, options);
            if (message.sequence != null && message.hasOwnProperty('sequence'))
              if (typeof message.sequence === 'number')
                object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
              else
                object.sequence =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.sequence)
                    : options.longs === Number
                    ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true)
                    : message.sequence;
            return object;
          };

          /**
           * Converts this SignatureDescriptor to JSON.
           * @function toJSON
           * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SignatureDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          SignatureDescriptor.Data = (function () {
            /**
             * Properties of a Data.
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @interface IData
             * @property {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle|null} [single] Data single
             * @property {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti|null} [multi] Data multi
             */

            /**
             * Constructs a new Data.
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor
             * @classdesc Represents a Data.
             * @implements IData
             * @constructor
             * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData=} [properties] Properties to set
             */
            function Data(properties) {
              if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
            }

            /**
             * Data single.
             * @member {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle|null|undefined} single
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @instance
             */
            Data.prototype.single = null;

            /**
             * Data multi.
             * @member {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti|null|undefined} multi
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @instance
             */
            Data.prototype.multi = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Data sum.
             * @member {"single"|"multi"|undefined} sum
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @instance
             */
            Object.defineProperty(Data.prototype, 'sum', {
              get: $util.oneOfGetter(($oneOfFields = ['single', 'multi'])),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Encodes the specified Data message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify|verify} messages.
             * @function encode
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @static
             * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData} message Data message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Data.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.single != null && Object.hasOwnProperty.call(message, 'single'))
                $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.encode(
                  message.single,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (message.multi != null && Object.hasOwnProperty.call(message, 'multi'))
                $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.encode(
                  message.multi,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Data message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify|verify} messages.
             * @function encodeDelimited
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @static
             * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.IData} message Data message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Data.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Data message from the specified reader or buffer.
             * @function decode
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} Data
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Data.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.single = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.decode(reader, reader.uint32());
                    break;
                  case 2:
                    message.multi = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.decode(reader, reader.uint32());
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Data message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} Data
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Data.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Data message.
             * @function verify
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Data.verify = function verify(message) {
              if (typeof message !== 'object' || message === null) return 'object expected';
              let properties = {};
              if (message.single != null && message.hasOwnProperty('single')) {
                properties.sum = 1;
                {
                  let error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.verify(message.single);
                  if (error) return 'single.' + error;
                }
              }
              if (message.multi != null && message.hasOwnProperty('multi')) {
                if (properties.sum === 1) return 'sum: multiple values';
                properties.sum = 1;
                {
                  let error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.verify(message.multi);
                  if (error) return 'multi.' + error;
                }
              }
              return null;
            };

            /**
             * Creates a Data message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} Data
             */
            Data.fromObject = function fromObject(object) {
              if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data) return object;
              let message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data();
              if (object.single != null) {
                if (typeof object.single !== 'object')
                  throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.single: object expected');
                message.single = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.fromObject(object.single);
              }
              if (object.multi != null) {
                if (typeof object.multi !== 'object')
                  throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.multi: object expected');
                message.multi = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.fromObject(object.multi);
              }
              return message;
            };

            /**
             * Creates a plain object from a Data message. Also converts values to other types if specified.
             * @function toObject
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @static
             * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data} message Data
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Data.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (message.single != null && message.hasOwnProperty('single')) {
                object.single = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.toObject(message.single, options);
                if (options.oneofs) object.sum = 'single';
              }
              if (message.multi != null && message.hasOwnProperty('multi')) {
                object.multi = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.toObject(message.multi, options);
                if (options.oneofs) object.sum = 'multi';
              }
              return object;
            };

            /**
             * Converts this Data to JSON.
             * @function toJSON
             * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Data.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Data.Single = (function () {
              /**
               * Properties of a Single.
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @interface ISingle
               * @property {cosmos.tx.signing.v1beta1.SignMode|null} [mode] Single mode
               * @property {Uint8Array|null} [signature] Single signature
               */

              /**
               * Constructs a new Single.
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @classdesc Represents a Single.
               * @implements ISingle
               * @constructor
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle=} [properties] Properties to set
               */
              function Single(properties) {
                if (properties)
                  for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }

              /**
               * Single mode.
               * @member {cosmos.tx.signing.v1beta1.SignMode} mode
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @instance
               */
              Single.prototype.mode = 0;

              /**
               * Single signature.
               * @member {Uint8Array} signature
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @instance
               */
              Single.prototype.signature = $util.newBuffer([]);

              /**
               * Encodes the specified Single message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.verify|verify} messages.
               * @function encode
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle} message Single message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Single.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.mode != null && Object.hasOwnProperty.call(message, 'mode'))
                  writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.mode);
                if (message.signature != null && Object.hasOwnProperty.call(message, 'signature'))
                  writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.signature);
                return writer;
              };

              /**
               * Encodes the specified Single message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single.verify|verify} messages.
               * @function encodeDelimited
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.ISingle} message Single message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Single.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a Single message from the specified reader or buffer.
               * @function decode
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} Single
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Single.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single();
                while (reader.pos < end) {
                  let tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1:
                      message.mode = reader.int32();
                      break;
                    case 2:
                      message.signature = reader.bytes();
                      break;
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };

              /**
               * Decodes a Single message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} Single
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Single.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a Single message.
               * @function verify
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              Single.verify = function verify(message) {
                if (typeof message !== 'object' || message === null) return 'object expected';
                if (message.mode != null && message.hasOwnProperty('mode'))
                  switch (message.mode) {
                    default:
                      return 'mode: enum value expected';
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 127:
                    case 191:
                      break;
                  }
                if (message.signature != null && message.hasOwnProperty('signature'))
                  if (!((message.signature && typeof message.signature.length === 'number') || $util.isString(message.signature)))
                    return 'signature: buffer expected';
                return null;
              };

              /**
               * Creates a Single message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} Single
               */
              Single.fromObject = function fromObject(object) {
                if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single) return object;
                let message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single();
                switch (object.mode) {
                  case 'SIGN_MODE_UNSPECIFIED':
                  case 0:
                    message.mode = 0;
                    break;
                  case 'SIGN_MODE_DIRECT':
                  case 1:
                    message.mode = 1;
                    break;
                  case 'SIGN_MODE_TEXTUAL':
                  case 2:
                    message.mode = 2;
                    break;
                  case 'SIGN_MODE_DIRECT_AUX':
                  case 3:
                    message.mode = 3;
                    break;
                  case 'SIGN_MODE_LEGACY_AMINO_JSON':
                  case 127:
                    message.mode = 127;
                    break;
                  case 'SIGN_MODE_EIP_191':
                  case 191:
                    message.mode = 191;
                    break;
                }
                if (object.signature != null)
                  if (typeof object.signature === 'string')
                    $util.base64.decode(object.signature, (message.signature = $util.newBuffer($util.base64.length(object.signature))), 0);
                  else if (object.signature.length) message.signature = object.signature;
                return message;
              };

              /**
               * Creates a plain object from a Single message. Also converts values to other types if specified.
               * @function toObject
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single} message Single
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              Single.toObject = function toObject(message, options) {
                if (!options) options = {};
                let object = {};
                if (options.defaults) {
                  object.mode = options.enums === String ? 'SIGN_MODE_UNSPECIFIED' : 0;
                  if (options.bytes === String) object.signature = '';
                  else {
                    object.signature = [];
                    if (options.bytes !== Array) object.signature = $util.newBuffer(object.signature);
                  }
                }
                if (message.mode != null && message.hasOwnProperty('mode'))
                  object.mode = options.enums === String ? $root.cosmos.tx.signing.v1beta1.SignMode[message.mode] : message.mode;
                if (message.signature != null && message.hasOwnProperty('signature'))
                  object.signature =
                    options.bytes === String
                      ? $util.base64.encode(message.signature, 0, message.signature.length)
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.signature)
                      : message.signature;
                return object;
              };

              /**
               * Converts this Single to JSON.
               * @function toJSON
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Single
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              Single.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };

              return Single;
            })();

            Data.Multi = (function () {
              /**
               * Properties of a Multi.
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @interface IMulti
               * @property {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null} [bitarray] Multi bitarray
               * @property {Array.<cosmos.tx.signing.v1beta1.SignatureDescriptor.IData>|null} [signatures] Multi signatures
               */

              /**
               * Constructs a new Multi.
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data
               * @classdesc Represents a Multi.
               * @implements IMulti
               * @constructor
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti=} [properties] Properties to set
               */
              function Multi(properties) {
                this.signatures = [];
                if (properties)
                  for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
              }

              /**
               * Multi bitarray.
               * @member {cosmos.crypto.multisig.v1beta1.ICompactBitArray|null|undefined} bitarray
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @instance
               */
              Multi.prototype.bitarray = null;

              /**
               * Multi signatures.
               * @member {Array.<cosmos.tx.signing.v1beta1.SignatureDescriptor.IData>} signatures
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @instance
               */
              Multi.prototype.signatures = $util.emptyArray;

              /**
               * Encodes the specified Multi message. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.verify|verify} messages.
               * @function encode
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti} message Multi message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Multi.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (message.bitarray != null && Object.hasOwnProperty.call(message, 'bitarray'))
                  $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.encode(
                    message.bitarray,
                    writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                  ).ldelim();
                if (message.signatures != null && message.signatures.length)
                  for (let i = 0; i < message.signatures.length; ++i)
                    $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.encode(
                      message.signatures[i],
                      writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                    ).ldelim();
                return writer;
              };

              /**
               * Encodes the specified Multi message, length delimited. Does not implicitly {@link cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.verify|verify} messages.
               * @function encodeDelimited
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.IMulti} message Multi message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Multi.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a Multi message from the specified reader or buffer.
               * @function decode
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} Multi
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Multi.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length,
                  message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi();
                while (reader.pos < end) {
                  let tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1:
                      message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.decode(reader, reader.uint32());
                      break;
                    case 2:
                      if (!(message.signatures && message.signatures.length)) message.signatures = [];
                      message.signatures.push($root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.decode(reader, reader.uint32()));
                      break;
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };

              /**
               * Decodes a Multi message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} Multi
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Multi.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a Multi message.
               * @function verify
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              Multi.verify = function verify(message) {
                if (typeof message !== 'object' || message === null) return 'object expected';
                if (message.bitarray != null && message.hasOwnProperty('bitarray')) {
                  let error = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.verify(message.bitarray);
                  if (error) return 'bitarray.' + error;
                }
                if (message.signatures != null && message.hasOwnProperty('signatures')) {
                  if (!Array.isArray(message.signatures)) return 'signatures: array expected';
                  for (let i = 0; i < message.signatures.length; ++i) {
                    let error = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.verify(message.signatures[i]);
                    if (error) return 'signatures.' + error;
                  }
                }
                return null;
              };

              /**
               * Creates a Multi message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} Multi
               */
              Multi.fromObject = function fromObject(object) {
                if (object instanceof $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi) return object;
                let message = new $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi();
                if (object.bitarray != null) {
                  if (typeof object.bitarray !== 'object')
                    throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.bitarray: object expected');
                  message.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.fromObject(object.bitarray);
                }
                if (object.signatures) {
                  if (!Array.isArray(object.signatures))
                    throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.signatures: array expected');
                  message.signatures = [];
                  for (let i = 0; i < object.signatures.length; ++i) {
                    if (typeof object.signatures[i] !== 'object')
                      throw TypeError('.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi.signatures: object expected');
                    message.signatures[i] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.fromObject(object.signatures[i]);
                  }
                }
                return message;
              };

              /**
               * Creates a plain object from a Multi message. Also converts values to other types if specified.
               * @function toObject
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @static
               * @param {cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi} message Multi
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              Multi.toObject = function toObject(message, options) {
                if (!options) options = {};
                let object = {};
                if (options.arrays || options.defaults) object.signatures = [];
                if (options.defaults) object.bitarray = null;
                if (message.bitarray != null && message.hasOwnProperty('bitarray'))
                  object.bitarray = $root.cosmos.crypto.multisig.v1beta1.CompactBitArray.toObject(message.bitarray, options);
                if (message.signatures && message.signatures.length) {
                  object.signatures = [];
                  for (let j = 0; j < message.signatures.length; ++j)
                    object.signatures[j] = $root.cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.toObject(
                      message.signatures[j],
                      options,
                    );
                }
                return object;
              };

              /**
               * Converts this Multi to JSON.
               * @function toJSON
               * @memberof cosmos.tx.signing.v1beta1.SignatureDescriptor.Data.Multi
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              Multi.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };

              return Multi;
            })();

            return Data;
          })();

          return SignatureDescriptor;
        })();

        return v1beta1;
      })();

      return signing;
    })();

    return tx;
  })();

  cosmos.crypto = (function () {
    /**
     * Namespace crypto.
     * @memberof cosmos
     * @namespace
     */
    const crypto = {};

    crypto.multisig = (function () {
      /**
       * Namespace multisig.
       * @memberof cosmos.crypto
       * @namespace
       */
      const multisig = {};

      multisig.v1beta1 = (function () {
        /**
         * Namespace v1beta1.
         * @memberof cosmos.crypto.multisig
         * @namespace
         */
        const v1beta1 = {};

        v1beta1.MultiSignature = (function () {
          /**
           * Properties of a MultiSignature.
           * @memberof cosmos.crypto.multisig.v1beta1
           * @interface IMultiSignature
           * @property {Array.<Uint8Array>|null} [signatures] MultiSignature signatures
           */

          /**
           * Constructs a new MultiSignature.
           * @memberof cosmos.crypto.multisig.v1beta1
           * @classdesc Represents a MultiSignature.
           * @implements IMultiSignature
           * @constructor
           * @param {cosmos.crypto.multisig.v1beta1.IMultiSignature=} [properties] Properties to set
           */
          function MultiSignature(properties) {
            this.signatures = [];
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * MultiSignature signatures.
           * @member {Array.<Uint8Array>} signatures
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @instance
           */
          MultiSignature.prototype.signatures = $util.emptyArray;

          /**
           * Encodes the specified MultiSignature message. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.MultiSignature.verify|verify} messages.
           * @function encode
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @static
           * @param {cosmos.crypto.multisig.v1beta1.IMultiSignature} message MultiSignature message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MultiSignature.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.signatures != null && message.signatures.length)
              for (let i = 0; i < message.signatures.length; ++i) writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.signatures[i]);
            return writer;
          };

          /**
           * Encodes the specified MultiSignature message, length delimited. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.MultiSignature.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @static
           * @param {cosmos.crypto.multisig.v1beta1.IMultiSignature} message MultiSignature message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MultiSignature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a MultiSignature message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.crypto.multisig.v1beta1.MultiSignature} MultiSignature
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MultiSignature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.crypto.multisig.v1beta1.MultiSignature();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.signatures && message.signatures.length)) message.signatures = [];
                  message.signatures.push(reader.bytes());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a MultiSignature message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.crypto.multisig.v1beta1.MultiSignature} MultiSignature
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MultiSignature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a MultiSignature message.
           * @function verify
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          MultiSignature.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.signatures != null && message.hasOwnProperty('signatures')) {
              if (!Array.isArray(message.signatures)) return 'signatures: array expected';
              for (let i = 0; i < message.signatures.length; ++i)
                if (!((message.signatures[i] && typeof message.signatures[i].length === 'number') || $util.isString(message.signatures[i])))
                  return 'signatures: buffer[] expected';
            }
            return null;
          };

          /**
           * Creates a MultiSignature message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.crypto.multisig.v1beta1.MultiSignature} MultiSignature
           */
          MultiSignature.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.crypto.multisig.v1beta1.MultiSignature) return object;
            let message = new $root.cosmos.crypto.multisig.v1beta1.MultiSignature();
            if (object.signatures) {
              if (!Array.isArray(object.signatures))
                throw TypeError('.cosmos.crypto.multisig.v1beta1.MultiSignature.signatures: array expected');
              message.signatures = [];
              for (let i = 0; i < object.signatures.length; ++i)
                if (typeof object.signatures[i] === 'string')
                  $util.base64.decode(
                    object.signatures[i],
                    (message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i]))),
                    0,
                  );
                else if (object.signatures[i].length) message.signatures[i] = object.signatures[i];
            }
            return message;
          };

          /**
           * Creates a plain object from a MultiSignature message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @static
           * @param {cosmos.crypto.multisig.v1beta1.MultiSignature} message MultiSignature
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          MultiSignature.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) object.signatures = [];
            if (message.signatures && message.signatures.length) {
              object.signatures = [];
              for (let j = 0; j < message.signatures.length; ++j)
                object.signatures[j] =
                  options.bytes === String
                    ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length)
                    : options.bytes === Array
                    ? Array.prototype.slice.call(message.signatures[j])
                    : message.signatures[j];
            }
            return object;
          };

          /**
           * Converts this MultiSignature to JSON.
           * @function toJSON
           * @memberof cosmos.crypto.multisig.v1beta1.MultiSignature
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          MultiSignature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return MultiSignature;
        })();

        v1beta1.CompactBitArray = (function () {
          /**
           * Properties of a CompactBitArray.
           * @memberof cosmos.crypto.multisig.v1beta1
           * @interface ICompactBitArray
           * @property {number|null} [extra_bits_stored] CompactBitArray extra_bits_stored
           * @property {Uint8Array|null} [elems] CompactBitArray elems
           */

          /**
           * Constructs a new CompactBitArray.
           * @memberof cosmos.crypto.multisig.v1beta1
           * @classdesc Represents a CompactBitArray.
           * @implements ICompactBitArray
           * @constructor
           * @param {cosmos.crypto.multisig.v1beta1.ICompactBitArray=} [properties] Properties to set
           */
          function CompactBitArray(properties) {
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * CompactBitArray extra_bits_stored.
           * @member {number} extra_bits_stored
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @instance
           */
          CompactBitArray.prototype.extra_bits_stored = 0;

          /**
           * CompactBitArray elems.
           * @member {Uint8Array} elems
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @instance
           */
          CompactBitArray.prototype.elems = $util.newBuffer([]);

          /**
           * Encodes the specified CompactBitArray message. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.CompactBitArray.verify|verify} messages.
           * @function encode
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @static
           * @param {cosmos.crypto.multisig.v1beta1.ICompactBitArray} message CompactBitArray message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CompactBitArray.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.extra_bits_stored != null && Object.hasOwnProperty.call(message, 'extra_bits_stored'))
              writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.extra_bits_stored);
            if (message.elems != null && Object.hasOwnProperty.call(message, 'elems'))
              writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.elems);
            return writer;
          };

          /**
           * Encodes the specified CompactBitArray message, length delimited. Does not implicitly {@link cosmos.crypto.multisig.v1beta1.CompactBitArray.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @static
           * @param {cosmos.crypto.multisig.v1beta1.ICompactBitArray} message CompactBitArray message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CompactBitArray.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a CompactBitArray message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.crypto.multisig.v1beta1.CompactBitArray} CompactBitArray
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CompactBitArray.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.crypto.multisig.v1beta1.CompactBitArray();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.extra_bits_stored = reader.uint32();
                  break;
                case 2:
                  message.elems = reader.bytes();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a CompactBitArray message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.crypto.multisig.v1beta1.CompactBitArray} CompactBitArray
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CompactBitArray.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a CompactBitArray message.
           * @function verify
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          CompactBitArray.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.extra_bits_stored != null && message.hasOwnProperty('extra_bits_stored'))
              if (!$util.isInteger(message.extra_bits_stored)) return 'extra_bits_stored: integer expected';
            if (message.elems != null && message.hasOwnProperty('elems'))
              if (!((message.elems && typeof message.elems.length === 'number') || $util.isString(message.elems)))
                return 'elems: buffer expected';
            return null;
          };

          /**
           * Creates a CompactBitArray message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.crypto.multisig.v1beta1.CompactBitArray} CompactBitArray
           */
          CompactBitArray.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.crypto.multisig.v1beta1.CompactBitArray) return object;
            let message = new $root.cosmos.crypto.multisig.v1beta1.CompactBitArray();
            if (object.extra_bits_stored != null) message.extra_bits_stored = object.extra_bits_stored >>> 0;
            if (object.elems != null)
              if (typeof object.elems === 'string')
                $util.base64.decode(object.elems, (message.elems = $util.newBuffer($util.base64.length(object.elems))), 0);
              else if (object.elems.length) message.elems = object.elems;
            return message;
          };

          /**
           * Creates a plain object from a CompactBitArray message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @static
           * @param {cosmos.crypto.multisig.v1beta1.CompactBitArray} message CompactBitArray
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          CompactBitArray.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object.extra_bits_stored = 0;
              if (options.bytes === String) object.elems = '';
              else {
                object.elems = [];
                if (options.bytes !== Array) object.elems = $util.newBuffer(object.elems);
              }
            }
            if (message.extra_bits_stored != null && message.hasOwnProperty('extra_bits_stored'))
              object.extra_bits_stored = message.extra_bits_stored;
            if (message.elems != null && message.hasOwnProperty('elems'))
              object.elems =
                options.bytes === String
                  ? $util.base64.encode(message.elems, 0, message.elems.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.elems)
                  : message.elems;
            return object;
          };

          /**
           * Converts this CompactBitArray to JSON.
           * @function toJSON
           * @memberof cosmos.crypto.multisig.v1beta1.CompactBitArray
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          CompactBitArray.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return CompactBitArray;
        })();

        return v1beta1;
      })();

      return multisig;
    })();

    return crypto;
  })();

  return cosmos;
})());

export const cosmos_proto = ($root.cosmos_proto = (() => {
  /**
   * Namespace cosmos_proto.
   * @exports cosmos_proto
   * @namespace
   */
  const cosmos_proto = {};

  return cosmos_proto;
})());

export const gogoproto = ($root.gogoproto = (() => {
  /**
   * Namespace gogoproto.
   * @exports gogoproto
   * @namespace
   */
  const gogoproto = {};

  return gogoproto;
})());

export const google = ($root.google = (() => {
  /**
   * Namespace google.
   * @exports google
   * @namespace
   */
  const google = {};

  google.api = (function () {
    /**
     * Namespace api.
     * @memberof google
     * @namespace
     */
    const api = {};

    api.Http = (function () {
      /**
       * Properties of a Http.
       * @memberof google.api
       * @interface IHttp
       * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
       * @property {boolean|null} [fully_decode_reserved_expansion] Http fully_decode_reserved_expansion
       */

      /**
       * Constructs a new Http.
       * @memberof google.api
       * @classdesc Represents a Http.
       * @implements IHttp
       * @constructor
       * @param {google.api.IHttp=} [properties] Properties to set
       */
      function Http(properties) {
        this.rules = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Http rules.
       * @member {Array.<google.api.IHttpRule>} rules
       * @memberof google.api.Http
       * @instance
       */
      Http.prototype.rules = $util.emptyArray;

      /**
       * Http fully_decode_reserved_expansion.
       * @member {boolean} fully_decode_reserved_expansion
       * @memberof google.api.Http
       * @instance
       */
      Http.prototype.fully_decode_reserved_expansion = false;

      /**
       * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
       * @function encode
       * @memberof google.api.Http
       * @static
       * @param {google.api.IHttp} message Http message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Http.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.rules != null && message.rules.length)
          for (let i = 0; i < message.rules.length; ++i)
            $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.fully_decode_reserved_expansion != null && Object.hasOwnProperty.call(message, 'fully_decode_reserved_expansion'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.fully_decode_reserved_expansion);
        return writer;
      };

      /**
       * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.Http
       * @static
       * @param {google.api.IHttp} message Http message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Http.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Http message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.Http
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.Http} Http
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Http.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.api.Http();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.rules && message.rules.length)) message.rules = [];
              message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fully_decode_reserved_expansion = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Http message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.Http
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.Http} Http
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Http.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Http message.
       * @function verify
       * @memberof google.api.Http
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Http.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.rules != null && message.hasOwnProperty('rules')) {
          if (!Array.isArray(message.rules)) return 'rules: array expected';
          for (let i = 0; i < message.rules.length; ++i) {
            let error = $root.google.api.HttpRule.verify(message.rules[i]);
            if (error) return 'rules.' + error;
          }
        }
        if (message.fully_decode_reserved_expansion != null && message.hasOwnProperty('fully_decode_reserved_expansion'))
          if (typeof message.fully_decode_reserved_expansion !== 'boolean') return 'fully_decode_reserved_expansion: boolean expected';
        return null;
      };

      /**
       * Creates a Http message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.Http
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.Http} Http
       */
      Http.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.Http) return object;
        let message = new $root.google.api.Http();
        if (object.rules) {
          if (!Array.isArray(object.rules)) throw TypeError('.google.api.Http.rules: array expected');
          message.rules = [];
          for (let i = 0; i < object.rules.length; ++i) {
            if (typeof object.rules[i] !== 'object') throw TypeError('.google.api.Http.rules: object expected');
            message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
          }
        }
        if (object.fully_decode_reserved_expansion != null)
          message.fully_decode_reserved_expansion = Boolean(object.fully_decode_reserved_expansion);
        return message;
      };

      /**
       * Creates a plain object from a Http message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.Http
       * @static
       * @param {google.api.Http} message Http
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Http.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rules = [];
        if (options.defaults) object.fully_decode_reserved_expansion = false;
        if (message.rules && message.rules.length) {
          object.rules = [];
          for (let j = 0; j < message.rules.length; ++j) object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
        }
        if (message.fully_decode_reserved_expansion != null && message.hasOwnProperty('fully_decode_reserved_expansion'))
          object.fully_decode_reserved_expansion = message.fully_decode_reserved_expansion;
        return object;
      };

      /**
       * Converts this Http to JSON.
       * @function toJSON
       * @memberof google.api.Http
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Http.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Http;
    })();

    api.HttpRule = (function () {
      /**
       * Properties of a HttpRule.
       * @memberof google.api
       * @interface IHttpRule
       * @property {string|null} [selector] HttpRule selector
       * @property {string|null} [get] HttpRule get
       * @property {string|null} [put] HttpRule put
       * @property {string|null} [post] HttpRule post
       * @property {string|null} ["delete"] HttpRule delete
       * @property {string|null} [patch] HttpRule patch
       * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
       * @property {string|null} [body] HttpRule body
       * @property {string|null} [response_body] HttpRule response_body
       * @property {Array.<google.api.IHttpRule>|null} [additional_bindings] HttpRule additional_bindings
       */

      /**
       * Constructs a new HttpRule.
       * @memberof google.api
       * @classdesc Represents a HttpRule.
       * @implements IHttpRule
       * @constructor
       * @param {google.api.IHttpRule=} [properties] Properties to set
       */
      function HttpRule(properties) {
        this.additional_bindings = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * HttpRule selector.
       * @member {string} selector
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.selector = '';

      /**
       * HttpRule get.
       * @member {string|null|undefined} get
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.get = null;

      /**
       * HttpRule put.
       * @member {string|null|undefined} put
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.put = null;

      /**
       * HttpRule post.
       * @member {string|null|undefined} post
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.post = null;

      /**
       * HttpRule delete.
       * @member {string|null|undefined} delete
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype['delete'] = null;

      /**
       * HttpRule patch.
       * @member {string|null|undefined} patch
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.patch = null;

      /**
       * HttpRule custom.
       * @member {google.api.ICustomHttpPattern|null|undefined} custom
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.custom = null;

      /**
       * HttpRule body.
       * @member {string} body
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.body = '';

      /**
       * HttpRule response_body.
       * @member {string} response_body
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.response_body = '';

      /**
       * HttpRule additional_bindings.
       * @member {Array.<google.api.IHttpRule>} additional_bindings
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.additional_bindings = $util.emptyArray;

      // OneOf field names bound to virtual getters and setters
      let $oneOfFields;

      /**
       * HttpRule pattern.
       * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
       * @memberof google.api.HttpRule
       * @instance
       */
      Object.defineProperty(HttpRule.prototype, 'pattern', {
        get: $util.oneOfGetter(($oneOfFields = ['get', 'put', 'post', 'delete', 'patch', 'custom'])),
        set: $util.oneOfSetter($oneOfFields),
      });

      /**
       * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
       * @function encode
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HttpRule.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.selector != null && Object.hasOwnProperty.call(message, 'selector'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.selector);
        if (message.get != null && Object.hasOwnProperty.call(message, 'get'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.get);
        if (message.put != null && Object.hasOwnProperty.call(message, 'put'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.put);
        if (message.post != null && Object.hasOwnProperty.call(message, 'post'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.post);
        if (message['delete'] != null && Object.hasOwnProperty.call(message, 'delete'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message['delete']);
        if (message.patch != null && Object.hasOwnProperty.call(message, 'patch'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.patch);
        if (message.body != null && Object.hasOwnProperty.call(message, 'body'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.body);
        if (message.custom != null && Object.hasOwnProperty.call(message, 'custom'))
          $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.additional_bindings != null && message.additional_bindings.length)
          for (let i = 0; i < message.additional_bindings.length; ++i)
            $root.google.api.HttpRule.encode(message.additional_bindings[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
        if (message.response_body != null && Object.hasOwnProperty.call(message, 'response_body'))
          writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.response_body);
        return writer;
      };

      /**
       * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a HttpRule message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.HttpRule
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.HttpRule} HttpRule
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HttpRule.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.api.HttpRule();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.selector = reader.string();
              break;
            case 2:
              message.get = reader.string();
              break;
            case 3:
              message.put = reader.string();
              break;
            case 4:
              message.post = reader.string();
              break;
            case 5:
              message['delete'] = reader.string();
              break;
            case 6:
              message.patch = reader.string();
              break;
            case 8:
              message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
              break;
            case 7:
              message.body = reader.string();
              break;
            case 12:
              message.response_body = reader.string();
              break;
            case 11:
              if (!(message.additional_bindings && message.additional_bindings.length)) message.additional_bindings = [];
              message.additional_bindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a HttpRule message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.HttpRule
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.HttpRule} HttpRule
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HttpRule.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a HttpRule message.
       * @function verify
       * @memberof google.api.HttpRule
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      HttpRule.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        let properties = {};
        if (message.selector != null && message.hasOwnProperty('selector'))
          if (!$util.isString(message.selector)) return 'selector: string expected';
        if (message.get != null && message.hasOwnProperty('get')) {
          properties.pattern = 1;
          if (!$util.isString(message.get)) return 'get: string expected';
        }
        if (message.put != null && message.hasOwnProperty('put')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message.put)) return 'put: string expected';
        }
        if (message.post != null && message.hasOwnProperty('post')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message.post)) return 'post: string expected';
        }
        if (message['delete'] != null && message.hasOwnProperty('delete')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message['delete'])) return 'delete: string expected';
        }
        if (message.patch != null && message.hasOwnProperty('patch')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message.patch)) return 'patch: string expected';
        }
        if (message.custom != null && message.hasOwnProperty('custom')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          {
            let error = $root.google.api.CustomHttpPattern.verify(message.custom);
            if (error) return 'custom.' + error;
          }
        }
        if (message.body != null && message.hasOwnProperty('body')) if (!$util.isString(message.body)) return 'body: string expected';
        if (message.response_body != null && message.hasOwnProperty('response_body'))
          if (!$util.isString(message.response_body)) return 'response_body: string expected';
        if (message.additional_bindings != null && message.hasOwnProperty('additional_bindings')) {
          if (!Array.isArray(message.additional_bindings)) return 'additional_bindings: array expected';
          for (let i = 0; i < message.additional_bindings.length; ++i) {
            let error = $root.google.api.HttpRule.verify(message.additional_bindings[i]);
            if (error) return 'additional_bindings.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.HttpRule
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.HttpRule} HttpRule
       */
      HttpRule.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.HttpRule) return object;
        let message = new $root.google.api.HttpRule();
        if (object.selector != null) message.selector = String(object.selector);
        if (object.get != null) message.get = String(object.get);
        if (object.put != null) message.put = String(object.put);
        if (object.post != null) message.post = String(object.post);
        if (object['delete'] != null) message['delete'] = String(object['delete']);
        if (object.patch != null) message.patch = String(object.patch);
        if (object.custom != null) {
          if (typeof object.custom !== 'object') throw TypeError('.google.api.HttpRule.custom: object expected');
          message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
        }
        if (object.body != null) message.body = String(object.body);
        if (object.response_body != null) message.response_body = String(object.response_body);
        if (object.additional_bindings) {
          if (!Array.isArray(object.additional_bindings)) throw TypeError('.google.api.HttpRule.additional_bindings: array expected');
          message.additional_bindings = [];
          for (let i = 0; i < object.additional_bindings.length; ++i) {
            if (typeof object.additional_bindings[i] !== 'object')
              throw TypeError('.google.api.HttpRule.additional_bindings: object expected');
            message.additional_bindings[i] = $root.google.api.HttpRule.fromObject(object.additional_bindings[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.HttpRule} message HttpRule
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      HttpRule.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.additional_bindings = [];
        if (options.defaults) {
          object.selector = '';
          object.body = '';
          object.response_body = '';
        }
        if (message.selector != null && message.hasOwnProperty('selector')) object.selector = message.selector;
        if (message.get != null && message.hasOwnProperty('get')) {
          object.get = message.get;
          if (options.oneofs) object.pattern = 'get';
        }
        if (message.put != null && message.hasOwnProperty('put')) {
          object.put = message.put;
          if (options.oneofs) object.pattern = 'put';
        }
        if (message.post != null && message.hasOwnProperty('post')) {
          object.post = message.post;
          if (options.oneofs) object.pattern = 'post';
        }
        if (message['delete'] != null && message.hasOwnProperty('delete')) {
          object['delete'] = message['delete'];
          if (options.oneofs) object.pattern = 'delete';
        }
        if (message.patch != null && message.hasOwnProperty('patch')) {
          object.patch = message.patch;
          if (options.oneofs) object.pattern = 'patch';
        }
        if (message.body != null && message.hasOwnProperty('body')) object.body = message.body;
        if (message.custom != null && message.hasOwnProperty('custom')) {
          object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
          if (options.oneofs) object.pattern = 'custom';
        }
        if (message.additional_bindings && message.additional_bindings.length) {
          object.additional_bindings = [];
          for (let j = 0; j < message.additional_bindings.length; ++j)
            object.additional_bindings[j] = $root.google.api.HttpRule.toObject(message.additional_bindings[j], options);
        }
        if (message.response_body != null && message.hasOwnProperty('response_body')) object.response_body = message.response_body;
        return object;
      };

      /**
       * Converts this HttpRule to JSON.
       * @function toJSON
       * @memberof google.api.HttpRule
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      HttpRule.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return HttpRule;
    })();

    api.CustomHttpPattern = (function () {
      /**
       * Properties of a CustomHttpPattern.
       * @memberof google.api
       * @interface ICustomHttpPattern
       * @property {string|null} [kind] CustomHttpPattern kind
       * @property {string|null} [path] CustomHttpPattern path
       */

      /**
       * Constructs a new CustomHttpPattern.
       * @memberof google.api
       * @classdesc Represents a CustomHttpPattern.
       * @implements ICustomHttpPattern
       * @constructor
       * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
       */
      function CustomHttpPattern(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * CustomHttpPattern kind.
       * @member {string} kind
       * @memberof google.api.CustomHttpPattern
       * @instance
       */
      CustomHttpPattern.prototype.kind = '';

      /**
       * CustomHttpPattern path.
       * @member {string} path
       * @memberof google.api.CustomHttpPattern
       * @instance
       */
      CustomHttpPattern.prototype.path = '';

      /**
       * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
       * @function encode
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CustomHttpPattern.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.kind != null && Object.hasOwnProperty.call(message, 'kind'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.kind);
        if (message.path != null && Object.hasOwnProperty.call(message, 'path'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.path);
        return writer;
      };

      /**
       * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CustomHttpPattern message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CustomHttpPattern.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.api.CustomHttpPattern();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.kind = reader.string();
              break;
            case 2:
              message.path = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CustomHttpPattern message.
       * @function verify
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CustomHttpPattern.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.kind != null && message.hasOwnProperty('kind')) if (!$util.isString(message.kind)) return 'kind: string expected';
        if (message.path != null && message.hasOwnProperty('path')) if (!$util.isString(message.path)) return 'path: string expected';
        return null;
      };

      /**
       * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       */
      CustomHttpPattern.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.CustomHttpPattern) return object;
        let message = new $root.google.api.CustomHttpPattern();
        if (object.kind != null) message.kind = String(object.kind);
        if (object.path != null) message.path = String(object.path);
        return message;
      };

      /**
       * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.CustomHttpPattern} message CustomHttpPattern
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CustomHttpPattern.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.kind = '';
          object.path = '';
        }
        if (message.kind != null && message.hasOwnProperty('kind')) object.kind = message.kind;
        if (message.path != null && message.hasOwnProperty('path')) object.path = message.path;
        return object;
      };

      /**
       * Converts this CustomHttpPattern to JSON.
       * @function toJSON
       * @memberof google.api.CustomHttpPattern
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CustomHttpPattern.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CustomHttpPattern;
    })();

    return api;
  })();

  google.protobuf = (function () {
    /**
     * Namespace protobuf.
     * @memberof google
     * @namespace
     */
    const protobuf = {};

    protobuf.FileDescriptorSet = (function () {
      /**
       * Properties of a FileDescriptorSet.
       * @memberof google.protobuf
       * @interface IFileDescriptorSet
       * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
       */

      /**
       * Constructs a new FileDescriptorSet.
       * @memberof google.protobuf
       * @classdesc Represents a FileDescriptorSet.
       * @implements IFileDescriptorSet
       * @constructor
       * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
       */
      function FileDescriptorSet(properties) {
        this.file = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileDescriptorSet file.
       * @member {Array.<google.protobuf.IFileDescriptorProto>} file
       * @memberof google.protobuf.FileDescriptorSet
       * @instance
       */
      FileDescriptorSet.prototype.file = $util.emptyArray;

      /**
       * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorSet.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.file != null && message.file.length)
          for (let i = 0; i < message.file.length; ++i)
            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileDescriptorSet message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorSet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FileDescriptorSet();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.file && message.file.length)) message.file = [];
              message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileDescriptorSet message.
       * @function verify
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileDescriptorSet.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.file != null && message.hasOwnProperty('file')) {
          if (!Array.isArray(message.file)) return 'file: array expected';
          for (let i = 0; i < message.file.length; ++i) {
            let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
            if (error) return 'file.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       */
      FileDescriptorSet.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileDescriptorSet) return object;
        let message = new $root.google.protobuf.FileDescriptorSet();
        if (object.file) {
          if (!Array.isArray(object.file)) throw TypeError('.google.protobuf.FileDescriptorSet.file: array expected');
          message.file = [];
          for (let i = 0; i < object.file.length; ++i) {
            if (typeof object.file[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorSet.file: object expected');
            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileDescriptorSet.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.file = [];
        if (message.file && message.file.length) {
          object.file = [];
          for (let j = 0; j < message.file.length; ++j)
            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
        }
        return object;
      };

      /**
       * Converts this FileDescriptorSet to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileDescriptorSet
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileDescriptorSet.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FileDescriptorSet;
    })();

    protobuf.FileDescriptorProto = (function () {
      /**
       * Properties of a FileDescriptorProto.
       * @memberof google.protobuf
       * @interface IFileDescriptorProto
       * @property {string|null} [name] FileDescriptorProto name
       * @property {string|null} ["package"] FileDescriptorProto package
       * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
       * @property {Array.<number>|null} [public_dependency] FileDescriptorProto public_dependency
       * @property {Array.<number>|null} [weak_dependency] FileDescriptorProto weak_dependency
       * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
       * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
       * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
       * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
       * @property {string|null} [syntax] FileDescriptorProto syntax
       */

      /**
       * Constructs a new FileDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a FileDescriptorProto.
       * @implements IFileDescriptorProto
       * @constructor
       * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
       */
      function FileDescriptorProto(properties) {
        this.dependency = [];
        this.public_dependency = [];
        this.weak_dependency = [];
        this.message_type = [];
        this.enum_type = [];
        this.service = [];
        this.extension = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.name = '';

      /**
       * FileDescriptorProto package.
       * @member {string} package
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype['package'] = '';

      /**
       * FileDescriptorProto dependency.
       * @member {Array.<string>} dependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.dependency = $util.emptyArray;

      /**
       * FileDescriptorProto public_dependency.
       * @member {Array.<number>} public_dependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.public_dependency = $util.emptyArray;

      /**
       * FileDescriptorProto weak_dependency.
       * @member {Array.<number>} weak_dependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.weak_dependency = $util.emptyArray;

      /**
       * FileDescriptorProto message_type.
       * @member {Array.<google.protobuf.IDescriptorProto>} message_type
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.message_type = $util.emptyArray;

      /**
       * FileDescriptorProto enum_type.
       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.enum_type = $util.emptyArray;

      /**
       * FileDescriptorProto service.
       * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.service = $util.emptyArray;

      /**
       * FileDescriptorProto extension.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.extension = $util.emptyArray;

      /**
       * FileDescriptorProto options.
       * @member {google.protobuf.IFileOptions|null|undefined} options
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.options = null;

      /**
       * FileDescriptorProto source_code_info.
       * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.source_code_info = null;

      /**
       * FileDescriptorProto syntax.
       * @member {string} syntax
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.syntax = '';

      /**
       * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message['package'] != null && Object.hasOwnProperty.call(message, 'package'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message['package']);
        if (message.dependency != null && message.dependency.length)
          for (let i = 0; i < message.dependency.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.dependency[i]);
        if (message.message_type != null && message.message_type.length)
          for (let i = 0; i < message.message_type.length; ++i)
            $root.google.protobuf.DescriptorProto.encode(
              message.message_type[i],
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
        if (message.enum_type != null && message.enum_type.length)
          for (let i = 0; i < message.enum_type.length; ++i)
            $root.google.protobuf.EnumDescriptorProto.encode(
              message.enum_type[i],
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
        if (message.service != null && message.service.length)
          for (let i = 0; i < message.service.length; ++i)
            $root.google.protobuf.ServiceDescriptorProto.encode(
              message.service[i],
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
        if (message.extension != null && message.extension.length)
          for (let i = 0; i < message.extension.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(
              message.extension[i],
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.source_code_info != null && Object.hasOwnProperty.call(message, 'source_code_info'))
          $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        if (message.public_dependency != null && message.public_dependency.length)
          for (let i = 0; i < message.public_dependency.length; ++i)
            writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.public_dependency[i]);
        if (message.weak_dependency != null && message.weak_dependency.length)
          for (let i = 0; i < message.weak_dependency.length; ++i)
            writer.uint32(/* id 11, wireType 0 =*/ 88).int32(message.weak_dependency[i]);
        if (message.syntax != null && Object.hasOwnProperty.call(message, 'syntax'))
          writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.syntax);
        return writer;
      };

      /**
       * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FileDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message['package'] = reader.string();
              break;
            case 3:
              if (!(message.dependency && message.dependency.length)) message.dependency = [];
              message.dependency.push(reader.string());
              break;
            case 10:
              if (!(message.public_dependency && message.public_dependency.length)) message.public_dependency = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) message.public_dependency.push(reader.int32());
              } else message.public_dependency.push(reader.int32());
              break;
            case 11:
              if (!(message.weak_dependency && message.weak_dependency.length)) message.weak_dependency = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) message.weak_dependency.push(reader.int32());
              } else message.weak_dependency.push(reader.int32());
              break;
            case 4:
              if (!(message.message_type && message.message_type.length)) message.message_type = [];
              message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.enum_type && message.enum_type.length)) message.enum_type = [];
              message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 6:
              if (!(message.service && message.service.length)) message.service = [];
              message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 7:
              if (!(message.extension && message.extension.length)) message.extension = [];
              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 8:
              message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
              break;
            case 9:
              message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
              break;
            case 12:
              message.syntax = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message['package'] != null && message.hasOwnProperty('package'))
          if (!$util.isString(message['package'])) return 'package: string expected';
        if (message.dependency != null && message.hasOwnProperty('dependency')) {
          if (!Array.isArray(message.dependency)) return 'dependency: array expected';
          for (let i = 0; i < message.dependency.length; ++i)
            if (!$util.isString(message.dependency[i])) return 'dependency: string[] expected';
        }
        if (message.public_dependency != null && message.hasOwnProperty('public_dependency')) {
          if (!Array.isArray(message.public_dependency)) return 'public_dependency: array expected';
          for (let i = 0; i < message.public_dependency.length; ++i)
            if (!$util.isInteger(message.public_dependency[i])) return 'public_dependency: integer[] expected';
        }
        if (message.weak_dependency != null && message.hasOwnProperty('weak_dependency')) {
          if (!Array.isArray(message.weak_dependency)) return 'weak_dependency: array expected';
          for (let i = 0; i < message.weak_dependency.length; ++i)
            if (!$util.isInteger(message.weak_dependency[i])) return 'weak_dependency: integer[] expected';
        }
        if (message.message_type != null && message.hasOwnProperty('message_type')) {
          if (!Array.isArray(message.message_type)) return 'message_type: array expected';
          for (let i = 0; i < message.message_type.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
            if (error) return 'message_type.' + error;
          }
        }
        if (message.enum_type != null && message.hasOwnProperty('enum_type')) {
          if (!Array.isArray(message.enum_type)) return 'enum_type: array expected';
          for (let i = 0; i < message.enum_type.length; ++i) {
            let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
            if (error) return 'enum_type.' + error;
          }
        }
        if (message.service != null && message.hasOwnProperty('service')) {
          if (!Array.isArray(message.service)) return 'service: array expected';
          for (let i = 0; i < message.service.length; ++i) {
            let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
            if (error) return 'service.' + error;
          }
        }
        if (message.extension != null && message.hasOwnProperty('extension')) {
          if (!Array.isArray(message.extension)) return 'extension: array expected';
          for (let i = 0; i < message.extension.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
            if (error) return 'extension.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.FileOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        if (message.source_code_info != null && message.hasOwnProperty('source_code_info')) {
          let error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
          if (error) return 'source_code_info.' + error;
        }
        if (message.syntax != null && message.hasOwnProperty('syntax'))
          if (!$util.isString(message.syntax)) return 'syntax: string expected';
        return null;
      };

      /**
       * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       */
      FileDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileDescriptorProto) return object;
        let message = new $root.google.protobuf.FileDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object['package'] != null) message['package'] = String(object['package']);
        if (object.dependency) {
          if (!Array.isArray(object.dependency)) throw TypeError('.google.protobuf.FileDescriptorProto.dependency: array expected');
          message.dependency = [];
          for (let i = 0; i < object.dependency.length; ++i) message.dependency[i] = String(object.dependency[i]);
        }
        if (object.public_dependency) {
          if (!Array.isArray(object.public_dependency))
            throw TypeError('.google.protobuf.FileDescriptorProto.public_dependency: array expected');
          message.public_dependency = [];
          for (let i = 0; i < object.public_dependency.length; ++i) message.public_dependency[i] = object.public_dependency[i] | 0;
        }
        if (object.weak_dependency) {
          if (!Array.isArray(object.weak_dependency))
            throw TypeError('.google.protobuf.FileDescriptorProto.weak_dependency: array expected');
          message.weak_dependency = [];
          for (let i = 0; i < object.weak_dependency.length; ++i) message.weak_dependency[i] = object.weak_dependency[i] | 0;
        }
        if (object.message_type) {
          if (!Array.isArray(object.message_type)) throw TypeError('.google.protobuf.FileDescriptorProto.message_type: array expected');
          message.message_type = [];
          for (let i = 0; i < object.message_type.length; ++i) {
            if (typeof object.message_type[i] !== 'object')
              throw TypeError('.google.protobuf.FileDescriptorProto.message_type: object expected');
            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
          }
        }
        if (object.enum_type) {
          if (!Array.isArray(object.enum_type)) throw TypeError('.google.protobuf.FileDescriptorProto.enum_type: array expected');
          message.enum_type = [];
          for (let i = 0; i < object.enum_type.length; ++i) {
            if (typeof object.enum_type[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.enum_type: object expected');
            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
          }
        }
        if (object.service) {
          if (!Array.isArray(object.service)) throw TypeError('.google.protobuf.FileDescriptorProto.service: array expected');
          message.service = [];
          for (let i = 0; i < object.service.length; ++i) {
            if (typeof object.service[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.service: object expected');
            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
          }
        }
        if (object.extension) {
          if (!Array.isArray(object.extension)) throw TypeError('.google.protobuf.FileDescriptorProto.extension: array expected');
          message.extension = [];
          for (let i = 0; i < object.extension.length; ++i) {
            if (typeof object.extension[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.extension: object expected');
            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
        }
        if (object.source_code_info != null) {
          if (typeof object.source_code_info !== 'object')
            throw TypeError('.google.protobuf.FileDescriptorProto.source_code_info: object expected');
          message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
        }
        if (object.syntax != null) message.syntax = String(object.syntax);
        return message;
      };

      /**
       * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.dependency = [];
          object.message_type = [];
          object.enum_type = [];
          object.service = [];
          object.extension = [];
          object.public_dependency = [];
          object.weak_dependency = [];
        }
        if (options.defaults) {
          object.name = '';
          object['package'] = '';
          object.options = null;
          object.source_code_info = null;
          object.syntax = '';
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message['package'] != null && message.hasOwnProperty('package')) object['package'] = message['package'];
        if (message.dependency && message.dependency.length) {
          object.dependency = [];
          for (let j = 0; j < message.dependency.length; ++j) object.dependency[j] = message.dependency[j];
        }
        if (message.message_type && message.message_type.length) {
          object.message_type = [];
          for (let j = 0; j < message.message_type.length; ++j)
            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
        }
        if (message.enum_type && message.enum_type.length) {
          object.enum_type = [];
          for (let j = 0; j < message.enum_type.length; ++j)
            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
        }
        if (message.service && message.service.length) {
          object.service = [];
          for (let j = 0; j < message.service.length; ++j)
            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
        }
        if (message.extension && message.extension.length) {
          object.extension = [];
          for (let j = 0; j < message.extension.length; ++j)
            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
        if (message.source_code_info != null && message.hasOwnProperty('source_code_info'))
          object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
        if (message.public_dependency && message.public_dependency.length) {
          object.public_dependency = [];
          for (let j = 0; j < message.public_dependency.length; ++j) object.public_dependency[j] = message.public_dependency[j];
        }
        if (message.weak_dependency && message.weak_dependency.length) {
          object.weak_dependency = [];
          for (let j = 0; j < message.weak_dependency.length; ++j) object.weak_dependency[j] = message.weak_dependency[j];
        }
        if (message.syntax != null && message.hasOwnProperty('syntax')) object.syntax = message.syntax;
        return object;
      };

      /**
       * Converts this FileDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FileDescriptorProto;
    })();

    protobuf.DescriptorProto = (function () {
      /**
       * Properties of a DescriptorProto.
       * @memberof google.protobuf
       * @interface IDescriptorProto
       * @property {string|null} [name] DescriptorProto name
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
       * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
       * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
       * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneof_decl] DescriptorProto oneof_decl
       * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
       * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reserved_range] DescriptorProto reserved_range
       * @property {Array.<string>|null} [reserved_name] DescriptorProto reserved_name
       */

      /**
       * Constructs a new DescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a DescriptorProto.
       * @implements IDescriptorProto
       * @constructor
       * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
       */
      function DescriptorProto(properties) {
        this.field = [];
        this.extension = [];
        this.nested_type = [];
        this.enum_type = [];
        this.extension_range = [];
        this.oneof_decl = [];
        this.reserved_range = [];
        this.reserved_name = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * DescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.name = '';

      /**
       * DescriptorProto field.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.field = $util.emptyArray;

      /**
       * DescriptorProto extension.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.extension = $util.emptyArray;

      /**
       * DescriptorProto nested_type.
       * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.nested_type = $util.emptyArray;

      /**
       * DescriptorProto enum_type.
       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.enum_type = $util.emptyArray;

      /**
       * DescriptorProto extension_range.
       * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.extension_range = $util.emptyArray;

      /**
       * DescriptorProto oneof_decl.
       * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneof_decl
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.oneof_decl = $util.emptyArray;

      /**
       * DescriptorProto options.
       * @member {google.protobuf.IMessageOptions|null|undefined} options
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.options = null;

      /**
       * DescriptorProto reserved_range.
       * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reserved_range
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.reserved_range = $util.emptyArray;

      /**
       * DescriptorProto reserved_name.
       * @member {Array.<string>} reserved_name
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.reserved_name = $util.emptyArray;

      /**
       * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.field != null && message.field.length)
          for (let i = 0; i < message.field.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.nested_type != null && message.nested_type.length)
          for (let i = 0; i < message.nested_type.length; ++i)
            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.enum_type != null && message.enum_type.length)
          for (let i = 0; i < message.enum_type.length; ++i)
            $root.google.protobuf.EnumDescriptorProto.encode(
              message.enum_type[i],
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
        if (message.extension_range != null && message.extension_range.length)
          for (let i = 0; i < message.extension_range.length; ++i)
            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(
              message.extension_range[i],
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
        if (message.extension != null && message.extension.length)
          for (let i = 0; i < message.extension.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(
              message.extension[i],
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.oneof_decl != null && message.oneof_decl.length)
          for (let i = 0; i < message.oneof_decl.length; ++i)
            $root.google.protobuf.OneofDescriptorProto.encode(
              message.oneof_decl[i],
              writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
            ).ldelim();
        if (message.reserved_range != null && message.reserved_range.length)
          for (let i = 0; i < message.reserved_range.length; ++i)
            $root.google.protobuf.DescriptorProto.ReservedRange.encode(
              message.reserved_range[i],
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
        if (message.reserved_name != null && message.reserved_name.length)
          for (let i = 0; i < message.reserved_name.length; ++i)
            writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.reserved_name[i]);
        return writer;
      };

      /**
       * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.DescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.field && message.field.length)) message.field = [];
              message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 6:
              if (!(message.extension && message.extension.length)) message.extension = [];
              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.nested_type && message.nested_type.length)) message.nested_type = [];
              message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
              break;
            case 4:
              if (!(message.enum_type && message.enum_type.length)) message.enum_type = [];
              message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.extension_range && message.extension_range.length)) message.extension_range = [];
              message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
              break;
            case 8:
              if (!(message.oneof_decl && message.oneof_decl.length)) message.oneof_decl = [];
              message.oneof_decl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 7:
              message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
              break;
            case 9:
              if (!(message.reserved_range && message.reserved_range.length)) message.reserved_range = [];
              message.reserved_range.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
              break;
            case 10:
              if (!(message.reserved_name && message.reserved_name.length)) message.reserved_name = [];
              message.reserved_name.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DescriptorProto message.
       * @function verify
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.field != null && message.hasOwnProperty('field')) {
          if (!Array.isArray(message.field)) return 'field: array expected';
          for (let i = 0; i < message.field.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
            if (error) return 'field.' + error;
          }
        }
        if (message.extension != null && message.hasOwnProperty('extension')) {
          if (!Array.isArray(message.extension)) return 'extension: array expected';
          for (let i = 0; i < message.extension.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
            if (error) return 'extension.' + error;
          }
        }
        if (message.nested_type != null && message.hasOwnProperty('nested_type')) {
          if (!Array.isArray(message.nested_type)) return 'nested_type: array expected';
          for (let i = 0; i < message.nested_type.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
            if (error) return 'nested_type.' + error;
          }
        }
        if (message.enum_type != null && message.hasOwnProperty('enum_type')) {
          if (!Array.isArray(message.enum_type)) return 'enum_type: array expected';
          for (let i = 0; i < message.enum_type.length; ++i) {
            let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
            if (error) return 'enum_type.' + error;
          }
        }
        if (message.extension_range != null && message.hasOwnProperty('extension_range')) {
          if (!Array.isArray(message.extension_range)) return 'extension_range: array expected';
          for (let i = 0; i < message.extension_range.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
            if (error) return 'extension_range.' + error;
          }
        }
        if (message.oneof_decl != null && message.hasOwnProperty('oneof_decl')) {
          if (!Array.isArray(message.oneof_decl)) return 'oneof_decl: array expected';
          for (let i = 0; i < message.oneof_decl.length; ++i) {
            let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneof_decl[i]);
            if (error) return 'oneof_decl.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.MessageOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        if (message.reserved_range != null && message.hasOwnProperty('reserved_range')) {
          if (!Array.isArray(message.reserved_range)) return 'reserved_range: array expected';
          for (let i = 0; i < message.reserved_range.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reserved_range[i]);
            if (error) return 'reserved_range.' + error;
          }
        }
        if (message.reserved_name != null && message.hasOwnProperty('reserved_name')) {
          if (!Array.isArray(message.reserved_name)) return 'reserved_name: array expected';
          for (let i = 0; i < message.reserved_name.length; ++i)
            if (!$util.isString(message.reserved_name[i])) return 'reserved_name: string[] expected';
        }
        return null;
      };

      /**
       * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       */
      DescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.DescriptorProto) return object;
        let message = new $root.google.protobuf.DescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.field) {
          if (!Array.isArray(object.field)) throw TypeError('.google.protobuf.DescriptorProto.field: array expected');
          message.field = [];
          for (let i = 0; i < object.field.length; ++i) {
            if (typeof object.field[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.field: object expected');
            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
          }
        }
        if (object.extension) {
          if (!Array.isArray(object.extension)) throw TypeError('.google.protobuf.DescriptorProto.extension: array expected');
          message.extension = [];
          for (let i = 0; i < object.extension.length; ++i) {
            if (typeof object.extension[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.extension: object expected');
            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
          }
        }
        if (object.nested_type) {
          if (!Array.isArray(object.nested_type)) throw TypeError('.google.protobuf.DescriptorProto.nested_type: array expected');
          message.nested_type = [];
          for (let i = 0; i < object.nested_type.length; ++i) {
            if (typeof object.nested_type[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.nested_type: object expected');
            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
          }
        }
        if (object.enum_type) {
          if (!Array.isArray(object.enum_type)) throw TypeError('.google.protobuf.DescriptorProto.enum_type: array expected');
          message.enum_type = [];
          for (let i = 0; i < object.enum_type.length; ++i) {
            if (typeof object.enum_type[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.enum_type: object expected');
            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
          }
        }
        if (object.extension_range) {
          if (!Array.isArray(object.extension_range)) throw TypeError('.google.protobuf.DescriptorProto.extension_range: array expected');
          message.extension_range = [];
          for (let i = 0; i < object.extension_range.length; ++i) {
            if (typeof object.extension_range[i] !== 'object')
              throw TypeError('.google.protobuf.DescriptorProto.extension_range: object expected');
            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
          }
        }
        if (object.oneof_decl) {
          if (!Array.isArray(object.oneof_decl)) throw TypeError('.google.protobuf.DescriptorProto.oneof_decl: array expected');
          message.oneof_decl = [];
          for (let i = 0; i < object.oneof_decl.length; ++i) {
            if (typeof object.oneof_decl[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.oneof_decl: object expected');
            message.oneof_decl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneof_decl[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.DescriptorProto.options: object expected');
          message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
        }
        if (object.reserved_range) {
          if (!Array.isArray(object.reserved_range)) throw TypeError('.google.protobuf.DescriptorProto.reserved_range: array expected');
          message.reserved_range = [];
          for (let i = 0; i < object.reserved_range.length; ++i) {
            if (typeof object.reserved_range[i] !== 'object')
              throw TypeError('.google.protobuf.DescriptorProto.reserved_range: object expected');
            message.reserved_range[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reserved_range[i]);
          }
        }
        if (object.reserved_name) {
          if (!Array.isArray(object.reserved_name)) throw TypeError('.google.protobuf.DescriptorProto.reserved_name: array expected');
          message.reserved_name = [];
          for (let i = 0; i < object.reserved_name.length; ++i) message.reserved_name[i] = String(object.reserved_name[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.DescriptorProto} message DescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.field = [];
          object.nested_type = [];
          object.enum_type = [];
          object.extension_range = [];
          object.extension = [];
          object.oneof_decl = [];
          object.reserved_range = [];
          object.reserved_name = [];
        }
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.field && message.field.length) {
          object.field = [];
          for (let j = 0; j < message.field.length; ++j)
            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
        }
        if (message.nested_type && message.nested_type.length) {
          object.nested_type = [];
          for (let j = 0; j < message.nested_type.length; ++j)
            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
        }
        if (message.enum_type && message.enum_type.length) {
          object.enum_type = [];
          for (let j = 0; j < message.enum_type.length; ++j)
            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
        }
        if (message.extension_range && message.extension_range.length) {
          object.extension_range = [];
          for (let j = 0; j < message.extension_range.length; ++j)
            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
        }
        if (message.extension && message.extension.length) {
          object.extension = [];
          for (let j = 0; j < message.extension.length; ++j)
            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
        if (message.oneof_decl && message.oneof_decl.length) {
          object.oneof_decl = [];
          for (let j = 0; j < message.oneof_decl.length; ++j)
            object.oneof_decl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneof_decl[j], options);
        }
        if (message.reserved_range && message.reserved_range.length) {
          object.reserved_range = [];
          for (let j = 0; j < message.reserved_range.length; ++j)
            object.reserved_range[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reserved_range[j], options);
        }
        if (message.reserved_name && message.reserved_name.length) {
          object.reserved_name = [];
          for (let j = 0; j < message.reserved_name.length; ++j) object.reserved_name[j] = message.reserved_name[j];
        }
        return object;
      };

      /**
       * Converts this DescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.DescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      DescriptorProto.ExtensionRange = (function () {
        /**
         * Properties of an ExtensionRange.
         * @memberof google.protobuf.DescriptorProto
         * @interface IExtensionRange
         * @property {number|null} [start] ExtensionRange start
         * @property {number|null} [end] ExtensionRange end
         */

        /**
         * Constructs a new ExtensionRange.
         * @memberof google.protobuf.DescriptorProto
         * @classdesc Represents an ExtensionRange.
         * @implements IExtensionRange
         * @constructor
         * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
         */
        function ExtensionRange(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExtensionRange start.
         * @member {number} start
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         */
        ExtensionRange.prototype.start = 0;

        /**
         * ExtensionRange end.
         * @member {number} end
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         */
        ExtensionRange.prototype.end = 0;

        /**
         * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtensionRange.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExtensionRange message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtensionRange.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.start = reader.int32();
                break;
              case 2:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExtensionRange message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExtensionRange.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.start != null && message.hasOwnProperty('start'))
            if (!$util.isInteger(message.start)) return 'start: integer expected';
          if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
          return null;
        };

        /**
         * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         */
        ExtensionRange.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange) return object;
          let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
          if (object.start != null) message.start = object.start | 0;
          if (object.end != null) message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExtensionRange.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.start = 0;
            object.end = 0;
          }
          if (message.start != null && message.hasOwnProperty('start')) object.start = message.start;
          if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
          return object;
        };

        /**
         * Converts this ExtensionRange to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExtensionRange.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExtensionRange;
      })();

      DescriptorProto.ReservedRange = (function () {
        /**
         * Properties of a ReservedRange.
         * @memberof google.protobuf.DescriptorProto
         * @interface IReservedRange
         * @property {number|null} [start] ReservedRange start
         * @property {number|null} [end] ReservedRange end
         */

        /**
         * Constructs a new ReservedRange.
         * @memberof google.protobuf.DescriptorProto
         * @classdesc Represents a ReservedRange.
         * @implements IReservedRange
         * @constructor
         * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
         */
        function ReservedRange(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReservedRange start.
         * @member {number} start
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         */
        ReservedRange.prototype.start = 0;

        /**
         * ReservedRange end.
         * @member {number} end
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         */
        ReservedRange.prototype.end = 0;

        /**
         * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReservedRange.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReservedRange message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReservedRange.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.DescriptorProto.ReservedRange();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.start = reader.int32();
                break;
              case 2:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReservedRange.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReservedRange message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReservedRange.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.start != null && message.hasOwnProperty('start'))
            if (!$util.isInteger(message.start)) return 'start: integer expected';
          if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
          return null;
        };

        /**
         * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         */
        ReservedRange.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange) return object;
          let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
          if (object.start != null) message.start = object.start | 0;
          if (object.end != null) message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReservedRange.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.start = 0;
            object.end = 0;
          }
          if (message.start != null && message.hasOwnProperty('start')) object.start = message.start;
          if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
          return object;
        };

        /**
         * Converts this ReservedRange to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReservedRange.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReservedRange;
      })();

      return DescriptorProto;
    })();

    protobuf.FieldDescriptorProto = (function () {
      /**
       * Properties of a FieldDescriptorProto.
       * @memberof google.protobuf
       * @interface IFieldDescriptorProto
       * @property {string|null} [name] FieldDescriptorProto name
       * @property {number|null} [number] FieldDescriptorProto number
       * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
       * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
       * @property {string|null} [type_name] FieldDescriptorProto type_name
       * @property {string|null} [extendee] FieldDescriptorProto extendee
       * @property {string|null} [default_value] FieldDescriptorProto default_value
       * @property {number|null} [oneof_index] FieldDescriptorProto oneof_index
       * @property {string|null} [json_name] FieldDescriptorProto json_name
       * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
       */

      /**
       * Constructs a new FieldDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a FieldDescriptorProto.
       * @implements IFieldDescriptorProto
       * @constructor
       * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
       */
      function FieldDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FieldDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.name = '';

      /**
       * FieldDescriptorProto number.
       * @member {number} number
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.number = 0;

      /**
       * FieldDescriptorProto label.
       * @member {google.protobuf.FieldDescriptorProto.Label} label
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.label = 1;

      /**
       * FieldDescriptorProto type.
       * @member {google.protobuf.FieldDescriptorProto.Type} type
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.type = 1;

      /**
       * FieldDescriptorProto type_name.
       * @member {string} type_name
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.type_name = '';

      /**
       * FieldDescriptorProto extendee.
       * @member {string} extendee
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.extendee = '';

      /**
       * FieldDescriptorProto default_value.
       * @member {string} default_value
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.default_value = '';

      /**
       * FieldDescriptorProto oneof_index.
       * @member {number} oneof_index
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.oneof_index = 0;

      /**
       * FieldDescriptorProto json_name.
       * @member {string} json_name
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.json_name = '';

      /**
       * FieldDescriptorProto options.
       * @member {google.protobuf.IFieldOptions|null|undefined} options
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.extendee != null && Object.hasOwnProperty.call(message, 'extendee'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.extendee);
        if (message.number != null && Object.hasOwnProperty.call(message, 'number'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.number);
        if (message.label != null && Object.hasOwnProperty.call(message, 'label'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.label);
        if (message.type != null && Object.hasOwnProperty.call(message, 'type'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.type);
        if (message.type_name != null && Object.hasOwnProperty.call(message, 'type_name'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.type_name);
        if (message.default_value != null && Object.hasOwnProperty.call(message, 'default_value'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.default_value);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.oneof_index != null && Object.hasOwnProperty.call(message, 'oneof_index'))
          writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.oneof_index);
        if (message.json_name != null && Object.hasOwnProperty.call(message, 'json_name'))
          writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.json_name);
        return writer;
      };

      /**
       * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FieldDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FieldDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 3:
              message.number = reader.int32();
              break;
            case 4:
              message.label = reader.int32();
              break;
            case 5:
              message.type = reader.int32();
              break;
            case 6:
              message.type_name = reader.string();
              break;
            case 2:
              message.extendee = reader.string();
              break;
            case 7:
              message.default_value = reader.string();
              break;
            case 9:
              message.oneof_index = reader.int32();
              break;
            case 10:
              message.json_name = reader.string();
              break;
            case 8:
              message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FieldDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FieldDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.number != null && message.hasOwnProperty('number'))
          if (!$util.isInteger(message.number)) return 'number: integer expected';
        if (message.label != null && message.hasOwnProperty('label'))
          switch (message.label) {
            default:
              return 'label: enum value expected';
            case 1:
            case 2:
            case 3:
              break;
          }
        if (message.type != null && message.hasOwnProperty('type'))
          switch (message.type) {
            default:
              return 'type: enum value expected';
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
              break;
          }
        if (message.type_name != null && message.hasOwnProperty('type_name'))
          if (!$util.isString(message.type_name)) return 'type_name: string expected';
        if (message.extendee != null && message.hasOwnProperty('extendee'))
          if (!$util.isString(message.extendee)) return 'extendee: string expected';
        if (message.default_value != null && message.hasOwnProperty('default_value'))
          if (!$util.isString(message.default_value)) return 'default_value: string expected';
        if (message.oneof_index != null && message.hasOwnProperty('oneof_index'))
          if (!$util.isInteger(message.oneof_index)) return 'oneof_index: integer expected';
        if (message.json_name != null && message.hasOwnProperty('json_name'))
          if (!$util.isString(message.json_name)) return 'json_name: string expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.FieldOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       */
      FieldDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FieldDescriptorProto) return object;
        let message = new $root.google.protobuf.FieldDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.number != null) message.number = object.number | 0;
        switch (object.label) {
          case 'LABEL_OPTIONAL':
          case 1:
            message.label = 1;
            break;
          case 'LABEL_REQUIRED':
          case 2:
            message.label = 2;
            break;
          case 'LABEL_REPEATED':
          case 3:
            message.label = 3;
            break;
        }
        switch (object.type) {
          case 'TYPE_DOUBLE':
          case 1:
            message.type = 1;
            break;
          case 'TYPE_FLOAT':
          case 2:
            message.type = 2;
            break;
          case 'TYPE_INT64':
          case 3:
            message.type = 3;
            break;
          case 'TYPE_UINT64':
          case 4:
            message.type = 4;
            break;
          case 'TYPE_INT32':
          case 5:
            message.type = 5;
            break;
          case 'TYPE_FIXED64':
          case 6:
            message.type = 6;
            break;
          case 'TYPE_FIXED32':
          case 7:
            message.type = 7;
            break;
          case 'TYPE_BOOL':
          case 8:
            message.type = 8;
            break;
          case 'TYPE_STRING':
          case 9:
            message.type = 9;
            break;
          case 'TYPE_GROUP':
          case 10:
            message.type = 10;
            break;
          case 'TYPE_MESSAGE':
          case 11:
            message.type = 11;
            break;
          case 'TYPE_BYTES':
          case 12:
            message.type = 12;
            break;
          case 'TYPE_UINT32':
          case 13:
            message.type = 13;
            break;
          case 'TYPE_ENUM':
          case 14:
            message.type = 14;
            break;
          case 'TYPE_SFIXED32':
          case 15:
            message.type = 15;
            break;
          case 'TYPE_SFIXED64':
          case 16:
            message.type = 16;
            break;
          case 'TYPE_SINT32':
          case 17:
            message.type = 17;
            break;
          case 'TYPE_SINT64':
          case 18:
            message.type = 18;
            break;
        }
        if (object.type_name != null) message.type_name = String(object.type_name);
        if (object.extendee != null) message.extendee = String(object.extendee);
        if (object.default_value != null) message.default_value = String(object.default_value);
        if (object.oneof_index != null) message.oneof_index = object.oneof_index | 0;
        if (object.json_name != null) message.json_name = String(object.json_name);
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.FieldDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FieldDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.extendee = '';
          object.number = 0;
          object.label = options.enums === String ? 'LABEL_OPTIONAL' : 1;
          object.type = options.enums === String ? 'TYPE_DOUBLE' : 1;
          object.type_name = '';
          object.default_value = '';
          object.options = null;
          object.oneof_index = 0;
          object.json_name = '';
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.extendee != null && message.hasOwnProperty('extendee')) object.extendee = message.extendee;
        if (message.number != null && message.hasOwnProperty('number')) object.number = message.number;
        if (message.label != null && message.hasOwnProperty('label'))
          object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
        if (message.type != null && message.hasOwnProperty('type'))
          object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
        if (message.type_name != null && message.hasOwnProperty('type_name')) object.type_name = message.type_name;
        if (message.default_value != null && message.hasOwnProperty('default_value')) object.default_value = message.default_value;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
        if (message.oneof_index != null && message.hasOwnProperty('oneof_index')) object.oneof_index = message.oneof_index;
        if (message.json_name != null && message.hasOwnProperty('json_name')) object.json_name = message.json_name;
        return object;
      };

      /**
       * Converts this FieldDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FieldDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * Type enum.
       * @name google.protobuf.FieldDescriptorProto.Type
       * @enum {number}
       * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
       * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
       * @property {number} TYPE_INT64=3 TYPE_INT64 value
       * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
       * @property {number} TYPE_INT32=5 TYPE_INT32 value
       * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
       * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
       * @property {number} TYPE_BOOL=8 TYPE_BOOL value
       * @property {number} TYPE_STRING=9 TYPE_STRING value
       * @property {number} TYPE_GROUP=10 TYPE_GROUP value
       * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
       * @property {number} TYPE_BYTES=12 TYPE_BYTES value
       * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
       * @property {number} TYPE_ENUM=14 TYPE_ENUM value
       * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
       * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
       * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
       * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
       */
      FieldDescriptorProto.Type = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[1] = 'TYPE_DOUBLE')] = 1;
        values[(valuesById[2] = 'TYPE_FLOAT')] = 2;
        values[(valuesById[3] = 'TYPE_INT64')] = 3;
        values[(valuesById[4] = 'TYPE_UINT64')] = 4;
        values[(valuesById[5] = 'TYPE_INT32')] = 5;
        values[(valuesById[6] = 'TYPE_FIXED64')] = 6;
        values[(valuesById[7] = 'TYPE_FIXED32')] = 7;
        values[(valuesById[8] = 'TYPE_BOOL')] = 8;
        values[(valuesById[9] = 'TYPE_STRING')] = 9;
        values[(valuesById[10] = 'TYPE_GROUP')] = 10;
        values[(valuesById[11] = 'TYPE_MESSAGE')] = 11;
        values[(valuesById[12] = 'TYPE_BYTES')] = 12;
        values[(valuesById[13] = 'TYPE_UINT32')] = 13;
        values[(valuesById[14] = 'TYPE_ENUM')] = 14;
        values[(valuesById[15] = 'TYPE_SFIXED32')] = 15;
        values[(valuesById[16] = 'TYPE_SFIXED64')] = 16;
        values[(valuesById[17] = 'TYPE_SINT32')] = 17;
        values[(valuesById[18] = 'TYPE_SINT64')] = 18;
        return values;
      })();

      /**
       * Label enum.
       * @name google.protobuf.FieldDescriptorProto.Label
       * @enum {number}
       * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
       * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
       * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
       */
      FieldDescriptorProto.Label = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[1] = 'LABEL_OPTIONAL')] = 1;
        values[(valuesById[2] = 'LABEL_REQUIRED')] = 2;
        values[(valuesById[3] = 'LABEL_REPEATED')] = 3;
        return values;
      })();

      return FieldDescriptorProto;
    })();

    protobuf.OneofDescriptorProto = (function () {
      /**
       * Properties of an OneofDescriptorProto.
       * @memberof google.protobuf
       * @interface IOneofDescriptorProto
       * @property {string|null} [name] OneofDescriptorProto name
       * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
       */

      /**
       * Constructs a new OneofDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an OneofDescriptorProto.
       * @implements IOneofDescriptorProto
       * @constructor
       * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
       */
      function OneofDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * OneofDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       */
      OneofDescriptorProto.prototype.name = '';

      /**
       * OneofDescriptorProto options.
       * @member {google.protobuf.IOneofOptions|null|undefined} options
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       */
      OneofDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OneofDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.OneofDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OneofDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OneofDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.OneofOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       */
      OneofDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.OneofDescriptorProto) return object;
        let message = new $root.google.protobuf.OneofDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.OneofDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OneofDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this OneofDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OneofDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OneofDescriptorProto;
    })();

    protobuf.EnumDescriptorProto = (function () {
      /**
       * Properties of an EnumDescriptorProto.
       * @memberof google.protobuf
       * @interface IEnumDescriptorProto
       * @property {string|null} [name] EnumDescriptorProto name
       * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
       * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
       */

      /**
       * Constructs a new EnumDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an EnumDescriptorProto.
       * @implements IEnumDescriptorProto
       * @constructor
       * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
       */
      function EnumDescriptorProto(properties) {
        this.value = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.name = '';

      /**
       * EnumDescriptorProto value.
       * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.value = $util.emptyArray;

      /**
       * EnumDescriptorProto options.
       * @member {google.protobuf.IEnumOptions|null|undefined} options
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.value != null && message.value.length)
          for (let i = 0; i < message.value.length; ++i)
            $root.google.protobuf.EnumValueDescriptorProto.encode(
              message.value[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.value && message.value.length)) message.value = [];
              message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.value != null && message.hasOwnProperty('value')) {
          if (!Array.isArray(message.value)) return 'value: array expected';
          for (let i = 0; i < message.value.length; ++i) {
            let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
            if (error) return 'value.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.EnumOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       */
      EnumDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumDescriptorProto) return object;
        let message = new $root.google.protobuf.EnumDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.value) {
          if (!Array.isArray(object.value)) throw TypeError('.google.protobuf.EnumDescriptorProto.value: array expected');
          message.value = [];
          for (let i = 0; i < object.value.length; ++i) {
            if (typeof object.value[i] !== 'object') throw TypeError('.google.protobuf.EnumDescriptorProto.value: object expected');
            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.EnumDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.value = [];
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.value && message.value.length) {
          object.value = [];
          for (let j = 0; j < message.value.length; ++j)
            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this EnumDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumDescriptorProto;
    })();

    protobuf.EnumValueDescriptorProto = (function () {
      /**
       * Properties of an EnumValueDescriptorProto.
       * @memberof google.protobuf
       * @interface IEnumValueDescriptorProto
       * @property {string|null} [name] EnumValueDescriptorProto name
       * @property {number|null} [number] EnumValueDescriptorProto number
       * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
       */

      /**
       * Constructs a new EnumValueDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an EnumValueDescriptorProto.
       * @implements IEnumValueDescriptorProto
       * @constructor
       * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
       */
      function EnumValueDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumValueDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.name = '';

      /**
       * EnumValueDescriptorProto number.
       * @member {number} number
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.number = 0;

      /**
       * EnumValueDescriptorProto options.
       * @member {google.protobuf.IEnumValueOptions|null|undefined} options
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.number != null && Object.hasOwnProperty.call(message, 'number'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.number);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumValueDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.number = reader.int32();
              break;
            case 3:
              message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumValueDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumValueDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.number != null && message.hasOwnProperty('number'))
          if (!$util.isInteger(message.number)) return 'number: integer expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       */
      EnumValueDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumValueDescriptorProto) return object;
        let message = new $root.google.protobuf.EnumValueDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.number != null) message.number = object.number | 0;
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.EnumValueDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumValueDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.number = 0;
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.number != null && message.hasOwnProperty('number')) object.number = message.number;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this EnumValueDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumValueDescriptorProto;
    })();

    protobuf.ServiceDescriptorProto = (function () {
      /**
       * Properties of a ServiceDescriptorProto.
       * @memberof google.protobuf
       * @interface IServiceDescriptorProto
       * @property {string|null} [name] ServiceDescriptorProto name
       * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
       * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
       */

      /**
       * Constructs a new ServiceDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a ServiceDescriptorProto.
       * @implements IServiceDescriptorProto
       * @constructor
       * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
       */
      function ServiceDescriptorProto(properties) {
        this.method = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ServiceDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.name = '';

      /**
       * ServiceDescriptorProto method.
       * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.method = $util.emptyArray;

      /**
       * ServiceDescriptorProto options.
       * @member {google.protobuf.IServiceOptions|null|undefined} options
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.method != null && message.method.length)
          for (let i = 0; i < message.method.length; ++i)
            $root.google.protobuf.MethodDescriptorProto.encode(
              message.method[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.ServiceDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.method && message.method.length)) message.method = [];
              message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ServiceDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ServiceDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.method != null && message.hasOwnProperty('method')) {
          if (!Array.isArray(message.method)) return 'method: array expected';
          for (let i = 0; i < message.method.length; ++i) {
            let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
            if (error) return 'method.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.ServiceOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       */
      ServiceDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.ServiceDescriptorProto) return object;
        let message = new $root.google.protobuf.ServiceDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.method) {
          if (!Array.isArray(object.method)) throw TypeError('.google.protobuf.ServiceDescriptorProto.method: array expected');
          message.method = [];
          for (let i = 0; i < object.method.length; ++i) {
            if (typeof object.method[i] !== 'object') throw TypeError('.google.protobuf.ServiceDescriptorProto.method: object expected');
            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.ServiceDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ServiceDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.method = [];
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.method && message.method.length) {
          object.method = [];
          for (let j = 0; j < message.method.length; ++j)
            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this ServiceDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ServiceDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ServiceDescriptorProto;
    })();

    protobuf.MethodDescriptorProto = (function () {
      /**
       * Properties of a MethodDescriptorProto.
       * @memberof google.protobuf
       * @interface IMethodDescriptorProto
       * @property {string|null} [name] MethodDescriptorProto name
       * @property {string|null} [input_type] MethodDescriptorProto input_type
       * @property {string|null} [output_type] MethodDescriptorProto output_type
       * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
       * @property {boolean|null} [client_streaming] MethodDescriptorProto client_streaming
       * @property {boolean|null} [server_streaming] MethodDescriptorProto server_streaming
       */

      /**
       * Constructs a new MethodDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a MethodDescriptorProto.
       * @implements IMethodDescriptorProto
       * @constructor
       * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
       */
      function MethodDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MethodDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.name = '';

      /**
       * MethodDescriptorProto input_type.
       * @member {string} input_type
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.input_type = '';

      /**
       * MethodDescriptorProto output_type.
       * @member {string} output_type
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.output_type = '';

      /**
       * MethodDescriptorProto options.
       * @member {google.protobuf.IMethodOptions|null|undefined} options
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.options = null;

      /**
       * MethodDescriptorProto client_streaming.
       * @member {boolean} client_streaming
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.client_streaming = false;

      /**
       * MethodDescriptorProto server_streaming.
       * @member {boolean} server_streaming
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.server_streaming = false;

      /**
       * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.input_type != null && Object.hasOwnProperty.call(message, 'input_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.input_type);
        if (message.output_type != null && Object.hasOwnProperty.call(message, 'output_type'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.output_type);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.client_streaming != null && Object.hasOwnProperty.call(message, 'client_streaming'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.client_streaming);
        if (message.server_streaming != null && Object.hasOwnProperty.call(message, 'server_streaming'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.server_streaming);
        return writer;
      };

      /**
       * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MethodDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.MethodDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.input_type = reader.string();
              break;
            case 3:
              message.output_type = reader.string();
              break;
            case 4:
              message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
              break;
            case 5:
              message.client_streaming = reader.bool();
              break;
            case 6:
              message.server_streaming = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MethodDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MethodDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.input_type != null && message.hasOwnProperty('input_type'))
          if (!$util.isString(message.input_type)) return 'input_type: string expected';
        if (message.output_type != null && message.hasOwnProperty('output_type'))
          if (!$util.isString(message.output_type)) return 'output_type: string expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.MethodOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        if (message.client_streaming != null && message.hasOwnProperty('client_streaming'))
          if (typeof message.client_streaming !== 'boolean') return 'client_streaming: boolean expected';
        if (message.server_streaming != null && message.hasOwnProperty('server_streaming'))
          if (typeof message.server_streaming !== 'boolean') return 'server_streaming: boolean expected';
        return null;
      };

      /**
       * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       */
      MethodDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MethodDescriptorProto) return object;
        let message = new $root.google.protobuf.MethodDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.input_type != null) message.input_type = String(object.input_type);
        if (object.output_type != null) message.output_type = String(object.output_type);
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.MethodDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
        }
        if (object.client_streaming != null) message.client_streaming = Boolean(object.client_streaming);
        if (object.server_streaming != null) message.server_streaming = Boolean(object.server_streaming);
        return message;
      };

      /**
       * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MethodDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.input_type = '';
          object.output_type = '';
          object.options = null;
          object.client_streaming = false;
          object.server_streaming = false;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.input_type != null && message.hasOwnProperty('input_type')) object.input_type = message.input_type;
        if (message.output_type != null && message.hasOwnProperty('output_type')) object.output_type = message.output_type;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
        if (message.client_streaming != null && message.hasOwnProperty('client_streaming'))
          object.client_streaming = message.client_streaming;
        if (message.server_streaming != null && message.hasOwnProperty('server_streaming'))
          object.server_streaming = message.server_streaming;
        return object;
      };

      /**
       * Converts this MethodDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MethodDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MethodDescriptorProto;
    })();

    protobuf.FileOptions = (function () {
      /**
       * Properties of a FileOptions.
       * @memberof google.protobuf
       * @interface IFileOptions
       * @property {string|null} [java_package] FileOptions java_package
       * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
       * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
       * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
       * @property {boolean|null} [java_string_check_utf8] FileOptions java_string_check_utf8
       * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
       * @property {string|null} [go_package] FileOptions go_package
       * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
       * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
       * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
       * @property {boolean|null} [deprecated] FileOptions deprecated
       * @property {boolean|null} [cc_enable_arenas] FileOptions cc_enable_arenas
       * @property {string|null} [objc_class_prefix] FileOptions objc_class_prefix
       * @property {string|null} [csharp_namespace] FileOptions csharp_namespace
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
       * @property {boolean|null} [".gogoproto.goproto_getters_all"] FileOptions .gogoproto.goproto_getters_all
       * @property {boolean|null} [".gogoproto.goproto_enum_prefix_all"] FileOptions .gogoproto.goproto_enum_prefix_all
       * @property {boolean|null} [".gogoproto.goproto_stringer_all"] FileOptions .gogoproto.goproto_stringer_all
       * @property {boolean|null} [".gogoproto.verbose_equal_all"] FileOptions .gogoproto.verbose_equal_all
       * @property {boolean|null} [".gogoproto.face_all"] FileOptions .gogoproto.face_all
       * @property {boolean|null} [".gogoproto.gostring_all"] FileOptions .gogoproto.gostring_all
       * @property {boolean|null} [".gogoproto.populate_all"] FileOptions .gogoproto.populate_all
       * @property {boolean|null} [".gogoproto.stringer_all"] FileOptions .gogoproto.stringer_all
       * @property {boolean|null} [".gogoproto.onlyone_all"] FileOptions .gogoproto.onlyone_all
       * @property {boolean|null} [".gogoproto.equal_all"] FileOptions .gogoproto.equal_all
       * @property {boolean|null} [".gogoproto.description_all"] FileOptions .gogoproto.description_all
       * @property {boolean|null} [".gogoproto.testgen_all"] FileOptions .gogoproto.testgen_all
       * @property {boolean|null} [".gogoproto.benchgen_all"] FileOptions .gogoproto.benchgen_all
       * @property {boolean|null} [".gogoproto.marshaler_all"] FileOptions .gogoproto.marshaler_all
       * @property {boolean|null} [".gogoproto.unmarshaler_all"] FileOptions .gogoproto.unmarshaler_all
       * @property {boolean|null} [".gogoproto.stable_marshaler_all"] FileOptions .gogoproto.stable_marshaler_all
       * @property {boolean|null} [".gogoproto.sizer_all"] FileOptions .gogoproto.sizer_all
       * @property {boolean|null} [".gogoproto.goproto_enum_stringer_all"] FileOptions .gogoproto.goproto_enum_stringer_all
       * @property {boolean|null} [".gogoproto.enum_stringer_all"] FileOptions .gogoproto.enum_stringer_all
       * @property {boolean|null} [".gogoproto.unsafe_marshaler_all"] FileOptions .gogoproto.unsafe_marshaler_all
       * @property {boolean|null} [".gogoproto.unsafe_unmarshaler_all"] FileOptions .gogoproto.unsafe_unmarshaler_all
       * @property {boolean|null} [".gogoproto.goproto_extensions_map_all"] FileOptions .gogoproto.goproto_extensions_map_all
       * @property {boolean|null} [".gogoproto.goproto_unrecognized_all"] FileOptions .gogoproto.goproto_unrecognized_all
       * @property {boolean|null} [".gogoproto.gogoproto_import"] FileOptions .gogoproto.gogoproto_import
       * @property {boolean|null} [".gogoproto.protosizer_all"] FileOptions .gogoproto.protosizer_all
       * @property {boolean|null} [".gogoproto.compare_all"] FileOptions .gogoproto.compare_all
       * @property {boolean|null} [".gogoproto.typedecl_all"] FileOptions .gogoproto.typedecl_all
       * @property {boolean|null} [".gogoproto.enumdecl_all"] FileOptions .gogoproto.enumdecl_all
       * @property {boolean|null} [".gogoproto.goproto_registration"] FileOptions .gogoproto.goproto_registration
       * @property {boolean|null} [".gogoproto.messagename_all"] FileOptions .gogoproto.messagename_all
       * @property {boolean|null} [".gogoproto.goproto_sizecache_all"] FileOptions .gogoproto.goproto_sizecache_all
       * @property {boolean|null} [".gogoproto.goproto_unkeyed_all"] FileOptions .gogoproto.goproto_unkeyed_all
       */

      /**
       * Constructs a new FileOptions.
       * @memberof google.protobuf
       * @classdesc Represents a FileOptions.
       * @implements IFileOptions
       * @constructor
       * @param {google.protobuf.IFileOptions=} [properties] Properties to set
       */
      function FileOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileOptions java_package.
       * @member {string} java_package
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_package = '';

      /**
       * FileOptions java_outer_classname.
       * @member {string} java_outer_classname
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_outer_classname = '';

      /**
       * FileOptions java_multiple_files.
       * @member {boolean} java_multiple_files
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_multiple_files = false;

      /**
       * FileOptions java_generate_equals_and_hash.
       * @member {boolean} java_generate_equals_and_hash
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_generate_equals_and_hash = false;

      /**
       * FileOptions java_string_check_utf8.
       * @member {boolean} java_string_check_utf8
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_string_check_utf8 = false;

      /**
       * FileOptions optimize_for.
       * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.optimize_for = 1;

      /**
       * FileOptions go_package.
       * @member {string} go_package
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.go_package = '';

      /**
       * FileOptions cc_generic_services.
       * @member {boolean} cc_generic_services
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.cc_generic_services = false;

      /**
       * FileOptions java_generic_services.
       * @member {boolean} java_generic_services
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_generic_services = false;

      /**
       * FileOptions py_generic_services.
       * @member {boolean} py_generic_services
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.py_generic_services = false;

      /**
       * FileOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.deprecated = false;

      /**
       * FileOptions cc_enable_arenas.
       * @member {boolean} cc_enable_arenas
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.cc_enable_arenas = false;

      /**
       * FileOptions objc_class_prefix.
       * @member {string} objc_class_prefix
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.objc_class_prefix = '';

      /**
       * FileOptions csharp_namespace.
       * @member {string} csharp_namespace
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.csharp_namespace = '';

      /**
       * FileOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * FileOptions .gogoproto.goproto_getters_all.
       * @member {boolean} .gogoproto.goproto_getters_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_getters_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_enum_prefix_all.
       * @member {boolean} .gogoproto.goproto_enum_prefix_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_enum_prefix_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_stringer_all.
       * @member {boolean} .gogoproto.goproto_stringer_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_stringer_all'] = false;

      /**
       * FileOptions .gogoproto.verbose_equal_all.
       * @member {boolean} .gogoproto.verbose_equal_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.verbose_equal_all'] = false;

      /**
       * FileOptions .gogoproto.face_all.
       * @member {boolean} .gogoproto.face_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.face_all'] = false;

      /**
       * FileOptions .gogoproto.gostring_all.
       * @member {boolean} .gogoproto.gostring_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.gostring_all'] = false;

      /**
       * FileOptions .gogoproto.populate_all.
       * @member {boolean} .gogoproto.populate_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.populate_all'] = false;

      /**
       * FileOptions .gogoproto.stringer_all.
       * @member {boolean} .gogoproto.stringer_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.stringer_all'] = false;

      /**
       * FileOptions .gogoproto.onlyone_all.
       * @member {boolean} .gogoproto.onlyone_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.onlyone_all'] = false;

      /**
       * FileOptions .gogoproto.equal_all.
       * @member {boolean} .gogoproto.equal_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.equal_all'] = false;

      /**
       * FileOptions .gogoproto.description_all.
       * @member {boolean} .gogoproto.description_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.description_all'] = false;

      /**
       * FileOptions .gogoproto.testgen_all.
       * @member {boolean} .gogoproto.testgen_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.testgen_all'] = false;

      /**
       * FileOptions .gogoproto.benchgen_all.
       * @member {boolean} .gogoproto.benchgen_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.benchgen_all'] = false;

      /**
       * FileOptions .gogoproto.marshaler_all.
       * @member {boolean} .gogoproto.marshaler_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.marshaler_all'] = false;

      /**
       * FileOptions .gogoproto.unmarshaler_all.
       * @member {boolean} .gogoproto.unmarshaler_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.unmarshaler_all'] = false;

      /**
       * FileOptions .gogoproto.stable_marshaler_all.
       * @member {boolean} .gogoproto.stable_marshaler_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.stable_marshaler_all'] = false;

      /**
       * FileOptions .gogoproto.sizer_all.
       * @member {boolean} .gogoproto.sizer_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.sizer_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_enum_stringer_all.
       * @member {boolean} .gogoproto.goproto_enum_stringer_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_enum_stringer_all'] = false;

      /**
       * FileOptions .gogoproto.enum_stringer_all.
       * @member {boolean} .gogoproto.enum_stringer_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.enum_stringer_all'] = false;

      /**
       * FileOptions .gogoproto.unsafe_marshaler_all.
       * @member {boolean} .gogoproto.unsafe_marshaler_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.unsafe_marshaler_all'] = false;

      /**
       * FileOptions .gogoproto.unsafe_unmarshaler_all.
       * @member {boolean} .gogoproto.unsafe_unmarshaler_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.unsafe_unmarshaler_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_extensions_map_all.
       * @member {boolean} .gogoproto.goproto_extensions_map_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_extensions_map_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_unrecognized_all.
       * @member {boolean} .gogoproto.goproto_unrecognized_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_unrecognized_all'] = false;

      /**
       * FileOptions .gogoproto.gogoproto_import.
       * @member {boolean} .gogoproto.gogoproto_import
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.gogoproto_import'] = false;

      /**
       * FileOptions .gogoproto.protosizer_all.
       * @member {boolean} .gogoproto.protosizer_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.protosizer_all'] = false;

      /**
       * FileOptions .gogoproto.compare_all.
       * @member {boolean} .gogoproto.compare_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.compare_all'] = false;

      /**
       * FileOptions .gogoproto.typedecl_all.
       * @member {boolean} .gogoproto.typedecl_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.typedecl_all'] = false;

      /**
       * FileOptions .gogoproto.enumdecl_all.
       * @member {boolean} .gogoproto.enumdecl_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.enumdecl_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_registration.
       * @member {boolean} .gogoproto.goproto_registration
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_registration'] = false;

      /**
       * FileOptions .gogoproto.messagename_all.
       * @member {boolean} .gogoproto.messagename_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.messagename_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_sizecache_all.
       * @member {boolean} .gogoproto.goproto_sizecache_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_sizecache_all'] = false;

      /**
       * FileOptions .gogoproto.goproto_unkeyed_all.
       * @member {boolean} .gogoproto.goproto_unkeyed_all
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype['.gogoproto.goproto_unkeyed_all'] = false;

      /**
       * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.java_package != null && Object.hasOwnProperty.call(message, 'java_package'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.java_package);
        if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, 'java_outer_classname'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.java_outer_classname);
        if (message.optimize_for != null && Object.hasOwnProperty.call(message, 'optimize_for'))
          writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.optimize_for);
        if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, 'java_multiple_files'))
          writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.java_multiple_files);
        if (message.go_package != null && Object.hasOwnProperty.call(message, 'go_package'))
          writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.go_package);
        if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, 'cc_generic_services'))
          writer.uint32(/* id 16, wireType 0 =*/ 128).bool(message.cc_generic_services);
        if (message.java_generic_services != null && Object.hasOwnProperty.call(message, 'java_generic_services'))
          writer.uint32(/* id 17, wireType 0 =*/ 136).bool(message.java_generic_services);
        if (message.py_generic_services != null && Object.hasOwnProperty.call(message, 'py_generic_services'))
          writer.uint32(/* id 18, wireType 0 =*/ 144).bool(message.py_generic_services);
        if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, 'java_generate_equals_and_hash'))
          writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.java_generate_equals_and_hash);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 23, wireType 0 =*/ 184).bool(message.deprecated);
        if (message.java_string_check_utf8 != null && Object.hasOwnProperty.call(message, 'java_string_check_utf8'))
          writer.uint32(/* id 27, wireType 0 =*/ 216).bool(message.java_string_check_utf8);
        if (message.cc_enable_arenas != null && Object.hasOwnProperty.call(message, 'cc_enable_arenas'))
          writer.uint32(/* id 31, wireType 0 =*/ 248).bool(message.cc_enable_arenas);
        if (message.objc_class_prefix != null && Object.hasOwnProperty.call(message, 'objc_class_prefix'))
          writer.uint32(/* id 36, wireType 2 =*/ 290).string(message.objc_class_prefix);
        if (message.csharp_namespace != null && Object.hasOwnProperty.call(message, 'csharp_namespace'))
          writer.uint32(/* id 37, wireType 2 =*/ 298).string(message.csharp_namespace);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.gogoproto.goproto_getters_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_getters_all'))
          writer.uint32(/* id 63001, wireType 0 =*/ 504008).bool(message['.gogoproto.goproto_getters_all']);
        if (
          message['.gogoproto.goproto_enum_prefix_all'] != null &&
          Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_prefix_all')
        )
          writer.uint32(/* id 63002, wireType 0 =*/ 504016).bool(message['.gogoproto.goproto_enum_prefix_all']);
        if (message['.gogoproto.goproto_stringer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_stringer_all'))
          writer.uint32(/* id 63003, wireType 0 =*/ 504024).bool(message['.gogoproto.goproto_stringer_all']);
        if (message['.gogoproto.verbose_equal_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.verbose_equal_all'))
          writer.uint32(/* id 63004, wireType 0 =*/ 504032).bool(message['.gogoproto.verbose_equal_all']);
        if (message['.gogoproto.face_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.face_all'))
          writer.uint32(/* id 63005, wireType 0 =*/ 504040).bool(message['.gogoproto.face_all']);
        if (message['.gogoproto.gostring_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.gostring_all'))
          writer.uint32(/* id 63006, wireType 0 =*/ 504048).bool(message['.gogoproto.gostring_all']);
        if (message['.gogoproto.populate_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.populate_all'))
          writer.uint32(/* id 63007, wireType 0 =*/ 504056).bool(message['.gogoproto.populate_all']);
        if (message['.gogoproto.stringer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stringer_all'))
          writer.uint32(/* id 63008, wireType 0 =*/ 504064).bool(message['.gogoproto.stringer_all']);
        if (message['.gogoproto.onlyone_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.onlyone_all'))
          writer.uint32(/* id 63009, wireType 0 =*/ 504072).bool(message['.gogoproto.onlyone_all']);
        if (message['.gogoproto.equal_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.equal_all'))
          writer.uint32(/* id 63013, wireType 0 =*/ 504104).bool(message['.gogoproto.equal_all']);
        if (message['.gogoproto.description_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.description_all'))
          writer.uint32(/* id 63014, wireType 0 =*/ 504112).bool(message['.gogoproto.description_all']);
        if (message['.gogoproto.testgen_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.testgen_all'))
          writer.uint32(/* id 63015, wireType 0 =*/ 504120).bool(message['.gogoproto.testgen_all']);
        if (message['.gogoproto.benchgen_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.benchgen_all'))
          writer.uint32(/* id 63016, wireType 0 =*/ 504128).bool(message['.gogoproto.benchgen_all']);
        if (message['.gogoproto.marshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.marshaler_all'))
          writer.uint32(/* id 63017, wireType 0 =*/ 504136).bool(message['.gogoproto.marshaler_all']);
        if (message['.gogoproto.unmarshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unmarshaler_all'))
          writer.uint32(/* id 63018, wireType 0 =*/ 504144).bool(message['.gogoproto.unmarshaler_all']);
        if (message['.gogoproto.stable_marshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stable_marshaler_all'))
          writer.uint32(/* id 63019, wireType 0 =*/ 504152).bool(message['.gogoproto.stable_marshaler_all']);
        if (message['.gogoproto.sizer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.sizer_all'))
          writer.uint32(/* id 63020, wireType 0 =*/ 504160).bool(message['.gogoproto.sizer_all']);
        if (
          message['.gogoproto.goproto_enum_stringer_all'] != null &&
          Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_stringer_all')
        )
          writer.uint32(/* id 63021, wireType 0 =*/ 504168).bool(message['.gogoproto.goproto_enum_stringer_all']);
        if (message['.gogoproto.enum_stringer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enum_stringer_all'))
          writer.uint32(/* id 63022, wireType 0 =*/ 504176).bool(message['.gogoproto.enum_stringer_all']);
        if (message['.gogoproto.unsafe_marshaler_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unsafe_marshaler_all'))
          writer.uint32(/* id 63023, wireType 0 =*/ 504184).bool(message['.gogoproto.unsafe_marshaler_all']);
        if (
          message['.gogoproto.unsafe_unmarshaler_all'] != null &&
          Object.hasOwnProperty.call(message, '.gogoproto.unsafe_unmarshaler_all')
        )
          writer.uint32(/* id 63024, wireType 0 =*/ 504192).bool(message['.gogoproto.unsafe_unmarshaler_all']);
        if (
          message['.gogoproto.goproto_extensions_map_all'] != null &&
          Object.hasOwnProperty.call(message, '.gogoproto.goproto_extensions_map_all')
        )
          writer.uint32(/* id 63025, wireType 0 =*/ 504200).bool(message['.gogoproto.goproto_extensions_map_all']);
        if (
          message['.gogoproto.goproto_unrecognized_all'] != null &&
          Object.hasOwnProperty.call(message, '.gogoproto.goproto_unrecognized_all')
        )
          writer.uint32(/* id 63026, wireType 0 =*/ 504208).bool(message['.gogoproto.goproto_unrecognized_all']);
        if (message['.gogoproto.gogoproto_import'] != null && Object.hasOwnProperty.call(message, '.gogoproto.gogoproto_import'))
          writer.uint32(/* id 63027, wireType 0 =*/ 504216).bool(message['.gogoproto.gogoproto_import']);
        if (message['.gogoproto.protosizer_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.protosizer_all'))
          writer.uint32(/* id 63028, wireType 0 =*/ 504224).bool(message['.gogoproto.protosizer_all']);
        if (message['.gogoproto.compare_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.compare_all'))
          writer.uint32(/* id 63029, wireType 0 =*/ 504232).bool(message['.gogoproto.compare_all']);
        if (message['.gogoproto.typedecl_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.typedecl_all'))
          writer.uint32(/* id 63030, wireType 0 =*/ 504240).bool(message['.gogoproto.typedecl_all']);
        if (message['.gogoproto.enumdecl_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enumdecl_all'))
          writer.uint32(/* id 63031, wireType 0 =*/ 504248).bool(message['.gogoproto.enumdecl_all']);
        if (message['.gogoproto.goproto_registration'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_registration'))
          writer.uint32(/* id 63032, wireType 0 =*/ 504256).bool(message['.gogoproto.goproto_registration']);
        if (message['.gogoproto.messagename_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.messagename_all'))
          writer.uint32(/* id 63033, wireType 0 =*/ 504264).bool(message['.gogoproto.messagename_all']);
        if (message['.gogoproto.goproto_sizecache_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_sizecache_all'))
          writer.uint32(/* id 63034, wireType 0 =*/ 504272).bool(message['.gogoproto.goproto_sizecache_all']);
        if (message['.gogoproto.goproto_unkeyed_all'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_unkeyed_all'))
          writer.uint32(/* id 63035, wireType 0 =*/ 504280).bool(message['.gogoproto.goproto_unkeyed_all']);
        return writer;
      };

      /**
       * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileOptions} FileOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FileOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.java_package = reader.string();
              break;
            case 8:
              message.java_outer_classname = reader.string();
              break;
            case 10:
              message.java_multiple_files = reader.bool();
              break;
            case 20:
              message.java_generate_equals_and_hash = reader.bool();
              break;
            case 27:
              message.java_string_check_utf8 = reader.bool();
              break;
            case 9:
              message.optimize_for = reader.int32();
              break;
            case 11:
              message.go_package = reader.string();
              break;
            case 16:
              message.cc_generic_services = reader.bool();
              break;
            case 17:
              message.java_generic_services = reader.bool();
              break;
            case 18:
              message.py_generic_services = reader.bool();
              break;
            case 23:
              message.deprecated = reader.bool();
              break;
            case 31:
              message.cc_enable_arenas = reader.bool();
              break;
            case 36:
              message.objc_class_prefix = reader.string();
              break;
            case 37:
              message.csharp_namespace = reader.string();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 63001:
              message['.gogoproto.goproto_getters_all'] = reader.bool();
              break;
            case 63002:
              message['.gogoproto.goproto_enum_prefix_all'] = reader.bool();
              break;
            case 63003:
              message['.gogoproto.goproto_stringer_all'] = reader.bool();
              break;
            case 63004:
              message['.gogoproto.verbose_equal_all'] = reader.bool();
              break;
            case 63005:
              message['.gogoproto.face_all'] = reader.bool();
              break;
            case 63006:
              message['.gogoproto.gostring_all'] = reader.bool();
              break;
            case 63007:
              message['.gogoproto.populate_all'] = reader.bool();
              break;
            case 63008:
              message['.gogoproto.stringer_all'] = reader.bool();
              break;
            case 63009:
              message['.gogoproto.onlyone_all'] = reader.bool();
              break;
            case 63013:
              message['.gogoproto.equal_all'] = reader.bool();
              break;
            case 63014:
              message['.gogoproto.description_all'] = reader.bool();
              break;
            case 63015:
              message['.gogoproto.testgen_all'] = reader.bool();
              break;
            case 63016:
              message['.gogoproto.benchgen_all'] = reader.bool();
              break;
            case 63017:
              message['.gogoproto.marshaler_all'] = reader.bool();
              break;
            case 63018:
              message['.gogoproto.unmarshaler_all'] = reader.bool();
              break;
            case 63019:
              message['.gogoproto.stable_marshaler_all'] = reader.bool();
              break;
            case 63020:
              message['.gogoproto.sizer_all'] = reader.bool();
              break;
            case 63021:
              message['.gogoproto.goproto_enum_stringer_all'] = reader.bool();
              break;
            case 63022:
              message['.gogoproto.enum_stringer_all'] = reader.bool();
              break;
            case 63023:
              message['.gogoproto.unsafe_marshaler_all'] = reader.bool();
              break;
            case 63024:
              message['.gogoproto.unsafe_unmarshaler_all'] = reader.bool();
              break;
            case 63025:
              message['.gogoproto.goproto_extensions_map_all'] = reader.bool();
              break;
            case 63026:
              message['.gogoproto.goproto_unrecognized_all'] = reader.bool();
              break;
            case 63027:
              message['.gogoproto.gogoproto_import'] = reader.bool();
              break;
            case 63028:
              message['.gogoproto.protosizer_all'] = reader.bool();
              break;
            case 63029:
              message['.gogoproto.compare_all'] = reader.bool();
              break;
            case 63030:
              message['.gogoproto.typedecl_all'] = reader.bool();
              break;
            case 63031:
              message['.gogoproto.enumdecl_all'] = reader.bool();
              break;
            case 63032:
              message['.gogoproto.goproto_registration'] = reader.bool();
              break;
            case 63033:
              message['.gogoproto.messagename_all'] = reader.bool();
              break;
            case 63034:
              message['.gogoproto.goproto_sizecache_all'] = reader.bool();
              break;
            case 63035:
              message['.gogoproto.goproto_unkeyed_all'] = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileOptions} FileOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileOptions message.
       * @function verify
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.java_package != null && message.hasOwnProperty('java_package'))
          if (!$util.isString(message.java_package)) return 'java_package: string expected';
        if (message.java_outer_classname != null && message.hasOwnProperty('java_outer_classname'))
          if (!$util.isString(message.java_outer_classname)) return 'java_outer_classname: string expected';
        if (message.java_multiple_files != null && message.hasOwnProperty('java_multiple_files'))
          if (typeof message.java_multiple_files !== 'boolean') return 'java_multiple_files: boolean expected';
        if (message.java_generate_equals_and_hash != null && message.hasOwnProperty('java_generate_equals_and_hash'))
          if (typeof message.java_generate_equals_and_hash !== 'boolean') return 'java_generate_equals_and_hash: boolean expected';
        if (message.java_string_check_utf8 != null && message.hasOwnProperty('java_string_check_utf8'))
          if (typeof message.java_string_check_utf8 !== 'boolean') return 'java_string_check_utf8: boolean expected';
        if (message.optimize_for != null && message.hasOwnProperty('optimize_for'))
          switch (message.optimize_for) {
            default:
              return 'optimize_for: enum value expected';
            case 1:
            case 2:
            case 3:
              break;
          }
        if (message.go_package != null && message.hasOwnProperty('go_package'))
          if (!$util.isString(message.go_package)) return 'go_package: string expected';
        if (message.cc_generic_services != null && message.hasOwnProperty('cc_generic_services'))
          if (typeof message.cc_generic_services !== 'boolean') return 'cc_generic_services: boolean expected';
        if (message.java_generic_services != null && message.hasOwnProperty('java_generic_services'))
          if (typeof message.java_generic_services !== 'boolean') return 'java_generic_services: boolean expected';
        if (message.py_generic_services != null && message.hasOwnProperty('py_generic_services'))
          if (typeof message.py_generic_services !== 'boolean') return 'py_generic_services: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.cc_enable_arenas != null && message.hasOwnProperty('cc_enable_arenas'))
          if (typeof message.cc_enable_arenas !== 'boolean') return 'cc_enable_arenas: boolean expected';
        if (message.objc_class_prefix != null && message.hasOwnProperty('objc_class_prefix'))
          if (!$util.isString(message.objc_class_prefix)) return 'objc_class_prefix: string expected';
        if (message.csharp_namespace != null && message.hasOwnProperty('csharp_namespace'))
          if (!$util.isString(message.csharp_namespace)) return 'csharp_namespace: string expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.gogoproto.goproto_getters_all'] != null && message.hasOwnProperty('.gogoproto.goproto_getters_all'))
          if (typeof message['.gogoproto.goproto_getters_all'] !== 'boolean') return '.gogoproto.goproto_getters_all: boolean expected';
        if (message['.gogoproto.goproto_enum_prefix_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix_all'))
          if (typeof message['.gogoproto.goproto_enum_prefix_all'] !== 'boolean')
            return '.gogoproto.goproto_enum_prefix_all: boolean expected';
        if (message['.gogoproto.goproto_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer_all'))
          if (typeof message['.gogoproto.goproto_stringer_all'] !== 'boolean') return '.gogoproto.goproto_stringer_all: boolean expected';
        if (message['.gogoproto.verbose_equal_all'] != null && message.hasOwnProperty('.gogoproto.verbose_equal_all'))
          if (typeof message['.gogoproto.verbose_equal_all'] !== 'boolean') return '.gogoproto.verbose_equal_all: boolean expected';
        if (message['.gogoproto.face_all'] != null && message.hasOwnProperty('.gogoproto.face_all'))
          if (typeof message['.gogoproto.face_all'] !== 'boolean') return '.gogoproto.face_all: boolean expected';
        if (message['.gogoproto.gostring_all'] != null && message.hasOwnProperty('.gogoproto.gostring_all'))
          if (typeof message['.gogoproto.gostring_all'] !== 'boolean') return '.gogoproto.gostring_all: boolean expected';
        if (message['.gogoproto.populate_all'] != null && message.hasOwnProperty('.gogoproto.populate_all'))
          if (typeof message['.gogoproto.populate_all'] !== 'boolean') return '.gogoproto.populate_all: boolean expected';
        if (message['.gogoproto.stringer_all'] != null && message.hasOwnProperty('.gogoproto.stringer_all'))
          if (typeof message['.gogoproto.stringer_all'] !== 'boolean') return '.gogoproto.stringer_all: boolean expected';
        if (message['.gogoproto.onlyone_all'] != null && message.hasOwnProperty('.gogoproto.onlyone_all'))
          if (typeof message['.gogoproto.onlyone_all'] !== 'boolean') return '.gogoproto.onlyone_all: boolean expected';
        if (message['.gogoproto.equal_all'] != null && message.hasOwnProperty('.gogoproto.equal_all'))
          if (typeof message['.gogoproto.equal_all'] !== 'boolean') return '.gogoproto.equal_all: boolean expected';
        if (message['.gogoproto.description_all'] != null && message.hasOwnProperty('.gogoproto.description_all'))
          if (typeof message['.gogoproto.description_all'] !== 'boolean') return '.gogoproto.description_all: boolean expected';
        if (message['.gogoproto.testgen_all'] != null && message.hasOwnProperty('.gogoproto.testgen_all'))
          if (typeof message['.gogoproto.testgen_all'] !== 'boolean') return '.gogoproto.testgen_all: boolean expected';
        if (message['.gogoproto.benchgen_all'] != null && message.hasOwnProperty('.gogoproto.benchgen_all'))
          if (typeof message['.gogoproto.benchgen_all'] !== 'boolean') return '.gogoproto.benchgen_all: boolean expected';
        if (message['.gogoproto.marshaler_all'] != null && message.hasOwnProperty('.gogoproto.marshaler_all'))
          if (typeof message['.gogoproto.marshaler_all'] !== 'boolean') return '.gogoproto.marshaler_all: boolean expected';
        if (message['.gogoproto.unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unmarshaler_all'))
          if (typeof message['.gogoproto.unmarshaler_all'] !== 'boolean') return '.gogoproto.unmarshaler_all: boolean expected';
        if (message['.gogoproto.stable_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler_all'))
          if (typeof message['.gogoproto.stable_marshaler_all'] !== 'boolean') return '.gogoproto.stable_marshaler_all: boolean expected';
        if (message['.gogoproto.sizer_all'] != null && message.hasOwnProperty('.gogoproto.sizer_all'))
          if (typeof message['.gogoproto.sizer_all'] !== 'boolean') return '.gogoproto.sizer_all: boolean expected';
        if (message['.gogoproto.goproto_enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer_all'))
          if (typeof message['.gogoproto.goproto_enum_stringer_all'] !== 'boolean')
            return '.gogoproto.goproto_enum_stringer_all: boolean expected';
        if (message['.gogoproto.enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.enum_stringer_all'))
          if (typeof message['.gogoproto.enum_stringer_all'] !== 'boolean') return '.gogoproto.enum_stringer_all: boolean expected';
        if (message['.gogoproto.unsafe_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler_all'))
          if (typeof message['.gogoproto.unsafe_marshaler_all'] !== 'boolean') return '.gogoproto.unsafe_marshaler_all: boolean expected';
        if (message['.gogoproto.unsafe_unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler_all'))
          if (typeof message['.gogoproto.unsafe_unmarshaler_all'] !== 'boolean')
            return '.gogoproto.unsafe_unmarshaler_all: boolean expected';
        if (message['.gogoproto.goproto_extensions_map_all'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map_all'))
          if (typeof message['.gogoproto.goproto_extensions_map_all'] !== 'boolean')
            return '.gogoproto.goproto_extensions_map_all: boolean expected';
        if (message['.gogoproto.goproto_unrecognized_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized_all'))
          if (typeof message['.gogoproto.goproto_unrecognized_all'] !== 'boolean')
            return '.gogoproto.goproto_unrecognized_all: boolean expected';
        if (message['.gogoproto.gogoproto_import'] != null && message.hasOwnProperty('.gogoproto.gogoproto_import'))
          if (typeof message['.gogoproto.gogoproto_import'] !== 'boolean') return '.gogoproto.gogoproto_import: boolean expected';
        if (message['.gogoproto.protosizer_all'] != null && message.hasOwnProperty('.gogoproto.protosizer_all'))
          if (typeof message['.gogoproto.protosizer_all'] !== 'boolean') return '.gogoproto.protosizer_all: boolean expected';
        if (message['.gogoproto.compare_all'] != null && message.hasOwnProperty('.gogoproto.compare_all'))
          if (typeof message['.gogoproto.compare_all'] !== 'boolean') return '.gogoproto.compare_all: boolean expected';
        if (message['.gogoproto.typedecl_all'] != null && message.hasOwnProperty('.gogoproto.typedecl_all'))
          if (typeof message['.gogoproto.typedecl_all'] !== 'boolean') return '.gogoproto.typedecl_all: boolean expected';
        if (message['.gogoproto.enumdecl_all'] != null && message.hasOwnProperty('.gogoproto.enumdecl_all'))
          if (typeof message['.gogoproto.enumdecl_all'] !== 'boolean') return '.gogoproto.enumdecl_all: boolean expected';
        if (message['.gogoproto.goproto_registration'] != null && message.hasOwnProperty('.gogoproto.goproto_registration'))
          if (typeof message['.gogoproto.goproto_registration'] !== 'boolean') return '.gogoproto.goproto_registration: boolean expected';
        if (message['.gogoproto.messagename_all'] != null && message.hasOwnProperty('.gogoproto.messagename_all'))
          if (typeof message['.gogoproto.messagename_all'] !== 'boolean') return '.gogoproto.messagename_all: boolean expected';
        if (message['.gogoproto.goproto_sizecache_all'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache_all'))
          if (typeof message['.gogoproto.goproto_sizecache_all'] !== 'boolean') return '.gogoproto.goproto_sizecache_all: boolean expected';
        if (message['.gogoproto.goproto_unkeyed_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed_all'))
          if (typeof message['.gogoproto.goproto_unkeyed_all'] !== 'boolean') return '.gogoproto.goproto_unkeyed_all: boolean expected';
        return null;
      };

      /**
       * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileOptions} FileOptions
       */
      FileOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileOptions) return object;
        let message = new $root.google.protobuf.FileOptions();
        if (object.java_package != null) message.java_package = String(object.java_package);
        if (object.java_outer_classname != null) message.java_outer_classname = String(object.java_outer_classname);
        if (object.java_multiple_files != null) message.java_multiple_files = Boolean(object.java_multiple_files);
        if (object.java_generate_equals_and_hash != null)
          message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
        if (object.java_string_check_utf8 != null) message.java_string_check_utf8 = Boolean(object.java_string_check_utf8);
        switch (object.optimize_for) {
          case 'SPEED':
          case 1:
            message.optimize_for = 1;
            break;
          case 'CODE_SIZE':
          case 2:
            message.optimize_for = 2;
            break;
          case 'LITE_RUNTIME':
          case 3:
            message.optimize_for = 3;
            break;
        }
        if (object.go_package != null) message.go_package = String(object.go_package);
        if (object.cc_generic_services != null) message.cc_generic_services = Boolean(object.cc_generic_services);
        if (object.java_generic_services != null) message.java_generic_services = Boolean(object.java_generic_services);
        if (object.py_generic_services != null) message.py_generic_services = Boolean(object.py_generic_services);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.cc_enable_arenas != null) message.cc_enable_arenas = Boolean(object.cc_enable_arenas);
        if (object.objc_class_prefix != null) message.objc_class_prefix = String(object.objc_class_prefix);
        if (object.csharp_namespace != null) message.csharp_namespace = String(object.csharp_namespace);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.FileOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.FileOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.gogoproto.goproto_getters_all'] != null)
          message['.gogoproto.goproto_getters_all'] = Boolean(object['.gogoproto.goproto_getters_all']);
        if (object['.gogoproto.goproto_enum_prefix_all'] != null)
          message['.gogoproto.goproto_enum_prefix_all'] = Boolean(object['.gogoproto.goproto_enum_prefix_all']);
        if (object['.gogoproto.goproto_stringer_all'] != null)
          message['.gogoproto.goproto_stringer_all'] = Boolean(object['.gogoproto.goproto_stringer_all']);
        if (object['.gogoproto.verbose_equal_all'] != null)
          message['.gogoproto.verbose_equal_all'] = Boolean(object['.gogoproto.verbose_equal_all']);
        if (object['.gogoproto.face_all'] != null) message['.gogoproto.face_all'] = Boolean(object['.gogoproto.face_all']);
        if (object['.gogoproto.gostring_all'] != null) message['.gogoproto.gostring_all'] = Boolean(object['.gogoproto.gostring_all']);
        if (object['.gogoproto.populate_all'] != null) message['.gogoproto.populate_all'] = Boolean(object['.gogoproto.populate_all']);
        if (object['.gogoproto.stringer_all'] != null) message['.gogoproto.stringer_all'] = Boolean(object['.gogoproto.stringer_all']);
        if (object['.gogoproto.onlyone_all'] != null) message['.gogoproto.onlyone_all'] = Boolean(object['.gogoproto.onlyone_all']);
        if (object['.gogoproto.equal_all'] != null) message['.gogoproto.equal_all'] = Boolean(object['.gogoproto.equal_all']);
        if (object['.gogoproto.description_all'] != null)
          message['.gogoproto.description_all'] = Boolean(object['.gogoproto.description_all']);
        if (object['.gogoproto.testgen_all'] != null) message['.gogoproto.testgen_all'] = Boolean(object['.gogoproto.testgen_all']);
        if (object['.gogoproto.benchgen_all'] != null) message['.gogoproto.benchgen_all'] = Boolean(object['.gogoproto.benchgen_all']);
        if (object['.gogoproto.marshaler_all'] != null) message['.gogoproto.marshaler_all'] = Boolean(object['.gogoproto.marshaler_all']);
        if (object['.gogoproto.unmarshaler_all'] != null)
          message['.gogoproto.unmarshaler_all'] = Boolean(object['.gogoproto.unmarshaler_all']);
        if (object['.gogoproto.stable_marshaler_all'] != null)
          message['.gogoproto.stable_marshaler_all'] = Boolean(object['.gogoproto.stable_marshaler_all']);
        if (object['.gogoproto.sizer_all'] != null) message['.gogoproto.sizer_all'] = Boolean(object['.gogoproto.sizer_all']);
        if (object['.gogoproto.goproto_enum_stringer_all'] != null)
          message['.gogoproto.goproto_enum_stringer_all'] = Boolean(object['.gogoproto.goproto_enum_stringer_all']);
        if (object['.gogoproto.enum_stringer_all'] != null)
          message['.gogoproto.enum_stringer_all'] = Boolean(object['.gogoproto.enum_stringer_all']);
        if (object['.gogoproto.unsafe_marshaler_all'] != null)
          message['.gogoproto.unsafe_marshaler_all'] = Boolean(object['.gogoproto.unsafe_marshaler_all']);
        if (object['.gogoproto.unsafe_unmarshaler_all'] != null)
          message['.gogoproto.unsafe_unmarshaler_all'] = Boolean(object['.gogoproto.unsafe_unmarshaler_all']);
        if (object['.gogoproto.goproto_extensions_map_all'] != null)
          message['.gogoproto.goproto_extensions_map_all'] = Boolean(object['.gogoproto.goproto_extensions_map_all']);
        if (object['.gogoproto.goproto_unrecognized_all'] != null)
          message['.gogoproto.goproto_unrecognized_all'] = Boolean(object['.gogoproto.goproto_unrecognized_all']);
        if (object['.gogoproto.gogoproto_import'] != null)
          message['.gogoproto.gogoproto_import'] = Boolean(object['.gogoproto.gogoproto_import']);
        if (object['.gogoproto.protosizer_all'] != null)
          message['.gogoproto.protosizer_all'] = Boolean(object['.gogoproto.protosizer_all']);
        if (object['.gogoproto.compare_all'] != null) message['.gogoproto.compare_all'] = Boolean(object['.gogoproto.compare_all']);
        if (object['.gogoproto.typedecl_all'] != null) message['.gogoproto.typedecl_all'] = Boolean(object['.gogoproto.typedecl_all']);
        if (object['.gogoproto.enumdecl_all'] != null) message['.gogoproto.enumdecl_all'] = Boolean(object['.gogoproto.enumdecl_all']);
        if (object['.gogoproto.goproto_registration'] != null)
          message['.gogoproto.goproto_registration'] = Boolean(object['.gogoproto.goproto_registration']);
        if (object['.gogoproto.messagename_all'] != null)
          message['.gogoproto.messagename_all'] = Boolean(object['.gogoproto.messagename_all']);
        if (object['.gogoproto.goproto_sizecache_all'] != null)
          message['.gogoproto.goproto_sizecache_all'] = Boolean(object['.gogoproto.goproto_sizecache_all']);
        if (object['.gogoproto.goproto_unkeyed_all'] != null)
          message['.gogoproto.goproto_unkeyed_all'] = Boolean(object['.gogoproto.goproto_unkeyed_all']);
        return message;
      };

      /**
       * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.FileOptions} message FileOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.java_package = '';
          object.java_outer_classname = '';
          object.optimize_for = options.enums === String ? 'SPEED' : 1;
          object.java_multiple_files = false;
          object.go_package = '';
          object.cc_generic_services = false;
          object.java_generic_services = false;
          object.py_generic_services = false;
          object.java_generate_equals_and_hash = false;
          object.deprecated = false;
          object.java_string_check_utf8 = false;
          object.cc_enable_arenas = false;
          object.objc_class_prefix = '';
          object.csharp_namespace = '';
          object['.gogoproto.goproto_getters_all'] = false;
          object['.gogoproto.goproto_enum_prefix_all'] = false;
          object['.gogoproto.goproto_stringer_all'] = false;
          object['.gogoproto.verbose_equal_all'] = false;
          object['.gogoproto.face_all'] = false;
          object['.gogoproto.gostring_all'] = false;
          object['.gogoproto.populate_all'] = false;
          object['.gogoproto.stringer_all'] = false;
          object['.gogoproto.onlyone_all'] = false;
          object['.gogoproto.equal_all'] = false;
          object['.gogoproto.description_all'] = false;
          object['.gogoproto.testgen_all'] = false;
          object['.gogoproto.benchgen_all'] = false;
          object['.gogoproto.marshaler_all'] = false;
          object['.gogoproto.unmarshaler_all'] = false;
          object['.gogoproto.stable_marshaler_all'] = false;
          object['.gogoproto.sizer_all'] = false;
          object['.gogoproto.goproto_enum_stringer_all'] = false;
          object['.gogoproto.enum_stringer_all'] = false;
          object['.gogoproto.unsafe_marshaler_all'] = false;
          object['.gogoproto.unsafe_unmarshaler_all'] = false;
          object['.gogoproto.goproto_extensions_map_all'] = false;
          object['.gogoproto.goproto_unrecognized_all'] = false;
          object['.gogoproto.gogoproto_import'] = false;
          object['.gogoproto.protosizer_all'] = false;
          object['.gogoproto.compare_all'] = false;
          object['.gogoproto.typedecl_all'] = false;
          object['.gogoproto.enumdecl_all'] = false;
          object['.gogoproto.goproto_registration'] = false;
          object['.gogoproto.messagename_all'] = false;
          object['.gogoproto.goproto_sizecache_all'] = false;
          object['.gogoproto.goproto_unkeyed_all'] = false;
        }
        if (message.java_package != null && message.hasOwnProperty('java_package')) object.java_package = message.java_package;
        if (message.java_outer_classname != null && message.hasOwnProperty('java_outer_classname'))
          object.java_outer_classname = message.java_outer_classname;
        if (message.optimize_for != null && message.hasOwnProperty('optimize_for'))
          object.optimize_for =
            options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
        if (message.java_multiple_files != null && message.hasOwnProperty('java_multiple_files'))
          object.java_multiple_files = message.java_multiple_files;
        if (message.go_package != null && message.hasOwnProperty('go_package')) object.go_package = message.go_package;
        if (message.cc_generic_services != null && message.hasOwnProperty('cc_generic_services'))
          object.cc_generic_services = message.cc_generic_services;
        if (message.java_generic_services != null && message.hasOwnProperty('java_generic_services'))
          object.java_generic_services = message.java_generic_services;
        if (message.py_generic_services != null && message.hasOwnProperty('py_generic_services'))
          object.py_generic_services = message.py_generic_services;
        if (message.java_generate_equals_and_hash != null && message.hasOwnProperty('java_generate_equals_and_hash'))
          object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.java_string_check_utf8 != null && message.hasOwnProperty('java_string_check_utf8'))
          object.java_string_check_utf8 = message.java_string_check_utf8;
        if (message.cc_enable_arenas != null && message.hasOwnProperty('cc_enable_arenas'))
          object.cc_enable_arenas = message.cc_enable_arenas;
        if (message.objc_class_prefix != null && message.hasOwnProperty('objc_class_prefix'))
          object.objc_class_prefix = message.objc_class_prefix;
        if (message.csharp_namespace != null && message.hasOwnProperty('csharp_namespace'))
          object.csharp_namespace = message.csharp_namespace;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.gogoproto.goproto_getters_all'] != null && message.hasOwnProperty('.gogoproto.goproto_getters_all'))
          object['.gogoproto.goproto_getters_all'] = message['.gogoproto.goproto_getters_all'];
        if (message['.gogoproto.goproto_enum_prefix_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix_all'))
          object['.gogoproto.goproto_enum_prefix_all'] = message['.gogoproto.goproto_enum_prefix_all'];
        if (message['.gogoproto.goproto_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer_all'))
          object['.gogoproto.goproto_stringer_all'] = message['.gogoproto.goproto_stringer_all'];
        if (message['.gogoproto.verbose_equal_all'] != null && message.hasOwnProperty('.gogoproto.verbose_equal_all'))
          object['.gogoproto.verbose_equal_all'] = message['.gogoproto.verbose_equal_all'];
        if (message['.gogoproto.face_all'] != null && message.hasOwnProperty('.gogoproto.face_all'))
          object['.gogoproto.face_all'] = message['.gogoproto.face_all'];
        if (message['.gogoproto.gostring_all'] != null && message.hasOwnProperty('.gogoproto.gostring_all'))
          object['.gogoproto.gostring_all'] = message['.gogoproto.gostring_all'];
        if (message['.gogoproto.populate_all'] != null && message.hasOwnProperty('.gogoproto.populate_all'))
          object['.gogoproto.populate_all'] = message['.gogoproto.populate_all'];
        if (message['.gogoproto.stringer_all'] != null && message.hasOwnProperty('.gogoproto.stringer_all'))
          object['.gogoproto.stringer_all'] = message['.gogoproto.stringer_all'];
        if (message['.gogoproto.onlyone_all'] != null && message.hasOwnProperty('.gogoproto.onlyone_all'))
          object['.gogoproto.onlyone_all'] = message['.gogoproto.onlyone_all'];
        if (message['.gogoproto.equal_all'] != null && message.hasOwnProperty('.gogoproto.equal_all'))
          object['.gogoproto.equal_all'] = message['.gogoproto.equal_all'];
        if (message['.gogoproto.description_all'] != null && message.hasOwnProperty('.gogoproto.description_all'))
          object['.gogoproto.description_all'] = message['.gogoproto.description_all'];
        if (message['.gogoproto.testgen_all'] != null && message.hasOwnProperty('.gogoproto.testgen_all'))
          object['.gogoproto.testgen_all'] = message['.gogoproto.testgen_all'];
        if (message['.gogoproto.benchgen_all'] != null && message.hasOwnProperty('.gogoproto.benchgen_all'))
          object['.gogoproto.benchgen_all'] = message['.gogoproto.benchgen_all'];
        if (message['.gogoproto.marshaler_all'] != null && message.hasOwnProperty('.gogoproto.marshaler_all'))
          object['.gogoproto.marshaler_all'] = message['.gogoproto.marshaler_all'];
        if (message['.gogoproto.unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unmarshaler_all'))
          object['.gogoproto.unmarshaler_all'] = message['.gogoproto.unmarshaler_all'];
        if (message['.gogoproto.stable_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler_all'))
          object['.gogoproto.stable_marshaler_all'] = message['.gogoproto.stable_marshaler_all'];
        if (message['.gogoproto.sizer_all'] != null && message.hasOwnProperty('.gogoproto.sizer_all'))
          object['.gogoproto.sizer_all'] = message['.gogoproto.sizer_all'];
        if (message['.gogoproto.goproto_enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer_all'))
          object['.gogoproto.goproto_enum_stringer_all'] = message['.gogoproto.goproto_enum_stringer_all'];
        if (message['.gogoproto.enum_stringer_all'] != null && message.hasOwnProperty('.gogoproto.enum_stringer_all'))
          object['.gogoproto.enum_stringer_all'] = message['.gogoproto.enum_stringer_all'];
        if (message['.gogoproto.unsafe_marshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler_all'))
          object['.gogoproto.unsafe_marshaler_all'] = message['.gogoproto.unsafe_marshaler_all'];
        if (message['.gogoproto.unsafe_unmarshaler_all'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler_all'))
          object['.gogoproto.unsafe_unmarshaler_all'] = message['.gogoproto.unsafe_unmarshaler_all'];
        if (message['.gogoproto.goproto_extensions_map_all'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map_all'))
          object['.gogoproto.goproto_extensions_map_all'] = message['.gogoproto.goproto_extensions_map_all'];
        if (message['.gogoproto.goproto_unrecognized_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized_all'))
          object['.gogoproto.goproto_unrecognized_all'] = message['.gogoproto.goproto_unrecognized_all'];
        if (message['.gogoproto.gogoproto_import'] != null && message.hasOwnProperty('.gogoproto.gogoproto_import'))
          object['.gogoproto.gogoproto_import'] = message['.gogoproto.gogoproto_import'];
        if (message['.gogoproto.protosizer_all'] != null && message.hasOwnProperty('.gogoproto.protosizer_all'))
          object['.gogoproto.protosizer_all'] = message['.gogoproto.protosizer_all'];
        if (message['.gogoproto.compare_all'] != null && message.hasOwnProperty('.gogoproto.compare_all'))
          object['.gogoproto.compare_all'] = message['.gogoproto.compare_all'];
        if (message['.gogoproto.typedecl_all'] != null && message.hasOwnProperty('.gogoproto.typedecl_all'))
          object['.gogoproto.typedecl_all'] = message['.gogoproto.typedecl_all'];
        if (message['.gogoproto.enumdecl_all'] != null && message.hasOwnProperty('.gogoproto.enumdecl_all'))
          object['.gogoproto.enumdecl_all'] = message['.gogoproto.enumdecl_all'];
        if (message['.gogoproto.goproto_registration'] != null && message.hasOwnProperty('.gogoproto.goproto_registration'))
          object['.gogoproto.goproto_registration'] = message['.gogoproto.goproto_registration'];
        if (message['.gogoproto.messagename_all'] != null && message.hasOwnProperty('.gogoproto.messagename_all'))
          object['.gogoproto.messagename_all'] = message['.gogoproto.messagename_all'];
        if (message['.gogoproto.goproto_sizecache_all'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache_all'))
          object['.gogoproto.goproto_sizecache_all'] = message['.gogoproto.goproto_sizecache_all'];
        if (message['.gogoproto.goproto_unkeyed_all'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed_all'))
          object['.gogoproto.goproto_unkeyed_all'] = message['.gogoproto.goproto_unkeyed_all'];
        return object;
      };

      /**
       * Converts this FileOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * OptimizeMode enum.
       * @name google.protobuf.FileOptions.OptimizeMode
       * @enum {number}
       * @property {number} SPEED=1 SPEED value
       * @property {number} CODE_SIZE=2 CODE_SIZE value
       * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
       */
      FileOptions.OptimizeMode = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[1] = 'SPEED')] = 1;
        values[(valuesById[2] = 'CODE_SIZE')] = 2;
        values[(valuesById[3] = 'LITE_RUNTIME')] = 3;
        return values;
      })();

      return FileOptions;
    })();

    protobuf.MessageOptions = (function () {
      /**
       * Properties of a MessageOptions.
       * @memberof google.protobuf
       * @interface IMessageOptions
       * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
       * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
       * @property {boolean|null} [deprecated] MessageOptions deprecated
       * @property {boolean|null} [map_entry] MessageOptions map_entry
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
       * @property {string|null} [".cosmos_proto.interface_type"] MessageOptions .cosmos_proto.interface_type
       * @property {string|null} [".cosmos_proto.implements_interface"] MessageOptions .cosmos_proto.implements_interface
       * @property {boolean|null} [".gogoproto.goproto_getters"] MessageOptions .gogoproto.goproto_getters
       * @property {boolean|null} [".gogoproto.goproto_stringer"] MessageOptions .gogoproto.goproto_stringer
       * @property {boolean|null} [".gogoproto.verbose_equal"] MessageOptions .gogoproto.verbose_equal
       * @property {boolean|null} [".gogoproto.face"] MessageOptions .gogoproto.face
       * @property {boolean|null} [".gogoproto.gostring"] MessageOptions .gogoproto.gostring
       * @property {boolean|null} [".gogoproto.populate"] MessageOptions .gogoproto.populate
       * @property {boolean|null} [".gogoproto.stringer"] MessageOptions .gogoproto.stringer
       * @property {boolean|null} [".gogoproto.onlyone"] MessageOptions .gogoproto.onlyone
       * @property {boolean|null} [".gogoproto.equal"] MessageOptions .gogoproto.equal
       * @property {boolean|null} [".gogoproto.description"] MessageOptions .gogoproto.description
       * @property {boolean|null} [".gogoproto.testgen"] MessageOptions .gogoproto.testgen
       * @property {boolean|null} [".gogoproto.benchgen"] MessageOptions .gogoproto.benchgen
       * @property {boolean|null} [".gogoproto.marshaler"] MessageOptions .gogoproto.marshaler
       * @property {boolean|null} [".gogoproto.unmarshaler"] MessageOptions .gogoproto.unmarshaler
       * @property {boolean|null} [".gogoproto.stable_marshaler"] MessageOptions .gogoproto.stable_marshaler
       * @property {boolean|null} [".gogoproto.sizer"] MessageOptions .gogoproto.sizer
       * @property {boolean|null} [".gogoproto.unsafe_marshaler"] MessageOptions .gogoproto.unsafe_marshaler
       * @property {boolean|null} [".gogoproto.unsafe_unmarshaler"] MessageOptions .gogoproto.unsafe_unmarshaler
       * @property {boolean|null} [".gogoproto.goproto_extensions_map"] MessageOptions .gogoproto.goproto_extensions_map
       * @property {boolean|null} [".gogoproto.goproto_unrecognized"] MessageOptions .gogoproto.goproto_unrecognized
       * @property {boolean|null} [".gogoproto.protosizer"] MessageOptions .gogoproto.protosizer
       * @property {boolean|null} [".gogoproto.compare"] MessageOptions .gogoproto.compare
       * @property {boolean|null} [".gogoproto.typedecl"] MessageOptions .gogoproto.typedecl
       * @property {boolean|null} [".gogoproto.messagename"] MessageOptions .gogoproto.messagename
       * @property {boolean|null} [".gogoproto.goproto_sizecache"] MessageOptions .gogoproto.goproto_sizecache
       * @property {boolean|null} [".gogoproto.goproto_unkeyed"] MessageOptions .gogoproto.goproto_unkeyed
       */

      /**
       * Constructs a new MessageOptions.
       * @memberof google.protobuf
       * @classdesc Represents a MessageOptions.
       * @implements IMessageOptions
       * @constructor
       * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
       */
      function MessageOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MessageOptions message_set_wire_format.
       * @member {boolean} message_set_wire_format
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.message_set_wire_format = false;

      /**
       * MessageOptions no_standard_descriptor_accessor.
       * @member {boolean} no_standard_descriptor_accessor
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.no_standard_descriptor_accessor = false;

      /**
       * MessageOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.deprecated = false;

      /**
       * MessageOptions map_entry.
       * @member {boolean} map_entry
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.map_entry = false;

      /**
       * MessageOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * MessageOptions .cosmos_proto.interface_type.
       * @member {string} .cosmos_proto.interface_type
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.cosmos_proto.interface_type'] = '';

      /**
       * MessageOptions .cosmos_proto.implements_interface.
       * @member {string} .cosmos_proto.implements_interface
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.cosmos_proto.implements_interface'] = '';

      /**
       * MessageOptions .gogoproto.goproto_getters.
       * @member {boolean} .gogoproto.goproto_getters
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.goproto_getters'] = false;

      /**
       * MessageOptions .gogoproto.goproto_stringer.
       * @member {boolean} .gogoproto.goproto_stringer
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.goproto_stringer'] = false;

      /**
       * MessageOptions .gogoproto.verbose_equal.
       * @member {boolean} .gogoproto.verbose_equal
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.verbose_equal'] = false;

      /**
       * MessageOptions .gogoproto.face.
       * @member {boolean} .gogoproto.face
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.face'] = false;

      /**
       * MessageOptions .gogoproto.gostring.
       * @member {boolean} .gogoproto.gostring
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.gostring'] = false;

      /**
       * MessageOptions .gogoproto.populate.
       * @member {boolean} .gogoproto.populate
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.populate'] = false;

      /**
       * MessageOptions .gogoproto.stringer.
       * @member {boolean} .gogoproto.stringer
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.stringer'] = false;

      /**
       * MessageOptions .gogoproto.onlyone.
       * @member {boolean} .gogoproto.onlyone
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.onlyone'] = false;

      /**
       * MessageOptions .gogoproto.equal.
       * @member {boolean} .gogoproto.equal
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.equal'] = false;

      /**
       * MessageOptions .gogoproto.description.
       * @member {boolean} .gogoproto.description
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.description'] = false;

      /**
       * MessageOptions .gogoproto.testgen.
       * @member {boolean} .gogoproto.testgen
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.testgen'] = false;

      /**
       * MessageOptions .gogoproto.benchgen.
       * @member {boolean} .gogoproto.benchgen
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.benchgen'] = false;

      /**
       * MessageOptions .gogoproto.marshaler.
       * @member {boolean} .gogoproto.marshaler
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.marshaler'] = false;

      /**
       * MessageOptions .gogoproto.unmarshaler.
       * @member {boolean} .gogoproto.unmarshaler
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.unmarshaler'] = false;

      /**
       * MessageOptions .gogoproto.stable_marshaler.
       * @member {boolean} .gogoproto.stable_marshaler
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.stable_marshaler'] = false;

      /**
       * MessageOptions .gogoproto.sizer.
       * @member {boolean} .gogoproto.sizer
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.sizer'] = false;

      /**
       * MessageOptions .gogoproto.unsafe_marshaler.
       * @member {boolean} .gogoproto.unsafe_marshaler
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.unsafe_marshaler'] = false;

      /**
       * MessageOptions .gogoproto.unsafe_unmarshaler.
       * @member {boolean} .gogoproto.unsafe_unmarshaler
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.unsafe_unmarshaler'] = false;

      /**
       * MessageOptions .gogoproto.goproto_extensions_map.
       * @member {boolean} .gogoproto.goproto_extensions_map
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.goproto_extensions_map'] = false;

      /**
       * MessageOptions .gogoproto.goproto_unrecognized.
       * @member {boolean} .gogoproto.goproto_unrecognized
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.goproto_unrecognized'] = false;

      /**
       * MessageOptions .gogoproto.protosizer.
       * @member {boolean} .gogoproto.protosizer
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.protosizer'] = false;

      /**
       * MessageOptions .gogoproto.compare.
       * @member {boolean} .gogoproto.compare
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.compare'] = false;

      /**
       * MessageOptions .gogoproto.typedecl.
       * @member {boolean} .gogoproto.typedecl
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.typedecl'] = false;

      /**
       * MessageOptions .gogoproto.messagename.
       * @member {boolean} .gogoproto.messagename
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.messagename'] = false;

      /**
       * MessageOptions .gogoproto.goproto_sizecache.
       * @member {boolean} .gogoproto.goproto_sizecache
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.goproto_sizecache'] = false;

      /**
       * MessageOptions .gogoproto.goproto_unkeyed.
       * @member {boolean} .gogoproto.goproto_unkeyed
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.gogoproto.goproto_unkeyed'] = false;

      /**
       * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MessageOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, 'message_set_wire_format'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.message_set_wire_format);
        if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, 'no_standard_descriptor_accessor'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.no_standard_descriptor_accessor);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
        if (message.map_entry != null && Object.hasOwnProperty.call(message, 'map_entry'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.map_entry);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.gogoproto.goproto_getters'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_getters'))
          writer.uint32(/* id 64001, wireType 0 =*/ 512008).bool(message['.gogoproto.goproto_getters']);
        if (message['.gogoproto.goproto_stringer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_stringer'))
          writer.uint32(/* id 64003, wireType 0 =*/ 512024).bool(message['.gogoproto.goproto_stringer']);
        if (message['.gogoproto.verbose_equal'] != null && Object.hasOwnProperty.call(message, '.gogoproto.verbose_equal'))
          writer.uint32(/* id 64004, wireType 0 =*/ 512032).bool(message['.gogoproto.verbose_equal']);
        if (message['.gogoproto.face'] != null && Object.hasOwnProperty.call(message, '.gogoproto.face'))
          writer.uint32(/* id 64005, wireType 0 =*/ 512040).bool(message['.gogoproto.face']);
        if (message['.gogoproto.gostring'] != null && Object.hasOwnProperty.call(message, '.gogoproto.gostring'))
          writer.uint32(/* id 64006, wireType 0 =*/ 512048).bool(message['.gogoproto.gostring']);
        if (message['.gogoproto.populate'] != null && Object.hasOwnProperty.call(message, '.gogoproto.populate'))
          writer.uint32(/* id 64007, wireType 0 =*/ 512056).bool(message['.gogoproto.populate']);
        if (message['.gogoproto.onlyone'] != null && Object.hasOwnProperty.call(message, '.gogoproto.onlyone'))
          writer.uint32(/* id 64009, wireType 0 =*/ 512072).bool(message['.gogoproto.onlyone']);
        if (message['.gogoproto.equal'] != null && Object.hasOwnProperty.call(message, '.gogoproto.equal'))
          writer.uint32(/* id 64013, wireType 0 =*/ 512104).bool(message['.gogoproto.equal']);
        if (message['.gogoproto.description'] != null && Object.hasOwnProperty.call(message, '.gogoproto.description'))
          writer.uint32(/* id 64014, wireType 0 =*/ 512112).bool(message['.gogoproto.description']);
        if (message['.gogoproto.testgen'] != null && Object.hasOwnProperty.call(message, '.gogoproto.testgen'))
          writer.uint32(/* id 64015, wireType 0 =*/ 512120).bool(message['.gogoproto.testgen']);
        if (message['.gogoproto.benchgen'] != null && Object.hasOwnProperty.call(message, '.gogoproto.benchgen'))
          writer.uint32(/* id 64016, wireType 0 =*/ 512128).bool(message['.gogoproto.benchgen']);
        if (message['.gogoproto.marshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.marshaler'))
          writer.uint32(/* id 64017, wireType 0 =*/ 512136).bool(message['.gogoproto.marshaler']);
        if (message['.gogoproto.unmarshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unmarshaler'))
          writer.uint32(/* id 64018, wireType 0 =*/ 512144).bool(message['.gogoproto.unmarshaler']);
        if (message['.gogoproto.stable_marshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stable_marshaler'))
          writer.uint32(/* id 64019, wireType 0 =*/ 512152).bool(message['.gogoproto.stable_marshaler']);
        if (message['.gogoproto.sizer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.sizer'))
          writer.uint32(/* id 64020, wireType 0 =*/ 512160).bool(message['.gogoproto.sizer']);
        if (message['.gogoproto.unsafe_marshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unsafe_marshaler'))
          writer.uint32(/* id 64023, wireType 0 =*/ 512184).bool(message['.gogoproto.unsafe_marshaler']);
        if (message['.gogoproto.unsafe_unmarshaler'] != null && Object.hasOwnProperty.call(message, '.gogoproto.unsafe_unmarshaler'))
          writer.uint32(/* id 64024, wireType 0 =*/ 512192).bool(message['.gogoproto.unsafe_unmarshaler']);
        if (
          message['.gogoproto.goproto_extensions_map'] != null &&
          Object.hasOwnProperty.call(message, '.gogoproto.goproto_extensions_map')
        )
          writer.uint32(/* id 64025, wireType 0 =*/ 512200).bool(message['.gogoproto.goproto_extensions_map']);
        if (message['.gogoproto.goproto_unrecognized'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_unrecognized'))
          writer.uint32(/* id 64026, wireType 0 =*/ 512208).bool(message['.gogoproto.goproto_unrecognized']);
        if (message['.gogoproto.protosizer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.protosizer'))
          writer.uint32(/* id 64028, wireType 0 =*/ 512224).bool(message['.gogoproto.protosizer']);
        if (message['.gogoproto.compare'] != null && Object.hasOwnProperty.call(message, '.gogoproto.compare'))
          writer.uint32(/* id 64029, wireType 0 =*/ 512232).bool(message['.gogoproto.compare']);
        if (message['.gogoproto.typedecl'] != null && Object.hasOwnProperty.call(message, '.gogoproto.typedecl'))
          writer.uint32(/* id 64030, wireType 0 =*/ 512240).bool(message['.gogoproto.typedecl']);
        if (message['.gogoproto.messagename'] != null && Object.hasOwnProperty.call(message, '.gogoproto.messagename'))
          writer.uint32(/* id 64033, wireType 0 =*/ 512264).bool(message['.gogoproto.messagename']);
        if (message['.gogoproto.goproto_sizecache'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_sizecache'))
          writer.uint32(/* id 64034, wireType 0 =*/ 512272).bool(message['.gogoproto.goproto_sizecache']);
        if (message['.gogoproto.goproto_unkeyed'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_unkeyed'))
          writer.uint32(/* id 64035, wireType 0 =*/ 512280).bool(message['.gogoproto.goproto_unkeyed']);
        if (message['.gogoproto.stringer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stringer'))
          writer.uint32(/* id 67008, wireType 0 =*/ 536064).bool(message['.gogoproto.stringer']);
        if (message['.cosmos_proto.interface_type'] != null && Object.hasOwnProperty.call(message, '.cosmos_proto.interface_type'))
          writer.uint32(/* id 93001, wireType 2 =*/ 744010).string(message['.cosmos_proto.interface_type']);
        if (
          message['.cosmos_proto.implements_interface'] != null &&
          Object.hasOwnProperty.call(message, '.cosmos_proto.implements_interface')
        )
          writer.uint32(/* id 93002, wireType 2 =*/ 744018).string(message['.cosmos_proto.implements_interface']);
        return writer;
      };

      /**
       * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MessageOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MessageOptions} MessageOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MessageOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.MessageOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message_set_wire_format = reader.bool();
              break;
            case 2:
              message.no_standard_descriptor_accessor = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 7:
              message.map_entry = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 93001:
              message['.cosmos_proto.interface_type'] = reader.string();
              break;
            case 93002:
              message['.cosmos_proto.implements_interface'] = reader.string();
              break;
            case 64001:
              message['.gogoproto.goproto_getters'] = reader.bool();
              break;
            case 64003:
              message['.gogoproto.goproto_stringer'] = reader.bool();
              break;
            case 64004:
              message['.gogoproto.verbose_equal'] = reader.bool();
              break;
            case 64005:
              message['.gogoproto.face'] = reader.bool();
              break;
            case 64006:
              message['.gogoproto.gostring'] = reader.bool();
              break;
            case 64007:
              message['.gogoproto.populate'] = reader.bool();
              break;
            case 67008:
              message['.gogoproto.stringer'] = reader.bool();
              break;
            case 64009:
              message['.gogoproto.onlyone'] = reader.bool();
              break;
            case 64013:
              message['.gogoproto.equal'] = reader.bool();
              break;
            case 64014:
              message['.gogoproto.description'] = reader.bool();
              break;
            case 64015:
              message['.gogoproto.testgen'] = reader.bool();
              break;
            case 64016:
              message['.gogoproto.benchgen'] = reader.bool();
              break;
            case 64017:
              message['.gogoproto.marshaler'] = reader.bool();
              break;
            case 64018:
              message['.gogoproto.unmarshaler'] = reader.bool();
              break;
            case 64019:
              message['.gogoproto.stable_marshaler'] = reader.bool();
              break;
            case 64020:
              message['.gogoproto.sizer'] = reader.bool();
              break;
            case 64023:
              message['.gogoproto.unsafe_marshaler'] = reader.bool();
              break;
            case 64024:
              message['.gogoproto.unsafe_unmarshaler'] = reader.bool();
              break;
            case 64025:
              message['.gogoproto.goproto_extensions_map'] = reader.bool();
              break;
            case 64026:
              message['.gogoproto.goproto_unrecognized'] = reader.bool();
              break;
            case 64028:
              message['.gogoproto.protosizer'] = reader.bool();
              break;
            case 64029:
              message['.gogoproto.compare'] = reader.bool();
              break;
            case 64030:
              message['.gogoproto.typedecl'] = reader.bool();
              break;
            case 64033:
              message['.gogoproto.messagename'] = reader.bool();
              break;
            case 64034:
              message['.gogoproto.goproto_sizecache'] = reader.bool();
              break;
            case 64035:
              message['.gogoproto.goproto_unkeyed'] = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MessageOptions} MessageOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MessageOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MessageOptions message.
       * @function verify
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MessageOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.message_set_wire_format != null && message.hasOwnProperty('message_set_wire_format'))
          if (typeof message.message_set_wire_format !== 'boolean') return 'message_set_wire_format: boolean expected';
        if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty('no_standard_descriptor_accessor'))
          if (typeof message.no_standard_descriptor_accessor !== 'boolean') return 'no_standard_descriptor_accessor: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.map_entry != null && message.hasOwnProperty('map_entry'))
          if (typeof message.map_entry !== 'boolean') return 'map_entry: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.cosmos_proto.interface_type'] != null && message.hasOwnProperty('.cosmos_proto.interface_type'))
          if (!$util.isString(message['.cosmos_proto.interface_type'])) return '.cosmos_proto.interface_type: string expected';
        if (message['.cosmos_proto.implements_interface'] != null && message.hasOwnProperty('.cosmos_proto.implements_interface'))
          if (!$util.isString(message['.cosmos_proto.implements_interface'])) return '.cosmos_proto.implements_interface: string expected';
        if (message['.gogoproto.goproto_getters'] != null && message.hasOwnProperty('.gogoproto.goproto_getters'))
          if (typeof message['.gogoproto.goproto_getters'] !== 'boolean') return '.gogoproto.goproto_getters: boolean expected';
        if (message['.gogoproto.goproto_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer'))
          if (typeof message['.gogoproto.goproto_stringer'] !== 'boolean') return '.gogoproto.goproto_stringer: boolean expected';
        if (message['.gogoproto.verbose_equal'] != null && message.hasOwnProperty('.gogoproto.verbose_equal'))
          if (typeof message['.gogoproto.verbose_equal'] !== 'boolean') return '.gogoproto.verbose_equal: boolean expected';
        if (message['.gogoproto.face'] != null && message.hasOwnProperty('.gogoproto.face'))
          if (typeof message['.gogoproto.face'] !== 'boolean') return '.gogoproto.face: boolean expected';
        if (message['.gogoproto.gostring'] != null && message.hasOwnProperty('.gogoproto.gostring'))
          if (typeof message['.gogoproto.gostring'] !== 'boolean') return '.gogoproto.gostring: boolean expected';
        if (message['.gogoproto.populate'] != null && message.hasOwnProperty('.gogoproto.populate'))
          if (typeof message['.gogoproto.populate'] !== 'boolean') return '.gogoproto.populate: boolean expected';
        if (message['.gogoproto.stringer'] != null && message.hasOwnProperty('.gogoproto.stringer'))
          if (typeof message['.gogoproto.stringer'] !== 'boolean') return '.gogoproto.stringer: boolean expected';
        if (message['.gogoproto.onlyone'] != null && message.hasOwnProperty('.gogoproto.onlyone'))
          if (typeof message['.gogoproto.onlyone'] !== 'boolean') return '.gogoproto.onlyone: boolean expected';
        if (message['.gogoproto.equal'] != null && message.hasOwnProperty('.gogoproto.equal'))
          if (typeof message['.gogoproto.equal'] !== 'boolean') return '.gogoproto.equal: boolean expected';
        if (message['.gogoproto.description'] != null && message.hasOwnProperty('.gogoproto.description'))
          if (typeof message['.gogoproto.description'] !== 'boolean') return '.gogoproto.description: boolean expected';
        if (message['.gogoproto.testgen'] != null && message.hasOwnProperty('.gogoproto.testgen'))
          if (typeof message['.gogoproto.testgen'] !== 'boolean') return '.gogoproto.testgen: boolean expected';
        if (message['.gogoproto.benchgen'] != null && message.hasOwnProperty('.gogoproto.benchgen'))
          if (typeof message['.gogoproto.benchgen'] !== 'boolean') return '.gogoproto.benchgen: boolean expected';
        if (message['.gogoproto.marshaler'] != null && message.hasOwnProperty('.gogoproto.marshaler'))
          if (typeof message['.gogoproto.marshaler'] !== 'boolean') return '.gogoproto.marshaler: boolean expected';
        if (message['.gogoproto.unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unmarshaler'))
          if (typeof message['.gogoproto.unmarshaler'] !== 'boolean') return '.gogoproto.unmarshaler: boolean expected';
        if (message['.gogoproto.stable_marshaler'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler'))
          if (typeof message['.gogoproto.stable_marshaler'] !== 'boolean') return '.gogoproto.stable_marshaler: boolean expected';
        if (message['.gogoproto.sizer'] != null && message.hasOwnProperty('.gogoproto.sizer'))
          if (typeof message['.gogoproto.sizer'] !== 'boolean') return '.gogoproto.sizer: boolean expected';
        if (message['.gogoproto.unsafe_marshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler'))
          if (typeof message['.gogoproto.unsafe_marshaler'] !== 'boolean') return '.gogoproto.unsafe_marshaler: boolean expected';
        if (message['.gogoproto.unsafe_unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler'))
          if (typeof message['.gogoproto.unsafe_unmarshaler'] !== 'boolean') return '.gogoproto.unsafe_unmarshaler: boolean expected';
        if (message['.gogoproto.goproto_extensions_map'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map'))
          if (typeof message['.gogoproto.goproto_extensions_map'] !== 'boolean')
            return '.gogoproto.goproto_extensions_map: boolean expected';
        if (message['.gogoproto.goproto_unrecognized'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized'))
          if (typeof message['.gogoproto.goproto_unrecognized'] !== 'boolean') return '.gogoproto.goproto_unrecognized: boolean expected';
        if (message['.gogoproto.protosizer'] != null && message.hasOwnProperty('.gogoproto.protosizer'))
          if (typeof message['.gogoproto.protosizer'] !== 'boolean') return '.gogoproto.protosizer: boolean expected';
        if (message['.gogoproto.compare'] != null && message.hasOwnProperty('.gogoproto.compare'))
          if (typeof message['.gogoproto.compare'] !== 'boolean') return '.gogoproto.compare: boolean expected';
        if (message['.gogoproto.typedecl'] != null && message.hasOwnProperty('.gogoproto.typedecl'))
          if (typeof message['.gogoproto.typedecl'] !== 'boolean') return '.gogoproto.typedecl: boolean expected';
        if (message['.gogoproto.messagename'] != null && message.hasOwnProperty('.gogoproto.messagename'))
          if (typeof message['.gogoproto.messagename'] !== 'boolean') return '.gogoproto.messagename: boolean expected';
        if (message['.gogoproto.goproto_sizecache'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache'))
          if (typeof message['.gogoproto.goproto_sizecache'] !== 'boolean') return '.gogoproto.goproto_sizecache: boolean expected';
        if (message['.gogoproto.goproto_unkeyed'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed'))
          if (typeof message['.gogoproto.goproto_unkeyed'] !== 'boolean') return '.gogoproto.goproto_unkeyed: boolean expected';
        return null;
      };

      /**
       * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MessageOptions} MessageOptions
       */
      MessageOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MessageOptions) return object;
        let message = new $root.google.protobuf.MessageOptions();
        if (object.message_set_wire_format != null) message.message_set_wire_format = Boolean(object.message_set_wire_format);
        if (object.no_standard_descriptor_accessor != null)
          message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.map_entry != null) message.map_entry = Boolean(object.map_entry);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.MessageOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.MessageOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.cosmos_proto.interface_type'] != null)
          message['.cosmos_proto.interface_type'] = String(object['.cosmos_proto.interface_type']);
        if (object['.cosmos_proto.implements_interface'] != null)
          message['.cosmos_proto.implements_interface'] = String(object['.cosmos_proto.implements_interface']);
        if (object['.gogoproto.goproto_getters'] != null)
          message['.gogoproto.goproto_getters'] = Boolean(object['.gogoproto.goproto_getters']);
        if (object['.gogoproto.goproto_stringer'] != null)
          message['.gogoproto.goproto_stringer'] = Boolean(object['.gogoproto.goproto_stringer']);
        if (object['.gogoproto.verbose_equal'] != null) message['.gogoproto.verbose_equal'] = Boolean(object['.gogoproto.verbose_equal']);
        if (object['.gogoproto.face'] != null) message['.gogoproto.face'] = Boolean(object['.gogoproto.face']);
        if (object['.gogoproto.gostring'] != null) message['.gogoproto.gostring'] = Boolean(object['.gogoproto.gostring']);
        if (object['.gogoproto.populate'] != null) message['.gogoproto.populate'] = Boolean(object['.gogoproto.populate']);
        if (object['.gogoproto.stringer'] != null) message['.gogoproto.stringer'] = Boolean(object['.gogoproto.stringer']);
        if (object['.gogoproto.onlyone'] != null) message['.gogoproto.onlyone'] = Boolean(object['.gogoproto.onlyone']);
        if (object['.gogoproto.equal'] != null) message['.gogoproto.equal'] = Boolean(object['.gogoproto.equal']);
        if (object['.gogoproto.description'] != null) message['.gogoproto.description'] = Boolean(object['.gogoproto.description']);
        if (object['.gogoproto.testgen'] != null) message['.gogoproto.testgen'] = Boolean(object['.gogoproto.testgen']);
        if (object['.gogoproto.benchgen'] != null) message['.gogoproto.benchgen'] = Boolean(object['.gogoproto.benchgen']);
        if (object['.gogoproto.marshaler'] != null) message['.gogoproto.marshaler'] = Boolean(object['.gogoproto.marshaler']);
        if (object['.gogoproto.unmarshaler'] != null) message['.gogoproto.unmarshaler'] = Boolean(object['.gogoproto.unmarshaler']);
        if (object['.gogoproto.stable_marshaler'] != null)
          message['.gogoproto.stable_marshaler'] = Boolean(object['.gogoproto.stable_marshaler']);
        if (object['.gogoproto.sizer'] != null) message['.gogoproto.sizer'] = Boolean(object['.gogoproto.sizer']);
        if (object['.gogoproto.unsafe_marshaler'] != null)
          message['.gogoproto.unsafe_marshaler'] = Boolean(object['.gogoproto.unsafe_marshaler']);
        if (object['.gogoproto.unsafe_unmarshaler'] != null)
          message['.gogoproto.unsafe_unmarshaler'] = Boolean(object['.gogoproto.unsafe_unmarshaler']);
        if (object['.gogoproto.goproto_extensions_map'] != null)
          message['.gogoproto.goproto_extensions_map'] = Boolean(object['.gogoproto.goproto_extensions_map']);
        if (object['.gogoproto.goproto_unrecognized'] != null)
          message['.gogoproto.goproto_unrecognized'] = Boolean(object['.gogoproto.goproto_unrecognized']);
        if (object['.gogoproto.protosizer'] != null) message['.gogoproto.protosizer'] = Boolean(object['.gogoproto.protosizer']);
        if (object['.gogoproto.compare'] != null) message['.gogoproto.compare'] = Boolean(object['.gogoproto.compare']);
        if (object['.gogoproto.typedecl'] != null) message['.gogoproto.typedecl'] = Boolean(object['.gogoproto.typedecl']);
        if (object['.gogoproto.messagename'] != null) message['.gogoproto.messagename'] = Boolean(object['.gogoproto.messagename']);
        if (object['.gogoproto.goproto_sizecache'] != null)
          message['.gogoproto.goproto_sizecache'] = Boolean(object['.gogoproto.goproto_sizecache']);
        if (object['.gogoproto.goproto_unkeyed'] != null)
          message['.gogoproto.goproto_unkeyed'] = Boolean(object['.gogoproto.goproto_unkeyed']);
        return message;
      };

      /**
       * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.MessageOptions} message MessageOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MessageOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.message_set_wire_format = false;
          object.no_standard_descriptor_accessor = false;
          object.deprecated = false;
          object.map_entry = false;
          object['.gogoproto.goproto_getters'] = false;
          object['.gogoproto.goproto_stringer'] = false;
          object['.gogoproto.verbose_equal'] = false;
          object['.gogoproto.face'] = false;
          object['.gogoproto.gostring'] = false;
          object['.gogoproto.populate'] = false;
          object['.gogoproto.onlyone'] = false;
          object['.gogoproto.equal'] = false;
          object['.gogoproto.description'] = false;
          object['.gogoproto.testgen'] = false;
          object['.gogoproto.benchgen'] = false;
          object['.gogoproto.marshaler'] = false;
          object['.gogoproto.unmarshaler'] = false;
          object['.gogoproto.stable_marshaler'] = false;
          object['.gogoproto.sizer'] = false;
          object['.gogoproto.unsafe_marshaler'] = false;
          object['.gogoproto.unsafe_unmarshaler'] = false;
          object['.gogoproto.goproto_extensions_map'] = false;
          object['.gogoproto.goproto_unrecognized'] = false;
          object['.gogoproto.protosizer'] = false;
          object['.gogoproto.compare'] = false;
          object['.gogoproto.typedecl'] = false;
          object['.gogoproto.messagename'] = false;
          object['.gogoproto.goproto_sizecache'] = false;
          object['.gogoproto.goproto_unkeyed'] = false;
          object['.gogoproto.stringer'] = false;
          object['.cosmos_proto.interface_type'] = '';
          object['.cosmos_proto.implements_interface'] = '';
        }
        if (message.message_set_wire_format != null && message.hasOwnProperty('message_set_wire_format'))
          object.message_set_wire_format = message.message_set_wire_format;
        if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty('no_standard_descriptor_accessor'))
          object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.map_entry != null && message.hasOwnProperty('map_entry')) object.map_entry = message.map_entry;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.gogoproto.goproto_getters'] != null && message.hasOwnProperty('.gogoproto.goproto_getters'))
          object['.gogoproto.goproto_getters'] = message['.gogoproto.goproto_getters'];
        if (message['.gogoproto.goproto_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_stringer'))
          object['.gogoproto.goproto_stringer'] = message['.gogoproto.goproto_stringer'];
        if (message['.gogoproto.verbose_equal'] != null && message.hasOwnProperty('.gogoproto.verbose_equal'))
          object['.gogoproto.verbose_equal'] = message['.gogoproto.verbose_equal'];
        if (message['.gogoproto.face'] != null && message.hasOwnProperty('.gogoproto.face'))
          object['.gogoproto.face'] = message['.gogoproto.face'];
        if (message['.gogoproto.gostring'] != null && message.hasOwnProperty('.gogoproto.gostring'))
          object['.gogoproto.gostring'] = message['.gogoproto.gostring'];
        if (message['.gogoproto.populate'] != null && message.hasOwnProperty('.gogoproto.populate'))
          object['.gogoproto.populate'] = message['.gogoproto.populate'];
        if (message['.gogoproto.onlyone'] != null && message.hasOwnProperty('.gogoproto.onlyone'))
          object['.gogoproto.onlyone'] = message['.gogoproto.onlyone'];
        if (message['.gogoproto.equal'] != null && message.hasOwnProperty('.gogoproto.equal'))
          object['.gogoproto.equal'] = message['.gogoproto.equal'];
        if (message['.gogoproto.description'] != null && message.hasOwnProperty('.gogoproto.description'))
          object['.gogoproto.description'] = message['.gogoproto.description'];
        if (message['.gogoproto.testgen'] != null && message.hasOwnProperty('.gogoproto.testgen'))
          object['.gogoproto.testgen'] = message['.gogoproto.testgen'];
        if (message['.gogoproto.benchgen'] != null && message.hasOwnProperty('.gogoproto.benchgen'))
          object['.gogoproto.benchgen'] = message['.gogoproto.benchgen'];
        if (message['.gogoproto.marshaler'] != null && message.hasOwnProperty('.gogoproto.marshaler'))
          object['.gogoproto.marshaler'] = message['.gogoproto.marshaler'];
        if (message['.gogoproto.unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unmarshaler'))
          object['.gogoproto.unmarshaler'] = message['.gogoproto.unmarshaler'];
        if (message['.gogoproto.stable_marshaler'] != null && message.hasOwnProperty('.gogoproto.stable_marshaler'))
          object['.gogoproto.stable_marshaler'] = message['.gogoproto.stable_marshaler'];
        if (message['.gogoproto.sizer'] != null && message.hasOwnProperty('.gogoproto.sizer'))
          object['.gogoproto.sizer'] = message['.gogoproto.sizer'];
        if (message['.gogoproto.unsafe_marshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_marshaler'))
          object['.gogoproto.unsafe_marshaler'] = message['.gogoproto.unsafe_marshaler'];
        if (message['.gogoproto.unsafe_unmarshaler'] != null && message.hasOwnProperty('.gogoproto.unsafe_unmarshaler'))
          object['.gogoproto.unsafe_unmarshaler'] = message['.gogoproto.unsafe_unmarshaler'];
        if (message['.gogoproto.goproto_extensions_map'] != null && message.hasOwnProperty('.gogoproto.goproto_extensions_map'))
          object['.gogoproto.goproto_extensions_map'] = message['.gogoproto.goproto_extensions_map'];
        if (message['.gogoproto.goproto_unrecognized'] != null && message.hasOwnProperty('.gogoproto.goproto_unrecognized'))
          object['.gogoproto.goproto_unrecognized'] = message['.gogoproto.goproto_unrecognized'];
        if (message['.gogoproto.protosizer'] != null && message.hasOwnProperty('.gogoproto.protosizer'))
          object['.gogoproto.protosizer'] = message['.gogoproto.protosizer'];
        if (message['.gogoproto.compare'] != null && message.hasOwnProperty('.gogoproto.compare'))
          object['.gogoproto.compare'] = message['.gogoproto.compare'];
        if (message['.gogoproto.typedecl'] != null && message.hasOwnProperty('.gogoproto.typedecl'))
          object['.gogoproto.typedecl'] = message['.gogoproto.typedecl'];
        if (message['.gogoproto.messagename'] != null && message.hasOwnProperty('.gogoproto.messagename'))
          object['.gogoproto.messagename'] = message['.gogoproto.messagename'];
        if (message['.gogoproto.goproto_sizecache'] != null && message.hasOwnProperty('.gogoproto.goproto_sizecache'))
          object['.gogoproto.goproto_sizecache'] = message['.gogoproto.goproto_sizecache'];
        if (message['.gogoproto.goproto_unkeyed'] != null && message.hasOwnProperty('.gogoproto.goproto_unkeyed'))
          object['.gogoproto.goproto_unkeyed'] = message['.gogoproto.goproto_unkeyed'];
        if (message['.gogoproto.stringer'] != null && message.hasOwnProperty('.gogoproto.stringer'))
          object['.gogoproto.stringer'] = message['.gogoproto.stringer'];
        if (message['.cosmos_proto.interface_type'] != null && message.hasOwnProperty('.cosmos_proto.interface_type'))
          object['.cosmos_proto.interface_type'] = message['.cosmos_proto.interface_type'];
        if (message['.cosmos_proto.implements_interface'] != null && message.hasOwnProperty('.cosmos_proto.implements_interface'))
          object['.cosmos_proto.implements_interface'] = message['.cosmos_proto.implements_interface'];
        return object;
      };

      /**
       * Converts this MessageOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.MessageOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MessageOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MessageOptions;
    })();

    protobuf.FieldOptions = (function () {
      /**
       * Properties of a FieldOptions.
       * @memberof google.protobuf
       * @interface IFieldOptions
       * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
       * @property {boolean|null} [packed] FieldOptions packed
       * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
       * @property {boolean|null} [lazy] FieldOptions lazy
       * @property {boolean|null} [deprecated] FieldOptions deprecated
       * @property {boolean|null} [weak] FieldOptions weak
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
       * @property {string|null} [".cosmos_proto.accepts_interface"] FieldOptions .cosmos_proto.accepts_interface
       * @property {string|null} [".cosmos_proto.scalar"] FieldOptions .cosmos_proto.scalar
       * @property {boolean|null} [".gogoproto.nullable"] FieldOptions .gogoproto.nullable
       * @property {boolean|null} [".gogoproto.embed"] FieldOptions .gogoproto.embed
       * @property {string|null} [".gogoproto.customtype"] FieldOptions .gogoproto.customtype
       * @property {string|null} [".gogoproto.customname"] FieldOptions .gogoproto.customname
       * @property {string|null} [".gogoproto.jsontag"] FieldOptions .gogoproto.jsontag
       * @property {string|null} [".gogoproto.moretags"] FieldOptions .gogoproto.moretags
       * @property {string|null} [".gogoproto.casttype"] FieldOptions .gogoproto.casttype
       * @property {string|null} [".gogoproto.castkey"] FieldOptions .gogoproto.castkey
       * @property {string|null} [".gogoproto.castvalue"] FieldOptions .gogoproto.castvalue
       * @property {boolean|null} [".gogoproto.stdtime"] FieldOptions .gogoproto.stdtime
       * @property {boolean|null} [".gogoproto.stdduration"] FieldOptions .gogoproto.stdduration
       * @property {boolean|null} [".gogoproto.wktpointer"] FieldOptions .gogoproto.wktpointer
       * @property {string|null} [".gogoproto.castrepeated"] FieldOptions .gogoproto.castrepeated
       */

      /**
       * Constructs a new FieldOptions.
       * @memberof google.protobuf
       * @classdesc Represents a FieldOptions.
       * @implements IFieldOptions
       * @constructor
       * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
       */
      function FieldOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FieldOptions ctype.
       * @member {google.protobuf.FieldOptions.CType} ctype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.ctype = 0;

      /**
       * FieldOptions packed.
       * @member {boolean} packed
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.packed = false;

      /**
       * FieldOptions jstype.
       * @member {google.protobuf.FieldOptions.JSType} jstype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.jstype = 0;

      /**
       * FieldOptions lazy.
       * @member {boolean} lazy
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.lazy = false;

      /**
       * FieldOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.deprecated = false;

      /**
       * FieldOptions weak.
       * @member {boolean} weak
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.weak = false;

      /**
       * FieldOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * FieldOptions .cosmos_proto.accepts_interface.
       * @member {string} .cosmos_proto.accepts_interface
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.cosmos_proto.accepts_interface'] = '';

      /**
       * FieldOptions .cosmos_proto.scalar.
       * @member {string} .cosmos_proto.scalar
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.cosmos_proto.scalar'] = '';

      /**
       * FieldOptions .gogoproto.nullable.
       * @member {boolean} .gogoproto.nullable
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.nullable'] = false;

      /**
       * FieldOptions .gogoproto.embed.
       * @member {boolean} .gogoproto.embed
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.embed'] = false;

      /**
       * FieldOptions .gogoproto.customtype.
       * @member {string} .gogoproto.customtype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.customtype'] = '';

      /**
       * FieldOptions .gogoproto.customname.
       * @member {string} .gogoproto.customname
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.customname'] = '';

      /**
       * FieldOptions .gogoproto.jsontag.
       * @member {string} .gogoproto.jsontag
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.jsontag'] = '';

      /**
       * FieldOptions .gogoproto.moretags.
       * @member {string} .gogoproto.moretags
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.moretags'] = '';

      /**
       * FieldOptions .gogoproto.casttype.
       * @member {string} .gogoproto.casttype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.casttype'] = '';

      /**
       * FieldOptions .gogoproto.castkey.
       * @member {string} .gogoproto.castkey
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.castkey'] = '';

      /**
       * FieldOptions .gogoproto.castvalue.
       * @member {string} .gogoproto.castvalue
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.castvalue'] = '';

      /**
       * FieldOptions .gogoproto.stdtime.
       * @member {boolean} .gogoproto.stdtime
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.stdtime'] = false;

      /**
       * FieldOptions .gogoproto.stdduration.
       * @member {boolean} .gogoproto.stdduration
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.stdduration'] = false;

      /**
       * FieldOptions .gogoproto.wktpointer.
       * @member {boolean} .gogoproto.wktpointer
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.wktpointer'] = false;

      /**
       * FieldOptions .gogoproto.castrepeated.
       * @member {string} .gogoproto.castrepeated
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype['.gogoproto.castrepeated'] = '';

      /**
       * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.ctype != null && Object.hasOwnProperty.call(message, 'ctype'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.ctype);
        if (message.packed != null && Object.hasOwnProperty.call(message, 'packed'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.packed);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
        if (message.lazy != null && Object.hasOwnProperty.call(message, 'lazy'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.lazy);
        if (message.jstype != null && Object.hasOwnProperty.call(message, 'jstype'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.jstype);
        if (message.weak != null && Object.hasOwnProperty.call(message, 'weak'))
          writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.weak);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.gogoproto.nullable'] != null && Object.hasOwnProperty.call(message, '.gogoproto.nullable'))
          writer.uint32(/* id 65001, wireType 0 =*/ 520008).bool(message['.gogoproto.nullable']);
        if (message['.gogoproto.embed'] != null && Object.hasOwnProperty.call(message, '.gogoproto.embed'))
          writer.uint32(/* id 65002, wireType 0 =*/ 520016).bool(message['.gogoproto.embed']);
        if (message['.gogoproto.customtype'] != null && Object.hasOwnProperty.call(message, '.gogoproto.customtype'))
          writer.uint32(/* id 65003, wireType 2 =*/ 520026).string(message['.gogoproto.customtype']);
        if (message['.gogoproto.customname'] != null && Object.hasOwnProperty.call(message, '.gogoproto.customname'))
          writer.uint32(/* id 65004, wireType 2 =*/ 520034).string(message['.gogoproto.customname']);
        if (message['.gogoproto.jsontag'] != null && Object.hasOwnProperty.call(message, '.gogoproto.jsontag'))
          writer.uint32(/* id 65005, wireType 2 =*/ 520042).string(message['.gogoproto.jsontag']);
        if (message['.gogoproto.moretags'] != null && Object.hasOwnProperty.call(message, '.gogoproto.moretags'))
          writer.uint32(/* id 65006, wireType 2 =*/ 520050).string(message['.gogoproto.moretags']);
        if (message['.gogoproto.casttype'] != null && Object.hasOwnProperty.call(message, '.gogoproto.casttype'))
          writer.uint32(/* id 65007, wireType 2 =*/ 520058).string(message['.gogoproto.casttype']);
        if (message['.gogoproto.castkey'] != null && Object.hasOwnProperty.call(message, '.gogoproto.castkey'))
          writer.uint32(/* id 65008, wireType 2 =*/ 520066).string(message['.gogoproto.castkey']);
        if (message['.gogoproto.castvalue'] != null && Object.hasOwnProperty.call(message, '.gogoproto.castvalue'))
          writer.uint32(/* id 65009, wireType 2 =*/ 520074).string(message['.gogoproto.castvalue']);
        if (message['.gogoproto.stdtime'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stdtime'))
          writer.uint32(/* id 65010, wireType 0 =*/ 520080).bool(message['.gogoproto.stdtime']);
        if (message['.gogoproto.stdduration'] != null && Object.hasOwnProperty.call(message, '.gogoproto.stdduration'))
          writer.uint32(/* id 65011, wireType 0 =*/ 520088).bool(message['.gogoproto.stdduration']);
        if (message['.gogoproto.wktpointer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.wktpointer'))
          writer.uint32(/* id 65012, wireType 0 =*/ 520096).bool(message['.gogoproto.wktpointer']);
        if (message['.gogoproto.castrepeated'] != null && Object.hasOwnProperty.call(message, '.gogoproto.castrepeated'))
          writer.uint32(/* id 65013, wireType 2 =*/ 520106).string(message['.gogoproto.castrepeated']);
        if (message['.cosmos_proto.accepts_interface'] != null && Object.hasOwnProperty.call(message, '.cosmos_proto.accepts_interface'))
          writer.uint32(/* id 93001, wireType 2 =*/ 744010).string(message['.cosmos_proto.accepts_interface']);
        if (message['.cosmos_proto.scalar'] != null && Object.hasOwnProperty.call(message, '.cosmos_proto.scalar'))
          writer.uint32(/* id 93002, wireType 2 =*/ 744018).string(message['.cosmos_proto.scalar']);
        return writer;
      };

      /**
       * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FieldOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FieldOptions} FieldOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FieldOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ctype = reader.int32();
              break;
            case 2:
              message.packed = reader.bool();
              break;
            case 6:
              message.jstype = reader.int32();
              break;
            case 5:
              message.lazy = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 10:
              message.weak = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 93001:
              message['.cosmos_proto.accepts_interface'] = reader.string();
              break;
            case 93002:
              message['.cosmos_proto.scalar'] = reader.string();
              break;
            case 65001:
              message['.gogoproto.nullable'] = reader.bool();
              break;
            case 65002:
              message['.gogoproto.embed'] = reader.bool();
              break;
            case 65003:
              message['.gogoproto.customtype'] = reader.string();
              break;
            case 65004:
              message['.gogoproto.customname'] = reader.string();
              break;
            case 65005:
              message['.gogoproto.jsontag'] = reader.string();
              break;
            case 65006:
              message['.gogoproto.moretags'] = reader.string();
              break;
            case 65007:
              message['.gogoproto.casttype'] = reader.string();
              break;
            case 65008:
              message['.gogoproto.castkey'] = reader.string();
              break;
            case 65009:
              message['.gogoproto.castvalue'] = reader.string();
              break;
            case 65010:
              message['.gogoproto.stdtime'] = reader.bool();
              break;
            case 65011:
              message['.gogoproto.stdduration'] = reader.bool();
              break;
            case 65012:
              message['.gogoproto.wktpointer'] = reader.bool();
              break;
            case 65013:
              message['.gogoproto.castrepeated'] = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FieldOptions} FieldOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FieldOptions message.
       * @function verify
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FieldOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.ctype != null && message.hasOwnProperty('ctype'))
          switch (message.ctype) {
            default:
              return 'ctype: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.packed != null && message.hasOwnProperty('packed'))
          if (typeof message.packed !== 'boolean') return 'packed: boolean expected';
        if (message.jstype != null && message.hasOwnProperty('jstype'))
          switch (message.jstype) {
            default:
              return 'jstype: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.lazy != null && message.hasOwnProperty('lazy')) if (typeof message.lazy !== 'boolean') return 'lazy: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.weak != null && message.hasOwnProperty('weak')) if (typeof message.weak !== 'boolean') return 'weak: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.cosmos_proto.accepts_interface'] != null && message.hasOwnProperty('.cosmos_proto.accepts_interface'))
          if (!$util.isString(message['.cosmos_proto.accepts_interface'])) return '.cosmos_proto.accepts_interface: string expected';
        if (message['.cosmos_proto.scalar'] != null && message.hasOwnProperty('.cosmos_proto.scalar'))
          if (!$util.isString(message['.cosmos_proto.scalar'])) return '.cosmos_proto.scalar: string expected';
        if (message['.gogoproto.nullable'] != null && message.hasOwnProperty('.gogoproto.nullable'))
          if (typeof message['.gogoproto.nullable'] !== 'boolean') return '.gogoproto.nullable: boolean expected';
        if (message['.gogoproto.embed'] != null && message.hasOwnProperty('.gogoproto.embed'))
          if (typeof message['.gogoproto.embed'] !== 'boolean') return '.gogoproto.embed: boolean expected';
        if (message['.gogoproto.customtype'] != null && message.hasOwnProperty('.gogoproto.customtype'))
          if (!$util.isString(message['.gogoproto.customtype'])) return '.gogoproto.customtype: string expected';
        if (message['.gogoproto.customname'] != null && message.hasOwnProperty('.gogoproto.customname'))
          if (!$util.isString(message['.gogoproto.customname'])) return '.gogoproto.customname: string expected';
        if (message['.gogoproto.jsontag'] != null && message.hasOwnProperty('.gogoproto.jsontag'))
          if (!$util.isString(message['.gogoproto.jsontag'])) return '.gogoproto.jsontag: string expected';
        if (message['.gogoproto.moretags'] != null && message.hasOwnProperty('.gogoproto.moretags'))
          if (!$util.isString(message['.gogoproto.moretags'])) return '.gogoproto.moretags: string expected';
        if (message['.gogoproto.casttype'] != null && message.hasOwnProperty('.gogoproto.casttype'))
          if (!$util.isString(message['.gogoproto.casttype'])) return '.gogoproto.casttype: string expected';
        if (message['.gogoproto.castkey'] != null && message.hasOwnProperty('.gogoproto.castkey'))
          if (!$util.isString(message['.gogoproto.castkey'])) return '.gogoproto.castkey: string expected';
        if (message['.gogoproto.castvalue'] != null && message.hasOwnProperty('.gogoproto.castvalue'))
          if (!$util.isString(message['.gogoproto.castvalue'])) return '.gogoproto.castvalue: string expected';
        if (message['.gogoproto.stdtime'] != null && message.hasOwnProperty('.gogoproto.stdtime'))
          if (typeof message['.gogoproto.stdtime'] !== 'boolean') return '.gogoproto.stdtime: boolean expected';
        if (message['.gogoproto.stdduration'] != null && message.hasOwnProperty('.gogoproto.stdduration'))
          if (typeof message['.gogoproto.stdduration'] !== 'boolean') return '.gogoproto.stdduration: boolean expected';
        if (message['.gogoproto.wktpointer'] != null && message.hasOwnProperty('.gogoproto.wktpointer'))
          if (typeof message['.gogoproto.wktpointer'] !== 'boolean') return '.gogoproto.wktpointer: boolean expected';
        if (message['.gogoproto.castrepeated'] != null && message.hasOwnProperty('.gogoproto.castrepeated'))
          if (!$util.isString(message['.gogoproto.castrepeated'])) return '.gogoproto.castrepeated: string expected';
        return null;
      };

      /**
       * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FieldOptions} FieldOptions
       */
      FieldOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FieldOptions) return object;
        let message = new $root.google.protobuf.FieldOptions();
        switch (object.ctype) {
          case 'STRING':
          case 0:
            message.ctype = 0;
            break;
          case 'CORD':
          case 1:
            message.ctype = 1;
            break;
          case 'STRING_PIECE':
          case 2:
            message.ctype = 2;
            break;
        }
        if (object.packed != null) message.packed = Boolean(object.packed);
        switch (object.jstype) {
          case 'JS_NORMAL':
          case 0:
            message.jstype = 0;
            break;
          case 'JS_STRING':
          case 1:
            message.jstype = 1;
            break;
          case 'JS_NUMBER':
          case 2:
            message.jstype = 2;
            break;
        }
        if (object.lazy != null) message.lazy = Boolean(object.lazy);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.weak != null) message.weak = Boolean(object.weak);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.FieldOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.FieldOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.cosmos_proto.accepts_interface'] != null)
          message['.cosmos_proto.accepts_interface'] = String(object['.cosmos_proto.accepts_interface']);
        if (object['.cosmos_proto.scalar'] != null) message['.cosmos_proto.scalar'] = String(object['.cosmos_proto.scalar']);
        if (object['.gogoproto.nullable'] != null) message['.gogoproto.nullable'] = Boolean(object['.gogoproto.nullable']);
        if (object['.gogoproto.embed'] != null) message['.gogoproto.embed'] = Boolean(object['.gogoproto.embed']);
        if (object['.gogoproto.customtype'] != null) message['.gogoproto.customtype'] = String(object['.gogoproto.customtype']);
        if (object['.gogoproto.customname'] != null) message['.gogoproto.customname'] = String(object['.gogoproto.customname']);
        if (object['.gogoproto.jsontag'] != null) message['.gogoproto.jsontag'] = String(object['.gogoproto.jsontag']);
        if (object['.gogoproto.moretags'] != null) message['.gogoproto.moretags'] = String(object['.gogoproto.moretags']);
        if (object['.gogoproto.casttype'] != null) message['.gogoproto.casttype'] = String(object['.gogoproto.casttype']);
        if (object['.gogoproto.castkey'] != null) message['.gogoproto.castkey'] = String(object['.gogoproto.castkey']);
        if (object['.gogoproto.castvalue'] != null) message['.gogoproto.castvalue'] = String(object['.gogoproto.castvalue']);
        if (object['.gogoproto.stdtime'] != null) message['.gogoproto.stdtime'] = Boolean(object['.gogoproto.stdtime']);
        if (object['.gogoproto.stdduration'] != null) message['.gogoproto.stdduration'] = Boolean(object['.gogoproto.stdduration']);
        if (object['.gogoproto.wktpointer'] != null) message['.gogoproto.wktpointer'] = Boolean(object['.gogoproto.wktpointer']);
        if (object['.gogoproto.castrepeated'] != null) message['.gogoproto.castrepeated'] = String(object['.gogoproto.castrepeated']);
        return message;
      };

      /**
       * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.FieldOptions} message FieldOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FieldOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.ctype = options.enums === String ? 'STRING' : 0;
          object.packed = false;
          object.deprecated = false;
          object.lazy = false;
          object.jstype = options.enums === String ? 'JS_NORMAL' : 0;
          object.weak = false;
          object['.gogoproto.nullable'] = false;
          object['.gogoproto.embed'] = false;
          object['.gogoproto.customtype'] = '';
          object['.gogoproto.customname'] = '';
          object['.gogoproto.jsontag'] = '';
          object['.gogoproto.moretags'] = '';
          object['.gogoproto.casttype'] = '';
          object['.gogoproto.castkey'] = '';
          object['.gogoproto.castvalue'] = '';
          object['.gogoproto.stdtime'] = false;
          object['.gogoproto.stdduration'] = false;
          object['.gogoproto.wktpointer'] = false;
          object['.gogoproto.castrepeated'] = '';
          object['.cosmos_proto.accepts_interface'] = '';
          object['.cosmos_proto.scalar'] = '';
        }
        if (message.ctype != null && message.hasOwnProperty('ctype'))
          object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
        if (message.packed != null && message.hasOwnProperty('packed')) object.packed = message.packed;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.lazy != null && message.hasOwnProperty('lazy')) object.lazy = message.lazy;
        if (message.jstype != null && message.hasOwnProperty('jstype'))
          object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
        if (message.weak != null && message.hasOwnProperty('weak')) object.weak = message.weak;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.gogoproto.nullable'] != null && message.hasOwnProperty('.gogoproto.nullable'))
          object['.gogoproto.nullable'] = message['.gogoproto.nullable'];
        if (message['.gogoproto.embed'] != null && message.hasOwnProperty('.gogoproto.embed'))
          object['.gogoproto.embed'] = message['.gogoproto.embed'];
        if (message['.gogoproto.customtype'] != null && message.hasOwnProperty('.gogoproto.customtype'))
          object['.gogoproto.customtype'] = message['.gogoproto.customtype'];
        if (message['.gogoproto.customname'] != null && message.hasOwnProperty('.gogoproto.customname'))
          object['.gogoproto.customname'] = message['.gogoproto.customname'];
        if (message['.gogoproto.jsontag'] != null && message.hasOwnProperty('.gogoproto.jsontag'))
          object['.gogoproto.jsontag'] = message['.gogoproto.jsontag'];
        if (message['.gogoproto.moretags'] != null && message.hasOwnProperty('.gogoproto.moretags'))
          object['.gogoproto.moretags'] = message['.gogoproto.moretags'];
        if (message['.gogoproto.casttype'] != null && message.hasOwnProperty('.gogoproto.casttype'))
          object['.gogoproto.casttype'] = message['.gogoproto.casttype'];
        if (message['.gogoproto.castkey'] != null && message.hasOwnProperty('.gogoproto.castkey'))
          object['.gogoproto.castkey'] = message['.gogoproto.castkey'];
        if (message['.gogoproto.castvalue'] != null && message.hasOwnProperty('.gogoproto.castvalue'))
          object['.gogoproto.castvalue'] = message['.gogoproto.castvalue'];
        if (message['.gogoproto.stdtime'] != null && message.hasOwnProperty('.gogoproto.stdtime'))
          object['.gogoproto.stdtime'] = message['.gogoproto.stdtime'];
        if (message['.gogoproto.stdduration'] != null && message.hasOwnProperty('.gogoproto.stdduration'))
          object['.gogoproto.stdduration'] = message['.gogoproto.stdduration'];
        if (message['.gogoproto.wktpointer'] != null && message.hasOwnProperty('.gogoproto.wktpointer'))
          object['.gogoproto.wktpointer'] = message['.gogoproto.wktpointer'];
        if (message['.gogoproto.castrepeated'] != null && message.hasOwnProperty('.gogoproto.castrepeated'))
          object['.gogoproto.castrepeated'] = message['.gogoproto.castrepeated'];
        if (message['.cosmos_proto.accepts_interface'] != null && message.hasOwnProperty('.cosmos_proto.accepts_interface'))
          object['.cosmos_proto.accepts_interface'] = message['.cosmos_proto.accepts_interface'];
        if (message['.cosmos_proto.scalar'] != null && message.hasOwnProperty('.cosmos_proto.scalar'))
          object['.cosmos_proto.scalar'] = message['.cosmos_proto.scalar'];
        return object;
      };

      /**
       * Converts this FieldOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.FieldOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FieldOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * CType enum.
       * @name google.protobuf.FieldOptions.CType
       * @enum {number}
       * @property {number} STRING=0 STRING value
       * @property {number} CORD=1 CORD value
       * @property {number} STRING_PIECE=2 STRING_PIECE value
       */
      FieldOptions.CType = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'STRING')] = 0;
        values[(valuesById[1] = 'CORD')] = 1;
        values[(valuesById[2] = 'STRING_PIECE')] = 2;
        return values;
      })();

      /**
       * JSType enum.
       * @name google.protobuf.FieldOptions.JSType
       * @enum {number}
       * @property {number} JS_NORMAL=0 JS_NORMAL value
       * @property {number} JS_STRING=1 JS_STRING value
       * @property {number} JS_NUMBER=2 JS_NUMBER value
       */
      FieldOptions.JSType = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'JS_NORMAL')] = 0;
        values[(valuesById[1] = 'JS_STRING')] = 1;
        values[(valuesById[2] = 'JS_NUMBER')] = 2;
        return values;
      })();

      return FieldOptions;
    })();

    protobuf.OneofOptions = (function () {
      /**
       * Properties of an OneofOptions.
       * @memberof google.protobuf
       * @interface IOneofOptions
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] OneofOptions uninterpreted_option
       */

      /**
       * Constructs a new OneofOptions.
       * @memberof google.protobuf
       * @classdesc Represents an OneofOptions.
       * @implements IOneofOptions
       * @constructor
       * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
       */
      function OneofOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * OneofOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.OneofOptions
       * @instance
       */
      OneofOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OneofOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.OneofOptions} OneofOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.OneofOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.OneofOptions} OneofOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OneofOptions message.
       * @function verify
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OneofOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.OneofOptions} OneofOptions
       */
      OneofOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.OneofOptions) return object;
        let message = new $root.google.protobuf.OneofOptions();
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.OneofOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.OneofOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.OneofOptions} message OneofOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OneofOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        return object;
      };

      /**
       * Converts this OneofOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.OneofOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OneofOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OneofOptions;
    })();

    protobuf.EnumOptions = (function () {
      /**
       * Properties of an EnumOptions.
       * @memberof google.protobuf
       * @interface IEnumOptions
       * @property {boolean|null} [allow_alias] EnumOptions allow_alias
       * @property {boolean|null} [deprecated] EnumOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
       * @property {boolean|null} [".gogoproto.goproto_enum_prefix"] EnumOptions .gogoproto.goproto_enum_prefix
       * @property {boolean|null} [".gogoproto.goproto_enum_stringer"] EnumOptions .gogoproto.goproto_enum_stringer
       * @property {boolean|null} [".gogoproto.enum_stringer"] EnumOptions .gogoproto.enum_stringer
       * @property {string|null} [".gogoproto.enum_customname"] EnumOptions .gogoproto.enum_customname
       * @property {boolean|null} [".gogoproto.enumdecl"] EnumOptions .gogoproto.enumdecl
       */

      /**
       * Constructs a new EnumOptions.
       * @memberof google.protobuf
       * @classdesc Represents an EnumOptions.
       * @implements IEnumOptions
       * @constructor
       * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
       */
      function EnumOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumOptions allow_alias.
       * @member {boolean} allow_alias
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.allow_alias = false;

      /**
       * EnumOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.deprecated = false;

      /**
       * EnumOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * EnumOptions .gogoproto.goproto_enum_prefix.
       * @member {boolean} .gogoproto.goproto_enum_prefix
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype['.gogoproto.goproto_enum_prefix'] = false;

      /**
       * EnumOptions .gogoproto.goproto_enum_stringer.
       * @member {boolean} .gogoproto.goproto_enum_stringer
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype['.gogoproto.goproto_enum_stringer'] = false;

      /**
       * EnumOptions .gogoproto.enum_stringer.
       * @member {boolean} .gogoproto.enum_stringer
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype['.gogoproto.enum_stringer'] = false;

      /**
       * EnumOptions .gogoproto.enum_customname.
       * @member {string} .gogoproto.enum_customname
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype['.gogoproto.enum_customname'] = '';

      /**
       * EnumOptions .gogoproto.enumdecl.
       * @member {boolean} .gogoproto.enumdecl
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype['.gogoproto.enumdecl'] = false;

      /**
       * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.allow_alias != null && Object.hasOwnProperty.call(message, 'allow_alias'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.allow_alias);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.gogoproto.goproto_enum_prefix'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_prefix'))
          writer.uint32(/* id 62001, wireType 0 =*/ 496008).bool(message['.gogoproto.goproto_enum_prefix']);
        if (message['.gogoproto.goproto_enum_stringer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.goproto_enum_stringer'))
          writer.uint32(/* id 62021, wireType 0 =*/ 496168).bool(message['.gogoproto.goproto_enum_stringer']);
        if (message['.gogoproto.enum_stringer'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enum_stringer'))
          writer.uint32(/* id 62022, wireType 0 =*/ 496176).bool(message['.gogoproto.enum_stringer']);
        if (message['.gogoproto.enum_customname'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enum_customname'))
          writer.uint32(/* id 62023, wireType 2 =*/ 496186).string(message['.gogoproto.enum_customname']);
        if (message['.gogoproto.enumdecl'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enumdecl'))
          writer.uint32(/* id 62024, wireType 0 =*/ 496192).bool(message['.gogoproto.enumdecl']);
        return writer;
      };

      /**
       * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumOptions} EnumOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.allow_alias = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 62001:
              message['.gogoproto.goproto_enum_prefix'] = reader.bool();
              break;
            case 62021:
              message['.gogoproto.goproto_enum_stringer'] = reader.bool();
              break;
            case 62022:
              message['.gogoproto.enum_stringer'] = reader.bool();
              break;
            case 62023:
              message['.gogoproto.enum_customname'] = reader.string();
              break;
            case 62024:
              message['.gogoproto.enumdecl'] = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumOptions} EnumOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumOptions message.
       * @function verify
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.allow_alias != null && message.hasOwnProperty('allow_alias'))
          if (typeof message.allow_alias !== 'boolean') return 'allow_alias: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.gogoproto.goproto_enum_prefix'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix'))
          if (typeof message['.gogoproto.goproto_enum_prefix'] !== 'boolean') return '.gogoproto.goproto_enum_prefix: boolean expected';
        if (message['.gogoproto.goproto_enum_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer'))
          if (typeof message['.gogoproto.goproto_enum_stringer'] !== 'boolean') return '.gogoproto.goproto_enum_stringer: boolean expected';
        if (message['.gogoproto.enum_stringer'] != null && message.hasOwnProperty('.gogoproto.enum_stringer'))
          if (typeof message['.gogoproto.enum_stringer'] !== 'boolean') return '.gogoproto.enum_stringer: boolean expected';
        if (message['.gogoproto.enum_customname'] != null && message.hasOwnProperty('.gogoproto.enum_customname'))
          if (!$util.isString(message['.gogoproto.enum_customname'])) return '.gogoproto.enum_customname: string expected';
        if (message['.gogoproto.enumdecl'] != null && message.hasOwnProperty('.gogoproto.enumdecl'))
          if (typeof message['.gogoproto.enumdecl'] !== 'boolean') return '.gogoproto.enumdecl: boolean expected';
        return null;
      };

      /**
       * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumOptions} EnumOptions
       */
      EnumOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumOptions) return object;
        let message = new $root.google.protobuf.EnumOptions();
        if (object.allow_alias != null) message.allow_alias = Boolean(object.allow_alias);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.EnumOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.EnumOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.gogoproto.goproto_enum_prefix'] != null)
          message['.gogoproto.goproto_enum_prefix'] = Boolean(object['.gogoproto.goproto_enum_prefix']);
        if (object['.gogoproto.goproto_enum_stringer'] != null)
          message['.gogoproto.goproto_enum_stringer'] = Boolean(object['.gogoproto.goproto_enum_stringer']);
        if (object['.gogoproto.enum_stringer'] != null) message['.gogoproto.enum_stringer'] = Boolean(object['.gogoproto.enum_stringer']);
        if (object['.gogoproto.enum_customname'] != null)
          message['.gogoproto.enum_customname'] = String(object['.gogoproto.enum_customname']);
        if (object['.gogoproto.enumdecl'] != null) message['.gogoproto.enumdecl'] = Boolean(object['.gogoproto.enumdecl']);
        return message;
      };

      /**
       * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.EnumOptions} message EnumOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.allow_alias = false;
          object.deprecated = false;
          object['.gogoproto.goproto_enum_prefix'] = false;
          object['.gogoproto.goproto_enum_stringer'] = false;
          object['.gogoproto.enum_stringer'] = false;
          object['.gogoproto.enum_customname'] = '';
          object['.gogoproto.enumdecl'] = false;
        }
        if (message.allow_alias != null && message.hasOwnProperty('allow_alias')) object.allow_alias = message.allow_alias;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.gogoproto.goproto_enum_prefix'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_prefix'))
          object['.gogoproto.goproto_enum_prefix'] = message['.gogoproto.goproto_enum_prefix'];
        if (message['.gogoproto.goproto_enum_stringer'] != null && message.hasOwnProperty('.gogoproto.goproto_enum_stringer'))
          object['.gogoproto.goproto_enum_stringer'] = message['.gogoproto.goproto_enum_stringer'];
        if (message['.gogoproto.enum_stringer'] != null && message.hasOwnProperty('.gogoproto.enum_stringer'))
          object['.gogoproto.enum_stringer'] = message['.gogoproto.enum_stringer'];
        if (message['.gogoproto.enum_customname'] != null && message.hasOwnProperty('.gogoproto.enum_customname'))
          object['.gogoproto.enum_customname'] = message['.gogoproto.enum_customname'];
        if (message['.gogoproto.enumdecl'] != null && message.hasOwnProperty('.gogoproto.enumdecl'))
          object['.gogoproto.enumdecl'] = message['.gogoproto.enumdecl'];
        return object;
      };

      /**
       * Converts this EnumOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumOptions;
    })();

    protobuf.EnumValueOptions = (function () {
      /**
       * Properties of an EnumValueOptions.
       * @memberof google.protobuf
       * @interface IEnumValueOptions
       * @property {boolean|null} [deprecated] EnumValueOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
       * @property {string|null} [".gogoproto.enumvalue_customname"] EnumValueOptions .gogoproto.enumvalue_customname
       */

      /**
       * Constructs a new EnumValueOptions.
       * @memberof google.protobuf
       * @classdesc Represents an EnumValueOptions.
       * @implements IEnumValueOptions
       * @constructor
       * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
       */
      function EnumValueOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumValueOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       */
      EnumValueOptions.prototype.deprecated = false;

      /**
       * EnumValueOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       */
      EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * EnumValueOptions .gogoproto.enumvalue_customname.
       * @member {string} .gogoproto.enumvalue_customname
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       */
      EnumValueOptions.prototype['.gogoproto.enumvalue_customname'] = '';

      /**
       * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.gogoproto.enumvalue_customname'] != null && Object.hasOwnProperty.call(message, '.gogoproto.enumvalue_customname'))
          writer.uint32(/* id 66001, wireType 2 =*/ 528010).string(message['.gogoproto.enumvalue_customname']);
        return writer;
      };

      /**
       * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumValueOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumValueOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 66001:
              message['.gogoproto.enumvalue_customname'] = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumValueOptions message.
       * @function verify
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumValueOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.gogoproto.enumvalue_customname'] != null && message.hasOwnProperty('.gogoproto.enumvalue_customname'))
          if (!$util.isString(message['.gogoproto.enumvalue_customname'])) return '.gogoproto.enumvalue_customname: string expected';
        return null;
      };

      /**
       * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       */
      EnumValueOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumValueOptions) return object;
        let message = new $root.google.protobuf.EnumValueOptions();
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.EnumValueOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.EnumValueOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.gogoproto.enumvalue_customname'] != null)
          message['.gogoproto.enumvalue_customname'] = String(object['.gogoproto.enumvalue_customname']);
        return message;
      };

      /**
       * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumValueOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.deprecated = false;
          object['.gogoproto.enumvalue_customname'] = '';
        }
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.gogoproto.enumvalue_customname'] != null && message.hasOwnProperty('.gogoproto.enumvalue_customname'))
          object['.gogoproto.enumvalue_customname'] = message['.gogoproto.enumvalue_customname'];
        return object;
      };

      /**
       * Converts this EnumValueOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumValueOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumValueOptions;
    })();

    protobuf.ServiceOptions = (function () {
      /**
       * Properties of a ServiceOptions.
       * @memberof google.protobuf
       * @interface IServiceOptions
       * @property {boolean|null} [deprecated] ServiceOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
       */

      /**
       * Constructs a new ServiceOptions.
       * @memberof google.protobuf
       * @classdesc Represents a ServiceOptions.
       * @implements IServiceOptions
       * @constructor
       * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
       */
      function ServiceOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ServiceOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.ServiceOptions
       * @instance
       */
      ServiceOptions.prototype.deprecated = false;

      /**
       * ServiceOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.ServiceOptions
       * @instance
       */
      ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ServiceOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.ServiceOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 33:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ServiceOptions message.
       * @function verify
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ServiceOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       */
      ServiceOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.ServiceOptions) return object;
        let message = new $root.google.protobuf.ServiceOptions();
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.ServiceOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.ServiceOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.ServiceOptions} message ServiceOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ServiceOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) object.deprecated = false;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        return object;
      };

      /**
       * Converts this ServiceOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.ServiceOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ServiceOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ServiceOptions;
    })();

    protobuf.MethodOptions = (function () {
      /**
       * Properties of a MethodOptions.
       * @memberof google.protobuf
       * @interface IMethodOptions
       * @property {boolean|null} [deprecated] MethodOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
       * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
       */

      /**
       * Constructs a new MethodOptions.
       * @memberof google.protobuf
       * @classdesc Represents a MethodOptions.
       * @implements IMethodOptions
       * @constructor
       * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
       */
      function MethodOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MethodOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype.deprecated = false;

      /**
       * MethodOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * MethodOptions .google.api.http.
       * @member {google.api.IHttpRule|null|undefined} .google.api.http
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype['.google.api.http'] = null;

      /**
       * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.google.api.http'] != null && Object.hasOwnProperty.call(message, '.google.api.http'))
          $root.google.api.HttpRule.encode(
            message['.google.api.http'],
            writer.uint32(/* id 72295728, wireType 2 =*/ 578365826).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MethodOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MethodOptions} MethodOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.MethodOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 33:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 72295728:
              message['.google.api.http'] = $root.google.api.HttpRule.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MethodOptions} MethodOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MethodOptions message.
       * @function verify
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MethodOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.google.api.http'] != null && message.hasOwnProperty('.google.api.http')) {
          let error = $root.google.api.HttpRule.verify(message['.google.api.http']);
          if (error) return '.google.api.http.' + error;
        }
        return null;
      };

      /**
       * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MethodOptions} MethodOptions
       */
      MethodOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MethodOptions) return object;
        let message = new $root.google.protobuf.MethodOptions();
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.MethodOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.MethodOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.google.api.http'] != null) {
          if (typeof object['.google.api.http'] !== 'object')
            throw TypeError('.google.protobuf.MethodOptions..google.api.http: object expected');
          message['.google.api.http'] = $root.google.api.HttpRule.fromObject(object['.google.api.http']);
        }
        return message;
      };

      /**
       * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.MethodOptions} message MethodOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MethodOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.deprecated = false;
          object['.google.api.http'] = null;
        }
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.google.api.http'] != null && message.hasOwnProperty('.google.api.http'))
          object['.google.api.http'] = $root.google.api.HttpRule.toObject(message['.google.api.http'], options);
        return object;
      };

      /**
       * Converts this MethodOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.MethodOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MethodOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MethodOptions;
    })();

    protobuf.UninterpretedOption = (function () {
      /**
       * Properties of an UninterpretedOption.
       * @memberof google.protobuf
       * @interface IUninterpretedOption
       * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
       * @property {string|null} [identifier_value] UninterpretedOption identifier_value
       * @property {Long|null} [positive_int_value] UninterpretedOption positive_int_value
       * @property {Long|null} [negative_int_value] UninterpretedOption negative_int_value
       * @property {number|null} [double_value] UninterpretedOption double_value
       * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
       * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
       */

      /**
       * Constructs a new UninterpretedOption.
       * @memberof google.protobuf
       * @classdesc Represents an UninterpretedOption.
       * @implements IUninterpretedOption
       * @constructor
       * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
       */
      function UninterpretedOption(properties) {
        this.name = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * UninterpretedOption name.
       * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.name = $util.emptyArray;

      /**
       * UninterpretedOption identifier_value.
       * @member {string} identifier_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.identifier_value = '';

      /**
       * UninterpretedOption positive_int_value.
       * @member {Long} positive_int_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * UninterpretedOption negative_int_value.
       * @member {Long} negative_int_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * UninterpretedOption double_value.
       * @member {number} double_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.double_value = 0;

      /**
       * UninterpretedOption string_value.
       * @member {Uint8Array} string_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.string_value = $util.newBuffer([]);

      /**
       * UninterpretedOption aggregate_value.
       * @member {string} aggregate_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.aggregate_value = '';

      /**
       * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UninterpretedOption.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && message.name.length)
          for (let i = 0; i < message.name.length; ++i)
            $root.google.protobuf.UninterpretedOption.NamePart.encode(
              message.name[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.identifier_value != null && Object.hasOwnProperty.call(message, 'identifier_value'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.identifier_value);
        if (message.positive_int_value != null && Object.hasOwnProperty.call(message, 'positive_int_value'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.positive_int_value);
        if (message.negative_int_value != null && Object.hasOwnProperty.call(message, 'negative_int_value'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.negative_int_value);
        if (message.double_value != null && Object.hasOwnProperty.call(message, 'double_value'))
          writer.uint32(/* id 6, wireType 1 =*/ 49).double(message.double_value);
        if (message.string_value != null && Object.hasOwnProperty.call(message, 'string_value'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.string_value);
        if (message.aggregate_value != null && Object.hasOwnProperty.call(message, 'aggregate_value'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.aggregate_value);
        return writer;
      };

      /**
       * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an UninterpretedOption message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UninterpretedOption.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.UninterpretedOption();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              if (!(message.name && message.name.length)) message.name = [];
              message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
              break;
            case 3:
              message.identifier_value = reader.string();
              break;
            case 4:
              message.positive_int_value = reader.uint64();
              break;
            case 5:
              message.negative_int_value = reader.int64();
              break;
            case 6:
              message.double_value = reader.double();
              break;
            case 7:
              message.string_value = reader.bytes();
              break;
            case 8:
              message.aggregate_value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an UninterpretedOption message.
       * @function verify
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      UninterpretedOption.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) {
          if (!Array.isArray(message.name)) return 'name: array expected';
          for (let i = 0; i < message.name.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
            if (error) return 'name.' + error;
          }
        }
        if (message.identifier_value != null && message.hasOwnProperty('identifier_value'))
          if (!$util.isString(message.identifier_value)) return 'identifier_value: string expected';
        if (message.positive_int_value != null && message.hasOwnProperty('positive_int_value'))
          if (
            !$util.isInteger(message.positive_int_value) &&
            !(
              message.positive_int_value &&
              $util.isInteger(message.positive_int_value.low) &&
              $util.isInteger(message.positive_int_value.high)
            )
          )
            return 'positive_int_value: integer|Long expected';
        if (message.negative_int_value != null && message.hasOwnProperty('negative_int_value'))
          if (
            !$util.isInteger(message.negative_int_value) &&
            !(
              message.negative_int_value &&
              $util.isInteger(message.negative_int_value.low) &&
              $util.isInteger(message.negative_int_value.high)
            )
          )
            return 'negative_int_value: integer|Long expected';
        if (message.double_value != null && message.hasOwnProperty('double_value'))
          if (typeof message.double_value !== 'number') return 'double_value: number expected';
        if (message.string_value != null && message.hasOwnProperty('string_value'))
          if (!((message.string_value && typeof message.string_value.length === 'number') || $util.isString(message.string_value)))
            return 'string_value: buffer expected';
        if (message.aggregate_value != null && message.hasOwnProperty('aggregate_value'))
          if (!$util.isString(message.aggregate_value)) return 'aggregate_value: string expected';
        return null;
      };

      /**
       * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       */
      UninterpretedOption.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.UninterpretedOption) return object;
        let message = new $root.google.protobuf.UninterpretedOption();
        if (object.name) {
          if (!Array.isArray(object.name)) throw TypeError('.google.protobuf.UninterpretedOption.name: array expected');
          message.name = [];
          for (let i = 0; i < object.name.length; ++i) {
            if (typeof object.name[i] !== 'object') throw TypeError('.google.protobuf.UninterpretedOption.name: object expected');
            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
          }
        }
        if (object.identifier_value != null) message.identifier_value = String(object.identifier_value);
        if (object.positive_int_value != null)
          if ($util.Long) (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
          else if (typeof object.positive_int_value === 'string') message.positive_int_value = parseInt(object.positive_int_value, 10);
          else if (typeof object.positive_int_value === 'number') message.positive_int_value = object.positive_int_value;
          else if (typeof object.positive_int_value === 'object')
            message.positive_int_value = new $util.LongBits(
              object.positive_int_value.low >>> 0,
              object.positive_int_value.high >>> 0,
            ).toNumber(true);
        if (object.negative_int_value != null)
          if ($util.Long) (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
          else if (typeof object.negative_int_value === 'string') message.negative_int_value = parseInt(object.negative_int_value, 10);
          else if (typeof object.negative_int_value === 'number') message.negative_int_value = object.negative_int_value;
          else if (typeof object.negative_int_value === 'object')
            message.negative_int_value = new $util.LongBits(
              object.negative_int_value.low >>> 0,
              object.negative_int_value.high >>> 0,
            ).toNumber();
        if (object.double_value != null) message.double_value = Number(object.double_value);
        if (object.string_value != null)
          if (typeof object.string_value === 'string')
            $util.base64.decode(object.string_value, (message.string_value = $util.newBuffer($util.base64.length(object.string_value))), 0);
          else if (object.string_value.length) message.string_value = object.string_value;
        if (object.aggregate_value != null) message.aggregate_value = String(object.aggregate_value);
        return message;
      };

      /**
       * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      UninterpretedOption.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.name = [];
        if (options.defaults) {
          object.identifier_value = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.positive_int_value = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.negative_int_value = options.longs === String ? '0' : 0;
          object.double_value = 0;
          if (options.bytes === String) object.string_value = '';
          else {
            object.string_value = [];
            if (options.bytes !== Array) object.string_value = $util.newBuffer(object.string_value);
          }
          object.aggregate_value = '';
        }
        if (message.name && message.name.length) {
          object.name = [];
          for (let j = 0; j < message.name.length; ++j)
            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
        }
        if (message.identifier_value != null && message.hasOwnProperty('identifier_value'))
          object.identifier_value = message.identifier_value;
        if (message.positive_int_value != null && message.hasOwnProperty('positive_int_value'))
          if (typeof message.positive_int_value === 'number')
            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
          else
            object.positive_int_value =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.positive_int_value)
                : options.longs === Number
                ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true)
                : message.positive_int_value;
        if (message.negative_int_value != null && message.hasOwnProperty('negative_int_value'))
          if (typeof message.negative_int_value === 'number')
            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
          else
            object.negative_int_value =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.negative_int_value)
                : options.longs === Number
                ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber()
                : message.negative_int_value;
        if (message.double_value != null && message.hasOwnProperty('double_value'))
          object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
        if (message.string_value != null && message.hasOwnProperty('string_value'))
          object.string_value =
            options.bytes === String
              ? $util.base64.encode(message.string_value, 0, message.string_value.length)
              : options.bytes === Array
              ? Array.prototype.slice.call(message.string_value)
              : message.string_value;
        if (message.aggregate_value != null && message.hasOwnProperty('aggregate_value')) object.aggregate_value = message.aggregate_value;
        return object;
      };

      /**
       * Converts this UninterpretedOption to JSON.
       * @function toJSON
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      UninterpretedOption.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      UninterpretedOption.NamePart = (function () {
        /**
         * Properties of a NamePart.
         * @memberof google.protobuf.UninterpretedOption
         * @interface INamePart
         * @property {string} name_part NamePart name_part
         * @property {boolean} is_extension NamePart is_extension
         */

        /**
         * Constructs a new NamePart.
         * @memberof google.protobuf.UninterpretedOption
         * @classdesc Represents a NamePart.
         * @implements INamePart
         * @constructor
         * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
         */
        function NamePart(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * NamePart name_part.
         * @member {string} name_part
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         */
        NamePart.prototype.name_part = '';

        /**
         * NamePart is_extension.
         * @member {boolean} is_extension
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         */
        NamePart.prototype.is_extension = false;

        /**
         * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NamePart.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name_part);
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.is_extension);
          return writer;
        };

        /**
         * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NamePart.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NamePart message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NamePart.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.UninterpretedOption.NamePart();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name_part = reader.string();
                break;
              case 2:
                message.is_extension = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty('name_part')) throw $util.ProtocolError("missing required 'name_part'", { instance: message });
          if (!message.hasOwnProperty('is_extension')) throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
          return message;
        };

        /**
         * Decodes a NamePart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NamePart.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NamePart message.
         * @function verify
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NamePart.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (!$util.isString(message.name_part)) return 'name_part: string expected';
          if (typeof message.is_extension !== 'boolean') return 'is_extension: boolean expected';
          return null;
        };

        /**
         * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         */
        NamePart.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart) return object;
          let message = new $root.google.protobuf.UninterpretedOption.NamePart();
          if (object.name_part != null) message.name_part = String(object.name_part);
          if (object.is_extension != null) message.is_extension = Boolean(object.is_extension);
          return message;
        };

        /**
         * Creates a plain object from a NamePart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NamePart.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.name_part = '';
            object.is_extension = false;
          }
          if (message.name_part != null && message.hasOwnProperty('name_part')) object.name_part = message.name_part;
          if (message.is_extension != null && message.hasOwnProperty('is_extension')) object.is_extension = message.is_extension;
          return object;
        };

        /**
         * Converts this NamePart to JSON.
         * @function toJSON
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NamePart.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NamePart;
      })();

      return UninterpretedOption;
    })();

    protobuf.SourceCodeInfo = (function () {
      /**
       * Properties of a SourceCodeInfo.
       * @memberof google.protobuf
       * @interface ISourceCodeInfo
       * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
       */

      /**
       * Constructs a new SourceCodeInfo.
       * @memberof google.protobuf
       * @classdesc Represents a SourceCodeInfo.
       * @implements ISourceCodeInfo
       * @constructor
       * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
       */
      function SourceCodeInfo(properties) {
        this.location = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * SourceCodeInfo location.
       * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
       * @memberof google.protobuf.SourceCodeInfo
       * @instance
       */
      SourceCodeInfo.prototype.location = $util.emptyArray;

      /**
       * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SourceCodeInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.location != null && message.location.length)
          for (let i = 0; i < message.location.length; ++i)
            $root.google.protobuf.SourceCodeInfo.Location.encode(
              message.location[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a SourceCodeInfo message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SourceCodeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.SourceCodeInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.location && message.location.length)) message.location = [];
              message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a SourceCodeInfo message.
       * @function verify
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      SourceCodeInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.location != null && message.hasOwnProperty('location')) {
          if (!Array.isArray(message.location)) return 'location: array expected';
          for (let i = 0; i < message.location.length; ++i) {
            let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
            if (error) return 'location.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       */
      SourceCodeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.SourceCodeInfo) return object;
        let message = new $root.google.protobuf.SourceCodeInfo();
        if (object.location) {
          if (!Array.isArray(object.location)) throw TypeError('.google.protobuf.SourceCodeInfo.location: array expected');
          message.location = [];
          for (let i = 0; i < object.location.length; ++i) {
            if (typeof object.location[i] !== 'object') throw TypeError('.google.protobuf.SourceCodeInfo.location: object expected');
            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      SourceCodeInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.location = [];
        if (message.location && message.location.length) {
          object.location = [];
          for (let j = 0; j < message.location.length; ++j)
            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
        }
        return object;
      };

      /**
       * Converts this SourceCodeInfo to JSON.
       * @function toJSON
       * @memberof google.protobuf.SourceCodeInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      SourceCodeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      SourceCodeInfo.Location = (function () {
        /**
         * Properties of a Location.
         * @memberof google.protobuf.SourceCodeInfo
         * @interface ILocation
         * @property {Array.<number>|null} [path] Location path
         * @property {Array.<number>|null} [span] Location span
         * @property {string|null} [leading_comments] Location leading_comments
         * @property {string|null} [trailing_comments] Location trailing_comments
         * @property {Array.<string>|null} [leading_detached_comments] Location leading_detached_comments
         */

        /**
         * Constructs a new Location.
         * @memberof google.protobuf.SourceCodeInfo
         * @classdesc Represents a Location.
         * @implements ILocation
         * @constructor
         * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
         */
        function Location(properties) {
          this.path = [];
          this.span = [];
          this.leading_detached_comments = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Location path.
         * @member {Array.<number>} path
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.path = $util.emptyArray;

        /**
         * Location span.
         * @member {Array.<number>} span
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.span = $util.emptyArray;

        /**
         * Location leading_comments.
         * @member {string} leading_comments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.leading_comments = '';

        /**
         * Location trailing_comments.
         * @member {string} trailing_comments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.trailing_comments = '';

        /**
         * Location leading_detached_comments.
         * @member {Array.<string>} leading_detached_comments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.leading_detached_comments = $util.emptyArray;

        /**
         * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.path != null && message.path.length) {
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
            for (let i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
            writer.ldelim();
          }
          if (message.span != null && message.span.length) {
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
            for (let i = 0; i < message.span.length; ++i) writer.int32(message.span[i]);
            writer.ldelim();
          }
          if (message.leading_comments != null && Object.hasOwnProperty.call(message, 'leading_comments'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.leading_comments);
          if (message.trailing_comments != null && Object.hasOwnProperty.call(message, 'trailing_comments'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.trailing_comments);
          if (message.leading_detached_comments != null && message.leading_detached_comments.length)
            for (let i = 0; i < message.leading_detached_comments.length; ++i)
              writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.leading_detached_comments[i]);
          return writer;
        };

        /**
         * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.SourceCodeInfo.Location();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.path && message.path.length)) message.path = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.path.push(reader.int32());
                } else message.path.push(reader.int32());
                break;
              case 2:
                if (!(message.span && message.span.length)) message.span = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.span.push(reader.int32());
                } else message.span.push(reader.int32());
                break;
              case 3:
                message.leading_comments = reader.string();
                break;
              case 4:
                message.trailing_comments = reader.string();
                break;
              case 6:
                if (!(message.leading_detached_comments && message.leading_detached_comments.length))
                  message.leading_detached_comments = [];
                message.leading_detached_comments.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Location message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Location message.
         * @function verify
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Location.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.path != null && message.hasOwnProperty('path')) {
            if (!Array.isArray(message.path)) return 'path: array expected';
            for (let i = 0; i < message.path.length; ++i) if (!$util.isInteger(message.path[i])) return 'path: integer[] expected';
          }
          if (message.span != null && message.hasOwnProperty('span')) {
            if (!Array.isArray(message.span)) return 'span: array expected';
            for (let i = 0; i < message.span.length; ++i) if (!$util.isInteger(message.span[i])) return 'span: integer[] expected';
          }
          if (message.leading_comments != null && message.hasOwnProperty('leading_comments'))
            if (!$util.isString(message.leading_comments)) return 'leading_comments: string expected';
          if (message.trailing_comments != null && message.hasOwnProperty('trailing_comments'))
            if (!$util.isString(message.trailing_comments)) return 'trailing_comments: string expected';
          if (message.leading_detached_comments != null && message.hasOwnProperty('leading_detached_comments')) {
            if (!Array.isArray(message.leading_detached_comments)) return 'leading_detached_comments: array expected';
            for (let i = 0; i < message.leading_detached_comments.length; ++i)
              if (!$util.isString(message.leading_detached_comments[i])) return 'leading_detached_comments: string[] expected';
          }
          return null;
        };

        /**
         * Creates a Location message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         */
        Location.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.SourceCodeInfo.Location) return object;
          let message = new $root.google.protobuf.SourceCodeInfo.Location();
          if (object.path) {
            if (!Array.isArray(object.path)) throw TypeError('.google.protobuf.SourceCodeInfo.Location.path: array expected');
            message.path = [];
            for (let i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
          }
          if (object.span) {
            if (!Array.isArray(object.span)) throw TypeError('.google.protobuf.SourceCodeInfo.Location.span: array expected');
            message.span = [];
            for (let i = 0; i < object.span.length; ++i) message.span[i] = object.span[i] | 0;
          }
          if (object.leading_comments != null) message.leading_comments = String(object.leading_comments);
          if (object.trailing_comments != null) message.trailing_comments = String(object.trailing_comments);
          if (object.leading_detached_comments) {
            if (!Array.isArray(object.leading_detached_comments))
              throw TypeError('.google.protobuf.SourceCodeInfo.Location.leading_detached_comments: array expected');
            message.leading_detached_comments = [];
            for (let i = 0; i < object.leading_detached_comments.length; ++i)
              message.leading_detached_comments[i] = String(object.leading_detached_comments[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a Location message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.Location} message Location
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Location.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) {
            object.path = [];
            object.span = [];
            object.leading_detached_comments = [];
          }
          if (options.defaults) {
            object.leading_comments = '';
            object.trailing_comments = '';
          }
          if (message.path && message.path.length) {
            object.path = [];
            for (let j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
          }
          if (message.span && message.span.length) {
            object.span = [];
            for (let j = 0; j < message.span.length; ++j) object.span[j] = message.span[j];
          }
          if (message.leading_comments != null && message.hasOwnProperty('leading_comments'))
            object.leading_comments = message.leading_comments;
          if (message.trailing_comments != null && message.hasOwnProperty('trailing_comments'))
            object.trailing_comments = message.trailing_comments;
          if (message.leading_detached_comments && message.leading_detached_comments.length) {
            object.leading_detached_comments = [];
            for (let j = 0; j < message.leading_detached_comments.length; ++j)
              object.leading_detached_comments[j] = message.leading_detached_comments[j];
          }
          return object;
        };

        /**
         * Converts this Location to JSON.
         * @function toJSON
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Location.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Location;
      })();

      return SourceCodeInfo;
    })();

    protobuf.GeneratedCodeInfo = (function () {
      /**
       * Properties of a GeneratedCodeInfo.
       * @memberof google.protobuf
       * @interface IGeneratedCodeInfo
       * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
       */

      /**
       * Constructs a new GeneratedCodeInfo.
       * @memberof google.protobuf
       * @classdesc Represents a GeneratedCodeInfo.
       * @implements IGeneratedCodeInfo
       * @constructor
       * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
       */
      function GeneratedCodeInfo(properties) {
        this.annotation = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GeneratedCodeInfo annotation.
       * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
       * @memberof google.protobuf.GeneratedCodeInfo
       * @instance
       */
      GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

      /**
       * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GeneratedCodeInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.annotation != null && message.annotation.length)
          for (let i = 0; i < message.annotation.length; ++i)
            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(
              message.annotation[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GeneratedCodeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.GeneratedCodeInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.annotation && message.annotation.length)) message.annotation = [];
              message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GeneratedCodeInfo message.
       * @function verify
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GeneratedCodeInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.annotation != null && message.hasOwnProperty('annotation')) {
          if (!Array.isArray(message.annotation)) return 'annotation: array expected';
          for (let i = 0; i < message.annotation.length; ++i) {
            let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
            if (error) return 'annotation.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       */
      GeneratedCodeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.GeneratedCodeInfo) return object;
        let message = new $root.google.protobuf.GeneratedCodeInfo();
        if (object.annotation) {
          if (!Array.isArray(object.annotation)) throw TypeError('.google.protobuf.GeneratedCodeInfo.annotation: array expected');
          message.annotation = [];
          for (let i = 0; i < object.annotation.length; ++i) {
            if (typeof object.annotation[i] !== 'object') throw TypeError('.google.protobuf.GeneratedCodeInfo.annotation: object expected');
            message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GeneratedCodeInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.annotation = [];
        if (message.annotation && message.annotation.length) {
          object.annotation = [];
          for (let j = 0; j < message.annotation.length; ++j)
            object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
        }
        return object;
      };

      /**
       * Converts this GeneratedCodeInfo to JSON.
       * @function toJSON
       * @memberof google.protobuf.GeneratedCodeInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GeneratedCodeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      GeneratedCodeInfo.Annotation = (function () {
        /**
         * Properties of an Annotation.
         * @memberof google.protobuf.GeneratedCodeInfo
         * @interface IAnnotation
         * @property {Array.<number>|null} [path] Annotation path
         * @property {string|null} [source_file] Annotation source_file
         * @property {number|null} [begin] Annotation begin
         * @property {number|null} [end] Annotation end
         */

        /**
         * Constructs a new Annotation.
         * @memberof google.protobuf.GeneratedCodeInfo
         * @classdesc Represents an Annotation.
         * @implements IAnnotation
         * @constructor
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
         */
        function Annotation(properties) {
          this.path = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Annotation path.
         * @member {Array.<number>} path
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.path = $util.emptyArray;

        /**
         * Annotation source_file.
         * @member {string} source_file
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.source_file = '';

        /**
         * Annotation begin.
         * @member {number} begin
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.begin = 0;

        /**
         * Annotation end.
         * @member {number} end
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.end = 0;

        /**
         * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Annotation.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.path != null && message.path.length) {
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
            for (let i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
            writer.ldelim();
          }
          if (message.source_file != null && Object.hasOwnProperty.call(message, 'source_file'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.source_file);
          if (message.begin != null && Object.hasOwnProperty.call(message, 'begin'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.begin);
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Annotation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Annotation message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Annotation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.path && message.path.length)) message.path = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.path.push(reader.int32());
                } else message.path.push(reader.int32());
                break;
              case 2:
                message.source_file = reader.string();
                break;
              case 3:
                message.begin = reader.int32();
                break;
              case 4:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Annotation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Annotation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Annotation message.
         * @function verify
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Annotation.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.path != null && message.hasOwnProperty('path')) {
            if (!Array.isArray(message.path)) return 'path: array expected';
            for (let i = 0; i < message.path.length; ++i) if (!$util.isInteger(message.path[i])) return 'path: integer[] expected';
          }
          if (message.source_file != null && message.hasOwnProperty('source_file'))
            if (!$util.isString(message.source_file)) return 'source_file: string expected';
          if (message.begin != null && message.hasOwnProperty('begin'))
            if (!$util.isInteger(message.begin)) return 'begin: integer expected';
          if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
          return null;
        };

        /**
         * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         */
        Annotation.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation) return object;
          let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
          if (object.path) {
            if (!Array.isArray(object.path)) throw TypeError('.google.protobuf.GeneratedCodeInfo.Annotation.path: array expected');
            message.path = [];
            for (let i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
          }
          if (object.source_file != null) message.source_file = String(object.source_file);
          if (object.begin != null) message.begin = object.begin | 0;
          if (object.end != null) message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from an Annotation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Annotation.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) object.path = [];
          if (options.defaults) {
            object.source_file = '';
            object.begin = 0;
            object.end = 0;
          }
          if (message.path && message.path.length) {
            object.path = [];
            for (let j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
          }
          if (message.source_file != null && message.hasOwnProperty('source_file')) object.source_file = message.source_file;
          if (message.begin != null && message.hasOwnProperty('begin')) object.begin = message.begin;
          if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
          return object;
        };

        /**
         * Converts this Annotation to JSON.
         * @function toJSON
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Annotation.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Annotation;
      })();

      return GeneratedCodeInfo;
    })();

    protobuf.Any = (function () {
      /**
       * Properties of an Any.
       * @memberof google.protobuf
       * @interface IAny
       * @property {string|null} [type_url] Any type_url
       * @property {Uint8Array|null} [value] Any value
       */

      /**
       * Constructs a new Any.
       * @memberof google.protobuf
       * @classdesc Represents an Any.
       * @implements IAny
       * @constructor
       * @param {google.protobuf.IAny=} [properties] Properties to set
       */
      function Any(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Any type_url.
       * @member {string} type_url
       * @memberof google.protobuf.Any
       * @instance
       */
      Any.prototype.type_url = '';

      /**
       * Any value.
       * @member {Uint8Array} value
       * @memberof google.protobuf.Any
       * @instance
       */
      Any.prototype.value = $util.newBuffer([]);

      /**
       * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.IAny} message Any message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Any.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.type_url != null && Object.hasOwnProperty.call(message, 'type_url'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type_url);
        if (message.value != null && Object.hasOwnProperty.call(message, 'value'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
        return writer;
      };

      /**
       * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.IAny} message Any message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Any.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an Any message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Any
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Any} Any
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Any.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.Any();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type_url = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an Any message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Any
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Any} Any
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Any.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an Any message.
       * @function verify
       * @memberof google.protobuf.Any
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Any.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.type_url != null && message.hasOwnProperty('type_url'))
          if (!$util.isString(message.type_url)) return 'type_url: string expected';
        if (message.value != null && message.hasOwnProperty('value'))
          if (!((message.value && typeof message.value.length === 'number') || $util.isString(message.value)))
            return 'value: buffer expected';
        return null;
      };

      /**
       * Creates an Any message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Any
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Any} Any
       */
      Any.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Any) return object;
        let message = new $root.google.protobuf.Any();
        if (object.type_url != null) message.type_url = String(object.type_url);
        if (object.value != null)
          if (typeof object.value === 'string')
            $util.base64.decode(object.value, (message.value = $util.newBuffer($util.base64.length(object.value))), 0);
          else if (object.value.length) message.value = object.value;
        return message;
      };

      /**
       * Creates a plain object from an Any message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.Any} message Any
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Any.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.type_url = '';
          if (options.bytes === String) object.value = '';
          else {
            object.value = [];
            if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
          }
        }
        if (message.type_url != null && message.hasOwnProperty('type_url')) object.type_url = message.type_url;
        if (message.value != null && message.hasOwnProperty('value'))
          object.value =
            options.bytes === String
              ? $util.base64.encode(message.value, 0, message.value.length)
              : options.bytes === Array
              ? Array.prototype.slice.call(message.value)
              : message.value;
        return object;
      };

      /**
       * Converts this Any to JSON.
       * @function toJSON
       * @memberof google.protobuf.Any
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Any.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Any;
    })();

    protobuf.Timestamp = (function () {
      /**
       * Properties of a Timestamp.
       * @memberof google.protobuf
       * @interface ITimestamp
       * @property {Long|null} [seconds] Timestamp seconds
       * @property {number|null} [nanos] Timestamp nanos
       */

      /**
       * Constructs a new Timestamp.
       * @memberof google.protobuf
       * @classdesc Represents a Timestamp.
       * @implements ITimestamp
       * @constructor
       * @param {google.protobuf.ITimestamp=} [properties] Properties to set
       */
      function Timestamp(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Timestamp seconds.
       * @member {Long} seconds
       * @memberof google.protobuf.Timestamp
       * @instance
       */
      Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Timestamp nanos.
       * @member {number} nanos
       * @memberof google.protobuf.Timestamp
       * @instance
       */
      Timestamp.prototype.nanos = 0;

      /**
       * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Timestamp.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.seconds != null && Object.hasOwnProperty.call(message, 'seconds'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
        if (message.nanos != null && Object.hasOwnProperty.call(message, 'nanos'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
        return writer;
      };

      /**
       * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Timestamp message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Timestamp} Timestamp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Timestamp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.Timestamp();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Timestamp message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Timestamp} Timestamp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Timestamp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Timestamp message.
       * @function verify
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Timestamp.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (
            !$util.isInteger(message.seconds) &&
            !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))
          )
            return 'seconds: integer|Long expected';
        if (message.nanos != null && message.hasOwnProperty('nanos')) if (!$util.isInteger(message.nanos)) return 'nanos: integer expected';
        return null;
      };

      /**
       * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Timestamp} Timestamp
       */
      Timestamp.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Timestamp) return object;
        let message = new $root.google.protobuf.Timestamp();
        if (object.seconds != null)
          if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
          else if (typeof object.seconds === 'string') message.seconds = parseInt(object.seconds, 10);
          else if (typeof object.seconds === 'number') message.seconds = object.seconds;
          else if (typeof object.seconds === 'object')
            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
        if (object.nanos != null) message.nanos = object.nanos | 0;
        return message;
      };

      /**
       * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.Timestamp} message Timestamp
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Timestamp.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.seconds = options.longs === String ? '0' : 0;
          object.nanos = 0;
        }
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (typeof message.seconds === 'number') object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
          else
            object.seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.seconds)
                : options.longs === Number
                ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                : message.seconds;
        if (message.nanos != null && message.hasOwnProperty('nanos')) object.nanos = message.nanos;
        return object;
      };

      /**
       * Converts this Timestamp to JSON.
       * @function toJSON
       * @memberof google.protobuf.Timestamp
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Timestamp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Timestamp;
    })();

    protobuf.Duration = (function () {
      /**
       * Properties of a Duration.
       * @memberof google.protobuf
       * @interface IDuration
       * @property {Long|null} [seconds] Duration seconds
       * @property {number|null} [nanos] Duration nanos
       */

      /**
       * Constructs a new Duration.
       * @memberof google.protobuf
       * @classdesc Represents a Duration.
       * @implements IDuration
       * @constructor
       * @param {google.protobuf.IDuration=} [properties] Properties to set
       */
      function Duration(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Duration seconds.
       * @member {Long} seconds
       * @memberof google.protobuf.Duration
       * @instance
       */
      Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Duration nanos.
       * @member {number} nanos
       * @memberof google.protobuf.Duration
       * @instance
       */
      Duration.prototype.nanos = 0;

      /**
       * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Duration
       * @static
       * @param {google.protobuf.IDuration} message Duration message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Duration.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.seconds != null && Object.hasOwnProperty.call(message, 'seconds'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
        if (message.nanos != null && Object.hasOwnProperty.call(message, 'nanos'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
        return writer;
      };

      /**
       * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Duration
       * @static
       * @param {google.protobuf.IDuration} message Duration message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Duration.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Duration message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Duration
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Duration} Duration
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Duration.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.Duration();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Duration message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Duration
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Duration} Duration
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Duration.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Duration message.
       * @function verify
       * @memberof google.protobuf.Duration
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Duration.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (
            !$util.isInteger(message.seconds) &&
            !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))
          )
            return 'seconds: integer|Long expected';
        if (message.nanos != null && message.hasOwnProperty('nanos')) if (!$util.isInteger(message.nanos)) return 'nanos: integer expected';
        return null;
      };

      /**
       * Creates a Duration message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Duration
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Duration} Duration
       */
      Duration.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Duration) return object;
        let message = new $root.google.protobuf.Duration();
        if (object.seconds != null)
          if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
          else if (typeof object.seconds === 'string') message.seconds = parseInt(object.seconds, 10);
          else if (typeof object.seconds === 'number') message.seconds = object.seconds;
          else if (typeof object.seconds === 'object')
            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
        if (object.nanos != null) message.nanos = object.nanos | 0;
        return message;
      };

      /**
       * Creates a plain object from a Duration message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Duration
       * @static
       * @param {google.protobuf.Duration} message Duration
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Duration.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.seconds = options.longs === String ? '0' : 0;
          object.nanos = 0;
        }
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (typeof message.seconds === 'number') object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
          else
            object.seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.seconds)
                : options.longs === Number
                ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                : message.seconds;
        if (message.nanos != null && message.hasOwnProperty('nanos')) object.nanos = message.nanos;
        return object;
      };

      /**
       * Converts this Duration to JSON.
       * @function toJSON
       * @memberof google.protobuf.Duration
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Duration.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Duration;
    })();

    return protobuf;
  })();

  return google;
})());

export { $root as default };
