/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from 'protobufjs/minimal';

// Common aliases
const $Reader = $protobuf.Reader,
  $Writer = $protobuf.Writer,
  $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots['ununifi-client'] || ($protobuf.roots['ununifi-client'] = {});

export const ununifi = ($root.ununifi = (() => {
  /**
   * Namespace ununifi.
   * @exports ununifi
   * @namespace
   */
  const ununifi = {};

  ununifi.derivatives = (function () {
    /**
     * Namespace derivatives.
     * @memberof ununifi
     * @namespace
     */
    const derivatives = {};

    derivatives.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.derivatives
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#depositToPool}.
       * @memberof ununifi.derivatives.Msg
       * @typedef DepositToPoolCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgDepositToPoolResponse} [response] MsgDepositToPoolResponse
       */

      /**
       * Calls DepositToPool.
       * @function depositToPool
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgDepositToPool} request MsgDepositToPool message or plain object
       * @param {ununifi.derivatives.Msg.DepositToPoolCallback} callback Node-style callback called with the error, if any, and MsgDepositToPoolResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.depositToPool = function depositToPool(request, callback) {
          return this.rpcCall(
            depositToPool,
            $root.ununifi.derivatives.MsgDepositToPool,
            $root.ununifi.derivatives.MsgDepositToPoolResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DepositToPool' },
      );

      /**
       * Calls DepositToPool.
       * @function depositToPool
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgDepositToPool} request MsgDepositToPool message or plain object
       * @returns {Promise<ununifi.derivatives.MsgDepositToPoolResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#withdrawFromPool}.
       * @memberof ununifi.derivatives.Msg
       * @typedef WithdrawFromPoolCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgWithdrawFromPoolResponse} [response] MsgWithdrawFromPoolResponse
       */

      /**
       * Calls WithdrawFromPool.
       * @function withdrawFromPool
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgWithdrawFromPool} request MsgWithdrawFromPool message or plain object
       * @param {ununifi.derivatives.Msg.WithdrawFromPoolCallback} callback Node-style callback called with the error, if any, and MsgWithdrawFromPoolResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawFromPool = function withdrawFromPool(request, callback) {
          return this.rpcCall(
            withdrawFromPool,
            $root.ununifi.derivatives.MsgWithdrawFromPool,
            $root.ununifi.derivatives.MsgWithdrawFromPoolResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawFromPool' },
      );

      /**
       * Calls WithdrawFromPool.
       * @function withdrawFromPool
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgWithdrawFromPool} request MsgWithdrawFromPool message or plain object
       * @returns {Promise<ununifi.derivatives.MsgWithdrawFromPoolResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#openPosition}.
       * @memberof ununifi.derivatives.Msg
       * @typedef OpenPositionCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgOpenPositionResponse} [response] MsgOpenPositionResponse
       */

      /**
       * Calls OpenPosition.
       * @function openPosition
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgOpenPosition} request MsgOpenPosition message or plain object
       * @param {ununifi.derivatives.Msg.OpenPositionCallback} callback Node-style callback called with the error, if any, and MsgOpenPositionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.openPosition = function openPosition(request, callback) {
          return this.rpcCall(
            openPosition,
            $root.ununifi.derivatives.MsgOpenPosition,
            $root.ununifi.derivatives.MsgOpenPositionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'OpenPosition' },
      );

      /**
       * Calls OpenPosition.
       * @function openPosition
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgOpenPosition} request MsgOpenPosition message or plain object
       * @returns {Promise<ununifi.derivatives.MsgOpenPositionResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#closePosition}.
       * @memberof ununifi.derivatives.Msg
       * @typedef ClosePositionCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgClosePositionResponse} [response] MsgClosePositionResponse
       */

      /**
       * Calls ClosePosition.
       * @function closePosition
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgClosePosition} request MsgClosePosition message or plain object
       * @param {ununifi.derivatives.Msg.ClosePositionCallback} callback Node-style callback called with the error, if any, and MsgClosePositionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.closePosition = function closePosition(request, callback) {
          return this.rpcCall(
            closePosition,
            $root.ununifi.derivatives.MsgClosePosition,
            $root.ununifi.derivatives.MsgClosePositionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ClosePosition' },
      );

      /**
       * Calls ClosePosition.
       * @function closePosition
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgClosePosition} request MsgClosePosition message or plain object
       * @returns {Promise<ununifi.derivatives.MsgClosePositionResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#reportLiquidation}.
       * @memberof ununifi.derivatives.Msg
       * @typedef ReportLiquidationCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgReportLiquidationResponse} [response] MsgReportLiquidationResponse
       */

      /**
       * Calls ReportLiquidation.
       * @function reportLiquidation
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgReportLiquidation} request MsgReportLiquidation message or plain object
       * @param {ununifi.derivatives.Msg.ReportLiquidationCallback} callback Node-style callback called with the error, if any, and MsgReportLiquidationResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.reportLiquidation = function reportLiquidation(request, callback) {
          return this.rpcCall(
            reportLiquidation,
            $root.ununifi.derivatives.MsgReportLiquidation,
            $root.ununifi.derivatives.MsgReportLiquidationResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ReportLiquidation' },
      );

      /**
       * Calls ReportLiquidation.
       * @function reportLiquidation
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgReportLiquidation} request MsgReportLiquidation message or plain object
       * @returns {Promise<ununifi.derivatives.MsgReportLiquidationResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#reportLevyPeriod}.
       * @memberof ununifi.derivatives.Msg
       * @typedef ReportLevyPeriodCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgReportLevyPeriodResponse} [response] MsgReportLevyPeriodResponse
       */

      /**
       * Calls ReportLevyPeriod.
       * @function reportLevyPeriod
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgReportLevyPeriod} request MsgReportLevyPeriod message or plain object
       * @param {ununifi.derivatives.Msg.ReportLevyPeriodCallback} callback Node-style callback called with the error, if any, and MsgReportLevyPeriodResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.reportLevyPeriod = function reportLevyPeriod(request, callback) {
          return this.rpcCall(
            reportLevyPeriod,
            $root.ununifi.derivatives.MsgReportLevyPeriod,
            $root.ununifi.derivatives.MsgReportLevyPeriodResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ReportLevyPeriod' },
      );

      /**
       * Calls ReportLevyPeriod.
       * @function reportLevyPeriod
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgReportLevyPeriod} request MsgReportLevyPeriod message or plain object
       * @returns {Promise<ununifi.derivatives.MsgReportLevyPeriodResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#addMargin}.
       * @memberof ununifi.derivatives.Msg
       * @typedef AddMarginCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgAddMarginResponse} [response] MsgAddMarginResponse
       */

      /**
       * Calls AddMargin.
       * @function addMargin
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgAddMargin} request MsgAddMargin message or plain object
       * @param {ununifi.derivatives.Msg.AddMarginCallback} callback Node-style callback called with the error, if any, and MsgAddMarginResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.addMargin = function addMargin(request, callback) {
          return this.rpcCall(
            addMargin,
            $root.ununifi.derivatives.MsgAddMargin,
            $root.ununifi.derivatives.MsgAddMarginResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AddMargin' },
      );

      /**
       * Calls AddMargin.
       * @function addMargin
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgAddMargin} request MsgAddMargin message or plain object
       * @returns {Promise<ununifi.derivatives.MsgAddMarginResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Msg#removeMargin}.
       * @memberof ununifi.derivatives.Msg
       * @typedef RemoveMarginCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.MsgRemoveMarginResponse} [response] MsgRemoveMarginResponse
       */

      /**
       * Calls RemoveMargin.
       * @function removeMargin
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgRemoveMargin} request MsgRemoveMargin message or plain object
       * @param {ununifi.derivatives.Msg.RemoveMarginCallback} callback Node-style callback called with the error, if any, and MsgRemoveMarginResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.removeMargin = function removeMargin(request, callback) {
          return this.rpcCall(
            removeMargin,
            $root.ununifi.derivatives.MsgRemoveMargin,
            $root.ununifi.derivatives.MsgRemoveMarginResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RemoveMargin' },
      );

      /**
       * Calls RemoveMargin.
       * @function removeMargin
       * @memberof ununifi.derivatives.Msg
       * @instance
       * @param {ununifi.derivatives.IMsgRemoveMargin} request MsgRemoveMargin message or plain object
       * @returns {Promise<ununifi.derivatives.MsgRemoveMarginResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    derivatives.MsgDepositToPool = (function () {
      /**
       * Properties of a MsgDepositToPool.
       * @memberof ununifi.derivatives
       * @interface IMsgDepositToPool
       * @property {string|null} [sender] MsgDepositToPool sender
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgDepositToPool amount
       */

      /**
       * Constructs a new MsgDepositToPool.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgDepositToPool.
       * @implements IMsgDepositToPool
       * @constructor
       * @param {ununifi.derivatives.IMsgDepositToPool=} [properties] Properties to set
       */
      function MsgDepositToPool(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgDepositToPool sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @instance
       */
      MsgDepositToPool.prototype.sender = '';

      /**
       * MsgDepositToPool amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @instance
       */
      MsgDepositToPool.prototype.amount = null;

      /**
       * Encodes the specified MsgDepositToPool message. Does not implicitly {@link ununifi.derivatives.MsgDepositToPool.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @static
       * @param {ununifi.derivatives.IMsgDepositToPool} message MsgDepositToPool message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToPool.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositToPool message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgDepositToPool.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @static
       * @param {ununifi.derivatives.IMsgDepositToPool} message MsgDepositToPool message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToPool.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositToPool message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgDepositToPool} MsgDepositToPool
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToPool.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgDepositToPool();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositToPool message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgDepositToPool} MsgDepositToPool
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToPool.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositToPool message.
       * @function verify
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositToPool.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgDepositToPool message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgDepositToPool} MsgDepositToPool
       */
      MsgDepositToPool.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgDepositToPool) return object;
        let message = new $root.ununifi.derivatives.MsgDepositToPool();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.derivatives.MsgDepositToPool.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgDepositToPool message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @static
       * @param {ununifi.derivatives.MsgDepositToPool} message MsgDepositToPool
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositToPool.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.amount = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this MsgDepositToPool to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgDepositToPool
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositToPool.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositToPool;
    })();

    derivatives.MsgDepositToPoolResponse = (function () {
      /**
       * Properties of a MsgDepositToPoolResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgDepositToPoolResponse
       */

      /**
       * Constructs a new MsgDepositToPoolResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgDepositToPoolResponse.
       * @implements IMsgDepositToPoolResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgDepositToPoolResponse=} [properties] Properties to set
       */
      function MsgDepositToPoolResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgDepositToPoolResponse message. Does not implicitly {@link ununifi.derivatives.MsgDepositToPoolResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @static
       * @param {ununifi.derivatives.IMsgDepositToPoolResponse} message MsgDepositToPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToPoolResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositToPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgDepositToPoolResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @static
       * @param {ununifi.derivatives.IMsgDepositToPoolResponse} message MsgDepositToPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositToPoolResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgDepositToPoolResponse} MsgDepositToPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToPoolResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgDepositToPoolResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositToPoolResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgDepositToPoolResponse} MsgDepositToPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToPoolResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositToPoolResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositToPoolResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgDepositToPoolResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgDepositToPoolResponse} MsgDepositToPoolResponse
       */
      MsgDepositToPoolResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgDepositToPoolResponse) return object;
        return new $root.ununifi.derivatives.MsgDepositToPoolResponse();
      };

      /**
       * Creates a plain object from a MsgDepositToPoolResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @static
       * @param {ununifi.derivatives.MsgDepositToPoolResponse} message MsgDepositToPoolResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositToPoolResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgDepositToPoolResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgDepositToPoolResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositToPoolResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositToPoolResponse;
    })();

    derivatives.MsgWithdrawFromPool = (function () {
      /**
       * Properties of a MsgWithdrawFromPool.
       * @memberof ununifi.derivatives
       * @interface IMsgWithdrawFromPool
       * @property {string|null} [sender] MsgWithdrawFromPool sender
       * @property {string|null} [lpt_amount] MsgWithdrawFromPool lpt_amount
       * @property {string|null} [redeem_denom] MsgWithdrawFromPool redeem_denom
       */

      /**
       * Constructs a new MsgWithdrawFromPool.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgWithdrawFromPool.
       * @implements IMsgWithdrawFromPool
       * @constructor
       * @param {ununifi.derivatives.IMsgWithdrawFromPool=} [properties] Properties to set
       */
      function MsgWithdrawFromPool(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawFromPool sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @instance
       */
      MsgWithdrawFromPool.prototype.sender = '';

      /**
       * MsgWithdrawFromPool lpt_amount.
       * @member {string} lpt_amount
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @instance
       */
      MsgWithdrawFromPool.prototype.lpt_amount = '';

      /**
       * MsgWithdrawFromPool redeem_denom.
       * @member {string} redeem_denom
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @instance
       */
      MsgWithdrawFromPool.prototype.redeem_denom = '';

      /**
       * Encodes the specified MsgWithdrawFromPool message. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPool.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @static
       * @param {ununifi.derivatives.IMsgWithdrawFromPool} message MsgWithdrawFromPool message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromPool.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.lpt_amount != null && Object.hasOwnProperty.call(message, 'lpt_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.lpt_amount);
        if (message.redeem_denom != null && Object.hasOwnProperty.call(message, 'redeem_denom'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.redeem_denom);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromPool message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPool.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @static
       * @param {ununifi.derivatives.IMsgWithdrawFromPool} message MsgWithdrawFromPool message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromPool.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromPool message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgWithdrawFromPool} MsgWithdrawFromPool
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromPool.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgWithdrawFromPool();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.lpt_amount = reader.string();
              break;
            case 3:
              message.redeem_denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromPool message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgWithdrawFromPool} MsgWithdrawFromPool
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromPool.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromPool message.
       * @function verify
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromPool.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.lpt_amount != null && message.hasOwnProperty('lpt_amount'))
          if (!$util.isString(message.lpt_amount)) return 'lpt_amount: string expected';
        if (message.redeem_denom != null && message.hasOwnProperty('redeem_denom'))
          if (!$util.isString(message.redeem_denom)) return 'redeem_denom: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromPool message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgWithdrawFromPool} MsgWithdrawFromPool
       */
      MsgWithdrawFromPool.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgWithdrawFromPool) return object;
        let message = new $root.ununifi.derivatives.MsgWithdrawFromPool();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.lpt_amount != null) message.lpt_amount = String(object.lpt_amount);
        if (object.redeem_denom != null) message.redeem_denom = String(object.redeem_denom);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawFromPool message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @static
       * @param {ununifi.derivatives.MsgWithdrawFromPool} message MsgWithdrawFromPool
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromPool.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.lpt_amount = '';
          object.redeem_denom = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.lpt_amount != null && message.hasOwnProperty('lpt_amount')) object.lpt_amount = message.lpt_amount;
        if (message.redeem_denom != null && message.hasOwnProperty('redeem_denom')) object.redeem_denom = message.redeem_denom;
        return object;
      };

      /**
       * Converts this MsgWithdrawFromPool to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgWithdrawFromPool
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromPool.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromPool;
    })();

    derivatives.MsgWithdrawFromPoolResponse = (function () {
      /**
       * Properties of a MsgWithdrawFromPoolResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgWithdrawFromPoolResponse
       */

      /**
       * Constructs a new MsgWithdrawFromPoolResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgWithdrawFromPoolResponse.
       * @implements IMsgWithdrawFromPoolResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgWithdrawFromPoolResponse=} [properties] Properties to set
       */
      function MsgWithdrawFromPoolResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawFromPoolResponse message. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPoolResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @static
       * @param {ununifi.derivatives.IMsgWithdrawFromPoolResponse} message MsgWithdrawFromPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromPoolResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgWithdrawFromPoolResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @static
       * @param {ununifi.derivatives.IMsgWithdrawFromPoolResponse} message MsgWithdrawFromPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromPoolResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgWithdrawFromPoolResponse} MsgWithdrawFromPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromPoolResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgWithdrawFromPoolResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromPoolResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgWithdrawFromPoolResponse} MsgWithdrawFromPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromPoolResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromPoolResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromPoolResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromPoolResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgWithdrawFromPoolResponse} MsgWithdrawFromPoolResponse
       */
      MsgWithdrawFromPoolResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgWithdrawFromPoolResponse) return object;
        return new $root.ununifi.derivatives.MsgWithdrawFromPoolResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawFromPoolResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @static
       * @param {ununifi.derivatives.MsgWithdrawFromPoolResponse} message MsgWithdrawFromPoolResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromPoolResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawFromPoolResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgWithdrawFromPoolResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromPoolResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromPoolResponse;
    })();

    derivatives.MsgOpenPosition = (function () {
      /**
       * Properties of a MsgOpenPosition.
       * @memberof ununifi.derivatives
       * @interface IMsgOpenPosition
       * @property {string|null} [sender] MsgOpenPosition sender
       * @property {cosmos.base.v1beta1.ICoin|null} [margin] MsgOpenPosition margin
       * @property {ununifi.derivatives.IMarket|null} [market] MsgOpenPosition market
       * @property {google.protobuf.IAny|null} [position_instance] MsgOpenPosition position_instance
       */

      /**
       * Constructs a new MsgOpenPosition.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgOpenPosition.
       * @implements IMsgOpenPosition
       * @constructor
       * @param {ununifi.derivatives.IMsgOpenPosition=} [properties] Properties to set
       */
      function MsgOpenPosition(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgOpenPosition sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @instance
       */
      MsgOpenPosition.prototype.sender = '';

      /**
       * MsgOpenPosition margin.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} margin
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @instance
       */
      MsgOpenPosition.prototype.margin = null;

      /**
       * MsgOpenPosition market.
       * @member {ununifi.derivatives.IMarket|null|undefined} market
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @instance
       */
      MsgOpenPosition.prototype.market = null;

      /**
       * MsgOpenPosition position_instance.
       * @member {google.protobuf.IAny|null|undefined} position_instance
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @instance
       */
      MsgOpenPosition.prototype.position_instance = null;

      /**
       * Encodes the specified MsgOpenPosition message. Does not implicitly {@link ununifi.derivatives.MsgOpenPosition.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @static
       * @param {ununifi.derivatives.IMsgOpenPosition} message MsgOpenPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgOpenPosition.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.margin != null && Object.hasOwnProperty.call(message, 'margin'))
          $root.cosmos.base.v1beta1.Coin.encode(message.margin, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.market != null && Object.hasOwnProperty.call(message, 'market'))
          $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.position_instance != null && Object.hasOwnProperty.call(message, 'position_instance'))
          $root.google.protobuf.Any.encode(message.position_instance, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgOpenPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgOpenPosition.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @static
       * @param {ununifi.derivatives.IMsgOpenPosition} message MsgOpenPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgOpenPosition.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgOpenPosition message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgOpenPosition} MsgOpenPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgOpenPosition.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgOpenPosition();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
              break;
            case 4:
              message.position_instance = $root.google.protobuf.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgOpenPosition message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgOpenPosition} MsgOpenPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgOpenPosition.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgOpenPosition message.
       * @function verify
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgOpenPosition.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.margin != null && message.hasOwnProperty('margin')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.margin);
          if (error) return 'margin.' + error;
        }
        if (message.market != null && message.hasOwnProperty('market')) {
          let error = $root.ununifi.derivatives.Market.verify(message.market);
          if (error) return 'market.' + error;
        }
        if (message.position_instance != null && message.hasOwnProperty('position_instance')) {
          let error = $root.google.protobuf.Any.verify(message.position_instance);
          if (error) return 'position_instance.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgOpenPosition message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgOpenPosition} MsgOpenPosition
       */
      MsgOpenPosition.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgOpenPosition) return object;
        let message = new $root.ununifi.derivatives.MsgOpenPosition();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.margin != null) {
          if (typeof object.margin !== 'object') throw TypeError('.ununifi.derivatives.MsgOpenPosition.margin: object expected');
          message.margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.margin);
        }
        if (object.market != null) {
          if (typeof object.market !== 'object') throw TypeError('.ununifi.derivatives.MsgOpenPosition.market: object expected');
          message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
        }
        if (object.position_instance != null) {
          if (typeof object.position_instance !== 'object')
            throw TypeError('.ununifi.derivatives.MsgOpenPosition.position_instance: object expected');
          message.position_instance = $root.google.protobuf.Any.fromObject(object.position_instance);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgOpenPosition message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @static
       * @param {ununifi.derivatives.MsgOpenPosition} message MsgOpenPosition
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgOpenPosition.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.margin = null;
          object.market = null;
          object.position_instance = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.margin != null && message.hasOwnProperty('margin'))
          object.margin = $root.cosmos.base.v1beta1.Coin.toObject(message.margin, options);
        if (message.market != null && message.hasOwnProperty('market'))
          object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
        if (message.position_instance != null && message.hasOwnProperty('position_instance'))
          object.position_instance = $root.google.protobuf.Any.toObject(message.position_instance, options);
        return object;
      };

      /**
       * Converts this MsgOpenPosition to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgOpenPosition
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgOpenPosition.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgOpenPosition;
    })();

    derivatives.MsgOpenPositionResponse = (function () {
      /**
       * Properties of a MsgOpenPositionResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgOpenPositionResponse
       */

      /**
       * Constructs a new MsgOpenPositionResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgOpenPositionResponse.
       * @implements IMsgOpenPositionResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgOpenPositionResponse=} [properties] Properties to set
       */
      function MsgOpenPositionResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgOpenPositionResponse message. Does not implicitly {@link ununifi.derivatives.MsgOpenPositionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @static
       * @param {ununifi.derivatives.IMsgOpenPositionResponse} message MsgOpenPositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgOpenPositionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgOpenPositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgOpenPositionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @static
       * @param {ununifi.derivatives.IMsgOpenPositionResponse} message MsgOpenPositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgOpenPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgOpenPositionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgOpenPositionResponse} MsgOpenPositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgOpenPositionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgOpenPositionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgOpenPositionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgOpenPositionResponse} MsgOpenPositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgOpenPositionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgOpenPositionResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgOpenPositionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgOpenPositionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgOpenPositionResponse} MsgOpenPositionResponse
       */
      MsgOpenPositionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgOpenPositionResponse) return object;
        return new $root.ununifi.derivatives.MsgOpenPositionResponse();
      };

      /**
       * Creates a plain object from a MsgOpenPositionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @static
       * @param {ununifi.derivatives.MsgOpenPositionResponse} message MsgOpenPositionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgOpenPositionResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgOpenPositionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgOpenPositionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgOpenPositionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgOpenPositionResponse;
    })();

    derivatives.MsgClosePosition = (function () {
      /**
       * Properties of a MsgClosePosition.
       * @memberof ununifi.derivatives
       * @interface IMsgClosePosition
       * @property {string|null} [sender] MsgClosePosition sender
       * @property {string|null} [position_id] MsgClosePosition position_id
       */

      /**
       * Constructs a new MsgClosePosition.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgClosePosition.
       * @implements IMsgClosePosition
       * @constructor
       * @param {ununifi.derivatives.IMsgClosePosition=} [properties] Properties to set
       */
      function MsgClosePosition(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgClosePosition sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgClosePosition
       * @instance
       */
      MsgClosePosition.prototype.sender = '';

      /**
       * MsgClosePosition position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.MsgClosePosition
       * @instance
       */
      MsgClosePosition.prototype.position_id = '';

      /**
       * Encodes the specified MsgClosePosition message. Does not implicitly {@link ununifi.derivatives.MsgClosePosition.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgClosePosition
       * @static
       * @param {ununifi.derivatives.IMsgClosePosition} message MsgClosePosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClosePosition.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified MsgClosePosition message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgClosePosition.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgClosePosition
       * @static
       * @param {ununifi.derivatives.IMsgClosePosition} message MsgClosePosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClosePosition.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgClosePosition message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgClosePosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgClosePosition} MsgClosePosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClosePosition.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgClosePosition();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgClosePosition message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgClosePosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgClosePosition} MsgClosePosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClosePosition.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgClosePosition message.
       * @function verify
       * @memberof ununifi.derivatives.MsgClosePosition
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgClosePosition.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates a MsgClosePosition message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgClosePosition
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgClosePosition} MsgClosePosition
       */
      MsgClosePosition.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgClosePosition) return object;
        let message = new $root.ununifi.derivatives.MsgClosePosition();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from a MsgClosePosition message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgClosePosition
       * @static
       * @param {ununifi.derivatives.MsgClosePosition} message MsgClosePosition
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgClosePosition.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.position_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this MsgClosePosition to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgClosePosition
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgClosePosition.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgClosePosition;
    })();

    derivatives.MsgClosePositionResponse = (function () {
      /**
       * Properties of a MsgClosePositionResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgClosePositionResponse
       */

      /**
       * Constructs a new MsgClosePositionResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgClosePositionResponse.
       * @implements IMsgClosePositionResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgClosePositionResponse=} [properties] Properties to set
       */
      function MsgClosePositionResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgClosePositionResponse message. Does not implicitly {@link ununifi.derivatives.MsgClosePositionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @static
       * @param {ununifi.derivatives.IMsgClosePositionResponse} message MsgClosePositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClosePositionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgClosePositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgClosePositionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @static
       * @param {ununifi.derivatives.IMsgClosePositionResponse} message MsgClosePositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgClosePositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgClosePositionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgClosePositionResponse} MsgClosePositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClosePositionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgClosePositionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgClosePositionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgClosePositionResponse} MsgClosePositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgClosePositionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgClosePositionResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgClosePositionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgClosePositionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgClosePositionResponse} MsgClosePositionResponse
       */
      MsgClosePositionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgClosePositionResponse) return object;
        return new $root.ununifi.derivatives.MsgClosePositionResponse();
      };

      /**
       * Creates a plain object from a MsgClosePositionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @static
       * @param {ununifi.derivatives.MsgClosePositionResponse} message MsgClosePositionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgClosePositionResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgClosePositionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgClosePositionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgClosePositionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgClosePositionResponse;
    })();

    derivatives.MsgReportLiquidation = (function () {
      /**
       * Properties of a MsgReportLiquidation.
       * @memberof ununifi.derivatives
       * @interface IMsgReportLiquidation
       * @property {string|null} [sender] MsgReportLiquidation sender
       * @property {string|null} [position_id] MsgReportLiquidation position_id
       * @property {string|null} [reward_recipient] MsgReportLiquidation reward_recipient
       */

      /**
       * Constructs a new MsgReportLiquidation.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgReportLiquidation.
       * @implements IMsgReportLiquidation
       * @constructor
       * @param {ununifi.derivatives.IMsgReportLiquidation=} [properties] Properties to set
       */
      function MsgReportLiquidation(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgReportLiquidation sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @instance
       */
      MsgReportLiquidation.prototype.sender = '';

      /**
       * MsgReportLiquidation position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @instance
       */
      MsgReportLiquidation.prototype.position_id = '';

      /**
       * MsgReportLiquidation reward_recipient.
       * @member {string} reward_recipient
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @instance
       */
      MsgReportLiquidation.prototype.reward_recipient = '';

      /**
       * Encodes the specified MsgReportLiquidation message. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidation.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @static
       * @param {ununifi.derivatives.IMsgReportLiquidation} message MsgReportLiquidation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLiquidation.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        if (message.reward_recipient != null && Object.hasOwnProperty.call(message, 'reward_recipient'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.reward_recipient);
        return writer;
      };

      /**
       * Encodes the specified MsgReportLiquidation message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidation.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @static
       * @param {ununifi.derivatives.IMsgReportLiquidation} message MsgReportLiquidation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLiquidation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgReportLiquidation message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgReportLiquidation} MsgReportLiquidation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLiquidation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgReportLiquidation();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            case 3:
              message.reward_recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgReportLiquidation message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgReportLiquidation} MsgReportLiquidation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLiquidation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgReportLiquidation message.
       * @function verify
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgReportLiquidation.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          if (!$util.isString(message.reward_recipient)) return 'reward_recipient: string expected';
        return null;
      };

      /**
       * Creates a MsgReportLiquidation message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgReportLiquidation} MsgReportLiquidation
       */
      MsgReportLiquidation.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgReportLiquidation) return object;
        let message = new $root.ununifi.derivatives.MsgReportLiquidation();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.position_id != null) message.position_id = String(object.position_id);
        if (object.reward_recipient != null) message.reward_recipient = String(object.reward_recipient);
        return message;
      };

      /**
       * Creates a plain object from a MsgReportLiquidation message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @static
       * @param {ununifi.derivatives.MsgReportLiquidation} message MsgReportLiquidation
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgReportLiquidation.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.position_id = '';
          object.reward_recipient = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          object.reward_recipient = message.reward_recipient;
        return object;
      };

      /**
       * Converts this MsgReportLiquidation to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgReportLiquidation
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgReportLiquidation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgReportLiquidation;
    })();

    derivatives.MsgReportLiquidationResponse = (function () {
      /**
       * Properties of a MsgReportLiquidationResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgReportLiquidationResponse
       */

      /**
       * Constructs a new MsgReportLiquidationResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgReportLiquidationResponse.
       * @implements IMsgReportLiquidationResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgReportLiquidationResponse=} [properties] Properties to set
       */
      function MsgReportLiquidationResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgReportLiquidationResponse message. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidationResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @static
       * @param {ununifi.derivatives.IMsgReportLiquidationResponse} message MsgReportLiquidationResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLiquidationResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgReportLiquidationResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLiquidationResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @static
       * @param {ununifi.derivatives.IMsgReportLiquidationResponse} message MsgReportLiquidationResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLiquidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgReportLiquidationResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgReportLiquidationResponse} MsgReportLiquidationResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLiquidationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgReportLiquidationResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgReportLiquidationResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgReportLiquidationResponse} MsgReportLiquidationResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLiquidationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgReportLiquidationResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgReportLiquidationResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgReportLiquidationResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgReportLiquidationResponse} MsgReportLiquidationResponse
       */
      MsgReportLiquidationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgReportLiquidationResponse) return object;
        return new $root.ununifi.derivatives.MsgReportLiquidationResponse();
      };

      /**
       * Creates a plain object from a MsgReportLiquidationResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @static
       * @param {ununifi.derivatives.MsgReportLiquidationResponse} message MsgReportLiquidationResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgReportLiquidationResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgReportLiquidationResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgReportLiquidationResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgReportLiquidationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgReportLiquidationResponse;
    })();

    derivatives.MsgReportLevyPeriod = (function () {
      /**
       * Properties of a MsgReportLevyPeriod.
       * @memberof ununifi.derivatives
       * @interface IMsgReportLevyPeriod
       * @property {string|null} [sender] MsgReportLevyPeriod sender
       * @property {string|null} [position_id] MsgReportLevyPeriod position_id
       * @property {string|null} [reward_recipient] MsgReportLevyPeriod reward_recipient
       */

      /**
       * Constructs a new MsgReportLevyPeriod.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgReportLevyPeriod.
       * @implements IMsgReportLevyPeriod
       * @constructor
       * @param {ununifi.derivatives.IMsgReportLevyPeriod=} [properties] Properties to set
       */
      function MsgReportLevyPeriod(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgReportLevyPeriod sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @instance
       */
      MsgReportLevyPeriod.prototype.sender = '';

      /**
       * MsgReportLevyPeriod position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @instance
       */
      MsgReportLevyPeriod.prototype.position_id = '';

      /**
       * MsgReportLevyPeriod reward_recipient.
       * @member {string} reward_recipient
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @instance
       */
      MsgReportLevyPeriod.prototype.reward_recipient = '';

      /**
       * Encodes the specified MsgReportLevyPeriod message. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriod.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @static
       * @param {ununifi.derivatives.IMsgReportLevyPeriod} message MsgReportLevyPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLevyPeriod.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        if (message.reward_recipient != null && Object.hasOwnProperty.call(message, 'reward_recipient'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.reward_recipient);
        return writer;
      };

      /**
       * Encodes the specified MsgReportLevyPeriod message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriod.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @static
       * @param {ununifi.derivatives.IMsgReportLevyPeriod} message MsgReportLevyPeriod message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLevyPeriod.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgReportLevyPeriod message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgReportLevyPeriod} MsgReportLevyPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLevyPeriod.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgReportLevyPeriod();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            case 3:
              message.reward_recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgReportLevyPeriod message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgReportLevyPeriod} MsgReportLevyPeriod
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLevyPeriod.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgReportLevyPeriod message.
       * @function verify
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgReportLevyPeriod.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          if (!$util.isString(message.reward_recipient)) return 'reward_recipient: string expected';
        return null;
      };

      /**
       * Creates a MsgReportLevyPeriod message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgReportLevyPeriod} MsgReportLevyPeriod
       */
      MsgReportLevyPeriod.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgReportLevyPeriod) return object;
        let message = new $root.ununifi.derivatives.MsgReportLevyPeriod();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.position_id != null) message.position_id = String(object.position_id);
        if (object.reward_recipient != null) message.reward_recipient = String(object.reward_recipient);
        return message;
      };

      /**
       * Creates a plain object from a MsgReportLevyPeriod message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @static
       * @param {ununifi.derivatives.MsgReportLevyPeriod} message MsgReportLevyPeriod
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgReportLevyPeriod.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.position_id = '';
          object.reward_recipient = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          object.reward_recipient = message.reward_recipient;
        return object;
      };

      /**
       * Converts this MsgReportLevyPeriod to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgReportLevyPeriod
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgReportLevyPeriod.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgReportLevyPeriod;
    })();

    derivatives.MsgReportLevyPeriodResponse = (function () {
      /**
       * Properties of a MsgReportLevyPeriodResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgReportLevyPeriodResponse
       */

      /**
       * Constructs a new MsgReportLevyPeriodResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgReportLevyPeriodResponse.
       * @implements IMsgReportLevyPeriodResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgReportLevyPeriodResponse=} [properties] Properties to set
       */
      function MsgReportLevyPeriodResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgReportLevyPeriodResponse message. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriodResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @static
       * @param {ununifi.derivatives.IMsgReportLevyPeriodResponse} message MsgReportLevyPeriodResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLevyPeriodResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgReportLevyPeriodResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgReportLevyPeriodResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @static
       * @param {ununifi.derivatives.IMsgReportLevyPeriodResponse} message MsgReportLevyPeriodResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReportLevyPeriodResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgReportLevyPeriodResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgReportLevyPeriodResponse} MsgReportLevyPeriodResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLevyPeriodResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgReportLevyPeriodResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgReportLevyPeriodResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgReportLevyPeriodResponse} MsgReportLevyPeriodResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReportLevyPeriodResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgReportLevyPeriodResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgReportLevyPeriodResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgReportLevyPeriodResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgReportLevyPeriodResponse} MsgReportLevyPeriodResponse
       */
      MsgReportLevyPeriodResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgReportLevyPeriodResponse) return object;
        return new $root.ununifi.derivatives.MsgReportLevyPeriodResponse();
      };

      /**
       * Creates a plain object from a MsgReportLevyPeriodResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @static
       * @param {ununifi.derivatives.MsgReportLevyPeriodResponse} message MsgReportLevyPeriodResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgReportLevyPeriodResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgReportLevyPeriodResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgReportLevyPeriodResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgReportLevyPeriodResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgReportLevyPeriodResponse;
    })();

    derivatives.MsgAddMargin = (function () {
      /**
       * Properties of a MsgAddMargin.
       * @memberof ununifi.derivatives
       * @interface IMsgAddMargin
       * @property {string|null} [sender] MsgAddMargin sender
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgAddMargin amount
       * @property {string|null} [position_id] MsgAddMargin position_id
       */

      /**
       * Constructs a new MsgAddMargin.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgAddMargin.
       * @implements IMsgAddMargin
       * @constructor
       * @param {ununifi.derivatives.IMsgAddMargin=} [properties] Properties to set
       */
      function MsgAddMargin(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgAddMargin sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgAddMargin
       * @instance
       */
      MsgAddMargin.prototype.sender = '';

      /**
       * MsgAddMargin amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.derivatives.MsgAddMargin
       * @instance
       */
      MsgAddMargin.prototype.amount = null;

      /**
       * MsgAddMargin position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.MsgAddMargin
       * @instance
       */
      MsgAddMargin.prototype.position_id = '';

      /**
       * Encodes the specified MsgAddMargin message. Does not implicitly {@link ununifi.derivatives.MsgAddMargin.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgAddMargin
       * @static
       * @param {ununifi.derivatives.IMsgAddMargin} message MsgAddMargin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgAddMargin.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified MsgAddMargin message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgAddMargin.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgAddMargin
       * @static
       * @param {ununifi.derivatives.IMsgAddMargin} message MsgAddMargin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgAddMargin.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgAddMargin message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgAddMargin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgAddMargin} MsgAddMargin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgAddMargin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgAddMargin();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgAddMargin message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgAddMargin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgAddMargin} MsgAddMargin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgAddMargin.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgAddMargin message.
       * @function verify
       * @memberof ununifi.derivatives.MsgAddMargin
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgAddMargin.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates a MsgAddMargin message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgAddMargin
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgAddMargin} MsgAddMargin
       */
      MsgAddMargin.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgAddMargin) return object;
        let message = new $root.ununifi.derivatives.MsgAddMargin();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.derivatives.MsgAddMargin.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from a MsgAddMargin message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgAddMargin
       * @static
       * @param {ununifi.derivatives.MsgAddMargin} message MsgAddMargin
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgAddMargin.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.amount = null;
          object.position_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this MsgAddMargin to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgAddMargin
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgAddMargin.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgAddMargin;
    })();

    derivatives.MsgAddMarginResponse = (function () {
      /**
       * Properties of a MsgAddMarginResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgAddMarginResponse
       */

      /**
       * Constructs a new MsgAddMarginResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgAddMarginResponse.
       * @implements IMsgAddMarginResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgAddMarginResponse=} [properties] Properties to set
       */
      function MsgAddMarginResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgAddMarginResponse message. Does not implicitly {@link ununifi.derivatives.MsgAddMarginResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @static
       * @param {ununifi.derivatives.IMsgAddMarginResponse} message MsgAddMarginResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgAddMarginResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgAddMarginResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgAddMarginResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @static
       * @param {ununifi.derivatives.IMsgAddMarginResponse} message MsgAddMarginResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgAddMarginResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgAddMarginResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgAddMarginResponse} MsgAddMarginResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgAddMarginResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgAddMarginResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgAddMarginResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgAddMarginResponse} MsgAddMarginResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgAddMarginResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgAddMarginResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgAddMarginResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgAddMarginResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgAddMarginResponse} MsgAddMarginResponse
       */
      MsgAddMarginResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgAddMarginResponse) return object;
        return new $root.ununifi.derivatives.MsgAddMarginResponse();
      };

      /**
       * Creates a plain object from a MsgAddMarginResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @static
       * @param {ununifi.derivatives.MsgAddMarginResponse} message MsgAddMarginResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgAddMarginResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgAddMarginResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgAddMarginResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgAddMarginResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgAddMarginResponse;
    })();

    derivatives.MsgRemoveMargin = (function () {
      /**
       * Properties of a MsgRemoveMargin.
       * @memberof ununifi.derivatives
       * @interface IMsgRemoveMargin
       * @property {string|null} [sender] MsgRemoveMargin sender
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgRemoveMargin amount
       * @property {string|null} [position_id] MsgRemoveMargin position_id
       */

      /**
       * Constructs a new MsgRemoveMargin.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgRemoveMargin.
       * @implements IMsgRemoveMargin
       * @constructor
       * @param {ununifi.derivatives.IMsgRemoveMargin=} [properties] Properties to set
       */
      function MsgRemoveMargin(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRemoveMargin sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @instance
       */
      MsgRemoveMargin.prototype.sender = '';

      /**
       * MsgRemoveMargin amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @instance
       */
      MsgRemoveMargin.prototype.amount = null;

      /**
       * MsgRemoveMargin position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @instance
       */
      MsgRemoveMargin.prototype.position_id = '';

      /**
       * Encodes the specified MsgRemoveMargin message. Does not implicitly {@link ununifi.derivatives.MsgRemoveMargin.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @static
       * @param {ununifi.derivatives.IMsgRemoveMargin} message MsgRemoveMargin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRemoveMargin.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified MsgRemoveMargin message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgRemoveMargin.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @static
       * @param {ununifi.derivatives.IMsgRemoveMargin} message MsgRemoveMargin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRemoveMargin.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRemoveMargin message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgRemoveMargin} MsgRemoveMargin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRemoveMargin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgRemoveMargin();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRemoveMargin message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgRemoveMargin} MsgRemoveMargin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRemoveMargin.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRemoveMargin message.
       * @function verify
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRemoveMargin.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates a MsgRemoveMargin message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgRemoveMargin} MsgRemoveMargin
       */
      MsgRemoveMargin.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgRemoveMargin) return object;
        let message = new $root.ununifi.derivatives.MsgRemoveMargin();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.derivatives.MsgRemoveMargin.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from a MsgRemoveMargin message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @static
       * @param {ununifi.derivatives.MsgRemoveMargin} message MsgRemoveMargin
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRemoveMargin.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.amount = null;
          object.position_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this MsgRemoveMargin to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgRemoveMargin
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRemoveMargin.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRemoveMargin;
    })();

    derivatives.MsgRemoveMarginResponse = (function () {
      /**
       * Properties of a MsgRemoveMarginResponse.
       * @memberof ununifi.derivatives
       * @interface IMsgRemoveMarginResponse
       */

      /**
       * Constructs a new MsgRemoveMarginResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a MsgRemoveMarginResponse.
       * @implements IMsgRemoveMarginResponse
       * @constructor
       * @param {ununifi.derivatives.IMsgRemoveMarginResponse=} [properties] Properties to set
       */
      function MsgRemoveMarginResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRemoveMarginResponse message. Does not implicitly {@link ununifi.derivatives.MsgRemoveMarginResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @static
       * @param {ununifi.derivatives.IMsgRemoveMarginResponse} message MsgRemoveMarginResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRemoveMarginResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRemoveMarginResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.MsgRemoveMarginResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @static
       * @param {ununifi.derivatives.IMsgRemoveMarginResponse} message MsgRemoveMarginResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRemoveMarginResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRemoveMarginResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.MsgRemoveMarginResponse} MsgRemoveMarginResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRemoveMarginResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.MsgRemoveMarginResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRemoveMarginResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.MsgRemoveMarginResponse} MsgRemoveMarginResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRemoveMarginResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRemoveMarginResponse message.
       * @function verify
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRemoveMarginResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRemoveMarginResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.MsgRemoveMarginResponse} MsgRemoveMarginResponse
       */
      MsgRemoveMarginResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.MsgRemoveMarginResponse) return object;
        return new $root.ununifi.derivatives.MsgRemoveMarginResponse();
      };

      /**
       * Creates a plain object from a MsgRemoveMarginResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @static
       * @param {ununifi.derivatives.MsgRemoveMarginResponse} message MsgRemoveMarginResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRemoveMarginResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRemoveMarginResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.MsgRemoveMarginResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRemoveMarginResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRemoveMarginResponse;
    })();

    derivatives.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.derivatives
       * @interface IGenesisState
       * @property {ununifi.derivatives.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.derivatives.IPosition>|null} [positions] GenesisState positions
       * @property {ununifi.derivatives.IPoolMarketCap|null} [pool_market_cap] GenesisState pool_market_cap
       * @property {Array.<ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket>|null} [perpetual_futures_gross_position_of_market] GenesisState perpetual_futures_gross_position_of_market
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.derivatives
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.derivatives.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.positions = [];
        this.perpetual_futures_gross_position_of_market = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.derivatives.IParams|null|undefined} params
       * @memberof ununifi.derivatives.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState positions.
       * @member {Array.<ununifi.derivatives.IPosition>} positions
       * @memberof ununifi.derivatives.GenesisState
       * @instance
       */
      GenesisState.prototype.positions = $util.emptyArray;

      /**
       * GenesisState pool_market_cap.
       * @member {ununifi.derivatives.IPoolMarketCap|null|undefined} pool_market_cap
       * @memberof ununifi.derivatives.GenesisState
       * @instance
       */
      GenesisState.prototype.pool_market_cap = null;

      /**
       * GenesisState perpetual_futures_gross_position_of_market.
       * @member {Array.<ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket>} perpetual_futures_gross_position_of_market
       * @memberof ununifi.derivatives.GenesisState
       * @instance
       */
      GenesisState.prototype.perpetual_futures_gross_position_of_market = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.derivatives.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.GenesisState
       * @static
       * @param {ununifi.derivatives.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.derivatives.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.positions != null && message.positions.length)
          for (let i = 0; i < message.positions.length; ++i)
            $root.ununifi.derivatives.Position.encode(message.positions[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.pool_market_cap != null && Object.hasOwnProperty.call(message, 'pool_market_cap'))
          $root.ununifi.derivatives.PoolMarketCap.encode(
            message.pool_market_cap,
            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
          ).ldelim();
        if (message.perpetual_futures_gross_position_of_market != null && message.perpetual_futures_gross_position_of_market.length)
          for (let i = 0; i < message.perpetual_futures_gross_position_of_market.length; ++i)
            $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.encode(
              message.perpetual_futures_gross_position_of_market[i],
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.derivatives.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.GenesisState
       * @static
       * @param {ununifi.derivatives.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.derivatives.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.positions && message.positions.length)) message.positions = [];
              message.positions.push($root.ununifi.derivatives.Position.decode(reader, reader.uint32()));
              break;
            case 3:
              message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.decode(reader, reader.uint32());
              break;
            case 4:
              if (!(message.perpetual_futures_gross_position_of_market && message.perpetual_futures_gross_position_of_market.length))
                message.perpetual_futures_gross_position_of_market = [];
              message.perpetual_futures_gross_position_of_market.push(
                $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.decode(reader, reader.uint32()),
              );
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.derivatives.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.derivatives.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.positions != null && message.hasOwnProperty('positions')) {
          if (!Array.isArray(message.positions)) return 'positions: array expected';
          for (let i = 0; i < message.positions.length; ++i) {
            let error = $root.ununifi.derivatives.Position.verify(message.positions[i]);
            if (error) return 'positions.' + error;
          }
        }
        if (message.pool_market_cap != null && message.hasOwnProperty('pool_market_cap')) {
          let error = $root.ununifi.derivatives.PoolMarketCap.verify(message.pool_market_cap);
          if (error) return 'pool_market_cap.' + error;
        }
        if (
          message.perpetual_futures_gross_position_of_market != null &&
          message.hasOwnProperty('perpetual_futures_gross_position_of_market')
        ) {
          if (!Array.isArray(message.perpetual_futures_gross_position_of_market))
            return 'perpetual_futures_gross_position_of_market: array expected';
          for (let i = 0; i < message.perpetual_futures_gross_position_of_market.length; ++i) {
            let error = $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.verify(
              message.perpetual_futures_gross_position_of_market[i],
            );
            if (error) return 'perpetual_futures_gross_position_of_market.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.GenesisState) return object;
        let message = new $root.ununifi.derivatives.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.derivatives.GenesisState.params: object expected');
          message.params = $root.ununifi.derivatives.Params.fromObject(object.params);
        }
        if (object.positions) {
          if (!Array.isArray(object.positions)) throw TypeError('.ununifi.derivatives.GenesisState.positions: array expected');
          message.positions = [];
          for (let i = 0; i < object.positions.length; ++i) {
            if (typeof object.positions[i] !== 'object') throw TypeError('.ununifi.derivatives.GenesisState.positions: object expected');
            message.positions[i] = $root.ununifi.derivatives.Position.fromObject(object.positions[i]);
          }
        }
        if (object.pool_market_cap != null) {
          if (typeof object.pool_market_cap !== 'object')
            throw TypeError('.ununifi.derivatives.GenesisState.pool_market_cap: object expected');
          message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.fromObject(object.pool_market_cap);
        }
        if (object.perpetual_futures_gross_position_of_market) {
          if (!Array.isArray(object.perpetual_futures_gross_position_of_market))
            throw TypeError('.ununifi.derivatives.GenesisState.perpetual_futures_gross_position_of_market: array expected');
          message.perpetual_futures_gross_position_of_market = [];
          for (let i = 0; i < object.perpetual_futures_gross_position_of_market.length; ++i) {
            if (typeof object.perpetual_futures_gross_position_of_market[i] !== 'object')
              throw TypeError('.ununifi.derivatives.GenesisState.perpetual_futures_gross_position_of_market: object expected');
            message.perpetual_futures_gross_position_of_market[i] =
              $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.fromObject(
                object.perpetual_futures_gross_position_of_market[i],
              );
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.GenesisState
       * @static
       * @param {ununifi.derivatives.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.positions = [];
          object.perpetual_futures_gross_position_of_market = [];
        }
        if (options.defaults) {
          object.params = null;
          object.pool_market_cap = null;
        }
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.derivatives.Params.toObject(message.params, options);
        if (message.positions && message.positions.length) {
          object.positions = [];
          for (let j = 0; j < message.positions.length; ++j)
            object.positions[j] = $root.ununifi.derivatives.Position.toObject(message.positions[j], options);
        }
        if (message.pool_market_cap != null && message.hasOwnProperty('pool_market_cap'))
          object.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.toObject(message.pool_market_cap, options);
        if (message.perpetual_futures_gross_position_of_market && message.perpetual_futures_gross_position_of_market.length) {
          object.perpetual_futures_gross_position_of_market = [];
          for (let j = 0; j < message.perpetual_futures_gross_position_of_market.length; ++j)
            object.perpetual_futures_gross_position_of_market[j] = $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.toObject(
              message.perpetual_futures_gross_position_of_market[j],
              options,
            );
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    /**
     * PositionType enum.
     * @name ununifi.derivatives.PositionType
     * @enum {number}
     * @property {number} POSITION_UNKNOWN=0 POSITION_UNKNOWN value
     * @property {number} LONG=1 LONG value
     * @property {number} SHORT=2 SHORT value
     */
    derivatives.PositionType = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'POSITION_UNKNOWN')] = 0;
      values[(valuesById[1] = 'LONG')] = 1;
      values[(valuesById[2] = 'SHORT')] = 2;
      return values;
    })();

    derivatives.Position = (function () {
      /**
       * Properties of a Position.
       * @memberof ununifi.derivatives
       * @interface IPosition
       * @property {string|null} [id] Position id
       * @property {ununifi.derivatives.IMarket|null} [market] Position market
       * @property {string|null} [opener_address] Position opener_address
       * @property {google.protobuf.ITimestamp|null} [opened_at] Position opened_at
       * @property {Long|null} [opened_height] Position opened_height
       * @property {string|null} [opened_base_rate] Position opened_base_rate
       * @property {string|null} [opened_quote_rate] Position opened_quote_rate
       * @property {cosmos.base.v1beta1.ICoin|null} [remaining_margin] Position remaining_margin
       * @property {cosmos.base.v1beta1.ICoin|null} [levied_amount] Position levied_amount
       * @property {boolean|null} [levied_amount_negative] Position levied_amount_negative
       * @property {google.protobuf.ITimestamp|null} [last_levied_at] Position last_levied_at
       * @property {google.protobuf.IAny|null} [position_instance] Position position_instance
       */

      /**
       * Constructs a new Position.
       * @memberof ununifi.derivatives
       * @classdesc Represents a Position.
       * @implements IPosition
       * @constructor
       * @param {ununifi.derivatives.IPosition=} [properties] Properties to set
       */
      function Position(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Position id.
       * @member {string} id
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.id = '';

      /**
       * Position market.
       * @member {ununifi.derivatives.IMarket|null|undefined} market
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.market = null;

      /**
       * Position opener_address.
       * @member {string} opener_address
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.opener_address = '';

      /**
       * Position opened_at.
       * @member {google.protobuf.ITimestamp|null|undefined} opened_at
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.opened_at = null;

      /**
       * Position opened_height.
       * @member {Long} opened_height
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.opened_height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Position opened_base_rate.
       * @member {string} opened_base_rate
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.opened_base_rate = '';

      /**
       * Position opened_quote_rate.
       * @member {string} opened_quote_rate
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.opened_quote_rate = '';

      /**
       * Position remaining_margin.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} remaining_margin
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.remaining_margin = null;

      /**
       * Position levied_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} levied_amount
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.levied_amount = null;

      /**
       * Position levied_amount_negative.
       * @member {boolean} levied_amount_negative
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.levied_amount_negative = false;

      /**
       * Position last_levied_at.
       * @member {google.protobuf.ITimestamp|null|undefined} last_levied_at
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.last_levied_at = null;

      /**
       * Position position_instance.
       * @member {google.protobuf.IAny|null|undefined} position_instance
       * @memberof ununifi.derivatives.Position
       * @instance
       */
      Position.prototype.position_instance = null;

      /**
       * Encodes the specified Position message. Does not implicitly {@link ununifi.derivatives.Position.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.Position
       * @static
       * @param {ununifi.derivatives.IPosition} message Position message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Position.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        if (message.market != null && Object.hasOwnProperty.call(message, 'market'))
          $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.opener_address != null && Object.hasOwnProperty.call(message, 'opener_address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.opener_address);
        if (message.opened_at != null && Object.hasOwnProperty.call(message, 'opened_at'))
          $root.google.protobuf.Timestamp.encode(message.opened_at, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.opened_height != null && Object.hasOwnProperty.call(message, 'opened_height'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.opened_height);
        if (message.opened_base_rate != null && Object.hasOwnProperty.call(message, 'opened_base_rate'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.opened_base_rate);
        if (message.opened_quote_rate != null && Object.hasOwnProperty.call(message, 'opened_quote_rate'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.opened_quote_rate);
        if (message.remaining_margin != null && Object.hasOwnProperty.call(message, 'remaining_margin'))
          $root.cosmos.base.v1beta1.Coin.encode(message.remaining_margin, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.levied_amount != null && Object.hasOwnProperty.call(message, 'levied_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.levied_amount, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        if (message.levied_amount_negative != null && Object.hasOwnProperty.call(message, 'levied_amount_negative'))
          writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.levied_amount_negative);
        if (message.last_levied_at != null && Object.hasOwnProperty.call(message, 'last_levied_at'))
          $root.google.protobuf.Timestamp.encode(message.last_levied_at, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
        if (message.position_instance != null && Object.hasOwnProperty.call(message, 'position_instance'))
          $root.google.protobuf.Any.encode(message.position_instance, writer.uint32(/* id 12, wireType 2 =*/ 98).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Position message, length delimited. Does not implicitly {@link ununifi.derivatives.Position.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.Position
       * @static
       * @param {ununifi.derivatives.IPosition} message Position message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Position.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Position message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.Position
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.Position} Position
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Position.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.Position();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
              break;
            case 3:
              message.opener_address = reader.string();
              break;
            case 4:
              message.opened_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.opened_height = reader.uint64();
              break;
            case 6:
              message.opened_base_rate = reader.string();
              break;
            case 7:
              message.opened_quote_rate = reader.string();
              break;
            case 8:
              message.remaining_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 9:
              message.levied_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 10:
              message.levied_amount_negative = reader.bool();
              break;
            case 11:
              message.last_levied_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 12:
              message.position_instance = $root.google.protobuf.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Position message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.Position
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.Position} Position
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Position.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Position message.
       * @function verify
       * @memberof ununifi.derivatives.Position
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Position.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        if (message.market != null && message.hasOwnProperty('market')) {
          let error = $root.ununifi.derivatives.Market.verify(message.market);
          if (error) return 'market.' + error;
        }
        if (message.opener_address != null && message.hasOwnProperty('opener_address'))
          if (!$util.isString(message.opener_address)) return 'opener_address: string expected';
        if (message.opened_at != null && message.hasOwnProperty('opened_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.opened_at);
          if (error) return 'opened_at.' + error;
        }
        if (message.opened_height != null && message.hasOwnProperty('opened_height'))
          if (
            !$util.isInteger(message.opened_height) &&
            !(message.opened_height && $util.isInteger(message.opened_height.low) && $util.isInteger(message.opened_height.high))
          )
            return 'opened_height: integer|Long expected';
        if (message.opened_base_rate != null && message.hasOwnProperty('opened_base_rate'))
          if (!$util.isString(message.opened_base_rate)) return 'opened_base_rate: string expected';
        if (message.opened_quote_rate != null && message.hasOwnProperty('opened_quote_rate'))
          if (!$util.isString(message.opened_quote_rate)) return 'opened_quote_rate: string expected';
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.remaining_margin);
          if (error) return 'remaining_margin.' + error;
        }
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.levied_amount);
          if (error) return 'levied_amount.' + error;
        }
        if (message.levied_amount_negative != null && message.hasOwnProperty('levied_amount_negative'))
          if (typeof message.levied_amount_negative !== 'boolean') return 'levied_amount_negative: boolean expected';
        if (message.last_levied_at != null && message.hasOwnProperty('last_levied_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.last_levied_at);
          if (error) return 'last_levied_at.' + error;
        }
        if (message.position_instance != null && message.hasOwnProperty('position_instance')) {
          let error = $root.google.protobuf.Any.verify(message.position_instance);
          if (error) return 'position_instance.' + error;
        }
        return null;
      };

      /**
       * Creates a Position message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.Position
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.Position} Position
       */
      Position.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.Position) return object;
        let message = new $root.ununifi.derivatives.Position();
        if (object.id != null) message.id = String(object.id);
        if (object.market != null) {
          if (typeof object.market !== 'object') throw TypeError('.ununifi.derivatives.Position.market: object expected');
          message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
        }
        if (object.opener_address != null) message.opener_address = String(object.opener_address);
        if (object.opened_at != null) {
          if (typeof object.opened_at !== 'object') throw TypeError('.ununifi.derivatives.Position.opened_at: object expected');
          message.opened_at = $root.google.protobuf.Timestamp.fromObject(object.opened_at);
        }
        if (object.opened_height != null)
          if ($util.Long) (message.opened_height = $util.Long.fromValue(object.opened_height)).unsigned = true;
          else if (typeof object.opened_height === 'string') message.opened_height = parseInt(object.opened_height, 10);
          else if (typeof object.opened_height === 'number') message.opened_height = object.opened_height;
          else if (typeof object.opened_height === 'object')
            message.opened_height = new $util.LongBits(object.opened_height.low >>> 0, object.opened_height.high >>> 0).toNumber(true);
        if (object.opened_base_rate != null) message.opened_base_rate = String(object.opened_base_rate);
        if (object.opened_quote_rate != null) message.opened_quote_rate = String(object.opened_quote_rate);
        if (object.remaining_margin != null) {
          if (typeof object.remaining_margin !== 'object')
            throw TypeError('.ununifi.derivatives.Position.remaining_margin: object expected');
          message.remaining_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.remaining_margin);
        }
        if (object.levied_amount != null) {
          if (typeof object.levied_amount !== 'object') throw TypeError('.ununifi.derivatives.Position.levied_amount: object expected');
          message.levied_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.levied_amount);
        }
        if (object.levied_amount_negative != null) message.levied_amount_negative = Boolean(object.levied_amount_negative);
        if (object.last_levied_at != null) {
          if (typeof object.last_levied_at !== 'object') throw TypeError('.ununifi.derivatives.Position.last_levied_at: object expected');
          message.last_levied_at = $root.google.protobuf.Timestamp.fromObject(object.last_levied_at);
        }
        if (object.position_instance != null) {
          if (typeof object.position_instance !== 'object')
            throw TypeError('.ununifi.derivatives.Position.position_instance: object expected');
          message.position_instance = $root.google.protobuf.Any.fromObject(object.position_instance);
        }
        return message;
      };

      /**
       * Creates a plain object from a Position message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.Position
       * @static
       * @param {ununifi.derivatives.Position} message Position
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Position.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.id = '';
          object.market = null;
          object.opener_address = '';
          object.opened_at = null;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.opened_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.opened_height = options.longs === String ? '0' : 0;
          object.opened_base_rate = '';
          object.opened_quote_rate = '';
          object.remaining_margin = null;
          object.levied_amount = null;
          object.levied_amount_negative = false;
          object.last_levied_at = null;
          object.position_instance = null;
        }
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        if (message.market != null && message.hasOwnProperty('market'))
          object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
        if (message.opener_address != null && message.hasOwnProperty('opener_address')) object.opener_address = message.opener_address;
        if (message.opened_at != null && message.hasOwnProperty('opened_at'))
          object.opened_at = $root.google.protobuf.Timestamp.toObject(message.opened_at, options);
        if (message.opened_height != null && message.hasOwnProperty('opened_height'))
          if (typeof message.opened_height === 'number')
            object.opened_height = options.longs === String ? String(message.opened_height) : message.opened_height;
          else
            object.opened_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.opened_height)
                : options.longs === Number
                ? new $util.LongBits(message.opened_height.low >>> 0, message.opened_height.high >>> 0).toNumber(true)
                : message.opened_height;
        if (message.opened_base_rate != null && message.hasOwnProperty('opened_base_rate'))
          object.opened_base_rate = message.opened_base_rate;
        if (message.opened_quote_rate != null && message.hasOwnProperty('opened_quote_rate'))
          object.opened_quote_rate = message.opened_quote_rate;
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin'))
          object.remaining_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.remaining_margin, options);
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount'))
          object.levied_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.levied_amount, options);
        if (message.levied_amount_negative != null && message.hasOwnProperty('levied_amount_negative'))
          object.levied_amount_negative = message.levied_amount_negative;
        if (message.last_levied_at != null && message.hasOwnProperty('last_levied_at'))
          object.last_levied_at = $root.google.protobuf.Timestamp.toObject(message.last_levied_at, options);
        if (message.position_instance != null && message.hasOwnProperty('position_instance'))
          object.position_instance = $root.google.protobuf.Any.toObject(message.position_instance, options);
        return object;
      };

      /**
       * Converts this Position to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.Position
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Position.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Position;
    })();

    derivatives.PendingPaymentPosition = (function () {
      /**
       * Properties of a PendingPaymentPosition.
       * @memberof ununifi.derivatives
       * @interface IPendingPaymentPosition
       * @property {string|null} [id] PendingPaymentPosition id
       * @property {cosmos.base.v1beta1.ICoin|null} [refundable_amount] PendingPaymentPosition refundable_amount
       * @property {google.protobuf.ITimestamp|null} [created_at] PendingPaymentPosition created_at
       * @property {Long|null} [created_height] PendingPaymentPosition created_height
       */

      /**
       * Constructs a new PendingPaymentPosition.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PendingPaymentPosition.
       * @implements IPendingPaymentPosition
       * @constructor
       * @param {ununifi.derivatives.IPendingPaymentPosition=} [properties] Properties to set
       */
      function PendingPaymentPosition(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PendingPaymentPosition id.
       * @member {string} id
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @instance
       */
      PendingPaymentPosition.prototype.id = '';

      /**
       * PendingPaymentPosition refundable_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} refundable_amount
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @instance
       */
      PendingPaymentPosition.prototype.refundable_amount = null;

      /**
       * PendingPaymentPosition created_at.
       * @member {google.protobuf.ITimestamp|null|undefined} created_at
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @instance
       */
      PendingPaymentPosition.prototype.created_at = null;

      /**
       * PendingPaymentPosition created_height.
       * @member {Long} created_height
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @instance
       */
      PendingPaymentPosition.prototype.created_height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified PendingPaymentPosition message. Does not implicitly {@link ununifi.derivatives.PendingPaymentPosition.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @static
       * @param {ununifi.derivatives.IPendingPaymentPosition} message PendingPaymentPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PendingPaymentPosition.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        if (message.refundable_amount != null && Object.hasOwnProperty.call(message, 'refundable_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.refundable_amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.created_at != null && Object.hasOwnProperty.call(message, 'created_at'))
          $root.google.protobuf.Timestamp.encode(message.created_at, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.created_height != null && Object.hasOwnProperty.call(message, 'created_height'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.created_height);
        return writer;
      };

      /**
       * Encodes the specified PendingPaymentPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.PendingPaymentPosition.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @static
       * @param {ununifi.derivatives.IPendingPaymentPosition} message PendingPaymentPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PendingPaymentPosition.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PendingPaymentPosition message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PendingPaymentPosition} PendingPaymentPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PendingPaymentPosition.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PendingPaymentPosition();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.refundable_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.created_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.created_height = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PendingPaymentPosition message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PendingPaymentPosition} PendingPaymentPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PendingPaymentPosition.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PendingPaymentPosition message.
       * @function verify
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PendingPaymentPosition.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        if (message.refundable_amount != null && message.hasOwnProperty('refundable_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.refundable_amount);
          if (error) return 'refundable_amount.' + error;
        }
        if (message.created_at != null && message.hasOwnProperty('created_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.created_at);
          if (error) return 'created_at.' + error;
        }
        if (message.created_height != null && message.hasOwnProperty('created_height'))
          if (
            !$util.isInteger(message.created_height) &&
            !(message.created_height && $util.isInteger(message.created_height.low) && $util.isInteger(message.created_height.high))
          )
            return 'created_height: integer|Long expected';
        return null;
      };

      /**
       * Creates a PendingPaymentPosition message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PendingPaymentPosition} PendingPaymentPosition
       */
      PendingPaymentPosition.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PendingPaymentPosition) return object;
        let message = new $root.ununifi.derivatives.PendingPaymentPosition();
        if (object.id != null) message.id = String(object.id);
        if (object.refundable_amount != null) {
          if (typeof object.refundable_amount !== 'object')
            throw TypeError('.ununifi.derivatives.PendingPaymentPosition.refundable_amount: object expected');
          message.refundable_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.refundable_amount);
        }
        if (object.created_at != null) {
          if (typeof object.created_at !== 'object')
            throw TypeError('.ununifi.derivatives.PendingPaymentPosition.created_at: object expected');
          message.created_at = $root.google.protobuf.Timestamp.fromObject(object.created_at);
        }
        if (object.created_height != null)
          if ($util.Long) (message.created_height = $util.Long.fromValue(object.created_height)).unsigned = true;
          else if (typeof object.created_height === 'string') message.created_height = parseInt(object.created_height, 10);
          else if (typeof object.created_height === 'number') message.created_height = object.created_height;
          else if (typeof object.created_height === 'object')
            message.created_height = new $util.LongBits(object.created_height.low >>> 0, object.created_height.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a PendingPaymentPosition message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @static
       * @param {ununifi.derivatives.PendingPaymentPosition} message PendingPaymentPosition
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PendingPaymentPosition.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.id = '';
          object.refundable_amount = null;
          object.created_at = null;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.created_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.created_height = options.longs === String ? '0' : 0;
        }
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        if (message.refundable_amount != null && message.hasOwnProperty('refundable_amount'))
          object.refundable_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.refundable_amount, options);
        if (message.created_at != null && message.hasOwnProperty('created_at'))
          object.created_at = $root.google.protobuf.Timestamp.toObject(message.created_at, options);
        if (message.created_height != null && message.hasOwnProperty('created_height'))
          if (typeof message.created_height === 'number')
            object.created_height = options.longs === String ? String(message.created_height) : message.created_height;
          else
            object.created_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.created_height)
                : options.longs === Number
                ? new $util.LongBits(message.created_height.low >>> 0, message.created_height.high >>> 0).toNumber(true)
                : message.created_height;
        return object;
      };

      /**
       * Converts this PendingPaymentPosition to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PendingPaymentPosition
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PendingPaymentPosition.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PendingPaymentPosition;
    })();

    derivatives.QueriedPosition = (function () {
      /**
       * Properties of a QueriedPosition.
       * @memberof ununifi.derivatives
       * @interface IQueriedPosition
       * @property {ununifi.derivatives.IPosition|null} [position] QueriedPosition position
       * @property {cosmos.base.v1beta1.ICoin|null} [valuation_profit] QueriedPosition valuation_profit
       * @property {string|null} [remaining_margin_value] QueriedPosition remaining_margin_value
       * @property {cosmos.base.v1beta1.ICoin|null} [effective_margin] QueriedPosition effective_margin
       * @property {string|null} [margin_maintenance_rate] QueriedPosition margin_maintenance_rate
       */

      /**
       * Constructs a new QueriedPosition.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueriedPosition.
       * @implements IQueriedPosition
       * @constructor
       * @param {ununifi.derivatives.IQueriedPosition=} [properties] Properties to set
       */
      function QueriedPosition(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueriedPosition position.
       * @member {ununifi.derivatives.IPosition|null|undefined} position
       * @memberof ununifi.derivatives.QueriedPosition
       * @instance
       */
      QueriedPosition.prototype.position = null;

      /**
       * QueriedPosition valuation_profit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} valuation_profit
       * @memberof ununifi.derivatives.QueriedPosition
       * @instance
       */
      QueriedPosition.prototype.valuation_profit = null;

      /**
       * QueriedPosition remaining_margin_value.
       * @member {string} remaining_margin_value
       * @memberof ununifi.derivatives.QueriedPosition
       * @instance
       */
      QueriedPosition.prototype.remaining_margin_value = '';

      /**
       * QueriedPosition effective_margin.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} effective_margin
       * @memberof ununifi.derivatives.QueriedPosition
       * @instance
       */
      QueriedPosition.prototype.effective_margin = null;

      /**
       * QueriedPosition margin_maintenance_rate.
       * @member {string} margin_maintenance_rate
       * @memberof ununifi.derivatives.QueriedPosition
       * @instance
       */
      QueriedPosition.prototype.margin_maintenance_rate = '';

      /**
       * Encodes the specified QueriedPosition message. Does not implicitly {@link ununifi.derivatives.QueriedPosition.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueriedPosition
       * @static
       * @param {ununifi.derivatives.IQueriedPosition} message QueriedPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueriedPosition.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position != null && Object.hasOwnProperty.call(message, 'position'))
          $root.ununifi.derivatives.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.valuation_profit != null && Object.hasOwnProperty.call(message, 'valuation_profit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.valuation_profit, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.remaining_margin_value != null && Object.hasOwnProperty.call(message, 'remaining_margin_value'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.remaining_margin_value);
        if (message.effective_margin != null && Object.hasOwnProperty.call(message, 'effective_margin'))
          $root.cosmos.base.v1beta1.Coin.encode(message.effective_margin, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, 'margin_maintenance_rate'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.margin_maintenance_rate);
        return writer;
      };

      /**
       * Encodes the specified QueriedPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.QueriedPosition.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueriedPosition
       * @static
       * @param {ununifi.derivatives.IQueriedPosition} message QueriedPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueriedPosition.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueriedPosition message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueriedPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueriedPosition} QueriedPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueriedPosition.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueriedPosition();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position = $root.ununifi.derivatives.Position.decode(reader, reader.uint32());
              break;
            case 2:
              message.valuation_profit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.remaining_margin_value = reader.string();
              break;
            case 4:
              message.effective_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 5:
              message.margin_maintenance_rate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueriedPosition message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueriedPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueriedPosition} QueriedPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueriedPosition.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueriedPosition message.
       * @function verify
       * @memberof ununifi.derivatives.QueriedPosition
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueriedPosition.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position != null && message.hasOwnProperty('position')) {
          let error = $root.ununifi.derivatives.Position.verify(message.position);
          if (error) return 'position.' + error;
        }
        if (message.valuation_profit != null && message.hasOwnProperty('valuation_profit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.valuation_profit);
          if (error) return 'valuation_profit.' + error;
        }
        if (message.remaining_margin_value != null && message.hasOwnProperty('remaining_margin_value'))
          if (!$util.isString(message.remaining_margin_value)) return 'remaining_margin_value: string expected';
        if (message.effective_margin != null && message.hasOwnProperty('effective_margin')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.effective_margin);
          if (error) return 'effective_margin.' + error;
        }
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          if (!$util.isString(message.margin_maintenance_rate)) return 'margin_maintenance_rate: string expected';
        return null;
      };

      /**
       * Creates a QueriedPosition message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueriedPosition
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueriedPosition} QueriedPosition
       */
      QueriedPosition.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueriedPosition) return object;
        let message = new $root.ununifi.derivatives.QueriedPosition();
        if (object.position != null) {
          if (typeof object.position !== 'object') throw TypeError('.ununifi.derivatives.QueriedPosition.position: object expected');
          message.position = $root.ununifi.derivatives.Position.fromObject(object.position);
        }
        if (object.valuation_profit != null) {
          if (typeof object.valuation_profit !== 'object')
            throw TypeError('.ununifi.derivatives.QueriedPosition.valuation_profit: object expected');
          message.valuation_profit = $root.cosmos.base.v1beta1.Coin.fromObject(object.valuation_profit);
        }
        if (object.remaining_margin_value != null) message.remaining_margin_value = String(object.remaining_margin_value);
        if (object.effective_margin != null) {
          if (typeof object.effective_margin !== 'object')
            throw TypeError('.ununifi.derivatives.QueriedPosition.effective_margin: object expected');
          message.effective_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.effective_margin);
        }
        if (object.margin_maintenance_rate != null) message.margin_maintenance_rate = String(object.margin_maintenance_rate);
        return message;
      };

      /**
       * Creates a plain object from a QueriedPosition message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueriedPosition
       * @static
       * @param {ununifi.derivatives.QueriedPosition} message QueriedPosition
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueriedPosition.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.position = null;
          object.valuation_profit = null;
          object.remaining_margin_value = '';
          object.effective_margin = null;
          object.margin_maintenance_rate = '';
        }
        if (message.position != null && message.hasOwnProperty('position'))
          object.position = $root.ununifi.derivatives.Position.toObject(message.position, options);
        if (message.valuation_profit != null && message.hasOwnProperty('valuation_profit'))
          object.valuation_profit = $root.cosmos.base.v1beta1.Coin.toObject(message.valuation_profit, options);
        if (message.remaining_margin_value != null && message.hasOwnProperty('remaining_margin_value'))
          object.remaining_margin_value = message.remaining_margin_value;
        if (message.effective_margin != null && message.hasOwnProperty('effective_margin'))
          object.effective_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.effective_margin, options);
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          object.margin_maintenance_rate = message.margin_maintenance_rate;
        return object;
      };

      /**
       * Converts this QueriedPosition to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueriedPosition
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueriedPosition.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueriedPosition;
    })();

    derivatives.PoolAssetConf = (function () {
      /**
       * Properties of a PoolAssetConf.
       * @memberof ununifi.derivatives
       * @interface IPoolAssetConf
       * @property {string|null} [denom] PoolAssetConf denom
       * @property {string|null} [target_weight] PoolAssetConf target_weight
       */

      /**
       * Constructs a new PoolAssetConf.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PoolAssetConf.
       * @implements IPoolAssetConf
       * @constructor
       * @param {ununifi.derivatives.IPoolAssetConf=} [properties] Properties to set
       */
      function PoolAssetConf(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PoolAssetConf denom.
       * @member {string} denom
       * @memberof ununifi.derivatives.PoolAssetConf
       * @instance
       */
      PoolAssetConf.prototype.denom = '';

      /**
       * PoolAssetConf target_weight.
       * @member {string} target_weight
       * @memberof ununifi.derivatives.PoolAssetConf
       * @instance
       */
      PoolAssetConf.prototype.target_weight = '';

      /**
       * Encodes the specified PoolAssetConf message. Does not implicitly {@link ununifi.derivatives.PoolAssetConf.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PoolAssetConf
       * @static
       * @param {ununifi.derivatives.IPoolAssetConf} message PoolAssetConf message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PoolAssetConf.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.target_weight != null && Object.hasOwnProperty.call(message, 'target_weight'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.target_weight);
        return writer;
      };

      /**
       * Encodes the specified PoolAssetConf message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolAssetConf.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PoolAssetConf
       * @static
       * @param {ununifi.derivatives.IPoolAssetConf} message PoolAssetConf message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PoolAssetConf.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PoolAssetConf message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PoolAssetConf
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PoolAssetConf} PoolAssetConf
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PoolAssetConf.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PoolAssetConf();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.target_weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PoolAssetConf message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PoolAssetConf
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PoolAssetConf} PoolAssetConf
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PoolAssetConf.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PoolAssetConf message.
       * @function verify
       * @memberof ununifi.derivatives.PoolAssetConf
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PoolAssetConf.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.target_weight != null && message.hasOwnProperty('target_weight'))
          if (!$util.isString(message.target_weight)) return 'target_weight: string expected';
        return null;
      };

      /**
       * Creates a PoolAssetConf message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PoolAssetConf
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PoolAssetConf} PoolAssetConf
       */
      PoolAssetConf.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PoolAssetConf) return object;
        let message = new $root.ununifi.derivatives.PoolAssetConf();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.target_weight != null) message.target_weight = String(object.target_weight);
        return message;
      };

      /**
       * Creates a plain object from a PoolAssetConf message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PoolAssetConf
       * @static
       * @param {ununifi.derivatives.PoolAssetConf} message PoolAssetConf
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PoolAssetConf.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          object.target_weight = '';
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.target_weight != null && message.hasOwnProperty('target_weight')) object.target_weight = message.target_weight;
        return object;
      };

      /**
       * Converts this PoolAssetConf to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PoolAssetConf
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PoolAssetConf.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PoolAssetConf;
    })();

    derivatives.PoolParams = (function () {
      /**
       * Properties of a PoolParams.
       * @memberof ununifi.derivatives
       * @interface IPoolParams
       * @property {string|null} [quote_ticker] PoolParams quote_ticker
       * @property {string|null} [base_lpt_mint_fee] PoolParams base_lpt_mint_fee
       * @property {string|null} [base_lpt_redeem_fee] PoolParams base_lpt_redeem_fee
       * @property {string|null} [borrowing_fee_rate_per_hour] PoolParams borrowing_fee_rate_per_hour
       * @property {string|null} [report_liquidation_reward_rate] PoolParams report_liquidation_reward_rate
       * @property {string|null} [report_levy_period_reward_rate] PoolParams report_levy_period_reward_rate
       * @property {Array.<ununifi.derivatives.IPoolAssetConf>|null} [accepted_assets_conf] PoolParams accepted_assets_conf
       * @property {Long|null} [levy_period_required_seconds] PoolParams levy_period_required_seconds
       */

      /**
       * Constructs a new PoolParams.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PoolParams.
       * @implements IPoolParams
       * @constructor
       * @param {ununifi.derivatives.IPoolParams=} [properties] Properties to set
       */
      function PoolParams(properties) {
        this.accepted_assets_conf = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PoolParams quote_ticker.
       * @member {string} quote_ticker
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.quote_ticker = '';

      /**
       * PoolParams base_lpt_mint_fee.
       * @member {string} base_lpt_mint_fee
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.base_lpt_mint_fee = '';

      /**
       * PoolParams base_lpt_redeem_fee.
       * @member {string} base_lpt_redeem_fee
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.base_lpt_redeem_fee = '';

      /**
       * PoolParams borrowing_fee_rate_per_hour.
       * @member {string} borrowing_fee_rate_per_hour
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.borrowing_fee_rate_per_hour = '';

      /**
       * PoolParams report_liquidation_reward_rate.
       * @member {string} report_liquidation_reward_rate
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.report_liquidation_reward_rate = '';

      /**
       * PoolParams report_levy_period_reward_rate.
       * @member {string} report_levy_period_reward_rate
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.report_levy_period_reward_rate = '';

      /**
       * PoolParams accepted_assets_conf.
       * @member {Array.<ununifi.derivatives.IPoolAssetConf>} accepted_assets_conf
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.accepted_assets_conf = $util.emptyArray;

      /**
       * PoolParams levy_period_required_seconds.
       * @member {Long} levy_period_required_seconds
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       */
      PoolParams.prototype.levy_period_required_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified PoolParams message. Does not implicitly {@link ununifi.derivatives.PoolParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PoolParams
       * @static
       * @param {ununifi.derivatives.IPoolParams} message PoolParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PoolParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.quote_ticker != null && Object.hasOwnProperty.call(message, 'quote_ticker'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.quote_ticker);
        if (message.base_lpt_mint_fee != null && Object.hasOwnProperty.call(message, 'base_lpt_mint_fee'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.base_lpt_mint_fee);
        if (message.base_lpt_redeem_fee != null && Object.hasOwnProperty.call(message, 'base_lpt_redeem_fee'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.base_lpt_redeem_fee);
        if (message.borrowing_fee_rate_per_hour != null && Object.hasOwnProperty.call(message, 'borrowing_fee_rate_per_hour'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.borrowing_fee_rate_per_hour);
        if (message.report_liquidation_reward_rate != null && Object.hasOwnProperty.call(message, 'report_liquidation_reward_rate'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.report_liquidation_reward_rate);
        if (message.report_levy_period_reward_rate != null && Object.hasOwnProperty.call(message, 'report_levy_period_reward_rate'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.report_levy_period_reward_rate);
        if (message.accepted_assets_conf != null && message.accepted_assets_conf.length)
          for (let i = 0; i < message.accepted_assets_conf.length; ++i)
            $root.ununifi.derivatives.PoolAssetConf.encode(
              message.accepted_assets_conf[i],
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
        if (message.levy_period_required_seconds != null && Object.hasOwnProperty.call(message, 'levy_period_required_seconds'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).uint64(message.levy_period_required_seconds);
        return writer;
      };

      /**
       * Encodes the specified PoolParams message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PoolParams
       * @static
       * @param {ununifi.derivatives.IPoolParams} message PoolParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PoolParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PoolParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PoolParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PoolParams} PoolParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PoolParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PoolParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quote_ticker = reader.string();
              break;
            case 2:
              message.base_lpt_mint_fee = reader.string();
              break;
            case 3:
              message.base_lpt_redeem_fee = reader.string();
              break;
            case 4:
              message.borrowing_fee_rate_per_hour = reader.string();
              break;
            case 5:
              message.report_liquidation_reward_rate = reader.string();
              break;
            case 6:
              message.report_levy_period_reward_rate = reader.string();
              break;
            case 7:
              if (!(message.accepted_assets_conf && message.accepted_assets_conf.length)) message.accepted_assets_conf = [];
              message.accepted_assets_conf.push($root.ununifi.derivatives.PoolAssetConf.decode(reader, reader.uint32()));
              break;
            case 8:
              message.levy_period_required_seconds = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PoolParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PoolParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PoolParams} PoolParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PoolParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PoolParams message.
       * @function verify
       * @memberof ununifi.derivatives.PoolParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PoolParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.quote_ticker != null && message.hasOwnProperty('quote_ticker'))
          if (!$util.isString(message.quote_ticker)) return 'quote_ticker: string expected';
        if (message.base_lpt_mint_fee != null && message.hasOwnProperty('base_lpt_mint_fee'))
          if (!$util.isString(message.base_lpt_mint_fee)) return 'base_lpt_mint_fee: string expected';
        if (message.base_lpt_redeem_fee != null && message.hasOwnProperty('base_lpt_redeem_fee'))
          if (!$util.isString(message.base_lpt_redeem_fee)) return 'base_lpt_redeem_fee: string expected';
        if (message.borrowing_fee_rate_per_hour != null && message.hasOwnProperty('borrowing_fee_rate_per_hour'))
          if (!$util.isString(message.borrowing_fee_rate_per_hour)) return 'borrowing_fee_rate_per_hour: string expected';
        if (message.report_liquidation_reward_rate != null && message.hasOwnProperty('report_liquidation_reward_rate'))
          if (!$util.isString(message.report_liquidation_reward_rate)) return 'report_liquidation_reward_rate: string expected';
        if (message.report_levy_period_reward_rate != null && message.hasOwnProperty('report_levy_period_reward_rate'))
          if (!$util.isString(message.report_levy_period_reward_rate)) return 'report_levy_period_reward_rate: string expected';
        if (message.accepted_assets_conf != null && message.hasOwnProperty('accepted_assets_conf')) {
          if (!Array.isArray(message.accepted_assets_conf)) return 'accepted_assets_conf: array expected';
          for (let i = 0; i < message.accepted_assets_conf.length; ++i) {
            let error = $root.ununifi.derivatives.PoolAssetConf.verify(message.accepted_assets_conf[i]);
            if (error) return 'accepted_assets_conf.' + error;
          }
        }
        if (message.levy_period_required_seconds != null && message.hasOwnProperty('levy_period_required_seconds'))
          if (
            !$util.isInteger(message.levy_period_required_seconds) &&
            !(
              message.levy_period_required_seconds &&
              $util.isInteger(message.levy_period_required_seconds.low) &&
              $util.isInteger(message.levy_period_required_seconds.high)
            )
          )
            return 'levy_period_required_seconds: integer|Long expected';
        return null;
      };

      /**
       * Creates a PoolParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PoolParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PoolParams} PoolParams
       */
      PoolParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PoolParams) return object;
        let message = new $root.ununifi.derivatives.PoolParams();
        if (object.quote_ticker != null) message.quote_ticker = String(object.quote_ticker);
        if (object.base_lpt_mint_fee != null) message.base_lpt_mint_fee = String(object.base_lpt_mint_fee);
        if (object.base_lpt_redeem_fee != null) message.base_lpt_redeem_fee = String(object.base_lpt_redeem_fee);
        if (object.borrowing_fee_rate_per_hour != null) message.borrowing_fee_rate_per_hour = String(object.borrowing_fee_rate_per_hour);
        if (object.report_liquidation_reward_rate != null)
          message.report_liquidation_reward_rate = String(object.report_liquidation_reward_rate);
        if (object.report_levy_period_reward_rate != null)
          message.report_levy_period_reward_rate = String(object.report_levy_period_reward_rate);
        if (object.accepted_assets_conf) {
          if (!Array.isArray(object.accepted_assets_conf))
            throw TypeError('.ununifi.derivatives.PoolParams.accepted_assets_conf: array expected');
          message.accepted_assets_conf = [];
          for (let i = 0; i < object.accepted_assets_conf.length; ++i) {
            if (typeof object.accepted_assets_conf[i] !== 'object')
              throw TypeError('.ununifi.derivatives.PoolParams.accepted_assets_conf: object expected');
            message.accepted_assets_conf[i] = $root.ununifi.derivatives.PoolAssetConf.fromObject(object.accepted_assets_conf[i]);
          }
        }
        if (object.levy_period_required_seconds != null)
          if ($util.Long)
            (message.levy_period_required_seconds = $util.Long.fromValue(object.levy_period_required_seconds)).unsigned = true;
          else if (typeof object.levy_period_required_seconds === 'string')
            message.levy_period_required_seconds = parseInt(object.levy_period_required_seconds, 10);
          else if (typeof object.levy_period_required_seconds === 'number')
            message.levy_period_required_seconds = object.levy_period_required_seconds;
          else if (typeof object.levy_period_required_seconds === 'object')
            message.levy_period_required_seconds = new $util.LongBits(
              object.levy_period_required_seconds.low >>> 0,
              object.levy_period_required_seconds.high >>> 0,
            ).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a PoolParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PoolParams
       * @static
       * @param {ununifi.derivatives.PoolParams} message PoolParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PoolParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.accepted_assets_conf = [];
        if (options.defaults) {
          object.quote_ticker = '';
          object.base_lpt_mint_fee = '';
          object.base_lpt_redeem_fee = '';
          object.borrowing_fee_rate_per_hour = '';
          object.report_liquidation_reward_rate = '';
          object.report_levy_period_reward_rate = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.levy_period_required_seconds =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.levy_period_required_seconds = options.longs === String ? '0' : 0;
        }
        if (message.quote_ticker != null && message.hasOwnProperty('quote_ticker')) object.quote_ticker = message.quote_ticker;
        if (message.base_lpt_mint_fee != null && message.hasOwnProperty('base_lpt_mint_fee'))
          object.base_lpt_mint_fee = message.base_lpt_mint_fee;
        if (message.base_lpt_redeem_fee != null && message.hasOwnProperty('base_lpt_redeem_fee'))
          object.base_lpt_redeem_fee = message.base_lpt_redeem_fee;
        if (message.borrowing_fee_rate_per_hour != null && message.hasOwnProperty('borrowing_fee_rate_per_hour'))
          object.borrowing_fee_rate_per_hour = message.borrowing_fee_rate_per_hour;
        if (message.report_liquidation_reward_rate != null && message.hasOwnProperty('report_liquidation_reward_rate'))
          object.report_liquidation_reward_rate = message.report_liquidation_reward_rate;
        if (message.report_levy_period_reward_rate != null && message.hasOwnProperty('report_levy_period_reward_rate'))
          object.report_levy_period_reward_rate = message.report_levy_period_reward_rate;
        if (message.accepted_assets_conf && message.accepted_assets_conf.length) {
          object.accepted_assets_conf = [];
          for (let j = 0; j < message.accepted_assets_conf.length; ++j)
            object.accepted_assets_conf[j] = $root.ununifi.derivatives.PoolAssetConf.toObject(message.accepted_assets_conf[j], options);
        }
        if (message.levy_period_required_seconds != null && message.hasOwnProperty('levy_period_required_seconds'))
          if (typeof message.levy_period_required_seconds === 'number')
            object.levy_period_required_seconds =
              options.longs === String ? String(message.levy_period_required_seconds) : message.levy_period_required_seconds;
          else
            object.levy_period_required_seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.levy_period_required_seconds)
                : options.longs === Number
                ? new $util.LongBits(
                    message.levy_period_required_seconds.low >>> 0,
                    message.levy_period_required_seconds.high >>> 0,
                  ).toNumber(true)
                : message.levy_period_required_seconds;
        return object;
      };

      /**
       * Converts this PoolParams to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PoolParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PoolParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PoolParams;
    })();

    derivatives.PoolMarketCap = (function () {
      /**
       * Properties of a PoolMarketCap.
       * @memberof ununifi.derivatives
       * @interface IPoolMarketCap
       * @property {string|null} [quote_ticker] PoolMarketCap quote_ticker
       * @property {string|null} [total] PoolMarketCap total
       * @property {Array.<ununifi.derivatives.PoolMarketCap.IAssetInfo>|null} [asset_info] PoolMarketCap asset_info
       */

      /**
       * Constructs a new PoolMarketCap.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PoolMarketCap.
       * @implements IPoolMarketCap
       * @constructor
       * @param {ununifi.derivatives.IPoolMarketCap=} [properties] Properties to set
       */
      function PoolMarketCap(properties) {
        this.asset_info = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PoolMarketCap quote_ticker.
       * @member {string} quote_ticker
       * @memberof ununifi.derivatives.PoolMarketCap
       * @instance
       */
      PoolMarketCap.prototype.quote_ticker = '';

      /**
       * PoolMarketCap total.
       * @member {string} total
       * @memberof ununifi.derivatives.PoolMarketCap
       * @instance
       */
      PoolMarketCap.prototype.total = '';

      /**
       * PoolMarketCap asset_info.
       * @member {Array.<ununifi.derivatives.PoolMarketCap.IAssetInfo>} asset_info
       * @memberof ununifi.derivatives.PoolMarketCap
       * @instance
       */
      PoolMarketCap.prototype.asset_info = $util.emptyArray;

      /**
       * Encodes the specified PoolMarketCap message. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PoolMarketCap
       * @static
       * @param {ununifi.derivatives.IPoolMarketCap} message PoolMarketCap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PoolMarketCap.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.quote_ticker != null && Object.hasOwnProperty.call(message, 'quote_ticker'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.quote_ticker);
        if (message.total != null && Object.hasOwnProperty.call(message, 'total'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.total);
        if (message.asset_info != null && message.asset_info.length)
          for (let i = 0; i < message.asset_info.length; ++i)
            $root.ununifi.derivatives.PoolMarketCap.AssetInfo.encode(
              message.asset_info[i],
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified PoolMarketCap message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PoolMarketCap
       * @static
       * @param {ununifi.derivatives.IPoolMarketCap} message PoolMarketCap message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PoolMarketCap.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PoolMarketCap message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PoolMarketCap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PoolMarketCap} PoolMarketCap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PoolMarketCap.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PoolMarketCap();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quote_ticker = reader.string();
              break;
            case 2:
              message.total = reader.string();
              break;
            case 3:
              if (!(message.asset_info && message.asset_info.length)) message.asset_info = [];
              message.asset_info.push($root.ununifi.derivatives.PoolMarketCap.AssetInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PoolMarketCap message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PoolMarketCap
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PoolMarketCap} PoolMarketCap
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PoolMarketCap.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PoolMarketCap message.
       * @function verify
       * @memberof ununifi.derivatives.PoolMarketCap
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PoolMarketCap.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.quote_ticker != null && message.hasOwnProperty('quote_ticker'))
          if (!$util.isString(message.quote_ticker)) return 'quote_ticker: string expected';
        if (message.total != null && message.hasOwnProperty('total')) if (!$util.isString(message.total)) return 'total: string expected';
        if (message.asset_info != null && message.hasOwnProperty('asset_info')) {
          if (!Array.isArray(message.asset_info)) return 'asset_info: array expected';
          for (let i = 0; i < message.asset_info.length; ++i) {
            let error = $root.ununifi.derivatives.PoolMarketCap.AssetInfo.verify(message.asset_info[i]);
            if (error) return 'asset_info.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a PoolMarketCap message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PoolMarketCap
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PoolMarketCap} PoolMarketCap
       */
      PoolMarketCap.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PoolMarketCap) return object;
        let message = new $root.ununifi.derivatives.PoolMarketCap();
        if (object.quote_ticker != null) message.quote_ticker = String(object.quote_ticker);
        if (object.total != null) message.total = String(object.total);
        if (object.asset_info) {
          if (!Array.isArray(object.asset_info)) throw TypeError('.ununifi.derivatives.PoolMarketCap.asset_info: array expected');
          message.asset_info = [];
          for (let i = 0; i < object.asset_info.length; ++i) {
            if (typeof object.asset_info[i] !== 'object') throw TypeError('.ununifi.derivatives.PoolMarketCap.asset_info: object expected');
            message.asset_info[i] = $root.ununifi.derivatives.PoolMarketCap.AssetInfo.fromObject(object.asset_info[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a PoolMarketCap message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PoolMarketCap
       * @static
       * @param {ununifi.derivatives.PoolMarketCap} message PoolMarketCap
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PoolMarketCap.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.asset_info = [];
        if (options.defaults) {
          object.quote_ticker = '';
          object.total = '';
        }
        if (message.quote_ticker != null && message.hasOwnProperty('quote_ticker')) object.quote_ticker = message.quote_ticker;
        if (message.total != null && message.hasOwnProperty('total')) object.total = message.total;
        if (message.asset_info && message.asset_info.length) {
          object.asset_info = [];
          for (let j = 0; j < message.asset_info.length; ++j)
            object.asset_info[j] = $root.ununifi.derivatives.PoolMarketCap.AssetInfo.toObject(message.asset_info[j], options);
        }
        return object;
      };

      /**
       * Converts this PoolMarketCap to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PoolMarketCap
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PoolMarketCap.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      PoolMarketCap.AssetInfo = (function () {
        /**
         * Properties of an AssetInfo.
         * @memberof ununifi.derivatives.PoolMarketCap
         * @interface IAssetInfo
         * @property {string|null} [denom] AssetInfo denom
         * @property {string|null} [amount] AssetInfo amount
         * @property {string|null} [price] AssetInfo price
         * @property {string|null} [reserved] AssetInfo reserved
         */

        /**
         * Constructs a new AssetInfo.
         * @memberof ununifi.derivatives.PoolMarketCap
         * @classdesc Represents an AssetInfo.
         * @implements IAssetInfo
         * @constructor
         * @param {ununifi.derivatives.PoolMarketCap.IAssetInfo=} [properties] Properties to set
         */
        function AssetInfo(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * AssetInfo denom.
         * @member {string} denom
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @instance
         */
        AssetInfo.prototype.denom = '';

        /**
         * AssetInfo amount.
         * @member {string} amount
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @instance
         */
        AssetInfo.prototype.amount = '';

        /**
         * AssetInfo price.
         * @member {string} price
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @instance
         */
        AssetInfo.prototype.price = '';

        /**
         * AssetInfo reserved.
         * @member {string} reserved
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @instance
         */
        AssetInfo.prototype.reserved = '';

        /**
         * Encodes the specified AssetInfo message. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.AssetInfo.verify|verify} messages.
         * @function encode
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @static
         * @param {ununifi.derivatives.PoolMarketCap.IAssetInfo} message AssetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetInfo.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
          if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
          if (message.reserved != null && Object.hasOwnProperty.call(message, 'reserved'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.reserved);
          return writer;
        };

        /**
         * Encodes the specified AssetInfo message, length delimited. Does not implicitly {@link ununifi.derivatives.PoolMarketCap.AssetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @static
         * @param {ununifi.derivatives.PoolMarketCap.IAssetInfo} message AssetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetInfo.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AssetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ununifi.derivatives.PoolMarketCap.AssetInfo} AssetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetInfo.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.ununifi.derivatives.PoolMarketCap.AssetInfo();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.amount = reader.string();
                break;
              case 3:
                message.price = reader.string();
                break;
              case 4:
                message.reserved = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an AssetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ununifi.derivatives.PoolMarketCap.AssetInfo} AssetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetInfo.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AssetInfo message.
         * @function verify
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AssetInfo.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
          if (message.reserved != null && message.hasOwnProperty('reserved'))
            if (!$util.isString(message.reserved)) return 'reserved: string expected';
          return null;
        };

        /**
         * Creates an AssetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ununifi.derivatives.PoolMarketCap.AssetInfo} AssetInfo
         */
        AssetInfo.fromObject = function fromObject(object) {
          if (object instanceof $root.ununifi.derivatives.PoolMarketCap.AssetInfo) return object;
          let message = new $root.ununifi.derivatives.PoolMarketCap.AssetInfo();
          if (object.denom != null) message.denom = String(object.denom);
          if (object.amount != null) message.amount = String(object.amount);
          if (object.price != null) message.price = String(object.price);
          if (object.reserved != null) message.reserved = String(object.reserved);
          return message;
        };

        /**
         * Creates a plain object from an AssetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @static
         * @param {ununifi.derivatives.PoolMarketCap.AssetInfo} message AssetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AssetInfo.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.denom = '';
            object.amount = '';
            object.price = '';
            object.reserved = '';
          }
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
          if (message.reserved != null && message.hasOwnProperty('reserved')) object.reserved = message.reserved;
          return object;
        };

        /**
         * Converts this AssetInfo to JSON.
         * @function toJSON
         * @memberof ununifi.derivatives.PoolMarketCap.AssetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AssetInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AssetInfo;
      })();

      return PoolMarketCap;
    })();

    derivatives.Market = (function () {
      /**
       * Properties of a Market.
       * @memberof ununifi.derivatives
       * @interface IMarket
       * @property {string|null} [base_denom] Market base_denom
       * @property {string|null} [quote_denom] Market quote_denom
       */

      /**
       * Constructs a new Market.
       * @memberof ununifi.derivatives
       * @classdesc Represents a Market.
       * @implements IMarket
       * @constructor
       * @param {ununifi.derivatives.IMarket=} [properties] Properties to set
       */
      function Market(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Market base_denom.
       * @member {string} base_denom
       * @memberof ununifi.derivatives.Market
       * @instance
       */
      Market.prototype.base_denom = '';

      /**
       * Market quote_denom.
       * @member {string} quote_denom
       * @memberof ununifi.derivatives.Market
       * @instance
       */
      Market.prototype.quote_denom = '';

      /**
       * Encodes the specified Market message. Does not implicitly {@link ununifi.derivatives.Market.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.Market
       * @static
       * @param {ununifi.derivatives.IMarket} message Market message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Market.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.base_denom != null && Object.hasOwnProperty.call(message, 'base_denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.base_denom);
        if (message.quote_denom != null && Object.hasOwnProperty.call(message, 'quote_denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.quote_denom);
        return writer;
      };

      /**
       * Encodes the specified Market message, length delimited. Does not implicitly {@link ununifi.derivatives.Market.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.Market
       * @static
       * @param {ununifi.derivatives.IMarket} message Market message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Market.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Market message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.Market
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.Market} Market
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Market.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.Market();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.base_denom = reader.string();
              break;
            case 2:
              message.quote_denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Market message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.Market
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.Market} Market
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Market.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Market message.
       * @function verify
       * @memberof ununifi.derivatives.Market
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Market.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.base_denom != null && message.hasOwnProperty('base_denom'))
          if (!$util.isString(message.base_denom)) return 'base_denom: string expected';
        if (message.quote_denom != null && message.hasOwnProperty('quote_denom'))
          if (!$util.isString(message.quote_denom)) return 'quote_denom: string expected';
        return null;
      };

      /**
       * Creates a Market message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.Market
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.Market} Market
       */
      Market.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.Market) return object;
        let message = new $root.ununifi.derivatives.Market();
        if (object.base_denom != null) message.base_denom = String(object.base_denom);
        if (object.quote_denom != null) message.quote_denom = String(object.quote_denom);
        return message;
      };

      /**
       * Creates a plain object from a Market message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.Market
       * @static
       * @param {ununifi.derivatives.Market} message Market
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Market.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.base_denom = '';
          object.quote_denom = '';
        }
        if (message.base_denom != null && message.hasOwnProperty('base_denom')) object.base_denom = message.base_denom;
        if (message.quote_denom != null && message.hasOwnProperty('quote_denom')) object.quote_denom = message.quote_denom;
        return object;
      };

      /**
       * Converts this Market to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.Market
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Market.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Market;
    })();

    /**
     * MarketType enum.
     * @name ununifi.derivatives.MarketType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} FUTURES=1 FUTURES value
     * @property {number} OPTIONS=2 OPTIONS value
     */
    derivatives.MarketType = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'UNKNOWN')] = 0;
      values[(valuesById[1] = 'FUTURES')] = 1;
      values[(valuesById[2] = 'OPTIONS')] = 2;
      return values;
    })();

    derivatives.Reserve = (function () {
      /**
       * Properties of a Reserve.
       * @memberof ununifi.derivatives
       * @interface IReserve
       * @property {ununifi.derivatives.MarketType|null} [market_type] Reserve market_type
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] Reserve amount
       */

      /**
       * Constructs a new Reserve.
       * @memberof ununifi.derivatives
       * @classdesc Represents a Reserve.
       * @implements IReserve
       * @constructor
       * @param {ununifi.derivatives.IReserve=} [properties] Properties to set
       */
      function Reserve(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Reserve market_type.
       * @member {ununifi.derivatives.MarketType} market_type
       * @memberof ununifi.derivatives.Reserve
       * @instance
       */
      Reserve.prototype.market_type = 0;

      /**
       * Reserve amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.derivatives.Reserve
       * @instance
       */
      Reserve.prototype.amount = null;

      /**
       * Encodes the specified Reserve message. Does not implicitly {@link ununifi.derivatives.Reserve.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.Reserve
       * @static
       * @param {ununifi.derivatives.IReserve} message Reserve message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Reserve.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_type != null && Object.hasOwnProperty.call(message, 'market_type'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.market_type);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Reserve message, length delimited. Does not implicitly {@link ununifi.derivatives.Reserve.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.Reserve
       * @static
       * @param {ununifi.derivatives.IReserve} message Reserve message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Reserve.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Reserve message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.Reserve
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.Reserve} Reserve
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Reserve.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.Reserve();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_type = reader.int32();
              break;
            case 2:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Reserve message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.Reserve
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.Reserve} Reserve
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Reserve.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Reserve message.
       * @function verify
       * @memberof ununifi.derivatives.Reserve
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Reserve.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_type != null && message.hasOwnProperty('market_type'))
          switch (message.market_type) {
            default:
              return 'market_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a Reserve message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.Reserve
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.Reserve} Reserve
       */
      Reserve.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.Reserve) return object;
        let message = new $root.ununifi.derivatives.Reserve();
        switch (object.market_type) {
          case 'UNKNOWN':
          case 0:
            message.market_type = 0;
            break;
          case 'FUTURES':
          case 1:
            message.market_type = 1;
            break;
          case 'OPTIONS':
          case 2:
            message.market_type = 2;
            break;
        }
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.derivatives.Reserve.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a Reserve message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.Reserve
       * @static
       * @param {ununifi.derivatives.Reserve} message Reserve
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Reserve.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_type = options.enums === String ? 'UNKNOWN' : 0;
          object.amount = null;
        }
        if (message.market_type != null && message.hasOwnProperty('market_type'))
          object.market_type = options.enums === String ? $root.ununifi.derivatives.MarketType[message.market_type] : message.market_type;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this Reserve to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.Reserve
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Reserve.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Reserve;
    })();

    derivatives.EventPriceIsNotFed = (function () {
      /**
       * Properties of an EventPriceIsNotFed.
       * @memberof ununifi.derivatives
       * @interface IEventPriceIsNotFed
       * @property {string|null} [asset] EventPriceIsNotFed asset
       */

      /**
       * Constructs a new EventPriceIsNotFed.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPriceIsNotFed.
       * @implements IEventPriceIsNotFed
       * @constructor
       * @param {ununifi.derivatives.IEventPriceIsNotFed=} [properties] Properties to set
       */
      function EventPriceIsNotFed(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPriceIsNotFed asset.
       * @member {string} asset
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @instance
       */
      EventPriceIsNotFed.prototype.asset = '';

      /**
       * Encodes the specified EventPriceIsNotFed message. Does not implicitly {@link ununifi.derivatives.EventPriceIsNotFed.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @static
       * @param {ununifi.derivatives.IEventPriceIsNotFed} message EventPriceIsNotFed message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPriceIsNotFed.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.asset != null && Object.hasOwnProperty.call(message, 'asset'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.asset);
        return writer;
      };

      /**
       * Encodes the specified EventPriceIsNotFed message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPriceIsNotFed.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @static
       * @param {ununifi.derivatives.IEventPriceIsNotFed} message EventPriceIsNotFed message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPriceIsNotFed.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPriceIsNotFed message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPriceIsNotFed} EventPriceIsNotFed
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPriceIsNotFed.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPriceIsNotFed();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.asset = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPriceIsNotFed message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPriceIsNotFed} EventPriceIsNotFed
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPriceIsNotFed.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPriceIsNotFed message.
       * @function verify
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPriceIsNotFed.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.asset != null && message.hasOwnProperty('asset')) if (!$util.isString(message.asset)) return 'asset: string expected';
        return null;
      };

      /**
       * Creates an EventPriceIsNotFed message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPriceIsNotFed} EventPriceIsNotFed
       */
      EventPriceIsNotFed.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPriceIsNotFed) return object;
        let message = new $root.ununifi.derivatives.EventPriceIsNotFed();
        if (object.asset != null) message.asset = String(object.asset);
        return message;
      };

      /**
       * Creates a plain object from an EventPriceIsNotFed message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @static
       * @param {ununifi.derivatives.EventPriceIsNotFed} message EventPriceIsNotFed
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPriceIsNotFed.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.asset = '';
        if (message.asset != null && message.hasOwnProperty('asset')) object.asset = message.asset;
        return object;
      };

      /**
       * Converts this EventPriceIsNotFed to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPriceIsNotFed
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPriceIsNotFed.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPriceIsNotFed;
    })();

    derivatives.EventPerpetualFuturesLevyFee = (function () {
      /**
       * Properties of an EventPerpetualFuturesLevyFee.
       * @memberof ununifi.derivatives
       * @interface IEventPerpetualFuturesLevyFee
       * @property {cosmos.base.v1beta1.ICoin|null} [fee] EventPerpetualFuturesLevyFee fee
       * @property {string|null} [position_id] EventPerpetualFuturesLevyFee position_id
       */

      /**
       * Constructs a new EventPerpetualFuturesLevyFee.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPerpetualFuturesLevyFee.
       * @implements IEventPerpetualFuturesLevyFee
       * @constructor
       * @param {ununifi.derivatives.IEventPerpetualFuturesLevyFee=} [properties] Properties to set
       */
      function EventPerpetualFuturesLevyFee(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPerpetualFuturesLevyFee fee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @instance
       */
      EventPerpetualFuturesLevyFee.prototype.fee = null;

      /**
       * EventPerpetualFuturesLevyFee position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @instance
       */
      EventPerpetualFuturesLevyFee.prototype.position_id = '';

      /**
       * Encodes the specified EventPerpetualFuturesLevyFee message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLevyFee.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesLevyFee} message EventPerpetualFuturesLevyFee message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesLevyFee.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
          $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified EventPerpetualFuturesLevyFee message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLevyFee.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesLevyFee} message EventPerpetualFuturesLevyFee message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesLevyFee.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPerpetualFuturesLevyFee message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPerpetualFuturesLevyFee} EventPerpetualFuturesLevyFee
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesLevyFee.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPerpetualFuturesLevyFee();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPerpetualFuturesLevyFee message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPerpetualFuturesLevyFee} EventPerpetualFuturesLevyFee
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesLevyFee.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPerpetualFuturesLevyFee message.
       * @function verify
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPerpetualFuturesLevyFee.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.fee != null && message.hasOwnProperty('fee')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
          if (error) return 'fee.' + error;
        }
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates an EventPerpetualFuturesLevyFee message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPerpetualFuturesLevyFee} EventPerpetualFuturesLevyFee
       */
      EventPerpetualFuturesLevyFee.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesLevyFee) return object;
        let message = new $root.ununifi.derivatives.EventPerpetualFuturesLevyFee();
        if (object.fee != null) {
          if (typeof object.fee !== 'object') throw TypeError('.ununifi.derivatives.EventPerpetualFuturesLevyFee.fee: object expected');
          message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
        }
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from an EventPerpetualFuturesLevyFee message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @static
       * @param {ununifi.derivatives.EventPerpetualFuturesLevyFee} message EventPerpetualFuturesLevyFee
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPerpetualFuturesLevyFee.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.fee = null;
          object.position_id = '';
        }
        if (message.fee != null && message.hasOwnProperty('fee'))
          object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this EventPerpetualFuturesLevyFee to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPerpetualFuturesLevyFee
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPerpetualFuturesLevyFee.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPerpetualFuturesLevyFee;
    })();

    derivatives.EventPerpetualFuturesImaginaryFundingFee = (function () {
      /**
       * Properties of an EventPerpetualFuturesImaginaryFundingFee.
       * @memberof ununifi.derivatives
       * @interface IEventPerpetualFuturesImaginaryFundingFee
       * @property {cosmos.base.v1beta1.ICoin|null} [fee] EventPerpetualFuturesImaginaryFundingFee fee
       * @property {boolean|null} [fee_negative] EventPerpetualFuturesImaginaryFundingFee fee_negative
       * @property {string|null} [position_id] EventPerpetualFuturesImaginaryFundingFee position_id
       */

      /**
       * Constructs a new EventPerpetualFuturesImaginaryFundingFee.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPerpetualFuturesImaginaryFundingFee.
       * @implements IEventPerpetualFuturesImaginaryFundingFee
       * @constructor
       * @param {ununifi.derivatives.IEventPerpetualFuturesImaginaryFundingFee=} [properties] Properties to set
       */
      function EventPerpetualFuturesImaginaryFundingFee(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPerpetualFuturesImaginaryFundingFee fee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @instance
       */
      EventPerpetualFuturesImaginaryFundingFee.prototype.fee = null;

      /**
       * EventPerpetualFuturesImaginaryFundingFee fee_negative.
       * @member {boolean} fee_negative
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @instance
       */
      EventPerpetualFuturesImaginaryFundingFee.prototype.fee_negative = false;

      /**
       * EventPerpetualFuturesImaginaryFundingFee position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @instance
       */
      EventPerpetualFuturesImaginaryFundingFee.prototype.position_id = '';

      /**
       * Encodes the specified EventPerpetualFuturesImaginaryFundingFee message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesImaginaryFundingFee} message EventPerpetualFuturesImaginaryFundingFee message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesImaginaryFundingFee.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
          $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        if (message.fee_negative != null && Object.hasOwnProperty.call(message, 'fee_negative'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.fee_negative);
        return writer;
      };

      /**
       * Encodes the specified EventPerpetualFuturesImaginaryFundingFee message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesImaginaryFundingFee} message EventPerpetualFuturesImaginaryFundingFee message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesImaginaryFundingFee.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPerpetualFuturesImaginaryFundingFee message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} EventPerpetualFuturesImaginaryFundingFee
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesImaginaryFundingFee.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.fee_negative = reader.bool();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPerpetualFuturesImaginaryFundingFee message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} EventPerpetualFuturesImaginaryFundingFee
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesImaginaryFundingFee.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPerpetualFuturesImaginaryFundingFee message.
       * @function verify
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPerpetualFuturesImaginaryFundingFee.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.fee != null && message.hasOwnProperty('fee')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
          if (error) return 'fee.' + error;
        }
        if (message.fee_negative != null && message.hasOwnProperty('fee_negative'))
          if (typeof message.fee_negative !== 'boolean') return 'fee_negative: boolean expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates an EventPerpetualFuturesImaginaryFundingFee message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} EventPerpetualFuturesImaginaryFundingFee
       */
      EventPerpetualFuturesImaginaryFundingFee.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee) return object;
        let message = new $root.ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee();
        if (object.fee != null) {
          if (typeof object.fee !== 'object')
            throw TypeError('.ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee.fee: object expected');
          message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
        }
        if (object.fee_negative != null) message.fee_negative = Boolean(object.fee_negative);
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from an EventPerpetualFuturesImaginaryFundingFee message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @static
       * @param {ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee} message EventPerpetualFuturesImaginaryFundingFee
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPerpetualFuturesImaginaryFundingFee.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.fee = null;
          object.position_id = '';
          object.fee_negative = false;
        }
        if (message.fee != null && message.hasOwnProperty('fee'))
          object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        if (message.fee_negative != null && message.hasOwnProperty('fee_negative')) object.fee_negative = message.fee_negative;
        return object;
      };

      /**
       * Converts this EventPerpetualFuturesImaginaryFundingFee to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPerpetualFuturesImaginaryFundingFee
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPerpetualFuturesImaginaryFundingFee.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPerpetualFuturesImaginaryFundingFee;
    })();

    derivatives.EventPerpetualFuturesLiquidationFee = (function () {
      /**
       * Properties of an EventPerpetualFuturesLiquidationFee.
       * @memberof ununifi.derivatives
       * @interface IEventPerpetualFuturesLiquidationFee
       * @property {cosmos.base.v1beta1.ICoin|null} [fee] EventPerpetualFuturesLiquidationFee fee
       * @property {string|null} [position_id] EventPerpetualFuturesLiquidationFee position_id
       */

      /**
       * Constructs a new EventPerpetualFuturesLiquidationFee.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPerpetualFuturesLiquidationFee.
       * @implements IEventPerpetualFuturesLiquidationFee
       * @constructor
       * @param {ununifi.derivatives.IEventPerpetualFuturesLiquidationFee=} [properties] Properties to set
       */
      function EventPerpetualFuturesLiquidationFee(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPerpetualFuturesLiquidationFee fee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @instance
       */
      EventPerpetualFuturesLiquidationFee.prototype.fee = null;

      /**
       * EventPerpetualFuturesLiquidationFee position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @instance
       */
      EventPerpetualFuturesLiquidationFee.prototype.position_id = '';

      /**
       * Encodes the specified EventPerpetualFuturesLiquidationFee message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLiquidationFee.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesLiquidationFee} message EventPerpetualFuturesLiquidationFee message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesLiquidationFee.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
          $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified EventPerpetualFuturesLiquidationFee message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesLiquidationFee.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesLiquidationFee} message EventPerpetualFuturesLiquidationFee message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesLiquidationFee.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPerpetualFuturesLiquidationFee message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} EventPerpetualFuturesLiquidationFee
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesLiquidationFee.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPerpetualFuturesLiquidationFee();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPerpetualFuturesLiquidationFee message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} EventPerpetualFuturesLiquidationFee
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesLiquidationFee.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPerpetualFuturesLiquidationFee message.
       * @function verify
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPerpetualFuturesLiquidationFee.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.fee != null && message.hasOwnProperty('fee')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
          if (error) return 'fee.' + error;
        }
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates an EventPerpetualFuturesLiquidationFee message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} EventPerpetualFuturesLiquidationFee
       */
      EventPerpetualFuturesLiquidationFee.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesLiquidationFee) return object;
        let message = new $root.ununifi.derivatives.EventPerpetualFuturesLiquidationFee();
        if (object.fee != null) {
          if (typeof object.fee !== 'object')
            throw TypeError('.ununifi.derivatives.EventPerpetualFuturesLiquidationFee.fee: object expected');
          message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
        }
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from an EventPerpetualFuturesLiquidationFee message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @static
       * @param {ununifi.derivatives.EventPerpetualFuturesLiquidationFee} message EventPerpetualFuturesLiquidationFee
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPerpetualFuturesLiquidationFee.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.fee = null;
          object.position_id = '';
        }
        if (message.fee != null && message.hasOwnProperty('fee'))
          object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this EventPerpetualFuturesLiquidationFee to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPerpetualFuturesLiquidationFee
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPerpetualFuturesLiquidationFee.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPerpetualFuturesLiquidationFee;
    })();

    derivatives.EventLiquidationNeeded = (function () {
      /**
       * Properties of an EventLiquidationNeeded.
       * @memberof ununifi.derivatives
       * @interface IEventLiquidationNeeded
       * @property {string|null} [position_id] EventLiquidationNeeded position_id
       */

      /**
       * Constructs a new EventLiquidationNeeded.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventLiquidationNeeded.
       * @implements IEventLiquidationNeeded
       * @constructor
       * @param {ununifi.derivatives.IEventLiquidationNeeded=} [properties] Properties to set
       */
      function EventLiquidationNeeded(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventLiquidationNeeded position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @instance
       */
      EventLiquidationNeeded.prototype.position_id = '';

      /**
       * Encodes the specified EventLiquidationNeeded message. Does not implicitly {@link ununifi.derivatives.EventLiquidationNeeded.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @static
       * @param {ununifi.derivatives.IEventLiquidationNeeded} message EventLiquidationNeeded message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLiquidationNeeded.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified EventLiquidationNeeded message, length delimited. Does not implicitly {@link ununifi.derivatives.EventLiquidationNeeded.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @static
       * @param {ununifi.derivatives.IEventLiquidationNeeded} message EventLiquidationNeeded message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLiquidationNeeded.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventLiquidationNeeded message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventLiquidationNeeded} EventLiquidationNeeded
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLiquidationNeeded.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventLiquidationNeeded();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventLiquidationNeeded message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventLiquidationNeeded} EventLiquidationNeeded
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLiquidationNeeded.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventLiquidationNeeded message.
       * @function verify
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventLiquidationNeeded.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates an EventLiquidationNeeded message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventLiquidationNeeded} EventLiquidationNeeded
       */
      EventLiquidationNeeded.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventLiquidationNeeded) return object;
        let message = new $root.ununifi.derivatives.EventLiquidationNeeded();
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from an EventLiquidationNeeded message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @static
       * @param {ununifi.derivatives.EventLiquidationNeeded} message EventLiquidationNeeded
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventLiquidationNeeded.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.position_id = '';
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this EventLiquidationNeeded to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventLiquidationNeeded
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventLiquidationNeeded.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventLiquidationNeeded;
    })();

    derivatives.PerpetualFuturesParams = (function () {
      /**
       * Properties of a PerpetualFuturesParams.
       * @memberof ununifi.derivatives
       * @interface IPerpetualFuturesParams
       * @property {string|null} [commission_rate] PerpetualFuturesParams commission_rate
       * @property {string|null} [margin_maintenance_rate] PerpetualFuturesParams margin_maintenance_rate
       * @property {string|null} [imaginary_funding_rate_proportional_coefficient] PerpetualFuturesParams imaginary_funding_rate_proportional_coefficient
       * @property {Array.<ununifi.derivatives.IMarket>|null} [markets] PerpetualFuturesParams markets
       * @property {number|null} [max_leverage] PerpetualFuturesParams max_leverage
       */

      /**
       * Constructs a new PerpetualFuturesParams.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PerpetualFuturesParams.
       * @implements IPerpetualFuturesParams
       * @constructor
       * @param {ununifi.derivatives.IPerpetualFuturesParams=} [properties] Properties to set
       */
      function PerpetualFuturesParams(properties) {
        this.markets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PerpetualFuturesParams commission_rate.
       * @member {string} commission_rate
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @instance
       */
      PerpetualFuturesParams.prototype.commission_rate = '';

      /**
       * PerpetualFuturesParams margin_maintenance_rate.
       * @member {string} margin_maintenance_rate
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @instance
       */
      PerpetualFuturesParams.prototype.margin_maintenance_rate = '';

      /**
       * PerpetualFuturesParams imaginary_funding_rate_proportional_coefficient.
       * @member {string} imaginary_funding_rate_proportional_coefficient
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @instance
       */
      PerpetualFuturesParams.prototype.imaginary_funding_rate_proportional_coefficient = '';

      /**
       * PerpetualFuturesParams markets.
       * @member {Array.<ununifi.derivatives.IMarket>} markets
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @instance
       */
      PerpetualFuturesParams.prototype.markets = $util.emptyArray;

      /**
       * PerpetualFuturesParams max_leverage.
       * @member {number} max_leverage
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @instance
       */
      PerpetualFuturesParams.prototype.max_leverage = 0;

      /**
       * Encodes the specified PerpetualFuturesParams message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesParams} message PerpetualFuturesParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.commission_rate != null && Object.hasOwnProperty.call(message, 'commission_rate'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.commission_rate);
        if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, 'margin_maintenance_rate'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.margin_maintenance_rate);
        if (
          message.imaginary_funding_rate_proportional_coefficient != null &&
          Object.hasOwnProperty.call(message, 'imaginary_funding_rate_proportional_coefficient')
        )
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.imaginary_funding_rate_proportional_coefficient);
        if (message.markets != null && message.markets.length)
          for (let i = 0; i < message.markets.length; ++i)
            $root.ununifi.derivatives.Market.encode(message.markets[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.max_leverage != null && Object.hasOwnProperty.call(message, 'max_leverage'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint32(message.max_leverage);
        return writer;
      };

      /**
       * Encodes the specified PerpetualFuturesParams message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesParams} message PerpetualFuturesParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PerpetualFuturesParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PerpetualFuturesParams} PerpetualFuturesParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PerpetualFuturesParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission_rate = reader.string();
              break;
            case 2:
              message.margin_maintenance_rate = reader.string();
              break;
            case 3:
              message.imaginary_funding_rate_proportional_coefficient = reader.string();
              break;
            case 4:
              if (!(message.markets && message.markets.length)) message.markets = [];
              message.markets.push($root.ununifi.derivatives.Market.decode(reader, reader.uint32()));
              break;
            case 5:
              message.max_leverage = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PerpetualFuturesParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PerpetualFuturesParams} PerpetualFuturesParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PerpetualFuturesParams message.
       * @function verify
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PerpetualFuturesParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.commission_rate != null && message.hasOwnProperty('commission_rate'))
          if (!$util.isString(message.commission_rate)) return 'commission_rate: string expected';
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          if (!$util.isString(message.margin_maintenance_rate)) return 'margin_maintenance_rate: string expected';
        if (
          message.imaginary_funding_rate_proportional_coefficient != null &&
          message.hasOwnProperty('imaginary_funding_rate_proportional_coefficient')
        )
          if (!$util.isString(message.imaginary_funding_rate_proportional_coefficient))
            return 'imaginary_funding_rate_proportional_coefficient: string expected';
        if (message.markets != null && message.hasOwnProperty('markets')) {
          if (!Array.isArray(message.markets)) return 'markets: array expected';
          for (let i = 0; i < message.markets.length; ++i) {
            let error = $root.ununifi.derivatives.Market.verify(message.markets[i]);
            if (error) return 'markets.' + error;
          }
        }
        if (message.max_leverage != null && message.hasOwnProperty('max_leverage'))
          if (!$util.isInteger(message.max_leverage)) return 'max_leverage: integer expected';
        return null;
      };

      /**
       * Creates a PerpetualFuturesParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PerpetualFuturesParams} PerpetualFuturesParams
       */
      PerpetualFuturesParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PerpetualFuturesParams) return object;
        let message = new $root.ununifi.derivatives.PerpetualFuturesParams();
        if (object.commission_rate != null) message.commission_rate = String(object.commission_rate);
        if (object.margin_maintenance_rate != null) message.margin_maintenance_rate = String(object.margin_maintenance_rate);
        if (object.imaginary_funding_rate_proportional_coefficient != null)
          message.imaginary_funding_rate_proportional_coefficient = String(object.imaginary_funding_rate_proportional_coefficient);
        if (object.markets) {
          if (!Array.isArray(object.markets)) throw TypeError('.ununifi.derivatives.PerpetualFuturesParams.markets: array expected');
          message.markets = [];
          for (let i = 0; i < object.markets.length; ++i) {
            if (typeof object.markets[i] !== 'object')
              throw TypeError('.ununifi.derivatives.PerpetualFuturesParams.markets: object expected');
            message.markets[i] = $root.ununifi.derivatives.Market.fromObject(object.markets[i]);
          }
        }
        if (object.max_leverage != null) message.max_leverage = object.max_leverage >>> 0;
        return message;
      };

      /**
       * Creates a plain object from a PerpetualFuturesParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @static
       * @param {ununifi.derivatives.PerpetualFuturesParams} message PerpetualFuturesParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PerpetualFuturesParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.markets = [];
        if (options.defaults) {
          object.commission_rate = '';
          object.margin_maintenance_rate = '';
          object.imaginary_funding_rate_proportional_coefficient = '';
          object.max_leverage = 0;
        }
        if (message.commission_rate != null && message.hasOwnProperty('commission_rate')) object.commission_rate = message.commission_rate;
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          object.margin_maintenance_rate = message.margin_maintenance_rate;
        if (
          message.imaginary_funding_rate_proportional_coefficient != null &&
          message.hasOwnProperty('imaginary_funding_rate_proportional_coefficient')
        )
          object.imaginary_funding_rate_proportional_coefficient = message.imaginary_funding_rate_proportional_coefficient;
        if (message.markets && message.markets.length) {
          object.markets = [];
          for (let j = 0; j < message.markets.length; ++j)
            object.markets[j] = $root.ununifi.derivatives.Market.toObject(message.markets[j], options);
        }
        if (message.max_leverage != null && message.hasOwnProperty('max_leverage')) object.max_leverage = message.max_leverage;
        return object;
      };

      /**
       * Converts this PerpetualFuturesParams to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PerpetualFuturesParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PerpetualFuturesParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PerpetualFuturesParams;
    })();

    derivatives.PerpetualFuturesPosition = (function () {
      /**
       * Properties of a PerpetualFuturesPosition.
       * @memberof ununifi.derivatives
       * @interface IPerpetualFuturesPosition
       * @property {string|null} [id] PerpetualFuturesPosition id
       * @property {ununifi.derivatives.IMarket|null} [market] PerpetualFuturesPosition market
       * @property {string|null} [opener_address] PerpetualFuturesPosition opener_address
       * @property {google.protobuf.ITimestamp|null} [opened_at] PerpetualFuturesPosition opened_at
       * @property {Long|null} [opened_height] PerpetualFuturesPosition opened_height
       * @property {string|null} [opened_base_rate] PerpetualFuturesPosition opened_base_rate
       * @property {string|null} [opened_quote_rate] PerpetualFuturesPosition opened_quote_rate
       * @property {cosmos.base.v1beta1.ICoin|null} [remaining_margin] PerpetualFuturesPosition remaining_margin
       * @property {cosmos.base.v1beta1.ICoin|null} [levied_amount] PerpetualFuturesPosition levied_amount
       * @property {boolean|null} [levied_amount_negative] PerpetualFuturesPosition levied_amount_negative
       * @property {google.protobuf.ITimestamp|null} [last_levied_at] PerpetualFuturesPosition last_levied_at
       * @property {ununifi.derivatives.IPerpetualFuturesPositionInstance|null} [position_instance] PerpetualFuturesPosition position_instance
       */

      /**
       * Constructs a new PerpetualFuturesPosition.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PerpetualFuturesPosition.
       * @implements IPerpetualFuturesPosition
       * @constructor
       * @param {ununifi.derivatives.IPerpetualFuturesPosition=} [properties] Properties to set
       */
      function PerpetualFuturesPosition(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PerpetualFuturesPosition id.
       * @member {string} id
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.id = '';

      /**
       * PerpetualFuturesPosition market.
       * @member {ununifi.derivatives.IMarket|null|undefined} market
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.market = null;

      /**
       * PerpetualFuturesPosition opener_address.
       * @member {string} opener_address
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.opener_address = '';

      /**
       * PerpetualFuturesPosition opened_at.
       * @member {google.protobuf.ITimestamp|null|undefined} opened_at
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.opened_at = null;

      /**
       * PerpetualFuturesPosition opened_height.
       * @member {Long} opened_height
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.opened_height = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * PerpetualFuturesPosition opened_base_rate.
       * @member {string} opened_base_rate
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.opened_base_rate = '';

      /**
       * PerpetualFuturesPosition opened_quote_rate.
       * @member {string} opened_quote_rate
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.opened_quote_rate = '';

      /**
       * PerpetualFuturesPosition remaining_margin.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} remaining_margin
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.remaining_margin = null;

      /**
       * PerpetualFuturesPosition levied_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} levied_amount
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.levied_amount = null;

      /**
       * PerpetualFuturesPosition levied_amount_negative.
       * @member {boolean} levied_amount_negative
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.levied_amount_negative = false;

      /**
       * PerpetualFuturesPosition last_levied_at.
       * @member {google.protobuf.ITimestamp|null|undefined} last_levied_at
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.last_levied_at = null;

      /**
       * PerpetualFuturesPosition position_instance.
       * @member {ununifi.derivatives.IPerpetualFuturesPositionInstance|null|undefined} position_instance
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       */
      PerpetualFuturesPosition.prototype.position_instance = null;

      /**
       * Encodes the specified PerpetualFuturesPosition message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPosition.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesPosition} message PerpetualFuturesPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesPosition.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        if (message.market != null && Object.hasOwnProperty.call(message, 'market'))
          $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.opener_address != null && Object.hasOwnProperty.call(message, 'opener_address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.opener_address);
        if (message.opened_at != null && Object.hasOwnProperty.call(message, 'opened_at'))
          $root.google.protobuf.Timestamp.encode(message.opened_at, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.opened_height != null && Object.hasOwnProperty.call(message, 'opened_height'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.opened_height);
        if (message.opened_base_rate != null && Object.hasOwnProperty.call(message, 'opened_base_rate'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.opened_base_rate);
        if (message.opened_quote_rate != null && Object.hasOwnProperty.call(message, 'opened_quote_rate'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.opened_quote_rate);
        if (message.remaining_margin != null && Object.hasOwnProperty.call(message, 'remaining_margin'))
          $root.cosmos.base.v1beta1.Coin.encode(message.remaining_margin, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.levied_amount != null && Object.hasOwnProperty.call(message, 'levied_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.levied_amount, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        if (message.levied_amount_negative != null && Object.hasOwnProperty.call(message, 'levied_amount_negative'))
          writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.levied_amount_negative);
        if (message.last_levied_at != null && Object.hasOwnProperty.call(message, 'last_levied_at'))
          $root.google.protobuf.Timestamp.encode(message.last_levied_at, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
        if (message.position_instance != null && Object.hasOwnProperty.call(message, 'position_instance'))
          $root.ununifi.derivatives.PerpetualFuturesPositionInstance.encode(
            message.position_instance,
            writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified PerpetualFuturesPosition message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPosition.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesPosition} message PerpetualFuturesPosition message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesPosition.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PerpetualFuturesPosition message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PerpetualFuturesPosition} PerpetualFuturesPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesPosition.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PerpetualFuturesPosition();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
              break;
            case 3:
              message.opener_address = reader.string();
              break;
            case 4:
              message.opened_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.opened_height = reader.uint64();
              break;
            case 6:
              message.opened_base_rate = reader.string();
              break;
            case 7:
              message.opened_quote_rate = reader.string();
              break;
            case 8:
              message.remaining_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 9:
              message.levied_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 10:
              message.levied_amount_negative = reader.bool();
              break;
            case 11:
              message.last_levied_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 12:
              message.position_instance = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PerpetualFuturesPosition message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PerpetualFuturesPosition} PerpetualFuturesPosition
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesPosition.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PerpetualFuturesPosition message.
       * @function verify
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PerpetualFuturesPosition.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        if (message.market != null && message.hasOwnProperty('market')) {
          let error = $root.ununifi.derivatives.Market.verify(message.market);
          if (error) return 'market.' + error;
        }
        if (message.opener_address != null && message.hasOwnProperty('opener_address'))
          if (!$util.isString(message.opener_address)) return 'opener_address: string expected';
        if (message.opened_at != null && message.hasOwnProperty('opened_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.opened_at);
          if (error) return 'opened_at.' + error;
        }
        if (message.opened_height != null && message.hasOwnProperty('opened_height'))
          if (
            !$util.isInteger(message.opened_height) &&
            !(message.opened_height && $util.isInteger(message.opened_height.low) && $util.isInteger(message.opened_height.high))
          )
            return 'opened_height: integer|Long expected';
        if (message.opened_base_rate != null && message.hasOwnProperty('opened_base_rate'))
          if (!$util.isString(message.opened_base_rate)) return 'opened_base_rate: string expected';
        if (message.opened_quote_rate != null && message.hasOwnProperty('opened_quote_rate'))
          if (!$util.isString(message.opened_quote_rate)) return 'opened_quote_rate: string expected';
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.remaining_margin);
          if (error) return 'remaining_margin.' + error;
        }
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.levied_amount);
          if (error) return 'levied_amount.' + error;
        }
        if (message.levied_amount_negative != null && message.hasOwnProperty('levied_amount_negative'))
          if (typeof message.levied_amount_negative !== 'boolean') return 'levied_amount_negative: boolean expected';
        if (message.last_levied_at != null && message.hasOwnProperty('last_levied_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.last_levied_at);
          if (error) return 'last_levied_at.' + error;
        }
        if (message.position_instance != null && message.hasOwnProperty('position_instance')) {
          let error = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.verify(message.position_instance);
          if (error) return 'position_instance.' + error;
        }
        return null;
      };

      /**
       * Creates a PerpetualFuturesPosition message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PerpetualFuturesPosition} PerpetualFuturesPosition
       */
      PerpetualFuturesPosition.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PerpetualFuturesPosition) return object;
        let message = new $root.ununifi.derivatives.PerpetualFuturesPosition();
        if (object.id != null) message.id = String(object.id);
        if (object.market != null) {
          if (typeof object.market !== 'object') throw TypeError('.ununifi.derivatives.PerpetualFuturesPosition.market: object expected');
          message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
        }
        if (object.opener_address != null) message.opener_address = String(object.opener_address);
        if (object.opened_at != null) {
          if (typeof object.opened_at !== 'object')
            throw TypeError('.ununifi.derivatives.PerpetualFuturesPosition.opened_at: object expected');
          message.opened_at = $root.google.protobuf.Timestamp.fromObject(object.opened_at);
        }
        if (object.opened_height != null)
          if ($util.Long) (message.opened_height = $util.Long.fromValue(object.opened_height)).unsigned = true;
          else if (typeof object.opened_height === 'string') message.opened_height = parseInt(object.opened_height, 10);
          else if (typeof object.opened_height === 'number') message.opened_height = object.opened_height;
          else if (typeof object.opened_height === 'object')
            message.opened_height = new $util.LongBits(object.opened_height.low >>> 0, object.opened_height.high >>> 0).toNumber(true);
        if (object.opened_base_rate != null) message.opened_base_rate = String(object.opened_base_rate);
        if (object.opened_quote_rate != null) message.opened_quote_rate = String(object.opened_quote_rate);
        if (object.remaining_margin != null) {
          if (typeof object.remaining_margin !== 'object')
            throw TypeError('.ununifi.derivatives.PerpetualFuturesPosition.remaining_margin: object expected');
          message.remaining_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.remaining_margin);
        }
        if (object.levied_amount != null) {
          if (typeof object.levied_amount !== 'object')
            throw TypeError('.ununifi.derivatives.PerpetualFuturesPosition.levied_amount: object expected');
          message.levied_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.levied_amount);
        }
        if (object.levied_amount_negative != null) message.levied_amount_negative = Boolean(object.levied_amount_negative);
        if (object.last_levied_at != null) {
          if (typeof object.last_levied_at !== 'object')
            throw TypeError('.ununifi.derivatives.PerpetualFuturesPosition.last_levied_at: object expected');
          message.last_levied_at = $root.google.protobuf.Timestamp.fromObject(object.last_levied_at);
        }
        if (object.position_instance != null) {
          if (typeof object.position_instance !== 'object')
            throw TypeError('.ununifi.derivatives.PerpetualFuturesPosition.position_instance: object expected');
          message.position_instance = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.fromObject(object.position_instance);
        }
        return message;
      };

      /**
       * Creates a plain object from a PerpetualFuturesPosition message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @static
       * @param {ununifi.derivatives.PerpetualFuturesPosition} message PerpetualFuturesPosition
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PerpetualFuturesPosition.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.id = '';
          object.market = null;
          object.opener_address = '';
          object.opened_at = null;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.opened_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.opened_height = options.longs === String ? '0' : 0;
          object.opened_base_rate = '';
          object.opened_quote_rate = '';
          object.remaining_margin = null;
          object.levied_amount = null;
          object.levied_amount_negative = false;
          object.last_levied_at = null;
          object.position_instance = null;
        }
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        if (message.market != null && message.hasOwnProperty('market'))
          object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
        if (message.opener_address != null && message.hasOwnProperty('opener_address')) object.opener_address = message.opener_address;
        if (message.opened_at != null && message.hasOwnProperty('opened_at'))
          object.opened_at = $root.google.protobuf.Timestamp.toObject(message.opened_at, options);
        if (message.opened_height != null && message.hasOwnProperty('opened_height'))
          if (typeof message.opened_height === 'number')
            object.opened_height = options.longs === String ? String(message.opened_height) : message.opened_height;
          else
            object.opened_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.opened_height)
                : options.longs === Number
                ? new $util.LongBits(message.opened_height.low >>> 0, message.opened_height.high >>> 0).toNumber(true)
                : message.opened_height;
        if (message.opened_base_rate != null && message.hasOwnProperty('opened_base_rate'))
          object.opened_base_rate = message.opened_base_rate;
        if (message.opened_quote_rate != null && message.hasOwnProperty('opened_quote_rate'))
          object.opened_quote_rate = message.opened_quote_rate;
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin'))
          object.remaining_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.remaining_margin, options);
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount'))
          object.levied_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.levied_amount, options);
        if (message.levied_amount_negative != null && message.hasOwnProperty('levied_amount_negative'))
          object.levied_amount_negative = message.levied_amount_negative;
        if (message.last_levied_at != null && message.hasOwnProperty('last_levied_at'))
          object.last_levied_at = $root.google.protobuf.Timestamp.toObject(message.last_levied_at, options);
        if (message.position_instance != null && message.hasOwnProperty('position_instance'))
          object.position_instance = $root.ununifi.derivatives.PerpetualFuturesPositionInstance.toObject(
            message.position_instance,
            options,
          );
        return object;
      };

      /**
       * Converts this PerpetualFuturesPosition to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PerpetualFuturesPosition
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PerpetualFuturesPosition.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PerpetualFuturesPosition;
    })();

    derivatives.PerpetualFuturesPositionInstance = (function () {
      /**
       * Properties of a PerpetualFuturesPositionInstance.
       * @memberof ununifi.derivatives
       * @interface IPerpetualFuturesPositionInstance
       * @property {ununifi.derivatives.PositionType|null} [position_type] PerpetualFuturesPositionInstance position_type
       * @property {string|null} [size] PerpetualFuturesPositionInstance size
       * @property {number|null} [leverage] PerpetualFuturesPositionInstance leverage
       */

      /**
       * Constructs a new PerpetualFuturesPositionInstance.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PerpetualFuturesPositionInstance.
       * @implements IPerpetualFuturesPositionInstance
       * @constructor
       * @param {ununifi.derivatives.IPerpetualFuturesPositionInstance=} [properties] Properties to set
       */
      function PerpetualFuturesPositionInstance(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PerpetualFuturesPositionInstance position_type.
       * @member {ununifi.derivatives.PositionType} position_type
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @instance
       */
      PerpetualFuturesPositionInstance.prototype.position_type = 0;

      /**
       * PerpetualFuturesPositionInstance size.
       * @member {string} size
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @instance
       */
      PerpetualFuturesPositionInstance.prototype.size = '';

      /**
       * PerpetualFuturesPositionInstance leverage.
       * @member {number} leverage
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @instance
       */
      PerpetualFuturesPositionInstance.prototype.leverage = 0;

      /**
       * Encodes the specified PerpetualFuturesPositionInstance message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPositionInstance.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesPositionInstance} message PerpetualFuturesPositionInstance message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesPositionInstance.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position_type != null && Object.hasOwnProperty.call(message, 'position_type'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.position_type);
        if (message.size != null && Object.hasOwnProperty.call(message, 'size'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.size);
        if (message.leverage != null && Object.hasOwnProperty.call(message, 'leverage'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).uint32(message.leverage);
        return writer;
      };

      /**
       * Encodes the specified PerpetualFuturesPositionInstance message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesPositionInstance.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesPositionInstance} message PerpetualFuturesPositionInstance message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesPositionInstance.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PerpetualFuturesPositionInstance message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PerpetualFuturesPositionInstance} PerpetualFuturesPositionInstance
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesPositionInstance.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PerpetualFuturesPositionInstance();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position_type = reader.int32();
              break;
            case 2:
              message.size = reader.string();
              break;
            case 3:
              message.leverage = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PerpetualFuturesPositionInstance message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PerpetualFuturesPositionInstance} PerpetualFuturesPositionInstance
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesPositionInstance.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PerpetualFuturesPositionInstance message.
       * @function verify
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PerpetualFuturesPositionInstance.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          switch (message.position_type) {
            default:
              return 'position_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.size != null && message.hasOwnProperty('size')) if (!$util.isString(message.size)) return 'size: string expected';
        if (message.leverage != null && message.hasOwnProperty('leverage'))
          if (!$util.isInteger(message.leverage)) return 'leverage: integer expected';
        return null;
      };

      /**
       * Creates a PerpetualFuturesPositionInstance message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PerpetualFuturesPositionInstance} PerpetualFuturesPositionInstance
       */
      PerpetualFuturesPositionInstance.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PerpetualFuturesPositionInstance) return object;
        let message = new $root.ununifi.derivatives.PerpetualFuturesPositionInstance();
        switch (object.position_type) {
          case 'POSITION_UNKNOWN':
          case 0:
            message.position_type = 0;
            break;
          case 'LONG':
          case 1:
            message.position_type = 1;
            break;
          case 'SHORT':
          case 2:
            message.position_type = 2;
            break;
        }
        if (object.size != null) message.size = String(object.size);
        if (object.leverage != null) message.leverage = object.leverage >>> 0;
        return message;
      };

      /**
       * Creates a plain object from a PerpetualFuturesPositionInstance message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @static
       * @param {ununifi.derivatives.PerpetualFuturesPositionInstance} message PerpetualFuturesPositionInstance
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PerpetualFuturesPositionInstance.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.position_type = options.enums === String ? 'POSITION_UNKNOWN' : 0;
          object.size = '';
          object.leverage = 0;
        }
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          object.position_type =
            options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
        if (message.size != null && message.hasOwnProperty('size')) object.size = message.size;
        if (message.leverage != null && message.hasOwnProperty('leverage')) object.leverage = message.leverage;
        return object;
      };

      /**
       * Converts this PerpetualFuturesPositionInstance to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PerpetualFuturesPositionInstance
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PerpetualFuturesPositionInstance.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PerpetualFuturesPositionInstance;
    })();

    derivatives.PerpetualFuturesGrossPositionOfMarket = (function () {
      /**
       * Properties of a PerpetualFuturesGrossPositionOfMarket.
       * @memberof ununifi.derivatives
       * @interface IPerpetualFuturesGrossPositionOfMarket
       * @property {ununifi.derivatives.IMarket|null} [market] PerpetualFuturesGrossPositionOfMarket market
       * @property {ununifi.derivatives.PositionType|null} [position_type] PerpetualFuturesGrossPositionOfMarket position_type
       * @property {string|null} [position_size_in_denom_exponent] PerpetualFuturesGrossPositionOfMarket position_size_in_denom_exponent
       */

      /**
       * Constructs a new PerpetualFuturesGrossPositionOfMarket.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PerpetualFuturesGrossPositionOfMarket.
       * @implements IPerpetualFuturesGrossPositionOfMarket
       * @constructor
       * @param {ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket=} [properties] Properties to set
       */
      function PerpetualFuturesGrossPositionOfMarket(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PerpetualFuturesGrossPositionOfMarket market.
       * @member {ununifi.derivatives.IMarket|null|undefined} market
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @instance
       */
      PerpetualFuturesGrossPositionOfMarket.prototype.market = null;

      /**
       * PerpetualFuturesGrossPositionOfMarket position_type.
       * @member {ununifi.derivatives.PositionType} position_type
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @instance
       */
      PerpetualFuturesGrossPositionOfMarket.prototype.position_type = 0;

      /**
       * PerpetualFuturesGrossPositionOfMarket position_size_in_denom_exponent.
       * @member {string} position_size_in_denom_exponent
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @instance
       */
      PerpetualFuturesGrossPositionOfMarket.prototype.position_size_in_denom_exponent = '';

      /**
       * Encodes the specified PerpetualFuturesGrossPositionOfMarket message. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket} message PerpetualFuturesGrossPositionOfMarket message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesGrossPositionOfMarket.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market != null && Object.hasOwnProperty.call(message, 'market'))
          $root.ununifi.derivatives.Market.encode(message.market, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.position_type != null && Object.hasOwnProperty.call(message, 'position_type'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.position_type);
        if (message.position_size_in_denom_exponent != null && Object.hasOwnProperty.call(message, 'position_size_in_denom_exponent'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.position_size_in_denom_exponent);
        return writer;
      };

      /**
       * Encodes the specified PerpetualFuturesGrossPositionOfMarket message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @static
       * @param {ununifi.derivatives.IPerpetualFuturesGrossPositionOfMarket} message PerpetualFuturesGrossPositionOfMarket message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualFuturesGrossPositionOfMarket.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PerpetualFuturesGrossPositionOfMarket message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} PerpetualFuturesGrossPositionOfMarket
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesGrossPositionOfMarket.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market = $root.ununifi.derivatives.Market.decode(reader, reader.uint32());
              break;
            case 2:
              message.position_type = reader.int32();
              break;
            case 3:
              message.position_size_in_denom_exponent = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PerpetualFuturesGrossPositionOfMarket message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} PerpetualFuturesGrossPositionOfMarket
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualFuturesGrossPositionOfMarket.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PerpetualFuturesGrossPositionOfMarket message.
       * @function verify
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PerpetualFuturesGrossPositionOfMarket.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market != null && message.hasOwnProperty('market')) {
          let error = $root.ununifi.derivatives.Market.verify(message.market);
          if (error) return 'market.' + error;
        }
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          switch (message.position_type) {
            default:
              return 'position_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.position_size_in_denom_exponent != null && message.hasOwnProperty('position_size_in_denom_exponent'))
          if (!$util.isString(message.position_size_in_denom_exponent)) return 'position_size_in_denom_exponent: string expected';
        return null;
      };

      /**
       * Creates a PerpetualFuturesGrossPositionOfMarket message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} PerpetualFuturesGrossPositionOfMarket
       */
      PerpetualFuturesGrossPositionOfMarket.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket) return object;
        let message = new $root.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket();
        if (object.market != null) {
          if (typeof object.market !== 'object')
            throw TypeError('.ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket.market: object expected');
          message.market = $root.ununifi.derivatives.Market.fromObject(object.market);
        }
        switch (object.position_type) {
          case 'POSITION_UNKNOWN':
          case 0:
            message.position_type = 0;
            break;
          case 'LONG':
          case 1:
            message.position_type = 1;
            break;
          case 'SHORT':
          case 2:
            message.position_type = 2;
            break;
        }
        if (object.position_size_in_denom_exponent != null)
          message.position_size_in_denom_exponent = String(object.position_size_in_denom_exponent);
        return message;
      };

      /**
       * Creates a plain object from a PerpetualFuturesGrossPositionOfMarket message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @static
       * @param {ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket} message PerpetualFuturesGrossPositionOfMarket
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PerpetualFuturesGrossPositionOfMarket.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market = null;
          object.position_type = options.enums === String ? 'POSITION_UNKNOWN' : 0;
          object.position_size_in_denom_exponent = '';
        }
        if (message.market != null && message.hasOwnProperty('market'))
          object.market = $root.ununifi.derivatives.Market.toObject(message.market, options);
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          object.position_type =
            options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
        if (message.position_size_in_denom_exponent != null && message.hasOwnProperty('position_size_in_denom_exponent'))
          object.position_size_in_denom_exponent = message.position_size_in_denom_exponent;
        return object;
      };

      /**
       * Converts this PerpetualFuturesGrossPositionOfMarket to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PerpetualFuturesGrossPositionOfMarket
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PerpetualFuturesGrossPositionOfMarket.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PerpetualFuturesGrossPositionOfMarket;
    })();

    derivatives.EventPerpetualFuturesPositionOpened = (function () {
      /**
       * Properties of an EventPerpetualFuturesPositionOpened.
       * @memberof ununifi.derivatives
       * @interface IEventPerpetualFuturesPositionOpened
       * @property {string|null} [sender] EventPerpetualFuturesPositionOpened sender
       * @property {string|null} [position_id] EventPerpetualFuturesPositionOpened position_id
       */

      /**
       * Constructs a new EventPerpetualFuturesPositionOpened.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPerpetualFuturesPositionOpened.
       * @implements IEventPerpetualFuturesPositionOpened
       * @constructor
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionOpened=} [properties] Properties to set
       */
      function EventPerpetualFuturesPositionOpened(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPerpetualFuturesPositionOpened sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @instance
       */
      EventPerpetualFuturesPositionOpened.prototype.sender = '';

      /**
       * EventPerpetualFuturesPositionOpened position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @instance
       */
      EventPerpetualFuturesPositionOpened.prototype.position_id = '';

      /**
       * Encodes the specified EventPerpetualFuturesPositionOpened message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionOpened.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionOpened} message EventPerpetualFuturesPositionOpened message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionOpened.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified EventPerpetualFuturesPositionOpened message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionOpened.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionOpened} message EventPerpetualFuturesPositionOpened message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionOpened.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPerpetualFuturesPositionOpened message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionOpened} EventPerpetualFuturesPositionOpened
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionOpened.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionOpened();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPerpetualFuturesPositionOpened message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionOpened} EventPerpetualFuturesPositionOpened
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionOpened.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPerpetualFuturesPositionOpened message.
       * @function verify
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPerpetualFuturesPositionOpened.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates an EventPerpetualFuturesPositionOpened message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionOpened} EventPerpetualFuturesPositionOpened
       */
      EventPerpetualFuturesPositionOpened.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionOpened) return object;
        let message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionOpened();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from an EventPerpetualFuturesPositionOpened message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @static
       * @param {ununifi.derivatives.EventPerpetualFuturesPositionOpened} message EventPerpetualFuturesPositionOpened
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPerpetualFuturesPositionOpened.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.position_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this EventPerpetualFuturesPositionOpened to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionOpened
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPerpetualFuturesPositionOpened.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPerpetualFuturesPositionOpened;
    })();

    derivatives.EventPerpetualFuturesPositionClosed = (function () {
      /**
       * Properties of an EventPerpetualFuturesPositionClosed.
       * @memberof ununifi.derivatives
       * @interface IEventPerpetualFuturesPositionClosed
       * @property {string|null} [sender] EventPerpetualFuturesPositionClosed sender
       * @property {string|null} [position_id] EventPerpetualFuturesPositionClosed position_id
       * @property {string|null} [position_size] EventPerpetualFuturesPositionClosed position_size
       * @property {string|null} [pnl_amount] EventPerpetualFuturesPositionClosed pnl_amount
       * @property {string|null} [returning_amount] EventPerpetualFuturesPositionClosed returning_amount
       */

      /**
       * Constructs a new EventPerpetualFuturesPositionClosed.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPerpetualFuturesPositionClosed.
       * @implements IEventPerpetualFuturesPositionClosed
       * @constructor
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionClosed=} [properties] Properties to set
       */
      function EventPerpetualFuturesPositionClosed(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPerpetualFuturesPositionClosed sender.
       * @member {string} sender
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @instance
       */
      EventPerpetualFuturesPositionClosed.prototype.sender = '';

      /**
       * EventPerpetualFuturesPositionClosed position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @instance
       */
      EventPerpetualFuturesPositionClosed.prototype.position_id = '';

      /**
       * EventPerpetualFuturesPositionClosed position_size.
       * @member {string} position_size
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @instance
       */
      EventPerpetualFuturesPositionClosed.prototype.position_size = '';

      /**
       * EventPerpetualFuturesPositionClosed pnl_amount.
       * @member {string} pnl_amount
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @instance
       */
      EventPerpetualFuturesPositionClosed.prototype.pnl_amount = '';

      /**
       * EventPerpetualFuturesPositionClosed returning_amount.
       * @member {string} returning_amount
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @instance
       */
      EventPerpetualFuturesPositionClosed.prototype.returning_amount = '';

      /**
       * Encodes the specified EventPerpetualFuturesPositionClosed message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionClosed.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionClosed} message EventPerpetualFuturesPositionClosed message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionClosed.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        if (message.position_size != null && Object.hasOwnProperty.call(message, 'position_size'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.position_size);
        if (message.pnl_amount != null && Object.hasOwnProperty.call(message, 'pnl_amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.pnl_amount);
        if (message.returning_amount != null && Object.hasOwnProperty.call(message, 'returning_amount'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.returning_amount);
        return writer;
      };

      /**
       * Encodes the specified EventPerpetualFuturesPositionClosed message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionClosed.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionClosed} message EventPerpetualFuturesPositionClosed message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionClosed.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPerpetualFuturesPositionClosed message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionClosed} EventPerpetualFuturesPositionClosed
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionClosed.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionClosed();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            case 3:
              message.position_size = reader.string();
              break;
            case 4:
              message.pnl_amount = reader.string();
              break;
            case 5:
              message.returning_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPerpetualFuturesPositionClosed message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionClosed} EventPerpetualFuturesPositionClosed
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionClosed.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPerpetualFuturesPositionClosed message.
       * @function verify
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPerpetualFuturesPositionClosed.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        if (message.position_size != null && message.hasOwnProperty('position_size'))
          if (!$util.isString(message.position_size)) return 'position_size: string expected';
        if (message.pnl_amount != null && message.hasOwnProperty('pnl_amount'))
          if (!$util.isString(message.pnl_amount)) return 'pnl_amount: string expected';
        if (message.returning_amount != null && message.hasOwnProperty('returning_amount'))
          if (!$util.isString(message.returning_amount)) return 'returning_amount: string expected';
        return null;
      };

      /**
       * Creates an EventPerpetualFuturesPositionClosed message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionClosed} EventPerpetualFuturesPositionClosed
       */
      EventPerpetualFuturesPositionClosed.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionClosed) return object;
        let message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionClosed();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.position_id != null) message.position_id = String(object.position_id);
        if (object.position_size != null) message.position_size = String(object.position_size);
        if (object.pnl_amount != null) message.pnl_amount = String(object.pnl_amount);
        if (object.returning_amount != null) message.returning_amount = String(object.returning_amount);
        return message;
      };

      /**
       * Creates a plain object from an EventPerpetualFuturesPositionClosed message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @static
       * @param {ununifi.derivatives.EventPerpetualFuturesPositionClosed} message EventPerpetualFuturesPositionClosed
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPerpetualFuturesPositionClosed.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.position_id = '';
          object.position_size = '';
          object.pnl_amount = '';
          object.returning_amount = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        if (message.position_size != null && message.hasOwnProperty('position_size')) object.position_size = message.position_size;
        if (message.pnl_amount != null && message.hasOwnProperty('pnl_amount')) object.pnl_amount = message.pnl_amount;
        if (message.returning_amount != null && message.hasOwnProperty('returning_amount'))
          object.returning_amount = message.returning_amount;
        return object;
      };

      /**
       * Converts this EventPerpetualFuturesPositionClosed to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionClosed
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPerpetualFuturesPositionClosed.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPerpetualFuturesPositionClosed;
    })();

    derivatives.EventPerpetualFuturesPositionLiquidated = (function () {
      /**
       * Properties of an EventPerpetualFuturesPositionLiquidated.
       * @memberof ununifi.derivatives
       * @interface IEventPerpetualFuturesPositionLiquidated
       * @property {string|null} [reward_recipient] EventPerpetualFuturesPositionLiquidated reward_recipient
       * @property {string|null} [position_id] EventPerpetualFuturesPositionLiquidated position_id
       * @property {string|null} [remaining_margin] EventPerpetualFuturesPositionLiquidated remaining_margin
       * @property {string|null} [reward_amount] EventPerpetualFuturesPositionLiquidated reward_amount
       * @property {string|null} [levied_amount] EventPerpetualFuturesPositionLiquidated levied_amount
       */

      /**
       * Constructs a new EventPerpetualFuturesPositionLiquidated.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPerpetualFuturesPositionLiquidated.
       * @implements IEventPerpetualFuturesPositionLiquidated
       * @constructor
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLiquidated=} [properties] Properties to set
       */
      function EventPerpetualFuturesPositionLiquidated(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPerpetualFuturesPositionLiquidated reward_recipient.
       * @member {string} reward_recipient
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @instance
       */
      EventPerpetualFuturesPositionLiquidated.prototype.reward_recipient = '';

      /**
       * EventPerpetualFuturesPositionLiquidated position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @instance
       */
      EventPerpetualFuturesPositionLiquidated.prototype.position_id = '';

      /**
       * EventPerpetualFuturesPositionLiquidated remaining_margin.
       * @member {string} remaining_margin
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @instance
       */
      EventPerpetualFuturesPositionLiquidated.prototype.remaining_margin = '';

      /**
       * EventPerpetualFuturesPositionLiquidated reward_amount.
       * @member {string} reward_amount
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @instance
       */
      EventPerpetualFuturesPositionLiquidated.prototype.reward_amount = '';

      /**
       * EventPerpetualFuturesPositionLiquidated levied_amount.
       * @member {string} levied_amount
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @instance
       */
      EventPerpetualFuturesPositionLiquidated.prototype.levied_amount = '';

      /**
       * Encodes the specified EventPerpetualFuturesPositionLiquidated message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLiquidated.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLiquidated} message EventPerpetualFuturesPositionLiquidated message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionLiquidated.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.reward_recipient != null && Object.hasOwnProperty.call(message, 'reward_recipient'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.reward_recipient);
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        if (message.remaining_margin != null && Object.hasOwnProperty.call(message, 'remaining_margin'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.remaining_margin);
        if (message.reward_amount != null && Object.hasOwnProperty.call(message, 'reward_amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.reward_amount);
        if (message.levied_amount != null && Object.hasOwnProperty.call(message, 'levied_amount'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.levied_amount);
        return writer;
      };

      /**
       * Encodes the specified EventPerpetualFuturesPositionLiquidated message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLiquidated.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLiquidated} message EventPerpetualFuturesPositionLiquidated message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionLiquidated.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPerpetualFuturesPositionLiquidated message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} EventPerpetualFuturesPositionLiquidated
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionLiquidated.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLiquidated();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.reward_recipient = reader.string();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            case 3:
              message.remaining_margin = reader.string();
              break;
            case 4:
              message.reward_amount = reader.string();
              break;
            case 5:
              message.levied_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPerpetualFuturesPositionLiquidated message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} EventPerpetualFuturesPositionLiquidated
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionLiquidated.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPerpetualFuturesPositionLiquidated message.
       * @function verify
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPerpetualFuturesPositionLiquidated.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          if (!$util.isString(message.reward_recipient)) return 'reward_recipient: string expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin'))
          if (!$util.isString(message.remaining_margin)) return 'remaining_margin: string expected';
        if (message.reward_amount != null && message.hasOwnProperty('reward_amount'))
          if (!$util.isString(message.reward_amount)) return 'reward_amount: string expected';
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount'))
          if (!$util.isString(message.levied_amount)) return 'levied_amount: string expected';
        return null;
      };

      /**
       * Creates an EventPerpetualFuturesPositionLiquidated message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} EventPerpetualFuturesPositionLiquidated
       */
      EventPerpetualFuturesPositionLiquidated.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionLiquidated) return object;
        let message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLiquidated();
        if (object.reward_recipient != null) message.reward_recipient = String(object.reward_recipient);
        if (object.position_id != null) message.position_id = String(object.position_id);
        if (object.remaining_margin != null) message.remaining_margin = String(object.remaining_margin);
        if (object.reward_amount != null) message.reward_amount = String(object.reward_amount);
        if (object.levied_amount != null) message.levied_amount = String(object.levied_amount);
        return message;
      };

      /**
       * Creates a plain object from an EventPerpetualFuturesPositionLiquidated message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @static
       * @param {ununifi.derivatives.EventPerpetualFuturesPositionLiquidated} message EventPerpetualFuturesPositionLiquidated
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPerpetualFuturesPositionLiquidated.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.reward_recipient = '';
          object.position_id = '';
          object.remaining_margin = '';
          object.reward_amount = '';
          object.levied_amount = '';
        }
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          object.reward_recipient = message.reward_recipient;
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin'))
          object.remaining_margin = message.remaining_margin;
        if (message.reward_amount != null && message.hasOwnProperty('reward_amount')) object.reward_amount = message.reward_amount;
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount')) object.levied_amount = message.levied_amount;
        return object;
      };

      /**
       * Converts this EventPerpetualFuturesPositionLiquidated to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLiquidated
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPerpetualFuturesPositionLiquidated.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPerpetualFuturesPositionLiquidated;
    })();

    derivatives.EventPerpetualFuturesPositionLevied = (function () {
      /**
       * Properties of an EventPerpetualFuturesPositionLevied.
       * @memberof ununifi.derivatives
       * @interface IEventPerpetualFuturesPositionLevied
       * @property {string|null} [reward_recipient] EventPerpetualFuturesPositionLevied reward_recipient
       * @property {string|null} [position_id] EventPerpetualFuturesPositionLevied position_id
       * @property {string|null} [remaining_margin] EventPerpetualFuturesPositionLevied remaining_margin
       * @property {string|null} [reward_amount] EventPerpetualFuturesPositionLevied reward_amount
       * @property {string|null} [levied_amount] EventPerpetualFuturesPositionLevied levied_amount
       */

      /**
       * Constructs a new EventPerpetualFuturesPositionLevied.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventPerpetualFuturesPositionLevied.
       * @implements IEventPerpetualFuturesPositionLevied
       * @constructor
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLevied=} [properties] Properties to set
       */
      function EventPerpetualFuturesPositionLevied(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPerpetualFuturesPositionLevied reward_recipient.
       * @member {string} reward_recipient
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @instance
       */
      EventPerpetualFuturesPositionLevied.prototype.reward_recipient = '';

      /**
       * EventPerpetualFuturesPositionLevied position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @instance
       */
      EventPerpetualFuturesPositionLevied.prototype.position_id = '';

      /**
       * EventPerpetualFuturesPositionLevied remaining_margin.
       * @member {string} remaining_margin
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @instance
       */
      EventPerpetualFuturesPositionLevied.prototype.remaining_margin = '';

      /**
       * EventPerpetualFuturesPositionLevied reward_amount.
       * @member {string} reward_amount
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @instance
       */
      EventPerpetualFuturesPositionLevied.prototype.reward_amount = '';

      /**
       * EventPerpetualFuturesPositionLevied levied_amount.
       * @member {string} levied_amount
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @instance
       */
      EventPerpetualFuturesPositionLevied.prototype.levied_amount = '';

      /**
       * Encodes the specified EventPerpetualFuturesPositionLevied message. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLevied.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLevied} message EventPerpetualFuturesPositionLevied message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionLevied.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.reward_recipient != null && Object.hasOwnProperty.call(message, 'reward_recipient'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.reward_recipient);
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.position_id);
        if (message.remaining_margin != null && Object.hasOwnProperty.call(message, 'remaining_margin'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.remaining_margin);
        if (message.reward_amount != null && Object.hasOwnProperty.call(message, 'reward_amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.reward_amount);
        if (message.levied_amount != null && Object.hasOwnProperty.call(message, 'levied_amount'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.levied_amount);
        return writer;
      };

      /**
       * Encodes the specified EventPerpetualFuturesPositionLevied message, length delimited. Does not implicitly {@link ununifi.derivatives.EventPerpetualFuturesPositionLevied.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @static
       * @param {ununifi.derivatives.IEventPerpetualFuturesPositionLevied} message EventPerpetualFuturesPositionLevied message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPerpetualFuturesPositionLevied.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPerpetualFuturesPositionLevied message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLevied} EventPerpetualFuturesPositionLevied
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionLevied.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLevied();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.reward_recipient = reader.string();
              break;
            case 2:
              message.position_id = reader.string();
              break;
            case 3:
              message.remaining_margin = reader.string();
              break;
            case 4:
              message.reward_amount = reader.string();
              break;
            case 5:
              message.levied_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPerpetualFuturesPositionLevied message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLevied} EventPerpetualFuturesPositionLevied
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPerpetualFuturesPositionLevied.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPerpetualFuturesPositionLevied message.
       * @function verify
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPerpetualFuturesPositionLevied.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          if (!$util.isString(message.reward_recipient)) return 'reward_recipient: string expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin'))
          if (!$util.isString(message.remaining_margin)) return 'remaining_margin: string expected';
        if (message.reward_amount != null && message.hasOwnProperty('reward_amount'))
          if (!$util.isString(message.reward_amount)) return 'reward_amount: string expected';
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount'))
          if (!$util.isString(message.levied_amount)) return 'levied_amount: string expected';
        return null;
      };

      /**
       * Creates an EventPerpetualFuturesPositionLevied message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventPerpetualFuturesPositionLevied} EventPerpetualFuturesPositionLevied
       */
      EventPerpetualFuturesPositionLevied.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventPerpetualFuturesPositionLevied) return object;
        let message = new $root.ununifi.derivatives.EventPerpetualFuturesPositionLevied();
        if (object.reward_recipient != null) message.reward_recipient = String(object.reward_recipient);
        if (object.position_id != null) message.position_id = String(object.position_id);
        if (object.remaining_margin != null) message.remaining_margin = String(object.remaining_margin);
        if (object.reward_amount != null) message.reward_amount = String(object.reward_amount);
        if (object.levied_amount != null) message.levied_amount = String(object.levied_amount);
        return message;
      };

      /**
       * Creates a plain object from an EventPerpetualFuturesPositionLevied message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @static
       * @param {ununifi.derivatives.EventPerpetualFuturesPositionLevied} message EventPerpetualFuturesPositionLevied
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPerpetualFuturesPositionLevied.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.reward_recipient = '';
          object.position_id = '';
          object.remaining_margin = '';
          object.reward_amount = '';
          object.levied_amount = '';
        }
        if (message.reward_recipient != null && message.hasOwnProperty('reward_recipient'))
          object.reward_recipient = message.reward_recipient;
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        if (message.remaining_margin != null && message.hasOwnProperty('remaining_margin'))
          object.remaining_margin = message.remaining_margin;
        if (message.reward_amount != null && message.hasOwnProperty('reward_amount')) object.reward_amount = message.reward_amount;
        if (message.levied_amount != null && message.hasOwnProperty('levied_amount')) object.levied_amount = message.levied_amount;
        return object;
      };

      /**
       * Converts this EventPerpetualFuturesPositionLevied to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventPerpetualFuturesPositionLevied
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPerpetualFuturesPositionLevied.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPerpetualFuturesPositionLevied;
    })();

    derivatives.EventLossToLP = (function () {
      /**
       * Properties of an EventLossToLP.
       * @memberof ununifi.derivatives
       * @interface IEventLossToLP
       * @property {string|null} [position_id] EventLossToLP position_id
       * @property {string|null} [loss_amount] EventLossToLP loss_amount
       */

      /**
       * Constructs a new EventLossToLP.
       * @memberof ununifi.derivatives
       * @classdesc Represents an EventLossToLP.
       * @implements IEventLossToLP
       * @constructor
       * @param {ununifi.derivatives.IEventLossToLP=} [properties] Properties to set
       */
      function EventLossToLP(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventLossToLP position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.EventLossToLP
       * @instance
       */
      EventLossToLP.prototype.position_id = '';

      /**
       * EventLossToLP loss_amount.
       * @member {string} loss_amount
       * @memberof ununifi.derivatives.EventLossToLP
       * @instance
       */
      EventLossToLP.prototype.loss_amount = '';

      /**
       * Encodes the specified EventLossToLP message. Does not implicitly {@link ununifi.derivatives.EventLossToLP.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.EventLossToLP
       * @static
       * @param {ununifi.derivatives.IEventLossToLP} message EventLossToLP message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLossToLP.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.position_id);
        if (message.loss_amount != null && Object.hasOwnProperty.call(message, 'loss_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.loss_amount);
        return writer;
      };

      /**
       * Encodes the specified EventLossToLP message, length delimited. Does not implicitly {@link ununifi.derivatives.EventLossToLP.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.EventLossToLP
       * @static
       * @param {ununifi.derivatives.IEventLossToLP} message EventLossToLP message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLossToLP.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventLossToLP message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.EventLossToLP
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.EventLossToLP} EventLossToLP
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLossToLP.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.EventLossToLP();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position_id = reader.string();
              break;
            case 2:
              message.loss_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventLossToLP message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.EventLossToLP
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.EventLossToLP} EventLossToLP
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLossToLP.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventLossToLP message.
       * @function verify
       * @memberof ununifi.derivatives.EventLossToLP
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventLossToLP.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        if (message.loss_amount != null && message.hasOwnProperty('loss_amount'))
          if (!$util.isString(message.loss_amount)) return 'loss_amount: string expected';
        return null;
      };

      /**
       * Creates an EventLossToLP message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.EventLossToLP
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.EventLossToLP} EventLossToLP
       */
      EventLossToLP.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.EventLossToLP) return object;
        let message = new $root.ununifi.derivatives.EventLossToLP();
        if (object.position_id != null) message.position_id = String(object.position_id);
        if (object.loss_amount != null) message.loss_amount = String(object.loss_amount);
        return message;
      };

      /**
       * Creates a plain object from an EventLossToLP message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.EventLossToLP
       * @static
       * @param {ununifi.derivatives.EventLossToLP} message EventLossToLP
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventLossToLP.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.position_id = '';
          object.loss_amount = '';
        }
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        if (message.loss_amount != null && message.hasOwnProperty('loss_amount')) object.loss_amount = message.loss_amount;
        return object;
      };

      /**
       * Converts this EventLossToLP to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.EventLossToLP
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventLossToLP.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventLossToLP;
    })();

    derivatives.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.derivatives
       * @interface IParams
       * @property {ununifi.derivatives.IPoolParams|null} [pool_params] Params pool_params
       * @property {ununifi.derivatives.IPerpetualFuturesParams|null} [perpetual_futures] Params perpetual_futures
       * @property {ununifi.derivatives.IPerpetualOptionsParams|null} [perpetual_options] Params perpetual_options
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.derivatives
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.derivatives.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params pool_params.
       * @member {ununifi.derivatives.IPoolParams|null|undefined} pool_params
       * @memberof ununifi.derivatives.Params
       * @instance
       */
      Params.prototype.pool_params = null;

      /**
       * Params perpetual_futures.
       * @member {ununifi.derivatives.IPerpetualFuturesParams|null|undefined} perpetual_futures
       * @memberof ununifi.derivatives.Params
       * @instance
       */
      Params.prototype.perpetual_futures = null;

      /**
       * Params perpetual_options.
       * @member {ununifi.derivatives.IPerpetualOptionsParams|null|undefined} perpetual_options
       * @memberof ununifi.derivatives.Params
       * @instance
       */
      Params.prototype.perpetual_options = null;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.derivatives.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.Params
       * @static
       * @param {ununifi.derivatives.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_params != null && Object.hasOwnProperty.call(message, 'pool_params'))
          $root.ununifi.derivatives.PoolParams.encode(message.pool_params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.perpetual_futures != null && Object.hasOwnProperty.call(message, 'perpetual_futures'))
          $root.ununifi.derivatives.PerpetualFuturesParams.encode(
            message.perpetual_futures,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        if (message.perpetual_options != null && Object.hasOwnProperty.call(message, 'perpetual_options'))
          $root.ununifi.derivatives.PerpetualOptionsParams.encode(
            message.perpetual_options,
            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.derivatives.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.Params
       * @static
       * @param {ununifi.derivatives.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_params = $root.ununifi.derivatives.PoolParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.perpetual_futures = $root.ununifi.derivatives.PerpetualFuturesParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.perpetual_options = $root.ununifi.derivatives.PerpetualOptionsParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.derivatives.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_params != null && message.hasOwnProperty('pool_params')) {
          let error = $root.ununifi.derivatives.PoolParams.verify(message.pool_params);
          if (error) return 'pool_params.' + error;
        }
        if (message.perpetual_futures != null && message.hasOwnProperty('perpetual_futures')) {
          let error = $root.ununifi.derivatives.PerpetualFuturesParams.verify(message.perpetual_futures);
          if (error) return 'perpetual_futures.' + error;
        }
        if (message.perpetual_options != null && message.hasOwnProperty('perpetual_options')) {
          let error = $root.ununifi.derivatives.PerpetualOptionsParams.verify(message.perpetual_options);
          if (error) return 'perpetual_options.' + error;
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.Params) return object;
        let message = new $root.ununifi.derivatives.Params();
        if (object.pool_params != null) {
          if (typeof object.pool_params !== 'object') throw TypeError('.ununifi.derivatives.Params.pool_params: object expected');
          message.pool_params = $root.ununifi.derivatives.PoolParams.fromObject(object.pool_params);
        }
        if (object.perpetual_futures != null) {
          if (typeof object.perpetual_futures !== 'object')
            throw TypeError('.ununifi.derivatives.Params.perpetual_futures: object expected');
          message.perpetual_futures = $root.ununifi.derivatives.PerpetualFuturesParams.fromObject(object.perpetual_futures);
        }
        if (object.perpetual_options != null) {
          if (typeof object.perpetual_options !== 'object')
            throw TypeError('.ununifi.derivatives.Params.perpetual_options: object expected');
          message.perpetual_options = $root.ununifi.derivatives.PerpetualOptionsParams.fromObject(object.perpetual_options);
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.Params
       * @static
       * @param {ununifi.derivatives.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.pool_params = null;
          object.perpetual_futures = null;
          object.perpetual_options = null;
        }
        if (message.pool_params != null && message.hasOwnProperty('pool_params'))
          object.pool_params = $root.ununifi.derivatives.PoolParams.toObject(message.pool_params, options);
        if (message.perpetual_futures != null && message.hasOwnProperty('perpetual_futures'))
          object.perpetual_futures = $root.ununifi.derivatives.PerpetualFuturesParams.toObject(message.perpetual_futures, options);
        if (message.perpetual_options != null && message.hasOwnProperty('perpetual_options'))
          object.perpetual_options = $root.ununifi.derivatives.PerpetualOptionsParams.toObject(message.perpetual_options, options);
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    derivatives.PerpetualOptionsParams = (function () {
      /**
       * Properties of a PerpetualOptionsParams.
       * @memberof ununifi.derivatives
       * @interface IPerpetualOptionsParams
       * @property {string|null} [premium_commission_rate] PerpetualOptionsParams premium_commission_rate
       * @property {string|null} [strike_commission_rate] PerpetualOptionsParams strike_commission_rate
       * @property {string|null} [margin_maintenance_rate] PerpetualOptionsParams margin_maintenance_rate
       * @property {string|null} [imaginary_funding_rate_proportional_coefficient] PerpetualOptionsParams imaginary_funding_rate_proportional_coefficient
       * @property {Array.<ununifi.derivatives.IMarket>|null} [markets] PerpetualOptionsParams markets
       */

      /**
       * Constructs a new PerpetualOptionsParams.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PerpetualOptionsParams.
       * @implements IPerpetualOptionsParams
       * @constructor
       * @param {ununifi.derivatives.IPerpetualOptionsParams=} [properties] Properties to set
       */
      function PerpetualOptionsParams(properties) {
        this.markets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PerpetualOptionsParams premium_commission_rate.
       * @member {string} premium_commission_rate
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @instance
       */
      PerpetualOptionsParams.prototype.premium_commission_rate = '';

      /**
       * PerpetualOptionsParams strike_commission_rate.
       * @member {string} strike_commission_rate
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @instance
       */
      PerpetualOptionsParams.prototype.strike_commission_rate = '';

      /**
       * PerpetualOptionsParams margin_maintenance_rate.
       * @member {string} margin_maintenance_rate
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @instance
       */
      PerpetualOptionsParams.prototype.margin_maintenance_rate = '';

      /**
       * PerpetualOptionsParams imaginary_funding_rate_proportional_coefficient.
       * @member {string} imaginary_funding_rate_proportional_coefficient
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @instance
       */
      PerpetualOptionsParams.prototype.imaginary_funding_rate_proportional_coefficient = '';

      /**
       * PerpetualOptionsParams markets.
       * @member {Array.<ununifi.derivatives.IMarket>} markets
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @instance
       */
      PerpetualOptionsParams.prototype.markets = $util.emptyArray;

      /**
       * Encodes the specified PerpetualOptionsParams message. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @static
       * @param {ununifi.derivatives.IPerpetualOptionsParams} message PerpetualOptionsParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualOptionsParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.premium_commission_rate != null && Object.hasOwnProperty.call(message, 'premium_commission_rate'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.premium_commission_rate);
        if (message.strike_commission_rate != null && Object.hasOwnProperty.call(message, 'strike_commission_rate'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.strike_commission_rate);
        if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, 'margin_maintenance_rate'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.margin_maintenance_rate);
        if (
          message.imaginary_funding_rate_proportional_coefficient != null &&
          Object.hasOwnProperty.call(message, 'imaginary_funding_rate_proportional_coefficient')
        )
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.imaginary_funding_rate_proportional_coefficient);
        if (message.markets != null && message.markets.length)
          for (let i = 0; i < message.markets.length; ++i)
            $root.ununifi.derivatives.Market.encode(message.markets[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified PerpetualOptionsParams message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @static
       * @param {ununifi.derivatives.IPerpetualOptionsParams} message PerpetualOptionsParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualOptionsParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PerpetualOptionsParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PerpetualOptionsParams} PerpetualOptionsParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualOptionsParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PerpetualOptionsParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.premium_commission_rate = reader.string();
              break;
            case 2:
              message.strike_commission_rate = reader.string();
              break;
            case 3:
              message.margin_maintenance_rate = reader.string();
              break;
            case 4:
              message.imaginary_funding_rate_proportional_coefficient = reader.string();
              break;
            case 5:
              if (!(message.markets && message.markets.length)) message.markets = [];
              message.markets.push($root.ununifi.derivatives.Market.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PerpetualOptionsParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PerpetualOptionsParams} PerpetualOptionsParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualOptionsParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PerpetualOptionsParams message.
       * @function verify
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PerpetualOptionsParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.premium_commission_rate != null && message.hasOwnProperty('premium_commission_rate'))
          if (!$util.isString(message.premium_commission_rate)) return 'premium_commission_rate: string expected';
        if (message.strike_commission_rate != null && message.hasOwnProperty('strike_commission_rate'))
          if (!$util.isString(message.strike_commission_rate)) return 'strike_commission_rate: string expected';
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          if (!$util.isString(message.margin_maintenance_rate)) return 'margin_maintenance_rate: string expected';
        if (
          message.imaginary_funding_rate_proportional_coefficient != null &&
          message.hasOwnProperty('imaginary_funding_rate_proportional_coefficient')
        )
          if (!$util.isString(message.imaginary_funding_rate_proportional_coefficient))
            return 'imaginary_funding_rate_proportional_coefficient: string expected';
        if (message.markets != null && message.hasOwnProperty('markets')) {
          if (!Array.isArray(message.markets)) return 'markets: array expected';
          for (let i = 0; i < message.markets.length; ++i) {
            let error = $root.ununifi.derivatives.Market.verify(message.markets[i]);
            if (error) return 'markets.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a PerpetualOptionsParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PerpetualOptionsParams} PerpetualOptionsParams
       */
      PerpetualOptionsParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PerpetualOptionsParams) return object;
        let message = new $root.ununifi.derivatives.PerpetualOptionsParams();
        if (object.premium_commission_rate != null) message.premium_commission_rate = String(object.premium_commission_rate);
        if (object.strike_commission_rate != null) message.strike_commission_rate = String(object.strike_commission_rate);
        if (object.margin_maintenance_rate != null) message.margin_maintenance_rate = String(object.margin_maintenance_rate);
        if (object.imaginary_funding_rate_proportional_coefficient != null)
          message.imaginary_funding_rate_proportional_coefficient = String(object.imaginary_funding_rate_proportional_coefficient);
        if (object.markets) {
          if (!Array.isArray(object.markets)) throw TypeError('.ununifi.derivatives.PerpetualOptionsParams.markets: array expected');
          message.markets = [];
          for (let i = 0; i < object.markets.length; ++i) {
            if (typeof object.markets[i] !== 'object')
              throw TypeError('.ununifi.derivatives.PerpetualOptionsParams.markets: object expected');
            message.markets[i] = $root.ununifi.derivatives.Market.fromObject(object.markets[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a PerpetualOptionsParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @static
       * @param {ununifi.derivatives.PerpetualOptionsParams} message PerpetualOptionsParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PerpetualOptionsParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.markets = [];
        if (options.defaults) {
          object.premium_commission_rate = '';
          object.strike_commission_rate = '';
          object.margin_maintenance_rate = '';
          object.imaginary_funding_rate_proportional_coefficient = '';
        }
        if (message.premium_commission_rate != null && message.hasOwnProperty('premium_commission_rate'))
          object.premium_commission_rate = message.premium_commission_rate;
        if (message.strike_commission_rate != null && message.hasOwnProperty('strike_commission_rate'))
          object.strike_commission_rate = message.strike_commission_rate;
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          object.margin_maintenance_rate = message.margin_maintenance_rate;
        if (
          message.imaginary_funding_rate_proportional_coefficient != null &&
          message.hasOwnProperty('imaginary_funding_rate_proportional_coefficient')
        )
          object.imaginary_funding_rate_proportional_coefficient = message.imaginary_funding_rate_proportional_coefficient;
        if (message.markets && message.markets.length) {
          object.markets = [];
          for (let j = 0; j < message.markets.length; ++j)
            object.markets[j] = $root.ununifi.derivatives.Market.toObject(message.markets[j], options);
        }
        return object;
      };

      /**
       * Converts this PerpetualOptionsParams to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PerpetualOptionsParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PerpetualOptionsParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PerpetualOptionsParams;
    })();

    /**
     * OptionType enum.
     * @name ununifi.derivatives.OptionType
     * @enum {number}
     * @property {number} OPTION_UNKNOWN=0 OPTION_UNKNOWN value
     * @property {number} CALL=1 CALL value
     * @property {number} PUT=2 PUT value
     */
    derivatives.OptionType = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'OPTION_UNKNOWN')] = 0;
      values[(valuesById[1] = 'CALL')] = 1;
      values[(valuesById[2] = 'PUT')] = 2;
      return values;
    })();

    derivatives.PerpetualOptionsPositionInstance = (function () {
      /**
       * Properties of a PerpetualOptionsPositionInstance.
       * @memberof ununifi.derivatives
       * @interface IPerpetualOptionsPositionInstance
       * @property {ununifi.derivatives.OptionType|null} [option_type] PerpetualOptionsPositionInstance option_type
       * @property {ununifi.derivatives.PositionType|null} [position_type] PerpetualOptionsPositionInstance position_type
       * @property {string|null} [strike_price] PerpetualOptionsPositionInstance strike_price
       * @property {string|null} [premium] PerpetualOptionsPositionInstance premium
       */

      /**
       * Constructs a new PerpetualOptionsPositionInstance.
       * @memberof ununifi.derivatives
       * @classdesc Represents a PerpetualOptionsPositionInstance.
       * @implements IPerpetualOptionsPositionInstance
       * @constructor
       * @param {ununifi.derivatives.IPerpetualOptionsPositionInstance=} [properties] Properties to set
       */
      function PerpetualOptionsPositionInstance(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PerpetualOptionsPositionInstance option_type.
       * @member {ununifi.derivatives.OptionType} option_type
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @instance
       */
      PerpetualOptionsPositionInstance.prototype.option_type = 0;

      /**
       * PerpetualOptionsPositionInstance position_type.
       * @member {ununifi.derivatives.PositionType} position_type
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @instance
       */
      PerpetualOptionsPositionInstance.prototype.position_type = 0;

      /**
       * PerpetualOptionsPositionInstance strike_price.
       * @member {string} strike_price
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @instance
       */
      PerpetualOptionsPositionInstance.prototype.strike_price = '';

      /**
       * PerpetualOptionsPositionInstance premium.
       * @member {string} premium
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @instance
       */
      PerpetualOptionsPositionInstance.prototype.premium = '';

      /**
       * Encodes the specified PerpetualOptionsPositionInstance message. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsPositionInstance.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @static
       * @param {ununifi.derivatives.IPerpetualOptionsPositionInstance} message PerpetualOptionsPositionInstance message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualOptionsPositionInstance.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.option_type != null && Object.hasOwnProperty.call(message, 'option_type'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.option_type);
        if (message.position_type != null && Object.hasOwnProperty.call(message, 'position_type'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.position_type);
        if (message.strike_price != null && Object.hasOwnProperty.call(message, 'strike_price'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.strike_price);
        if (message.premium != null && Object.hasOwnProperty.call(message, 'premium'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.premium);
        return writer;
      };

      /**
       * Encodes the specified PerpetualOptionsPositionInstance message, length delimited. Does not implicitly {@link ununifi.derivatives.PerpetualOptionsPositionInstance.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @static
       * @param {ununifi.derivatives.IPerpetualOptionsPositionInstance} message PerpetualOptionsPositionInstance message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PerpetualOptionsPositionInstance.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PerpetualOptionsPositionInstance message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.PerpetualOptionsPositionInstance} PerpetualOptionsPositionInstance
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualOptionsPositionInstance.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.PerpetualOptionsPositionInstance();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option_type = reader.int32();
              break;
            case 2:
              message.position_type = reader.int32();
              break;
            case 3:
              message.strike_price = reader.string();
              break;
            case 4:
              message.premium = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PerpetualOptionsPositionInstance message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.PerpetualOptionsPositionInstance} PerpetualOptionsPositionInstance
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PerpetualOptionsPositionInstance.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PerpetualOptionsPositionInstance message.
       * @function verify
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PerpetualOptionsPositionInstance.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.option_type != null && message.hasOwnProperty('option_type'))
          switch (message.option_type) {
            default:
              return 'option_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          switch (message.position_type) {
            default:
              return 'position_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.strike_price != null && message.hasOwnProperty('strike_price'))
          if (!$util.isString(message.strike_price)) return 'strike_price: string expected';
        if (message.premium != null && message.hasOwnProperty('premium'))
          if (!$util.isString(message.premium)) return 'premium: string expected';
        return null;
      };

      /**
       * Creates a PerpetualOptionsPositionInstance message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.PerpetualOptionsPositionInstance} PerpetualOptionsPositionInstance
       */
      PerpetualOptionsPositionInstance.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.PerpetualOptionsPositionInstance) return object;
        let message = new $root.ununifi.derivatives.PerpetualOptionsPositionInstance();
        switch (object.option_type) {
          case 'OPTION_UNKNOWN':
          case 0:
            message.option_type = 0;
            break;
          case 'CALL':
          case 1:
            message.option_type = 1;
            break;
          case 'PUT':
          case 2:
            message.option_type = 2;
            break;
        }
        switch (object.position_type) {
          case 'POSITION_UNKNOWN':
          case 0:
            message.position_type = 0;
            break;
          case 'LONG':
          case 1:
            message.position_type = 1;
            break;
          case 'SHORT':
          case 2:
            message.position_type = 2;
            break;
        }
        if (object.strike_price != null) message.strike_price = String(object.strike_price);
        if (object.premium != null) message.premium = String(object.premium);
        return message;
      };

      /**
       * Creates a plain object from a PerpetualOptionsPositionInstance message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @static
       * @param {ununifi.derivatives.PerpetualOptionsPositionInstance} message PerpetualOptionsPositionInstance
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PerpetualOptionsPositionInstance.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.option_type = options.enums === String ? 'OPTION_UNKNOWN' : 0;
          object.position_type = options.enums === String ? 'POSITION_UNKNOWN' : 0;
          object.strike_price = '';
          object.premium = '';
        }
        if (message.option_type != null && message.hasOwnProperty('option_type'))
          object.option_type = options.enums === String ? $root.ununifi.derivatives.OptionType[message.option_type] : message.option_type;
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          object.position_type =
            options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
        if (message.strike_price != null && message.hasOwnProperty('strike_price')) object.strike_price = message.strike_price;
        if (message.premium != null && message.hasOwnProperty('premium')) object.premium = message.premium;
        return object;
      };

      /**
       * Converts this PerpetualOptionsPositionInstance to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.PerpetualOptionsPositionInstance
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PerpetualOptionsPositionInstance.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PerpetualOptionsPositionInstance;
    })();

    derivatives.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.derivatives
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.derivatives.Query#params}.
       * @memberof ununifi.derivatives.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.derivatives.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.derivatives.QueryParamsRequest,
            $root.ununifi.derivatives.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#pool}.
       * @memberof ununifi.derivatives.Query
       * @typedef PoolCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPoolResponse} [response] QueryPoolResponse
       */

      /**
       * Calls Pool.
       * @function pool
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPoolRequest} request QueryPoolRequest message or plain object
       * @param {ununifi.derivatives.Query.PoolCallback} callback Node-style callback called with the error, if any, and QueryPoolResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.pool = function pool(request, callback) {
          return this.rpcCall(
            pool,
            $root.ununifi.derivatives.QueryPoolRequest,
            $root.ununifi.derivatives.QueryPoolResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Pool' },
      );

      /**
       * Calls Pool.
       * @function pool
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPoolRequest} request QueryPoolRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPoolResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#liquidityProviderTokenRealAPY}.
       * @memberof ununifi.derivatives.Query
       * @typedef LiquidityProviderTokenRealAPYCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} [response] QueryLiquidityProviderTokenRealAPYResponse
       */

      /**
       * Calls LiquidityProviderTokenRealAPY.
       * @function liquidityProviderTokenRealAPY
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} request QueryLiquidityProviderTokenRealAPYRequest message or plain object
       * @param {ununifi.derivatives.Query.LiquidityProviderTokenRealAPYCallback} callback Node-style callback called with the error, if any, and QueryLiquidityProviderTokenRealAPYResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.liquidityProviderTokenRealAPY = function liquidityProviderTokenRealAPY(request, callback) {
          return this.rpcCall(
            liquidityProviderTokenRealAPY,
            $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest,
            $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'LiquidityProviderTokenRealAPY' },
      );

      /**
       * Calls LiquidityProviderTokenRealAPY.
       * @function liquidityProviderTokenRealAPY
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} request QueryLiquidityProviderTokenRealAPYRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#liquidityProviderTokenNominalAPY}.
       * @memberof ununifi.derivatives.Query
       * @typedef LiquidityProviderTokenNominalAPYCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} [response] QueryLiquidityProviderTokenNominalAPYResponse
       */

      /**
       * Calls LiquidityProviderTokenNominalAPY.
       * @function liquidityProviderTokenNominalAPY
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} request QueryLiquidityProviderTokenNominalAPYRequest message or plain object
       * @param {ununifi.derivatives.Query.LiquidityProviderTokenNominalAPYCallback} callback Node-style callback called with the error, if any, and QueryLiquidityProviderTokenNominalAPYResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.liquidityProviderTokenNominalAPY = function liquidityProviderTokenNominalAPY(request, callback) {
          return this.rpcCall(
            liquidityProviderTokenNominalAPY,
            $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest,
            $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'LiquidityProviderTokenNominalAPY' },
      );

      /**
       * Calls LiquidityProviderTokenNominalAPY.
       * @function liquidityProviderTokenNominalAPY
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} request QueryLiquidityProviderTokenNominalAPYRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#perpetualFutures}.
       * @memberof ununifi.derivatives.Query
       * @typedef PerpetualFuturesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPerpetualFuturesResponse} [response] QueryPerpetualFuturesResponse
       */

      /**
       * Calls PerpetualFutures.
       * @function perpetualFutures
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} request QueryPerpetualFuturesRequest message or plain object
       * @param {ununifi.derivatives.Query.PerpetualFuturesCallback} callback Node-style callback called with the error, if any, and QueryPerpetualFuturesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.perpetualFutures = function perpetualFutures(request, callback) {
          return this.rpcCall(
            perpetualFutures,
            $root.ununifi.derivatives.QueryPerpetualFuturesRequest,
            $root.ununifi.derivatives.QueryPerpetualFuturesResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PerpetualFutures' },
      );

      /**
       * Calls PerpetualFutures.
       * @function perpetualFutures
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} request QueryPerpetualFuturesRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPerpetualFuturesResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#perpetualFuturesMarket}.
       * @memberof ununifi.derivatives.Query
       * @typedef PerpetualFuturesMarketCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} [response] QueryPerpetualFuturesMarketResponse
       */

      /**
       * Calls PerpetualFuturesMarket.
       * @function perpetualFuturesMarket
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} request QueryPerpetualFuturesMarketRequest message or plain object
       * @param {ununifi.derivatives.Query.PerpetualFuturesMarketCallback} callback Node-style callback called with the error, if any, and QueryPerpetualFuturesMarketResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.perpetualFuturesMarket = function perpetualFuturesMarket(request, callback) {
          return this.rpcCall(
            perpetualFuturesMarket,
            $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest,
            $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PerpetualFuturesMarket' },
      );

      /**
       * Calls PerpetualFuturesMarket.
       * @function perpetualFuturesMarket
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} request QueryPerpetualFuturesMarketRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPerpetualFuturesMarketResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#perpetualOptions}.
       * @memberof ununifi.derivatives.Query
       * @typedef PerpetualOptionsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPerpetualOptionsResponse} [response] QueryPerpetualOptionsResponse
       */

      /**
       * Calls PerpetualOptions.
       * @function perpetualOptions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} request QueryPerpetualOptionsRequest message or plain object
       * @param {ununifi.derivatives.Query.PerpetualOptionsCallback} callback Node-style callback called with the error, if any, and QueryPerpetualOptionsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.perpetualOptions = function perpetualOptions(request, callback) {
          return this.rpcCall(
            perpetualOptions,
            $root.ununifi.derivatives.QueryPerpetualOptionsRequest,
            $root.ununifi.derivatives.QueryPerpetualOptionsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PerpetualOptions' },
      );

      /**
       * Calls PerpetualOptions.
       * @function perpetualOptions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} request QueryPerpetualOptionsRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPerpetualOptionsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#perpetualOptionsMarket}.
       * @memberof ununifi.derivatives.Query
       * @typedef PerpetualOptionsMarketCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} [response] QueryPerpetualOptionsMarketResponse
       */

      /**
       * Calls PerpetualOptionsMarket.
       * @function perpetualOptionsMarket
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} request QueryPerpetualOptionsMarketRequest message or plain object
       * @param {ununifi.derivatives.Query.PerpetualOptionsMarketCallback} callback Node-style callback called with the error, if any, and QueryPerpetualOptionsMarketResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.perpetualOptionsMarket = function perpetualOptionsMarket(request, callback) {
          return this.rpcCall(
            perpetualOptionsMarket,
            $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest,
            $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PerpetualOptionsMarket' },
      );

      /**
       * Calls PerpetualOptionsMarket.
       * @function perpetualOptionsMarket
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} request QueryPerpetualOptionsMarketRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPerpetualOptionsMarketResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#allPositions}.
       * @memberof ununifi.derivatives.Query
       * @typedef AllPositionsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryAllPositionsResponse} [response] QueryAllPositionsResponse
       */

      /**
       * Calls AllPositions.
       * @function allPositions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAllPositionsRequest} request QueryAllPositionsRequest message or plain object
       * @param {ununifi.derivatives.Query.AllPositionsCallback} callback Node-style callback called with the error, if any, and QueryAllPositionsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.allPositions = function allPositions(request, callback) {
          return this.rpcCall(
            allPositions,
            $root.ununifi.derivatives.QueryAllPositionsRequest,
            $root.ununifi.derivatives.QueryAllPositionsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AllPositions' },
      );

      /**
       * Calls AllPositions.
       * @function allPositions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAllPositionsRequest} request QueryAllPositionsRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryAllPositionsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#position}.
       * @memberof ununifi.derivatives.Query
       * @typedef PositionCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPositionResponse} [response] QueryPositionResponse
       */

      /**
       * Calls Position.
       * @function position
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPositionRequest} request QueryPositionRequest message or plain object
       * @param {ununifi.derivatives.Query.PositionCallback} callback Node-style callback called with the error, if any, and QueryPositionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.position = function position(request, callback) {
          return this.rpcCall(
            position,
            $root.ununifi.derivatives.QueryPositionRequest,
            $root.ununifi.derivatives.QueryPositionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Position' },
      );

      /**
       * Calls Position.
       * @function position
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPositionRequest} request QueryPositionRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPositionResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#perpetualFuturesPositionSize}.
       * @memberof ununifi.derivatives.Query
       * @typedef PerpetualFuturesPositionSizeCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} [response] QueryPerpetualFuturesPositionSizeResponse
       */

      /**
       * Calls PerpetualFuturesPositionSize.
       * @function perpetualFuturesPositionSize
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} request QueryPerpetualFuturesPositionSizeRequest message or plain object
       * @param {ununifi.derivatives.Query.PerpetualFuturesPositionSizeCallback} callback Node-style callback called with the error, if any, and QueryPerpetualFuturesPositionSizeResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.perpetualFuturesPositionSize = function perpetualFuturesPositionSize(request, callback) {
          return this.rpcCall(
            perpetualFuturesPositionSize,
            $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest,
            $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PerpetualFuturesPositionSize' },
      );

      /**
       * Calls PerpetualFuturesPositionSize.
       * @function perpetualFuturesPositionSize
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} request QueryPerpetualFuturesPositionSizeRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#addressPositions}.
       * @memberof ununifi.derivatives.Query
       * @typedef AddressPositionsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryAddressPositionsResponse} [response] QueryAddressPositionsResponse
       */

      /**
       * Calls AddressPositions.
       * @function addressPositions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAddressPositionsRequest} request QueryAddressPositionsRequest message or plain object
       * @param {ununifi.derivatives.Query.AddressPositionsCallback} callback Node-style callback called with the error, if any, and QueryAddressPositionsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.addressPositions = function addressPositions(request, callback) {
          return this.rpcCall(
            addressPositions,
            $root.ununifi.derivatives.QueryAddressPositionsRequest,
            $root.ununifi.derivatives.QueryAddressPositionsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AddressPositions' },
      );

      /**
       * Calls AddressPositions.
       * @function addressPositions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAddressPositionsRequest} request QueryAddressPositionsRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryAddressPositionsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#allPendingPaymentPositions}.
       * @memberof ununifi.derivatives.Query
       * @typedef AllPendingPaymentPositionsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} [response] QueryAllPendingPaymentPositionsResponse
       */

      /**
       * Calls AllPendingPaymentPositions.
       * @function allPendingPaymentPositions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} request QueryAllPendingPaymentPositionsRequest message or plain object
       * @param {ununifi.derivatives.Query.AllPendingPaymentPositionsCallback} callback Node-style callback called with the error, if any, and QueryAllPendingPaymentPositionsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.allPendingPaymentPositions = function allPendingPaymentPositions(request, callback) {
          return this.rpcCall(
            allPendingPaymentPositions,
            $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest,
            $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AllPendingPaymentPositions' },
      );

      /**
       * Calls AllPendingPaymentPositions.
       * @function allPendingPaymentPositions
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} request QueryAllPendingPaymentPositionsRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryAllPendingPaymentPositionsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#pendingPaymentPosition}.
       * @memberof ununifi.derivatives.Query
       * @typedef PendingPaymentPositionCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryPendingPaymentPositionResponse} [response] QueryPendingPaymentPositionResponse
       */

      /**
       * Calls PendingPaymentPosition.
       * @function pendingPaymentPosition
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} request QueryPendingPaymentPositionRequest message or plain object
       * @param {ununifi.derivatives.Query.PendingPaymentPositionCallback} callback Node-style callback called with the error, if any, and QueryPendingPaymentPositionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.pendingPaymentPosition = function pendingPaymentPosition(request, callback) {
          return this.rpcCall(
            pendingPaymentPosition,
            $root.ununifi.derivatives.QueryPendingPaymentPositionRequest,
            $root.ununifi.derivatives.QueryPendingPaymentPositionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PendingPaymentPosition' },
      );

      /**
       * Calls PendingPaymentPosition.
       * @function pendingPaymentPosition
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} request QueryPendingPaymentPositionRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryPendingPaymentPositionResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#dLPTokenRates}.
       * @memberof ununifi.derivatives.Query
       * @typedef DLPTokenRatesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryDLPTokenRateResponse} [response] QueryDLPTokenRateResponse
       */

      /**
       * Calls DLPTokenRates.
       * @function dLPTokenRates
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} request QueryDLPTokenRateRequest message or plain object
       * @param {ununifi.derivatives.Query.DLPTokenRatesCallback} callback Node-style callback called with the error, if any, and QueryDLPTokenRateResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.dLPTokenRates = function dLPTokenRates(request, callback) {
          return this.rpcCall(
            dLPTokenRates,
            $root.ununifi.derivatives.QueryDLPTokenRateRequest,
            $root.ununifi.derivatives.QueryDLPTokenRateResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DLPTokenRates' },
      );

      /**
       * Calls DLPTokenRates.
       * @function dLPTokenRates
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} request QueryDLPTokenRateRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryDLPTokenRateResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#estimateDLPTokenAmount}.
       * @memberof ununifi.derivatives.Query
       * @typedef EstimateDLPTokenAmountCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} [response] QueryEstimateDLPTokenAmountResponse
       */

      /**
       * Calls EstimateDLPTokenAmount.
       * @function estimateDLPTokenAmount
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} request QueryEstimateDLPTokenAmountRequest message or plain object
       * @param {ununifi.derivatives.Query.EstimateDLPTokenAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateDLPTokenAmountResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateDLPTokenAmount = function estimateDLPTokenAmount(request, callback) {
          return this.rpcCall(
            estimateDLPTokenAmount,
            $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest,
            $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateDLPTokenAmount' },
      );

      /**
       * Calls EstimateDLPTokenAmount.
       * @function estimateDLPTokenAmount
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} request QueryEstimateDLPTokenAmountRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryEstimateDLPTokenAmountResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#estimateRedeemTokenAmount}.
       * @memberof ununifi.derivatives.Query
       * @typedef EstimateRedeemTokenAmountCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} [response] QueryEstimateRedeemTokenAmountResponse
       */

      /**
       * Calls EstimateRedeemTokenAmount.
       * @function estimateRedeemTokenAmount
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} request QueryEstimateRedeemTokenAmountRequest message or plain object
       * @param {ununifi.derivatives.Query.EstimateRedeemTokenAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateRedeemTokenAmountResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateRedeemTokenAmount = function estimateRedeemTokenAmount(request, callback) {
          return this.rpcCall(
            estimateRedeemTokenAmount,
            $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest,
            $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateRedeemTokenAmount' },
      );

      /**
       * Calls EstimateRedeemTokenAmount.
       * @function estimateRedeemTokenAmount
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} request QueryEstimateRedeemTokenAmountRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.derivatives.Query#availableAssetsInPool}.
       * @memberof ununifi.derivatives.Query
       * @typedef AvailableAssetsInPoolCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} [response] QueryAvailableAssetsInPoolResponse
       */

      /**
       * Calls AvailableAssetsInPool.
       * @function availableAssetsInPool
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} request QueryAvailableAssetsInPoolRequest message or plain object
       * @param {ununifi.derivatives.Query.AvailableAssetsInPoolCallback} callback Node-style callback called with the error, if any, and QueryAvailableAssetsInPoolResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.availableAssetsInPool = function availableAssetsInPool(request, callback) {
          return this.rpcCall(
            availableAssetsInPool,
            $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest,
            $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AvailableAssetsInPool' },
      );

      /**
       * Calls AvailableAssetsInPool.
       * @function availableAssetsInPool
       * @memberof ununifi.derivatives.Query
       * @instance
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} request QueryAvailableAssetsInPoolRequest message or plain object
       * @returns {Promise<ununifi.derivatives.QueryAvailableAssetsInPoolResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    derivatives.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.derivatives.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @static
       * @param {ununifi.derivatives.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @static
       * @param {ununifi.derivatives.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryParamsRequest) return object;
        return new $root.ununifi.derivatives.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @static
       * @param {ununifi.derivatives.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    derivatives.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryParamsResponse
       * @property {ununifi.derivatives.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.derivatives.IParams|null|undefined} params
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.derivatives.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @static
       * @param {ununifi.derivatives.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.derivatives.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @static
       * @param {ununifi.derivatives.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.derivatives.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.derivatives.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryParamsResponse) return object;
        let message = new $root.ununifi.derivatives.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.derivatives.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.derivatives.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @static
       * @param {ununifi.derivatives.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.derivatives.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    derivatives.QueryPoolRequest = (function () {
      /**
       * Properties of a QueryPoolRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPoolRequest
       */

      /**
       * Constructs a new QueryPoolRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPoolRequest.
       * @implements IQueryPoolRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPoolRequest=} [properties] Properties to set
       */
      function QueryPoolRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryPoolRequest message. Does not implicitly {@link ununifi.derivatives.QueryPoolRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @static
       * @param {ununifi.derivatives.IQueryPoolRequest} message QueryPoolRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPoolRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryPoolRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPoolRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @static
       * @param {ununifi.derivatives.IQueryPoolRequest} message QueryPoolRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPoolRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPoolRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPoolRequest} QueryPoolRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPoolRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPoolRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPoolRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPoolRequest} QueryPoolRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPoolRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPoolRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPoolRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryPoolRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPoolRequest} QueryPoolRequest
       */
      QueryPoolRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPoolRequest) return object;
        return new $root.ununifi.derivatives.QueryPoolRequest();
      };

      /**
       * Creates a plain object from a QueryPoolRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @static
       * @param {ununifi.derivatives.QueryPoolRequest} message QueryPoolRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPoolRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryPoolRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPoolRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPoolRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPoolRequest;
    })();

    derivatives.QueryPoolResponse = (function () {
      /**
       * Properties of a QueryPoolResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPoolResponse
       * @property {string|null} [metrics_quote_ticker] QueryPoolResponse metrics_quote_ticker
       * @property {ununifi.derivatives.IPoolMarketCap|null} [pool_market_cap] QueryPoolResponse pool_market_cap
       */

      /**
       * Constructs a new QueryPoolResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPoolResponse.
       * @implements IQueryPoolResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPoolResponse=} [properties] Properties to set
       */
      function QueryPoolResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPoolResponse metrics_quote_ticker.
       * @member {string} metrics_quote_ticker
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @instance
       */
      QueryPoolResponse.prototype.metrics_quote_ticker = '';

      /**
       * QueryPoolResponse pool_market_cap.
       * @member {ununifi.derivatives.IPoolMarketCap|null|undefined} pool_market_cap
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @instance
       */
      QueryPoolResponse.prototype.pool_market_cap = null;

      /**
       * Encodes the specified QueryPoolResponse message. Does not implicitly {@link ununifi.derivatives.QueryPoolResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @static
       * @param {ununifi.derivatives.IQueryPoolResponse} message QueryPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPoolResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.metrics_quote_ticker != null && Object.hasOwnProperty.call(message, 'metrics_quote_ticker'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.metrics_quote_ticker);
        if (message.pool_market_cap != null && Object.hasOwnProperty.call(message, 'pool_market_cap'))
          $root.ununifi.derivatives.PoolMarketCap.encode(
            message.pool_market_cap,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPoolResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @static
       * @param {ununifi.derivatives.IQueryPoolResponse} message QueryPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPoolResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPoolResponse} QueryPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPoolResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPoolResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metrics_quote_ticker = reader.string();
              break;
            case 2:
              message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPoolResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPoolResponse} QueryPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPoolResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPoolResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPoolResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.metrics_quote_ticker != null && message.hasOwnProperty('metrics_quote_ticker'))
          if (!$util.isString(message.metrics_quote_ticker)) return 'metrics_quote_ticker: string expected';
        if (message.pool_market_cap != null && message.hasOwnProperty('pool_market_cap')) {
          let error = $root.ununifi.derivatives.PoolMarketCap.verify(message.pool_market_cap);
          if (error) return 'pool_market_cap.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryPoolResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPoolResponse} QueryPoolResponse
       */
      QueryPoolResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPoolResponse) return object;
        let message = new $root.ununifi.derivatives.QueryPoolResponse();
        if (object.metrics_quote_ticker != null) message.metrics_quote_ticker = String(object.metrics_quote_ticker);
        if (object.pool_market_cap != null) {
          if (typeof object.pool_market_cap !== 'object')
            throw TypeError('.ununifi.derivatives.QueryPoolResponse.pool_market_cap: object expected');
          message.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.fromObject(object.pool_market_cap);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryPoolResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @static
       * @param {ununifi.derivatives.QueryPoolResponse} message QueryPoolResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPoolResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.metrics_quote_ticker = '';
          object.pool_market_cap = null;
        }
        if (message.metrics_quote_ticker != null && message.hasOwnProperty('metrics_quote_ticker'))
          object.metrics_quote_ticker = message.metrics_quote_ticker;
        if (message.pool_market_cap != null && message.hasOwnProperty('pool_market_cap'))
          object.pool_market_cap = $root.ununifi.derivatives.PoolMarketCap.toObject(message.pool_market_cap, options);
        return object;
      };

      /**
       * Converts this QueryPoolResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPoolResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPoolResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPoolResponse;
    })();

    derivatives.QueryLiquidityProviderTokenRealAPYRequest = (function () {
      /**
       * Properties of a QueryLiquidityProviderTokenRealAPYRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryLiquidityProviderTokenRealAPYRequest
       * @property {Long|null} [before_height] QueryLiquidityProviderTokenRealAPYRequest before_height
       * @property {Long|null} [after_height] QueryLiquidityProviderTokenRealAPYRequest after_height
       */

      /**
       * Constructs a new QueryLiquidityProviderTokenRealAPYRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryLiquidityProviderTokenRealAPYRequest.
       * @implements IQueryLiquidityProviderTokenRealAPYRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest=} [properties] Properties to set
       */
      function QueryLiquidityProviderTokenRealAPYRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLiquidityProviderTokenRealAPYRequest before_height.
       * @member {Long} before_height
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @instance
       */
      QueryLiquidityProviderTokenRealAPYRequest.prototype.before_height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * QueryLiquidityProviderTokenRealAPYRequest after_height.
       * @member {Long} after_height
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @instance
       */
      QueryLiquidityProviderTokenRealAPYRequest.prototype.after_height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Encodes the specified QueryLiquidityProviderTokenRealAPYRequest message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} message QueryLiquidityProviderTokenRealAPYRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenRealAPYRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.before_height != null && Object.hasOwnProperty.call(message, 'before_height'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.before_height);
        if (message.after_height != null && Object.hasOwnProperty.call(message, 'after_height'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.after_height);
        return writer;
      };

      /**
       * Encodes the specified QueryLiquidityProviderTokenRealAPYRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYRequest} message QueryLiquidityProviderTokenRealAPYRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenRealAPYRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLiquidityProviderTokenRealAPYRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} QueryLiquidityProviderTokenRealAPYRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenRealAPYRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.before_height = reader.int64();
              break;
            case 2:
              message.after_height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLiquidityProviderTokenRealAPYRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} QueryLiquidityProviderTokenRealAPYRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenRealAPYRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLiquidityProviderTokenRealAPYRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLiquidityProviderTokenRealAPYRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.before_height != null && message.hasOwnProperty('before_height'))
          if (
            !$util.isInteger(message.before_height) &&
            !(message.before_height && $util.isInteger(message.before_height.low) && $util.isInteger(message.before_height.high))
          )
            return 'before_height: integer|Long expected';
        if (message.after_height != null && message.hasOwnProperty('after_height'))
          if (
            !$util.isInteger(message.after_height) &&
            !(message.after_height && $util.isInteger(message.after_height.low) && $util.isInteger(message.after_height.high))
          )
            return 'after_height: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryLiquidityProviderTokenRealAPYRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} QueryLiquidityProviderTokenRealAPYRequest
       */
      QueryLiquidityProviderTokenRealAPYRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest) return object;
        let message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest();
        if (object.before_height != null)
          if ($util.Long) (message.before_height = $util.Long.fromValue(object.before_height)).unsigned = false;
          else if (typeof object.before_height === 'string') message.before_height = parseInt(object.before_height, 10);
          else if (typeof object.before_height === 'number') message.before_height = object.before_height;
          else if (typeof object.before_height === 'object')
            message.before_height = new $util.LongBits(object.before_height.low >>> 0, object.before_height.high >>> 0).toNumber();
        if (object.after_height != null)
          if ($util.Long) (message.after_height = $util.Long.fromValue(object.after_height)).unsigned = false;
          else if (typeof object.after_height === 'string') message.after_height = parseInt(object.after_height, 10);
          else if (typeof object.after_height === 'number') message.after_height = object.after_height;
          else if (typeof object.after_height === 'object')
            message.after_height = new $util.LongBits(object.after_height.low >>> 0, object.after_height.high >>> 0).toNumber();
        return message;
      };

      /**
       * Creates a plain object from a QueryLiquidityProviderTokenRealAPYRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @static
       * @param {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest} message QueryLiquidityProviderTokenRealAPYRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLiquidityProviderTokenRealAPYRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.before_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.before_height = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.after_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.after_height = options.longs === String ? '0' : 0;
        }
        if (message.before_height != null && message.hasOwnProperty('before_height'))
          if (typeof message.before_height === 'number')
            object.before_height = options.longs === String ? String(message.before_height) : message.before_height;
          else
            object.before_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.before_height)
                : options.longs === Number
                ? new $util.LongBits(message.before_height.low >>> 0, message.before_height.high >>> 0).toNumber()
                : message.before_height;
        if (message.after_height != null && message.hasOwnProperty('after_height'))
          if (typeof message.after_height === 'number')
            object.after_height = options.longs === String ? String(message.after_height) : message.after_height;
          else
            object.after_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.after_height)
                : options.longs === Number
                ? new $util.LongBits(message.after_height.low >>> 0, message.after_height.high >>> 0).toNumber()
                : message.after_height;
        return object;
      };

      /**
       * Converts this QueryLiquidityProviderTokenRealAPYRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLiquidityProviderTokenRealAPYRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLiquidityProviderTokenRealAPYRequest;
    })();

    derivatives.QueryLiquidityProviderTokenRealAPYResponse = (function () {
      /**
       * Properties of a QueryLiquidityProviderTokenRealAPYResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryLiquidityProviderTokenRealAPYResponse
       * @property {string|null} [apy] QueryLiquidityProviderTokenRealAPYResponse apy
       */

      /**
       * Constructs a new QueryLiquidityProviderTokenRealAPYResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryLiquidityProviderTokenRealAPYResponse.
       * @implements IQueryLiquidityProviderTokenRealAPYResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYResponse=} [properties] Properties to set
       */
      function QueryLiquidityProviderTokenRealAPYResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLiquidityProviderTokenRealAPYResponse apy.
       * @member {string} apy
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @instance
       */
      QueryLiquidityProviderTokenRealAPYResponse.prototype.apy = '';

      /**
       * Encodes the specified QueryLiquidityProviderTokenRealAPYResponse message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYResponse} message QueryLiquidityProviderTokenRealAPYResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenRealAPYResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.apy != null && Object.hasOwnProperty.call(message, 'apy'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.apy);
        return writer;
      };

      /**
       * Encodes the specified QueryLiquidityProviderTokenRealAPYResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenRealAPYResponse} message QueryLiquidityProviderTokenRealAPYResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenRealAPYResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLiquidityProviderTokenRealAPYResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} QueryLiquidityProviderTokenRealAPYResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenRealAPYResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.apy = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLiquidityProviderTokenRealAPYResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} QueryLiquidityProviderTokenRealAPYResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenRealAPYResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLiquidityProviderTokenRealAPYResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLiquidityProviderTokenRealAPYResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.apy != null && message.hasOwnProperty('apy')) if (!$util.isString(message.apy)) return 'apy: string expected';
        return null;
      };

      /**
       * Creates a QueryLiquidityProviderTokenRealAPYResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} QueryLiquidityProviderTokenRealAPYResponse
       */
      QueryLiquidityProviderTokenRealAPYResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse) return object;
        let message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse();
        if (object.apy != null) message.apy = String(object.apy);
        return message;
      };

      /**
       * Creates a plain object from a QueryLiquidityProviderTokenRealAPYResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @static
       * @param {ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse} message QueryLiquidityProviderTokenRealAPYResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLiquidityProviderTokenRealAPYResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.apy = '';
        if (message.apy != null && message.hasOwnProperty('apy')) object.apy = message.apy;
        return object;
      };

      /**
       * Converts this QueryLiquidityProviderTokenRealAPYResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenRealAPYResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLiquidityProviderTokenRealAPYResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLiquidityProviderTokenRealAPYResponse;
    })();

    derivatives.QueryLiquidityProviderTokenNominalAPYRequest = (function () {
      /**
       * Properties of a QueryLiquidityProviderTokenNominalAPYRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryLiquidityProviderTokenNominalAPYRequest
       * @property {Long|null} [before_height] QueryLiquidityProviderTokenNominalAPYRequest before_height
       * @property {Long|null} [after_height] QueryLiquidityProviderTokenNominalAPYRequest after_height
       */

      /**
       * Constructs a new QueryLiquidityProviderTokenNominalAPYRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryLiquidityProviderTokenNominalAPYRequest.
       * @implements IQueryLiquidityProviderTokenNominalAPYRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest=} [properties] Properties to set
       */
      function QueryLiquidityProviderTokenNominalAPYRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLiquidityProviderTokenNominalAPYRequest before_height.
       * @member {Long} before_height
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @instance
       */
      QueryLiquidityProviderTokenNominalAPYRequest.prototype.before_height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * QueryLiquidityProviderTokenNominalAPYRequest after_height.
       * @member {Long} after_height
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @instance
       */
      QueryLiquidityProviderTokenNominalAPYRequest.prototype.after_height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Encodes the specified QueryLiquidityProviderTokenNominalAPYRequest message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} message QueryLiquidityProviderTokenNominalAPYRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenNominalAPYRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.before_height != null && Object.hasOwnProperty.call(message, 'before_height'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.before_height);
        if (message.after_height != null && Object.hasOwnProperty.call(message, 'after_height'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.after_height);
        return writer;
      };

      /**
       * Encodes the specified QueryLiquidityProviderTokenNominalAPYRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYRequest} message QueryLiquidityProviderTokenNominalAPYRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenNominalAPYRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLiquidityProviderTokenNominalAPYRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} QueryLiquidityProviderTokenNominalAPYRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenNominalAPYRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.before_height = reader.int64();
              break;
            case 2:
              message.after_height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLiquidityProviderTokenNominalAPYRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} QueryLiquidityProviderTokenNominalAPYRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenNominalAPYRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLiquidityProviderTokenNominalAPYRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLiquidityProviderTokenNominalAPYRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.before_height != null && message.hasOwnProperty('before_height'))
          if (
            !$util.isInteger(message.before_height) &&
            !(message.before_height && $util.isInteger(message.before_height.low) && $util.isInteger(message.before_height.high))
          )
            return 'before_height: integer|Long expected';
        if (message.after_height != null && message.hasOwnProperty('after_height'))
          if (
            !$util.isInteger(message.after_height) &&
            !(message.after_height && $util.isInteger(message.after_height.low) && $util.isInteger(message.after_height.high))
          )
            return 'after_height: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryLiquidityProviderTokenNominalAPYRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} QueryLiquidityProviderTokenNominalAPYRequest
       */
      QueryLiquidityProviderTokenNominalAPYRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest) return object;
        let message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest();
        if (object.before_height != null)
          if ($util.Long) (message.before_height = $util.Long.fromValue(object.before_height)).unsigned = false;
          else if (typeof object.before_height === 'string') message.before_height = parseInt(object.before_height, 10);
          else if (typeof object.before_height === 'number') message.before_height = object.before_height;
          else if (typeof object.before_height === 'object')
            message.before_height = new $util.LongBits(object.before_height.low >>> 0, object.before_height.high >>> 0).toNumber();
        if (object.after_height != null)
          if ($util.Long) (message.after_height = $util.Long.fromValue(object.after_height)).unsigned = false;
          else if (typeof object.after_height === 'string') message.after_height = parseInt(object.after_height, 10);
          else if (typeof object.after_height === 'number') message.after_height = object.after_height;
          else if (typeof object.after_height === 'object')
            message.after_height = new $util.LongBits(object.after_height.low >>> 0, object.after_height.high >>> 0).toNumber();
        return message;
      };

      /**
       * Creates a plain object from a QueryLiquidityProviderTokenNominalAPYRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @static
       * @param {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest} message QueryLiquidityProviderTokenNominalAPYRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLiquidityProviderTokenNominalAPYRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.before_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.before_height = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.after_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.after_height = options.longs === String ? '0' : 0;
        }
        if (message.before_height != null && message.hasOwnProperty('before_height'))
          if (typeof message.before_height === 'number')
            object.before_height = options.longs === String ? String(message.before_height) : message.before_height;
          else
            object.before_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.before_height)
                : options.longs === Number
                ? new $util.LongBits(message.before_height.low >>> 0, message.before_height.high >>> 0).toNumber()
                : message.before_height;
        if (message.after_height != null && message.hasOwnProperty('after_height'))
          if (typeof message.after_height === 'number')
            object.after_height = options.longs === String ? String(message.after_height) : message.after_height;
          else
            object.after_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.after_height)
                : options.longs === Number
                ? new $util.LongBits(message.after_height.low >>> 0, message.after_height.high >>> 0).toNumber()
                : message.after_height;
        return object;
      };

      /**
       * Converts this QueryLiquidityProviderTokenNominalAPYRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLiquidityProviderTokenNominalAPYRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLiquidityProviderTokenNominalAPYRequest;
    })();

    derivatives.QueryLiquidityProviderTokenNominalAPYResponse = (function () {
      /**
       * Properties of a QueryLiquidityProviderTokenNominalAPYResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryLiquidityProviderTokenNominalAPYResponse
       * @property {string|null} [apy] QueryLiquidityProviderTokenNominalAPYResponse apy
       */

      /**
       * Constructs a new QueryLiquidityProviderTokenNominalAPYResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryLiquidityProviderTokenNominalAPYResponse.
       * @implements IQueryLiquidityProviderTokenNominalAPYResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYResponse=} [properties] Properties to set
       */
      function QueryLiquidityProviderTokenNominalAPYResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLiquidityProviderTokenNominalAPYResponse apy.
       * @member {string} apy
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @instance
       */
      QueryLiquidityProviderTokenNominalAPYResponse.prototype.apy = '';

      /**
       * Encodes the specified QueryLiquidityProviderTokenNominalAPYResponse message. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYResponse} message QueryLiquidityProviderTokenNominalAPYResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenNominalAPYResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.apy != null && Object.hasOwnProperty.call(message, 'apy'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.apy);
        return writer;
      };

      /**
       * Encodes the specified QueryLiquidityProviderTokenNominalAPYResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @static
       * @param {ununifi.derivatives.IQueryLiquidityProviderTokenNominalAPYResponse} message QueryLiquidityProviderTokenNominalAPYResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidityProviderTokenNominalAPYResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLiquidityProviderTokenNominalAPYResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} QueryLiquidityProviderTokenNominalAPYResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenNominalAPYResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.apy = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLiquidityProviderTokenNominalAPYResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} QueryLiquidityProviderTokenNominalAPYResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidityProviderTokenNominalAPYResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLiquidityProviderTokenNominalAPYResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLiquidityProviderTokenNominalAPYResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.apy != null && message.hasOwnProperty('apy')) if (!$util.isString(message.apy)) return 'apy: string expected';
        return null;
      };

      /**
       * Creates a QueryLiquidityProviderTokenNominalAPYResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} QueryLiquidityProviderTokenNominalAPYResponse
       */
      QueryLiquidityProviderTokenNominalAPYResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse) return object;
        let message = new $root.ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse();
        if (object.apy != null) message.apy = String(object.apy);
        return message;
      };

      /**
       * Creates a plain object from a QueryLiquidityProviderTokenNominalAPYResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @static
       * @param {ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse} message QueryLiquidityProviderTokenNominalAPYResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLiquidityProviderTokenNominalAPYResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.apy = '';
        if (message.apy != null && message.hasOwnProperty('apy')) object.apy = message.apy;
        return object;
      };

      /**
       * Converts this QueryLiquidityProviderTokenNominalAPYResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryLiquidityProviderTokenNominalAPYResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLiquidityProviderTokenNominalAPYResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLiquidityProviderTokenNominalAPYResponse;
    })();

    derivatives.QueryPerpetualFuturesRequest = (function () {
      /**
       * Properties of a QueryPerpetualFuturesRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualFuturesRequest
       */

      /**
       * Constructs a new QueryPerpetualFuturesRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualFuturesRequest.
       * @implements IQueryPerpetualFuturesRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest=} [properties] Properties to set
       */
      function QueryPerpetualFuturesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryPerpetualFuturesRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} message QueryPerpetualFuturesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualFuturesRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesRequest} message QueryPerpetualFuturesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualFuturesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualFuturesRequest} QueryPerpetualFuturesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualFuturesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualFuturesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualFuturesRequest} QueryPerpetualFuturesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualFuturesRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualFuturesRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualFuturesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualFuturesRequest} QueryPerpetualFuturesRequest
       */
      QueryPerpetualFuturesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesRequest) return object;
        return new $root.ununifi.derivatives.QueryPerpetualFuturesRequest();
      };

      /**
       * Creates a plain object from a QueryPerpetualFuturesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @static
       * @param {ununifi.derivatives.QueryPerpetualFuturesRequest} message QueryPerpetualFuturesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualFuturesRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryPerpetualFuturesRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualFuturesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualFuturesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualFuturesRequest;
    })();

    derivatives.QueryPerpetualFuturesResponse = (function () {
      /**
       * Properties of a QueryPerpetualFuturesResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualFuturesResponse
       * @property {string|null} [metrics_quote_ticker] QueryPerpetualFuturesResponse metrics_quote_ticker
       * @property {string|null} [long_positions] QueryPerpetualFuturesResponse long_positions
       * @property {string|null} [short_positions] QueryPerpetualFuturesResponse short_positions
       */

      /**
       * Constructs a new QueryPerpetualFuturesResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualFuturesResponse.
       * @implements IQueryPerpetualFuturesResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualFuturesResponse=} [properties] Properties to set
       */
      function QueryPerpetualFuturesResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPerpetualFuturesResponse metrics_quote_ticker.
       * @member {string} metrics_quote_ticker
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @instance
       */
      QueryPerpetualFuturesResponse.prototype.metrics_quote_ticker = '';

      /**
       * QueryPerpetualFuturesResponse long_positions.
       * @member {string} long_positions
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @instance
       */
      QueryPerpetualFuturesResponse.prototype.long_positions = '';

      /**
       * QueryPerpetualFuturesResponse short_positions.
       * @member {string} short_positions
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @instance
       */
      QueryPerpetualFuturesResponse.prototype.short_positions = '';

      /**
       * Encodes the specified QueryPerpetualFuturesResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesResponse} message QueryPerpetualFuturesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.metrics_quote_ticker != null && Object.hasOwnProperty.call(message, 'metrics_quote_ticker'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.metrics_quote_ticker);
        if (message.long_positions != null && Object.hasOwnProperty.call(message, 'long_positions'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.long_positions);
        if (message.short_positions != null && Object.hasOwnProperty.call(message, 'short_positions'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.short_positions);
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualFuturesResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesResponse} message QueryPerpetualFuturesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualFuturesResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualFuturesResponse} QueryPerpetualFuturesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualFuturesResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metrics_quote_ticker = reader.string();
              break;
            case 2:
              message.long_positions = reader.string();
              break;
            case 3:
              message.short_positions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualFuturesResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualFuturesResponse} QueryPerpetualFuturesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualFuturesResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualFuturesResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.metrics_quote_ticker != null && message.hasOwnProperty('metrics_quote_ticker'))
          if (!$util.isString(message.metrics_quote_ticker)) return 'metrics_quote_ticker: string expected';
        if (message.long_positions != null && message.hasOwnProperty('long_positions'))
          if (!$util.isString(message.long_positions)) return 'long_positions: string expected';
        if (message.short_positions != null && message.hasOwnProperty('short_positions'))
          if (!$util.isString(message.short_positions)) return 'short_positions: string expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualFuturesResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualFuturesResponse} QueryPerpetualFuturesResponse
       */
      QueryPerpetualFuturesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesResponse) return object;
        let message = new $root.ununifi.derivatives.QueryPerpetualFuturesResponse();
        if (object.metrics_quote_ticker != null) message.metrics_quote_ticker = String(object.metrics_quote_ticker);
        if (object.long_positions != null) message.long_positions = String(object.long_positions);
        if (object.short_positions != null) message.short_positions = String(object.short_positions);
        return message;
      };

      /**
       * Creates a plain object from a QueryPerpetualFuturesResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @static
       * @param {ununifi.derivatives.QueryPerpetualFuturesResponse} message QueryPerpetualFuturesResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualFuturesResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.metrics_quote_ticker = '';
          object.long_positions = '';
          object.short_positions = '';
        }
        if (message.metrics_quote_ticker != null && message.hasOwnProperty('metrics_quote_ticker'))
          object.metrics_quote_ticker = message.metrics_quote_ticker;
        if (message.long_positions != null && message.hasOwnProperty('long_positions')) object.long_positions = message.long_positions;
        if (message.short_positions != null && message.hasOwnProperty('short_positions')) object.short_positions = message.short_positions;
        return object;
      };

      /**
       * Converts this QueryPerpetualFuturesResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualFuturesResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualFuturesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualFuturesResponse;
    })();

    derivatives.QueryPerpetualFuturesMarketRequest = (function () {
      /**
       * Properties of a QueryPerpetualFuturesMarketRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualFuturesMarketRequest
       * @property {string|null} [base_denom] QueryPerpetualFuturesMarketRequest base_denom
       * @property {string|null} [quote_denom] QueryPerpetualFuturesMarketRequest quote_denom
       */

      /**
       * Constructs a new QueryPerpetualFuturesMarketRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualFuturesMarketRequest.
       * @implements IQueryPerpetualFuturesMarketRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest=} [properties] Properties to set
       */
      function QueryPerpetualFuturesMarketRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPerpetualFuturesMarketRequest base_denom.
       * @member {string} base_denom
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @instance
       */
      QueryPerpetualFuturesMarketRequest.prototype.base_denom = '';

      /**
       * QueryPerpetualFuturesMarketRequest quote_denom.
       * @member {string} quote_denom
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @instance
       */
      QueryPerpetualFuturesMarketRequest.prototype.quote_denom = '';

      /**
       * Encodes the specified QueryPerpetualFuturesMarketRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} message QueryPerpetualFuturesMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesMarketRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.base_denom != null && Object.hasOwnProperty.call(message, 'base_denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.base_denom);
        if (message.quote_denom != null && Object.hasOwnProperty.call(message, 'quote_denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.quote_denom);
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualFuturesMarketRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketRequest} message QueryPerpetualFuturesMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualFuturesMarketRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} QueryPerpetualFuturesMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesMarketRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.base_denom = reader.string();
              break;
            case 2:
              message.quote_denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualFuturesMarketRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} QueryPerpetualFuturesMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesMarketRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualFuturesMarketRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualFuturesMarketRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.base_denom != null && message.hasOwnProperty('base_denom'))
          if (!$util.isString(message.base_denom)) return 'base_denom: string expected';
        if (message.quote_denom != null && message.hasOwnProperty('quote_denom'))
          if (!$util.isString(message.quote_denom)) return 'quote_denom: string expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualFuturesMarketRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} QueryPerpetualFuturesMarketRequest
       */
      QueryPerpetualFuturesMarketRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest) return object;
        let message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketRequest();
        if (object.base_denom != null) message.base_denom = String(object.base_denom);
        if (object.quote_denom != null) message.quote_denom = String(object.quote_denom);
        return message;
      };

      /**
       * Creates a plain object from a QueryPerpetualFuturesMarketRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @static
       * @param {ununifi.derivatives.QueryPerpetualFuturesMarketRequest} message QueryPerpetualFuturesMarketRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualFuturesMarketRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.base_denom = '';
          object.quote_denom = '';
        }
        if (message.base_denom != null && message.hasOwnProperty('base_denom')) object.base_denom = message.base_denom;
        if (message.quote_denom != null && message.hasOwnProperty('quote_denom')) object.quote_denom = message.quote_denom;
        return object;
      };

      /**
       * Converts this QueryPerpetualFuturesMarketRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualFuturesMarketRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualFuturesMarketRequest;
    })();

    derivatives.QueryPerpetualFuturesMarketResponse = (function () {
      /**
       * Properties of a QueryPerpetualFuturesMarketResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualFuturesMarketResponse
       * @property {string|null} [price] QueryPerpetualFuturesMarketResponse price
       * @property {string|null} [metrics_quote_ticker] QueryPerpetualFuturesMarketResponse metrics_quote_ticker
       * @property {string|null} [long_positions] QueryPerpetualFuturesMarketResponse long_positions
       * @property {string|null} [short_positions] QueryPerpetualFuturesMarketResponse short_positions
       */

      /**
       * Constructs a new QueryPerpetualFuturesMarketResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualFuturesMarketResponse.
       * @implements IQueryPerpetualFuturesMarketResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketResponse=} [properties] Properties to set
       */
      function QueryPerpetualFuturesMarketResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPerpetualFuturesMarketResponse price.
       * @member {string} price
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @instance
       */
      QueryPerpetualFuturesMarketResponse.prototype.price = '';

      /**
       * QueryPerpetualFuturesMarketResponse metrics_quote_ticker.
       * @member {string} metrics_quote_ticker
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @instance
       */
      QueryPerpetualFuturesMarketResponse.prototype.metrics_quote_ticker = '';

      /**
       * QueryPerpetualFuturesMarketResponse long_positions.
       * @member {string} long_positions
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @instance
       */
      QueryPerpetualFuturesMarketResponse.prototype.long_positions = '';

      /**
       * QueryPerpetualFuturesMarketResponse short_positions.
       * @member {string} short_positions
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @instance
       */
      QueryPerpetualFuturesMarketResponse.prototype.short_positions = '';

      /**
       * Encodes the specified QueryPerpetualFuturesMarketResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketResponse} message QueryPerpetualFuturesMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesMarketResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.price);
        if (message.metrics_quote_ticker != null && Object.hasOwnProperty.call(message, 'metrics_quote_ticker'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.metrics_quote_ticker);
        if (message.long_positions != null && Object.hasOwnProperty.call(message, 'long_positions'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.long_positions);
        if (message.short_positions != null && Object.hasOwnProperty.call(message, 'short_positions'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.short_positions);
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualFuturesMarketResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesMarketResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesMarketResponse} message QueryPerpetualFuturesMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualFuturesMarketResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} QueryPerpetualFuturesMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesMarketResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.price = reader.string();
              break;
            case 2:
              message.metrics_quote_ticker = reader.string();
              break;
            case 3:
              message.long_positions = reader.string();
              break;
            case 4:
              message.short_positions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualFuturesMarketResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} QueryPerpetualFuturesMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesMarketResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualFuturesMarketResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualFuturesMarketResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
        if (message.metrics_quote_ticker != null && message.hasOwnProperty('metrics_quote_ticker'))
          if (!$util.isString(message.metrics_quote_ticker)) return 'metrics_quote_ticker: string expected';
        if (message.long_positions != null && message.hasOwnProperty('long_positions'))
          if (!$util.isString(message.long_positions)) return 'long_positions: string expected';
        if (message.short_positions != null && message.hasOwnProperty('short_positions'))
          if (!$util.isString(message.short_positions)) return 'short_positions: string expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualFuturesMarketResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} QueryPerpetualFuturesMarketResponse
       */
      QueryPerpetualFuturesMarketResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse) return object;
        let message = new $root.ununifi.derivatives.QueryPerpetualFuturesMarketResponse();
        if (object.price != null) message.price = String(object.price);
        if (object.metrics_quote_ticker != null) message.metrics_quote_ticker = String(object.metrics_quote_ticker);
        if (object.long_positions != null) message.long_positions = String(object.long_positions);
        if (object.short_positions != null) message.short_positions = String(object.short_positions);
        return message;
      };

      /**
       * Creates a plain object from a QueryPerpetualFuturesMarketResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @static
       * @param {ununifi.derivatives.QueryPerpetualFuturesMarketResponse} message QueryPerpetualFuturesMarketResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualFuturesMarketResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.price = '';
          object.metrics_quote_ticker = '';
          object.long_positions = '';
          object.short_positions = '';
        }
        if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
        if (message.metrics_quote_ticker != null && message.hasOwnProperty('metrics_quote_ticker'))
          object.metrics_quote_ticker = message.metrics_quote_ticker;
        if (message.long_positions != null && message.hasOwnProperty('long_positions')) object.long_positions = message.long_positions;
        if (message.short_positions != null && message.hasOwnProperty('short_positions')) object.short_positions = message.short_positions;
        return object;
      };

      /**
       * Converts this QueryPerpetualFuturesMarketResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualFuturesMarketResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualFuturesMarketResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualFuturesMarketResponse;
    })();

    derivatives.QueryPerpetualOptionsRequest = (function () {
      /**
       * Properties of a QueryPerpetualOptionsRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualOptionsRequest
       */

      /**
       * Constructs a new QueryPerpetualOptionsRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualOptionsRequest.
       * @implements IQueryPerpetualOptionsRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest=} [properties] Properties to set
       */
      function QueryPerpetualOptionsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryPerpetualOptionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} message QueryPerpetualOptionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualOptionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsRequest} message QueryPerpetualOptionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualOptionsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualOptionsRequest} QueryPerpetualOptionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualOptionsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualOptionsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualOptionsRequest} QueryPerpetualOptionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualOptionsRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualOptionsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualOptionsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualOptionsRequest} QueryPerpetualOptionsRequest
       */
      QueryPerpetualOptionsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsRequest) return object;
        return new $root.ununifi.derivatives.QueryPerpetualOptionsRequest();
      };

      /**
       * Creates a plain object from a QueryPerpetualOptionsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @static
       * @param {ununifi.derivatives.QueryPerpetualOptionsRequest} message QueryPerpetualOptionsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualOptionsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryPerpetualOptionsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualOptionsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualOptionsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualOptionsRequest;
    })();

    derivatives.QueryPerpetualOptionsResponse = (function () {
      /**
       * Properties of a QueryPerpetualOptionsResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualOptionsResponse
       */

      /**
       * Constructs a new QueryPerpetualOptionsResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualOptionsResponse.
       * @implements IQueryPerpetualOptionsResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualOptionsResponse=} [properties] Properties to set
       */
      function QueryPerpetualOptionsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryPerpetualOptionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsResponse} message QueryPerpetualOptionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualOptionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsResponse} message QueryPerpetualOptionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualOptionsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualOptionsResponse} QueryPerpetualOptionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualOptionsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualOptionsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualOptionsResponse} QueryPerpetualOptionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualOptionsResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualOptionsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualOptionsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualOptionsResponse} QueryPerpetualOptionsResponse
       */
      QueryPerpetualOptionsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsResponse) return object;
        return new $root.ununifi.derivatives.QueryPerpetualOptionsResponse();
      };

      /**
       * Creates a plain object from a QueryPerpetualOptionsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @static
       * @param {ununifi.derivatives.QueryPerpetualOptionsResponse} message QueryPerpetualOptionsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualOptionsResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryPerpetualOptionsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualOptionsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualOptionsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualOptionsResponse;
    })();

    derivatives.QueryPerpetualOptionsMarketRequest = (function () {
      /**
       * Properties of a QueryPerpetualOptionsMarketRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualOptionsMarketRequest
       * @property {string|null} [base_denom] QueryPerpetualOptionsMarketRequest base_denom
       * @property {string|null} [quote_denom] QueryPerpetualOptionsMarketRequest quote_denom
       */

      /**
       * Constructs a new QueryPerpetualOptionsMarketRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualOptionsMarketRequest.
       * @implements IQueryPerpetualOptionsMarketRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest=} [properties] Properties to set
       */
      function QueryPerpetualOptionsMarketRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPerpetualOptionsMarketRequest base_denom.
       * @member {string} base_denom
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @instance
       */
      QueryPerpetualOptionsMarketRequest.prototype.base_denom = '';

      /**
       * QueryPerpetualOptionsMarketRequest quote_denom.
       * @member {string} quote_denom
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @instance
       */
      QueryPerpetualOptionsMarketRequest.prototype.quote_denom = '';

      /**
       * Encodes the specified QueryPerpetualOptionsMarketRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} message QueryPerpetualOptionsMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsMarketRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.base_denom != null && Object.hasOwnProperty.call(message, 'base_denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.base_denom);
        if (message.quote_denom != null && Object.hasOwnProperty.call(message, 'quote_denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.quote_denom);
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualOptionsMarketRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketRequest} message QueryPerpetualOptionsMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualOptionsMarketRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} QueryPerpetualOptionsMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsMarketRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.base_denom = reader.string();
              break;
            case 2:
              message.quote_denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualOptionsMarketRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} QueryPerpetualOptionsMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsMarketRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualOptionsMarketRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualOptionsMarketRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.base_denom != null && message.hasOwnProperty('base_denom'))
          if (!$util.isString(message.base_denom)) return 'base_denom: string expected';
        if (message.quote_denom != null && message.hasOwnProperty('quote_denom'))
          if (!$util.isString(message.quote_denom)) return 'quote_denom: string expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualOptionsMarketRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} QueryPerpetualOptionsMarketRequest
       */
      QueryPerpetualOptionsMarketRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest) return object;
        let message = new $root.ununifi.derivatives.QueryPerpetualOptionsMarketRequest();
        if (object.base_denom != null) message.base_denom = String(object.base_denom);
        if (object.quote_denom != null) message.quote_denom = String(object.quote_denom);
        return message;
      };

      /**
       * Creates a plain object from a QueryPerpetualOptionsMarketRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @static
       * @param {ununifi.derivatives.QueryPerpetualOptionsMarketRequest} message QueryPerpetualOptionsMarketRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualOptionsMarketRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.base_denom = '';
          object.quote_denom = '';
        }
        if (message.base_denom != null && message.hasOwnProperty('base_denom')) object.base_denom = message.base_denom;
        if (message.quote_denom != null && message.hasOwnProperty('quote_denom')) object.quote_denom = message.quote_denom;
        return object;
      };

      /**
       * Converts this QueryPerpetualOptionsMarketRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualOptionsMarketRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualOptionsMarketRequest;
    })();

    derivatives.QueryPerpetualOptionsMarketResponse = (function () {
      /**
       * Properties of a QueryPerpetualOptionsMarketResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualOptionsMarketResponse
       */

      /**
       * Constructs a new QueryPerpetualOptionsMarketResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualOptionsMarketResponse.
       * @implements IQueryPerpetualOptionsMarketResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketResponse=} [properties] Properties to set
       */
      function QueryPerpetualOptionsMarketResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryPerpetualOptionsMarketResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketResponse} message QueryPerpetualOptionsMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsMarketResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualOptionsMarketResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualOptionsMarketResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualOptionsMarketResponse} message QueryPerpetualOptionsMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualOptionsMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualOptionsMarketResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} QueryPerpetualOptionsMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsMarketResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualOptionsMarketResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} QueryPerpetualOptionsMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualOptionsMarketResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualOptionsMarketResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualOptionsMarketResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualOptionsMarketResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} QueryPerpetualOptionsMarketResponse
       */
      QueryPerpetualOptionsMarketResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse) return object;
        return new $root.ununifi.derivatives.QueryPerpetualOptionsMarketResponse();
      };

      /**
       * Creates a plain object from a QueryPerpetualOptionsMarketResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @static
       * @param {ununifi.derivatives.QueryPerpetualOptionsMarketResponse} message QueryPerpetualOptionsMarketResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualOptionsMarketResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryPerpetualOptionsMarketResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualOptionsMarketResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualOptionsMarketResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualOptionsMarketResponse;
    })();

    derivatives.QueryAllPositionsRequest = (function () {
      /**
       * Properties of a QueryAllPositionsRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryAllPositionsRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllPositionsRequest pagination
       */

      /**
       * Constructs a new QueryAllPositionsRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAllPositionsRequest.
       * @implements IQueryAllPositionsRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryAllPositionsRequest=} [properties] Properties to set
       */
      function QueryAllPositionsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllPositionsRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @instance
       */
      QueryAllPositionsRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllPositionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryAllPositionsRequest} message QueryAllPositionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPositionsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPositionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryAllPositionsRequest} message QueryAllPositionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPositionsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAllPositionsRequest} QueryAllPositionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPositionsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAllPositionsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPositionsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAllPositionsRequest} QueryAllPositionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPositionsRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPositionsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllPositionsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAllPositionsRequest} QueryAllPositionsRequest
       */
      QueryAllPositionsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAllPositionsRequest) return object;
        let message = new $root.ununifi.derivatives.QueryAllPositionsRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.derivatives.QueryAllPositionsRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllPositionsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @static
       * @param {ununifi.derivatives.QueryAllPositionsRequest} message QueryAllPositionsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPositionsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllPositionsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAllPositionsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPositionsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPositionsRequest;
    })();

    derivatives.QueryAllPositionsResponse = (function () {
      /**
       * Properties of a QueryAllPositionsResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryAllPositionsResponse
       * @property {Array.<ununifi.derivatives.IPosition>|null} [positions] QueryAllPositionsResponse positions
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllPositionsResponse pagination
       */

      /**
       * Constructs a new QueryAllPositionsResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAllPositionsResponse.
       * @implements IQueryAllPositionsResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryAllPositionsResponse=} [properties] Properties to set
       */
      function QueryAllPositionsResponse(properties) {
        this.positions = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllPositionsResponse positions.
       * @member {Array.<ununifi.derivatives.IPosition>} positions
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @instance
       */
      QueryAllPositionsResponse.prototype.positions = $util.emptyArray;

      /**
       * QueryAllPositionsResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @instance
       */
      QueryAllPositionsResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllPositionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryAllPositionsResponse} message QueryAllPositionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPositionsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.positions != null && message.positions.length)
          for (let i = 0; i < message.positions.length; ++i)
            $root.ununifi.derivatives.Position.encode(message.positions[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPositionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPositionsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryAllPositionsResponse} message QueryAllPositionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPositionsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAllPositionsResponse} QueryAllPositionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPositionsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAllPositionsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.positions && message.positions.length)) message.positions = [];
              message.positions.push($root.ununifi.derivatives.Position.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPositionsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAllPositionsResponse} QueryAllPositionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPositionsResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPositionsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.positions != null && message.hasOwnProperty('positions')) {
          if (!Array.isArray(message.positions)) return 'positions: array expected';
          for (let i = 0; i < message.positions.length; ++i) {
            let error = $root.ununifi.derivatives.Position.verify(message.positions[i]);
            if (error) return 'positions.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllPositionsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAllPositionsResponse} QueryAllPositionsResponse
       */
      QueryAllPositionsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAllPositionsResponse) return object;
        let message = new $root.ununifi.derivatives.QueryAllPositionsResponse();
        if (object.positions) {
          if (!Array.isArray(object.positions)) throw TypeError('.ununifi.derivatives.QueryAllPositionsResponse.positions: array expected');
          message.positions = [];
          for (let i = 0; i < object.positions.length; ++i) {
            if (typeof object.positions[i] !== 'object')
              throw TypeError('.ununifi.derivatives.QueryAllPositionsResponse.positions: object expected');
            message.positions[i] = $root.ununifi.derivatives.Position.fromObject(object.positions[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.derivatives.QueryAllPositionsResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllPositionsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @static
       * @param {ununifi.derivatives.QueryAllPositionsResponse} message QueryAllPositionsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPositionsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.positions = [];
        if (options.defaults) object.pagination = null;
        if (message.positions && message.positions.length) {
          object.positions = [];
          for (let j = 0; j < message.positions.length; ++j)
            object.positions[j] = $root.ununifi.derivatives.Position.toObject(message.positions[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllPositionsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAllPositionsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPositionsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPositionsResponse;
    })();

    derivatives.QueryPositionRequest = (function () {
      /**
       * Properties of a QueryPositionRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPositionRequest
       * @property {string|null} [position_id] QueryPositionRequest position_id
       */

      /**
       * Constructs a new QueryPositionRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPositionRequest.
       * @implements IQueryPositionRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPositionRequest=} [properties] Properties to set
       */
      function QueryPositionRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPositionRequest position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @instance
       */
      QueryPositionRequest.prototype.position_id = '';

      /**
       * Encodes the specified QueryPositionRequest message. Does not implicitly {@link ununifi.derivatives.QueryPositionRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @static
       * @param {ununifi.derivatives.IQueryPositionRequest} message QueryPositionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPositionRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified QueryPositionRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPositionRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @static
       * @param {ununifi.derivatives.IQueryPositionRequest} message QueryPositionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPositionRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPositionRequest} QueryPositionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPositionRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPositionRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPositionRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPositionRequest} QueryPositionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPositionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPositionRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPositionRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates a QueryPositionRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPositionRequest} QueryPositionRequest
       */
      QueryPositionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPositionRequest) return object;
        let message = new $root.ununifi.derivatives.QueryPositionRequest();
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryPositionRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @static
       * @param {ununifi.derivatives.QueryPositionRequest} message QueryPositionRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPositionRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.position_id = '';
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this QueryPositionRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPositionRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPositionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPositionRequest;
    })();

    derivatives.QueryPositionResponse = (function () {
      /**
       * Properties of a QueryPositionResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPositionResponse
       * @property {ununifi.derivatives.IPosition|null} [position] QueryPositionResponse position
       * @property {cosmos.base.v1beta1.ICoin|null} [valuation_profit] QueryPositionResponse valuation_profit
       * @property {string|null} [margin_maintenance_rate] QueryPositionResponse margin_maintenance_rate
       * @property {cosmos.base.v1beta1.ICoin|null} [effective_margin] QueryPositionResponse effective_margin
       */

      /**
       * Constructs a new QueryPositionResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPositionResponse.
       * @implements IQueryPositionResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPositionResponse=} [properties] Properties to set
       */
      function QueryPositionResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPositionResponse position.
       * @member {ununifi.derivatives.IPosition|null|undefined} position
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @instance
       */
      QueryPositionResponse.prototype.position = null;

      /**
       * QueryPositionResponse valuation_profit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} valuation_profit
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @instance
       */
      QueryPositionResponse.prototype.valuation_profit = null;

      /**
       * QueryPositionResponse margin_maintenance_rate.
       * @member {string} margin_maintenance_rate
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @instance
       */
      QueryPositionResponse.prototype.margin_maintenance_rate = '';

      /**
       * QueryPositionResponse effective_margin.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} effective_margin
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @instance
       */
      QueryPositionResponse.prototype.effective_margin = null;

      /**
       * Encodes the specified QueryPositionResponse message. Does not implicitly {@link ununifi.derivatives.QueryPositionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @static
       * @param {ununifi.derivatives.IQueryPositionResponse} message QueryPositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPositionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position != null && Object.hasOwnProperty.call(message, 'position'))
          $root.ununifi.derivatives.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.valuation_profit != null && Object.hasOwnProperty.call(message, 'valuation_profit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.valuation_profit, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.margin_maintenance_rate != null && Object.hasOwnProperty.call(message, 'margin_maintenance_rate'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.margin_maintenance_rate);
        if (message.effective_margin != null && Object.hasOwnProperty.call(message, 'effective_margin'))
          $root.cosmos.base.v1beta1.Coin.encode(message.effective_margin, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryPositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPositionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @static
       * @param {ununifi.derivatives.IQueryPositionResponse} message QueryPositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPositionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPositionResponse} QueryPositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPositionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPositionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position = $root.ununifi.derivatives.Position.decode(reader, reader.uint32());
              break;
            case 2:
              message.valuation_profit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.margin_maintenance_rate = reader.string();
              break;
            case 4:
              message.effective_margin = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPositionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPositionResponse} QueryPositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPositionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPositionResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPositionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position != null && message.hasOwnProperty('position')) {
          let error = $root.ununifi.derivatives.Position.verify(message.position);
          if (error) return 'position.' + error;
        }
        if (message.valuation_profit != null && message.hasOwnProperty('valuation_profit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.valuation_profit);
          if (error) return 'valuation_profit.' + error;
        }
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          if (!$util.isString(message.margin_maintenance_rate)) return 'margin_maintenance_rate: string expected';
        if (message.effective_margin != null && message.hasOwnProperty('effective_margin')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.effective_margin);
          if (error) return 'effective_margin.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryPositionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPositionResponse} QueryPositionResponse
       */
      QueryPositionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPositionResponse) return object;
        let message = new $root.ununifi.derivatives.QueryPositionResponse();
        if (object.position != null) {
          if (typeof object.position !== 'object') throw TypeError('.ununifi.derivatives.QueryPositionResponse.position: object expected');
          message.position = $root.ununifi.derivatives.Position.fromObject(object.position);
        }
        if (object.valuation_profit != null) {
          if (typeof object.valuation_profit !== 'object')
            throw TypeError('.ununifi.derivatives.QueryPositionResponse.valuation_profit: object expected');
          message.valuation_profit = $root.cosmos.base.v1beta1.Coin.fromObject(object.valuation_profit);
        }
        if (object.margin_maintenance_rate != null) message.margin_maintenance_rate = String(object.margin_maintenance_rate);
        if (object.effective_margin != null) {
          if (typeof object.effective_margin !== 'object')
            throw TypeError('.ununifi.derivatives.QueryPositionResponse.effective_margin: object expected');
          message.effective_margin = $root.cosmos.base.v1beta1.Coin.fromObject(object.effective_margin);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryPositionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @static
       * @param {ununifi.derivatives.QueryPositionResponse} message QueryPositionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPositionResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.position = null;
          object.valuation_profit = null;
          object.margin_maintenance_rate = '';
          object.effective_margin = null;
        }
        if (message.position != null && message.hasOwnProperty('position'))
          object.position = $root.ununifi.derivatives.Position.toObject(message.position, options);
        if (message.valuation_profit != null && message.hasOwnProperty('valuation_profit'))
          object.valuation_profit = $root.cosmos.base.v1beta1.Coin.toObject(message.valuation_profit, options);
        if (message.margin_maintenance_rate != null && message.hasOwnProperty('margin_maintenance_rate'))
          object.margin_maintenance_rate = message.margin_maintenance_rate;
        if (message.effective_margin != null && message.hasOwnProperty('effective_margin'))
          object.effective_margin = $root.cosmos.base.v1beta1.Coin.toObject(message.effective_margin, options);
        return object;
      };

      /**
       * Converts this QueryPositionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPositionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPositionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPositionResponse;
    })();

    derivatives.QueryPerpetualFuturesPositionSizeRequest = (function () {
      /**
       * Properties of a QueryPerpetualFuturesPositionSizeRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualFuturesPositionSizeRequest
       * @property {ununifi.derivatives.PositionType|null} [position_type] QueryPerpetualFuturesPositionSizeRequest position_type
       * @property {string|null} [address] QueryPerpetualFuturesPositionSizeRequest address
       */

      /**
       * Constructs a new QueryPerpetualFuturesPositionSizeRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualFuturesPositionSizeRequest.
       * @implements IQueryPerpetualFuturesPositionSizeRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest=} [properties] Properties to set
       */
      function QueryPerpetualFuturesPositionSizeRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPerpetualFuturesPositionSizeRequest position_type.
       * @member {ununifi.derivatives.PositionType} position_type
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @instance
       */
      QueryPerpetualFuturesPositionSizeRequest.prototype.position_type = 0;

      /**
       * QueryPerpetualFuturesPositionSizeRequest address.
       * @member {string} address
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @instance
       */
      QueryPerpetualFuturesPositionSizeRequest.prototype.address = '';

      /**
       * Encodes the specified QueryPerpetualFuturesPositionSizeRequest message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} message QueryPerpetualFuturesPositionSizeRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesPositionSizeRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position_type != null && Object.hasOwnProperty.call(message, 'position_type'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.position_type);
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualFuturesPositionSizeRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeRequest} message QueryPerpetualFuturesPositionSizeRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesPositionSizeRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualFuturesPositionSizeRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} QueryPerpetualFuturesPositionSizeRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesPositionSizeRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position_type = reader.int32();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualFuturesPositionSizeRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} QueryPerpetualFuturesPositionSizeRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesPositionSizeRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualFuturesPositionSizeRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualFuturesPositionSizeRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          switch (message.position_type) {
            default:
              return 'position_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        return null;
      };

      /**
       * Creates a QueryPerpetualFuturesPositionSizeRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} QueryPerpetualFuturesPositionSizeRequest
       */
      QueryPerpetualFuturesPositionSizeRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest) return object;
        let message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest();
        switch (object.position_type) {
          case 'POSITION_UNKNOWN':
          case 0:
            message.position_type = 0;
            break;
          case 'LONG':
          case 1:
            message.position_type = 1;
            break;
          case 'SHORT':
          case 2:
            message.position_type = 2;
            break;
        }
        if (object.address != null) message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryPerpetualFuturesPositionSizeRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @static
       * @param {ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest} message QueryPerpetualFuturesPositionSizeRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualFuturesPositionSizeRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.position_type = options.enums === String ? 'POSITION_UNKNOWN' : 0;
          object.address = '';
        }
        if (message.position_type != null && message.hasOwnProperty('position_type'))
          object.position_type =
            options.enums === String ? $root.ununifi.derivatives.PositionType[message.position_type] : message.position_type;
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryPerpetualFuturesPositionSizeRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualFuturesPositionSizeRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualFuturesPositionSizeRequest;
    })();

    derivatives.QueryPerpetualFuturesPositionSizeResponse = (function () {
      /**
       * Properties of a QueryPerpetualFuturesPositionSizeResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPerpetualFuturesPositionSizeResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [total_position_size_usd] QueryPerpetualFuturesPositionSizeResponse total_position_size_usd
       */

      /**
       * Constructs a new QueryPerpetualFuturesPositionSizeResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPerpetualFuturesPositionSizeResponse.
       * @implements IQueryPerpetualFuturesPositionSizeResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeResponse=} [properties] Properties to set
       */
      function QueryPerpetualFuturesPositionSizeResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPerpetualFuturesPositionSizeResponse total_position_size_usd.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} total_position_size_usd
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @instance
       */
      QueryPerpetualFuturesPositionSizeResponse.prototype.total_position_size_usd = null;

      /**
       * Encodes the specified QueryPerpetualFuturesPositionSizeResponse message. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeResponse} message QueryPerpetualFuturesPositionSizeResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesPositionSizeResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.total_position_size_usd != null && Object.hasOwnProperty.call(message, 'total_position_size_usd'))
          $root.cosmos.base.v1beta1.Coin.encode(message.total_position_size_usd, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryPerpetualFuturesPositionSizeResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @static
       * @param {ununifi.derivatives.IQueryPerpetualFuturesPositionSizeResponse} message QueryPerpetualFuturesPositionSizeResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPerpetualFuturesPositionSizeResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPerpetualFuturesPositionSizeResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} QueryPerpetualFuturesPositionSizeResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesPositionSizeResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total_position_size_usd = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPerpetualFuturesPositionSizeResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} QueryPerpetualFuturesPositionSizeResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPerpetualFuturesPositionSizeResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPerpetualFuturesPositionSizeResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPerpetualFuturesPositionSizeResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.total_position_size_usd != null && message.hasOwnProperty('total_position_size_usd')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.total_position_size_usd);
          if (error) return 'total_position_size_usd.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryPerpetualFuturesPositionSizeResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} QueryPerpetualFuturesPositionSizeResponse
       */
      QueryPerpetualFuturesPositionSizeResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse) return object;
        let message = new $root.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse();
        if (object.total_position_size_usd != null) {
          if (typeof object.total_position_size_usd !== 'object')
            throw TypeError('.ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse.total_position_size_usd: object expected');
          message.total_position_size_usd = $root.cosmos.base.v1beta1.Coin.fromObject(object.total_position_size_usd);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryPerpetualFuturesPositionSizeResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @static
       * @param {ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse} message QueryPerpetualFuturesPositionSizeResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPerpetualFuturesPositionSizeResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.total_position_size_usd = null;
        if (message.total_position_size_usd != null && message.hasOwnProperty('total_position_size_usd'))
          object.total_position_size_usd = $root.cosmos.base.v1beta1.Coin.toObject(message.total_position_size_usd, options);
        return object;
      };

      /**
       * Converts this QueryPerpetualFuturesPositionSizeResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPerpetualFuturesPositionSizeResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPerpetualFuturesPositionSizeResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPerpetualFuturesPositionSizeResponse;
    })();

    derivatives.QueryAddressPositionsRequest = (function () {
      /**
       * Properties of a QueryAddressPositionsRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryAddressPositionsRequest
       * @property {string|null} [address] QueryAddressPositionsRequest address
       */

      /**
       * Constructs a new QueryAddressPositionsRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAddressPositionsRequest.
       * @implements IQueryAddressPositionsRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryAddressPositionsRequest=} [properties] Properties to set
       */
      function QueryAddressPositionsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAddressPositionsRequest address.
       * @member {string} address
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @instance
       */
      QueryAddressPositionsRequest.prototype.address = '';

      /**
       * Encodes the specified QueryAddressPositionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryAddressPositionsRequest} message QueryAddressPositionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAddressPositionsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryAddressPositionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryAddressPositionsRequest} message QueryAddressPositionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAddressPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAddressPositionsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAddressPositionsRequest} QueryAddressPositionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAddressPositionsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAddressPositionsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAddressPositionsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAddressPositionsRequest} QueryAddressPositionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAddressPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAddressPositionsRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAddressPositionsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        return null;
      };

      /**
       * Creates a QueryAddressPositionsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAddressPositionsRequest} QueryAddressPositionsRequest
       */
      QueryAddressPositionsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAddressPositionsRequest) return object;
        let message = new $root.ununifi.derivatives.QueryAddressPositionsRequest();
        if (object.address != null) message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryAddressPositionsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @static
       * @param {ununifi.derivatives.QueryAddressPositionsRequest} message QueryAddressPositionsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAddressPositionsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.address = '';
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryAddressPositionsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAddressPositionsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAddressPositionsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAddressPositionsRequest;
    })();

    derivatives.QueryAddressPositionsResponse = (function () {
      /**
       * Properties of a QueryAddressPositionsResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryAddressPositionsResponse
       * @property {Array.<ununifi.derivatives.IQueriedPosition>|null} [positions] QueryAddressPositionsResponse positions
       */

      /**
       * Constructs a new QueryAddressPositionsResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAddressPositionsResponse.
       * @implements IQueryAddressPositionsResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryAddressPositionsResponse=} [properties] Properties to set
       */
      function QueryAddressPositionsResponse(properties) {
        this.positions = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAddressPositionsResponse positions.
       * @member {Array.<ununifi.derivatives.IQueriedPosition>} positions
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @instance
       */
      QueryAddressPositionsResponse.prototype.positions = $util.emptyArray;

      /**
       * Encodes the specified QueryAddressPositionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryAddressPositionsResponse} message QueryAddressPositionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAddressPositionsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.positions != null && message.positions.length)
          for (let i = 0; i < message.positions.length; ++i)
            $root.ununifi.derivatives.QueriedPosition.encode(
              message.positions[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAddressPositionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAddressPositionsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryAddressPositionsResponse} message QueryAddressPositionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAddressPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAddressPositionsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAddressPositionsResponse} QueryAddressPositionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAddressPositionsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAddressPositionsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.positions && message.positions.length)) message.positions = [];
              message.positions.push($root.ununifi.derivatives.QueriedPosition.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAddressPositionsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAddressPositionsResponse} QueryAddressPositionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAddressPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAddressPositionsResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAddressPositionsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.positions != null && message.hasOwnProperty('positions')) {
          if (!Array.isArray(message.positions)) return 'positions: array expected';
          for (let i = 0; i < message.positions.length; ++i) {
            let error = $root.ununifi.derivatives.QueriedPosition.verify(message.positions[i]);
            if (error) return 'positions.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryAddressPositionsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAddressPositionsResponse} QueryAddressPositionsResponse
       */
      QueryAddressPositionsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAddressPositionsResponse) return object;
        let message = new $root.ununifi.derivatives.QueryAddressPositionsResponse();
        if (object.positions) {
          if (!Array.isArray(object.positions))
            throw TypeError('.ununifi.derivatives.QueryAddressPositionsResponse.positions: array expected');
          message.positions = [];
          for (let i = 0; i < object.positions.length; ++i) {
            if (typeof object.positions[i] !== 'object')
              throw TypeError('.ununifi.derivatives.QueryAddressPositionsResponse.positions: object expected');
            message.positions[i] = $root.ununifi.derivatives.QueriedPosition.fromObject(object.positions[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAddressPositionsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @static
       * @param {ununifi.derivatives.QueryAddressPositionsResponse} message QueryAddressPositionsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAddressPositionsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.positions = [];
        if (message.positions && message.positions.length) {
          object.positions = [];
          for (let j = 0; j < message.positions.length; ++j)
            object.positions[j] = $root.ununifi.derivatives.QueriedPosition.toObject(message.positions[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryAddressPositionsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAddressPositionsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAddressPositionsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAddressPositionsResponse;
    })();

    derivatives.QueryAllPendingPaymentPositionsRequest = (function () {
      /**
       * Properties of a QueryAllPendingPaymentPositionsRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryAllPendingPaymentPositionsRequest
       */

      /**
       * Constructs a new QueryAllPendingPaymentPositionsRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAllPendingPaymentPositionsRequest.
       * @implements IQueryAllPendingPaymentPositionsRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest=} [properties] Properties to set
       */
      function QueryAllPendingPaymentPositionsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryAllPendingPaymentPositionsRequest message. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} message QueryAllPendingPaymentPositionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPendingPaymentPositionsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPendingPaymentPositionsRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @static
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsRequest} message QueryAllPendingPaymentPositionsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPendingPaymentPositionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPendingPaymentPositionsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} QueryAllPendingPaymentPositionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPendingPaymentPositionsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPendingPaymentPositionsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} QueryAllPendingPaymentPositionsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPendingPaymentPositionsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPendingPaymentPositionsRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPendingPaymentPositionsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryAllPendingPaymentPositionsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} QueryAllPendingPaymentPositionsRequest
       */
      QueryAllPendingPaymentPositionsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest) return object;
        return new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsRequest();
      };

      /**
       * Creates a plain object from a QueryAllPendingPaymentPositionsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @static
       * @param {ununifi.derivatives.QueryAllPendingPaymentPositionsRequest} message QueryAllPendingPaymentPositionsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPendingPaymentPositionsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryAllPendingPaymentPositionsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPendingPaymentPositionsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPendingPaymentPositionsRequest;
    })();

    derivatives.QueryAllPendingPaymentPositionsResponse = (function () {
      /**
       * Properties of a QueryAllPendingPaymentPositionsResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryAllPendingPaymentPositionsResponse
       * @property {Array.<ununifi.derivatives.IPendingPaymentPosition>|null} [pending_payment_positions] QueryAllPendingPaymentPositionsResponse pending_payment_positions
       */

      /**
       * Constructs a new QueryAllPendingPaymentPositionsResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAllPendingPaymentPositionsResponse.
       * @implements IQueryAllPendingPaymentPositionsResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsResponse=} [properties] Properties to set
       */
      function QueryAllPendingPaymentPositionsResponse(properties) {
        this.pending_payment_positions = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllPendingPaymentPositionsResponse pending_payment_positions.
       * @member {Array.<ununifi.derivatives.IPendingPaymentPosition>} pending_payment_positions
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @instance
       */
      QueryAllPendingPaymentPositionsResponse.prototype.pending_payment_positions = $util.emptyArray;

      /**
       * Encodes the specified QueryAllPendingPaymentPositionsResponse message. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsResponse} message QueryAllPendingPaymentPositionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPendingPaymentPositionsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pending_payment_positions != null && message.pending_payment_positions.length)
          for (let i = 0; i < message.pending_payment_positions.length; ++i)
            $root.ununifi.derivatives.PendingPaymentPosition.encode(
              message.pending_payment_positions[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPendingPaymentPositionsResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @static
       * @param {ununifi.derivatives.IQueryAllPendingPaymentPositionsResponse} message QueryAllPendingPaymentPositionsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPendingPaymentPositionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPendingPaymentPositionsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} QueryAllPendingPaymentPositionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPendingPaymentPositionsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.pending_payment_positions && message.pending_payment_positions.length)) message.pending_payment_positions = [];
              message.pending_payment_positions.push($root.ununifi.derivatives.PendingPaymentPosition.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPendingPaymentPositionsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} QueryAllPendingPaymentPositionsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPendingPaymentPositionsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPendingPaymentPositionsResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPendingPaymentPositionsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pending_payment_positions != null && message.hasOwnProperty('pending_payment_positions')) {
          if (!Array.isArray(message.pending_payment_positions)) return 'pending_payment_positions: array expected';
          for (let i = 0; i < message.pending_payment_positions.length; ++i) {
            let error = $root.ununifi.derivatives.PendingPaymentPosition.verify(message.pending_payment_positions[i]);
            if (error) return 'pending_payment_positions.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryAllPendingPaymentPositionsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} QueryAllPendingPaymentPositionsResponse
       */
      QueryAllPendingPaymentPositionsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse) return object;
        let message = new $root.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse();
        if (object.pending_payment_positions) {
          if (!Array.isArray(object.pending_payment_positions))
            throw TypeError('.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.pending_payment_positions: array expected');
          message.pending_payment_positions = [];
          for (let i = 0; i < object.pending_payment_positions.length; ++i) {
            if (typeof object.pending_payment_positions[i] !== 'object')
              throw TypeError('.ununifi.derivatives.QueryAllPendingPaymentPositionsResponse.pending_payment_positions: object expected');
            message.pending_payment_positions[i] = $root.ununifi.derivatives.PendingPaymentPosition.fromObject(
              object.pending_payment_positions[i],
            );
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllPendingPaymentPositionsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @static
       * @param {ununifi.derivatives.QueryAllPendingPaymentPositionsResponse} message QueryAllPendingPaymentPositionsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPendingPaymentPositionsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.pending_payment_positions = [];
        if (message.pending_payment_positions && message.pending_payment_positions.length) {
          object.pending_payment_positions = [];
          for (let j = 0; j < message.pending_payment_positions.length; ++j)
            object.pending_payment_positions[j] = $root.ununifi.derivatives.PendingPaymentPosition.toObject(
              message.pending_payment_positions[j],
              options,
            );
        }
        return object;
      };

      /**
       * Converts this QueryAllPendingPaymentPositionsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAllPendingPaymentPositionsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPendingPaymentPositionsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPendingPaymentPositionsResponse;
    })();

    derivatives.QueryPendingPaymentPositionRequest = (function () {
      /**
       * Properties of a QueryPendingPaymentPositionRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryPendingPaymentPositionRequest
       * @property {string|null} [position_id] QueryPendingPaymentPositionRequest position_id
       */

      /**
       * Constructs a new QueryPendingPaymentPositionRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPendingPaymentPositionRequest.
       * @implements IQueryPendingPaymentPositionRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest=} [properties] Properties to set
       */
      function QueryPendingPaymentPositionRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPendingPaymentPositionRequest position_id.
       * @member {string} position_id
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @instance
       */
      QueryPendingPaymentPositionRequest.prototype.position_id = '';

      /**
       * Encodes the specified QueryPendingPaymentPositionRequest message. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @static
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} message QueryPendingPaymentPositionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingPaymentPositionRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.position_id != null && Object.hasOwnProperty.call(message, 'position_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.position_id);
        return writer;
      };

      /**
       * Encodes the specified QueryPendingPaymentPositionRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @static
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionRequest} message QueryPendingPaymentPositionRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingPaymentPositionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPendingPaymentPositionRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPendingPaymentPositionRequest} QueryPendingPaymentPositionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingPaymentPositionRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPendingPaymentPositionRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.position_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPendingPaymentPositionRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPendingPaymentPositionRequest} QueryPendingPaymentPositionRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingPaymentPositionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPendingPaymentPositionRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPendingPaymentPositionRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.position_id != null && message.hasOwnProperty('position_id'))
          if (!$util.isString(message.position_id)) return 'position_id: string expected';
        return null;
      };

      /**
       * Creates a QueryPendingPaymentPositionRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPendingPaymentPositionRequest} QueryPendingPaymentPositionRequest
       */
      QueryPendingPaymentPositionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPendingPaymentPositionRequest) return object;
        let message = new $root.ununifi.derivatives.QueryPendingPaymentPositionRequest();
        if (object.position_id != null) message.position_id = String(object.position_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryPendingPaymentPositionRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @static
       * @param {ununifi.derivatives.QueryPendingPaymentPositionRequest} message QueryPendingPaymentPositionRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPendingPaymentPositionRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.position_id = '';
        if (message.position_id != null && message.hasOwnProperty('position_id')) object.position_id = message.position_id;
        return object;
      };

      /**
       * Converts this QueryPendingPaymentPositionRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPendingPaymentPositionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPendingPaymentPositionRequest;
    })();

    derivatives.QueryPendingPaymentPositionResponse = (function () {
      /**
       * Properties of a QueryPendingPaymentPositionResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryPendingPaymentPositionResponse
       * @property {ununifi.derivatives.IPendingPaymentPosition|null} [pending_payment_position] QueryPendingPaymentPositionResponse pending_payment_position
       */

      /**
       * Constructs a new QueryPendingPaymentPositionResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryPendingPaymentPositionResponse.
       * @implements IQueryPendingPaymentPositionResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionResponse=} [properties] Properties to set
       */
      function QueryPendingPaymentPositionResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPendingPaymentPositionResponse pending_payment_position.
       * @member {ununifi.derivatives.IPendingPaymentPosition|null|undefined} pending_payment_position
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @instance
       */
      QueryPendingPaymentPositionResponse.prototype.pending_payment_position = null;

      /**
       * Encodes the specified QueryPendingPaymentPositionResponse message. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @static
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionResponse} message QueryPendingPaymentPositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingPaymentPositionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pending_payment_position != null && Object.hasOwnProperty.call(message, 'pending_payment_position'))
          $root.ununifi.derivatives.PendingPaymentPosition.encode(
            message.pending_payment_position,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryPendingPaymentPositionResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryPendingPaymentPositionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @static
       * @param {ununifi.derivatives.IQueryPendingPaymentPositionResponse} message QueryPendingPaymentPositionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingPaymentPositionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPendingPaymentPositionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryPendingPaymentPositionResponse} QueryPendingPaymentPositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingPaymentPositionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryPendingPaymentPositionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pending_payment_position = $root.ununifi.derivatives.PendingPaymentPosition.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPendingPaymentPositionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryPendingPaymentPositionResponse} QueryPendingPaymentPositionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingPaymentPositionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPendingPaymentPositionResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPendingPaymentPositionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pending_payment_position != null && message.hasOwnProperty('pending_payment_position')) {
          let error = $root.ununifi.derivatives.PendingPaymentPosition.verify(message.pending_payment_position);
          if (error) return 'pending_payment_position.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryPendingPaymentPositionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryPendingPaymentPositionResponse} QueryPendingPaymentPositionResponse
       */
      QueryPendingPaymentPositionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryPendingPaymentPositionResponse) return object;
        let message = new $root.ununifi.derivatives.QueryPendingPaymentPositionResponse();
        if (object.pending_payment_position != null) {
          if (typeof object.pending_payment_position !== 'object')
            throw TypeError('.ununifi.derivatives.QueryPendingPaymentPositionResponse.pending_payment_position: object expected');
          message.pending_payment_position = $root.ununifi.derivatives.PendingPaymentPosition.fromObject(object.pending_payment_position);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryPendingPaymentPositionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @static
       * @param {ununifi.derivatives.QueryPendingPaymentPositionResponse} message QueryPendingPaymentPositionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPendingPaymentPositionResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pending_payment_position = null;
        if (message.pending_payment_position != null && message.hasOwnProperty('pending_payment_position'))
          object.pending_payment_position = $root.ununifi.derivatives.PendingPaymentPosition.toObject(
            message.pending_payment_position,
            options,
          );
        return object;
      };

      /**
       * Converts this QueryPendingPaymentPositionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryPendingPaymentPositionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPendingPaymentPositionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPendingPaymentPositionResponse;
    })();

    derivatives.QueryDLPTokenRateRequest = (function () {
      /**
       * Properties of a QueryDLPTokenRateRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryDLPTokenRateRequest
       */

      /**
       * Constructs a new QueryDLPTokenRateRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryDLPTokenRateRequest.
       * @implements IQueryDLPTokenRateRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryDLPTokenRateRequest=} [properties] Properties to set
       */
      function QueryDLPTokenRateRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryDLPTokenRateRequest message. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @static
       * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} message QueryDLPTokenRateRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDLPTokenRateRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryDLPTokenRateRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @static
       * @param {ununifi.derivatives.IQueryDLPTokenRateRequest} message QueryDLPTokenRateRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDLPTokenRateRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDLPTokenRateRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryDLPTokenRateRequest} QueryDLPTokenRateRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDLPTokenRateRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryDLPTokenRateRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDLPTokenRateRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryDLPTokenRateRequest} QueryDLPTokenRateRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDLPTokenRateRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDLPTokenRateRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDLPTokenRateRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryDLPTokenRateRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryDLPTokenRateRequest} QueryDLPTokenRateRequest
       */
      QueryDLPTokenRateRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryDLPTokenRateRequest) return object;
        return new $root.ununifi.derivatives.QueryDLPTokenRateRequest();
      };

      /**
       * Creates a plain object from a QueryDLPTokenRateRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @static
       * @param {ununifi.derivatives.QueryDLPTokenRateRequest} message QueryDLPTokenRateRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDLPTokenRateRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryDLPTokenRateRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryDLPTokenRateRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDLPTokenRateRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDLPTokenRateRequest;
    })();

    derivatives.QueryDLPTokenRateResponse = (function () {
      /**
       * Properties of a QueryDLPTokenRateResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryDLPTokenRateResponse
       * @property {string|null} [symbol] QueryDLPTokenRateResponse symbol
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rates] QueryDLPTokenRateResponse rates
       */

      /**
       * Constructs a new QueryDLPTokenRateResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryDLPTokenRateResponse.
       * @implements IQueryDLPTokenRateResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryDLPTokenRateResponse=} [properties] Properties to set
       */
      function QueryDLPTokenRateResponse(properties) {
        this.rates = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDLPTokenRateResponse symbol.
       * @member {string} symbol
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @instance
       */
      QueryDLPTokenRateResponse.prototype.symbol = '';

      /**
       * QueryDLPTokenRateResponse rates.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} rates
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @instance
       */
      QueryDLPTokenRateResponse.prototype.rates = $util.emptyArray;

      /**
       * Encodes the specified QueryDLPTokenRateResponse message. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @static
       * @param {ununifi.derivatives.IQueryDLPTokenRateResponse} message QueryDLPTokenRateResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDLPTokenRateResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.symbol);
        if (message.rates != null && message.rates.length)
          for (let i = 0; i < message.rates.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.rates[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryDLPTokenRateResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryDLPTokenRateResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @static
       * @param {ununifi.derivatives.IQueryDLPTokenRateResponse} message QueryDLPTokenRateResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDLPTokenRateResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDLPTokenRateResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryDLPTokenRateResponse} QueryDLPTokenRateResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDLPTokenRateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryDLPTokenRateResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.symbol = reader.string();
              break;
            case 2:
              if (!(message.rates && message.rates.length)) message.rates = [];
              message.rates.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDLPTokenRateResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryDLPTokenRateResponse} QueryDLPTokenRateResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDLPTokenRateResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDLPTokenRateResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDLPTokenRateResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.rates != null && message.hasOwnProperty('rates')) {
          if (!Array.isArray(message.rates)) return 'rates: array expected';
          for (let i = 0; i < message.rates.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.rates[i]);
            if (error) return 'rates.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryDLPTokenRateResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryDLPTokenRateResponse} QueryDLPTokenRateResponse
       */
      QueryDLPTokenRateResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryDLPTokenRateResponse) return object;
        let message = new $root.ununifi.derivatives.QueryDLPTokenRateResponse();
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.rates) {
          if (!Array.isArray(object.rates)) throw TypeError('.ununifi.derivatives.QueryDLPTokenRateResponse.rates: array expected');
          message.rates = [];
          for (let i = 0; i < object.rates.length; ++i) {
            if (typeof object.rates[i] !== 'object')
              throw TypeError('.ununifi.derivatives.QueryDLPTokenRateResponse.rates: object expected');
            message.rates[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rates[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryDLPTokenRateResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @static
       * @param {ununifi.derivatives.QueryDLPTokenRateResponse} message QueryDLPTokenRateResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDLPTokenRateResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rates = [];
        if (options.defaults) object.symbol = '';
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.rates && message.rates.length) {
          object.rates = [];
          for (let j = 0; j < message.rates.length; ++j)
            object.rates[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rates[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryDLPTokenRateResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryDLPTokenRateResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDLPTokenRateResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDLPTokenRateResponse;
    })();

    derivatives.QueryEstimateDLPTokenAmountRequest = (function () {
      /**
       * Properties of a QueryEstimateDLPTokenAmountRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryEstimateDLPTokenAmountRequest
       * @property {string|null} [mint_denom] QueryEstimateDLPTokenAmountRequest mint_denom
       * @property {string|null} [amount] QueryEstimateDLPTokenAmountRequest amount
       */

      /**
       * Constructs a new QueryEstimateDLPTokenAmountRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryEstimateDLPTokenAmountRequest.
       * @implements IQueryEstimateDLPTokenAmountRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest=} [properties] Properties to set
       */
      function QueryEstimateDLPTokenAmountRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateDLPTokenAmountRequest mint_denom.
       * @member {string} mint_denom
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @instance
       */
      QueryEstimateDLPTokenAmountRequest.prototype.mint_denom = '';

      /**
       * QueryEstimateDLPTokenAmountRequest amount.
       * @member {string} amount
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @instance
       */
      QueryEstimateDLPTokenAmountRequest.prototype.amount = '';

      /**
       * Encodes the specified QueryEstimateDLPTokenAmountRequest message. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @static
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} message QueryEstimateDLPTokenAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateDLPTokenAmountRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.mint_denom != null && Object.hasOwnProperty.call(message, 'mint_denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.mint_denom);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateDLPTokenAmountRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @static
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountRequest} message QueryEstimateDLPTokenAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateDLPTokenAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateDLPTokenAmountRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} QueryEstimateDLPTokenAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateDLPTokenAmountRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mint_denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateDLPTokenAmountRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} QueryEstimateDLPTokenAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateDLPTokenAmountRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateDLPTokenAmountRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateDLPTokenAmountRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.mint_denom != null && message.hasOwnProperty('mint_denom'))
          if (!$util.isString(message.mint_denom)) return 'mint_denom: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateDLPTokenAmountRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} QueryEstimateDLPTokenAmountRequest
       */
      QueryEstimateDLPTokenAmountRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest) return object;
        let message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountRequest();
        if (object.mint_denom != null) message.mint_denom = String(object.mint_denom);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateDLPTokenAmountRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @static
       * @param {ununifi.derivatives.QueryEstimateDLPTokenAmountRequest} message QueryEstimateDLPTokenAmountRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateDLPTokenAmountRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.mint_denom = '';
          object.amount = '';
        }
        if (message.mint_denom != null && message.hasOwnProperty('mint_denom')) object.mint_denom = message.mint_denom;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this QueryEstimateDLPTokenAmountRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateDLPTokenAmountRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateDLPTokenAmountRequest;
    })();

    derivatives.QueryEstimateDLPTokenAmountResponse = (function () {
      /**
       * Properties of a QueryEstimateDLPTokenAmountResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryEstimateDLPTokenAmountResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [estimated_dlp_amount] QueryEstimateDLPTokenAmountResponse estimated_dlp_amount
       * @property {cosmos.base.v1beta1.ICoin|null} [deposit_fee] QueryEstimateDLPTokenAmountResponse deposit_fee
       */

      /**
       * Constructs a new QueryEstimateDLPTokenAmountResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryEstimateDLPTokenAmountResponse.
       * @implements IQueryEstimateDLPTokenAmountResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountResponse=} [properties] Properties to set
       */
      function QueryEstimateDLPTokenAmountResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateDLPTokenAmountResponse estimated_dlp_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} estimated_dlp_amount
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @instance
       */
      QueryEstimateDLPTokenAmountResponse.prototype.estimated_dlp_amount = null;

      /**
       * QueryEstimateDLPTokenAmountResponse deposit_fee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit_fee
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @instance
       */
      QueryEstimateDLPTokenAmountResponse.prototype.deposit_fee = null;

      /**
       * Encodes the specified QueryEstimateDLPTokenAmountResponse message. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @static
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountResponse} message QueryEstimateDLPTokenAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateDLPTokenAmountResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.estimated_dlp_amount != null && Object.hasOwnProperty.call(message, 'estimated_dlp_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.estimated_dlp_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.deposit_fee != null && Object.hasOwnProperty.call(message, 'deposit_fee'))
          $root.cosmos.base.v1beta1.Coin.encode(message.deposit_fee, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateDLPTokenAmountResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @static
       * @param {ununifi.derivatives.IQueryEstimateDLPTokenAmountResponse} message QueryEstimateDLPTokenAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateDLPTokenAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateDLPTokenAmountResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} QueryEstimateDLPTokenAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateDLPTokenAmountResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.estimated_dlp_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.deposit_fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateDLPTokenAmountResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} QueryEstimateDLPTokenAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateDLPTokenAmountResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateDLPTokenAmountResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateDLPTokenAmountResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.estimated_dlp_amount != null && message.hasOwnProperty('estimated_dlp_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.estimated_dlp_amount);
          if (error) return 'estimated_dlp_amount.' + error;
        }
        if (message.deposit_fee != null && message.hasOwnProperty('deposit_fee')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit_fee);
          if (error) return 'deposit_fee.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateDLPTokenAmountResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} QueryEstimateDLPTokenAmountResponse
       */
      QueryEstimateDLPTokenAmountResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse) return object;
        let message = new $root.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse();
        if (object.estimated_dlp_amount != null) {
          if (typeof object.estimated_dlp_amount !== 'object')
            throw TypeError('.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.estimated_dlp_amount: object expected');
          message.estimated_dlp_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.estimated_dlp_amount);
        }
        if (object.deposit_fee != null) {
          if (typeof object.deposit_fee !== 'object')
            throw TypeError('.ununifi.derivatives.QueryEstimateDLPTokenAmountResponse.deposit_fee: object expected');
          message.deposit_fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit_fee);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateDLPTokenAmountResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @static
       * @param {ununifi.derivatives.QueryEstimateDLPTokenAmountResponse} message QueryEstimateDLPTokenAmountResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateDLPTokenAmountResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.estimated_dlp_amount = null;
          object.deposit_fee = null;
        }
        if (message.estimated_dlp_amount != null && message.hasOwnProperty('estimated_dlp_amount'))
          object.estimated_dlp_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.estimated_dlp_amount, options);
        if (message.deposit_fee != null && message.hasOwnProperty('deposit_fee'))
          object.deposit_fee = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit_fee, options);
        return object;
      };

      /**
       * Converts this QueryEstimateDLPTokenAmountResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryEstimateDLPTokenAmountResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateDLPTokenAmountResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateDLPTokenAmountResponse;
    })();

    derivatives.QueryEstimateRedeemTokenAmountRequest = (function () {
      /**
       * Properties of a QueryEstimateRedeemTokenAmountRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryEstimateRedeemTokenAmountRequest
       * @property {string|null} [redeem_denom] QueryEstimateRedeemTokenAmountRequest redeem_denom
       * @property {string|null} [lpt_amount] QueryEstimateRedeemTokenAmountRequest lpt_amount
       */

      /**
       * Constructs a new QueryEstimateRedeemTokenAmountRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryEstimateRedeemTokenAmountRequest.
       * @implements IQueryEstimateRedeemTokenAmountRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest=} [properties] Properties to set
       */
      function QueryEstimateRedeemTokenAmountRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemTokenAmountRequest redeem_denom.
       * @member {string} redeem_denom
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @instance
       */
      QueryEstimateRedeemTokenAmountRequest.prototype.redeem_denom = '';

      /**
       * QueryEstimateRedeemTokenAmountRequest lpt_amount.
       * @member {string} lpt_amount
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @instance
       */
      QueryEstimateRedeemTokenAmountRequest.prototype.lpt_amount = '';

      /**
       * Encodes the specified QueryEstimateRedeemTokenAmountRequest message. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @static
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} message QueryEstimateRedeemTokenAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemTokenAmountRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.redeem_denom != null && Object.hasOwnProperty.call(message, 'redeem_denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.redeem_denom);
        if (message.lpt_amount != null && Object.hasOwnProperty.call(message, 'lpt_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.lpt_amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemTokenAmountRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @static
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountRequest} message QueryEstimateRedeemTokenAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemTokenAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemTokenAmountRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} QueryEstimateRedeemTokenAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemTokenAmountRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redeem_denom = reader.string();
              break;
            case 2:
              message.lpt_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemTokenAmountRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} QueryEstimateRedeemTokenAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemTokenAmountRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemTokenAmountRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemTokenAmountRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.redeem_denom != null && message.hasOwnProperty('redeem_denom'))
          if (!$util.isString(message.redeem_denom)) return 'redeem_denom: string expected';
        if (message.lpt_amount != null && message.hasOwnProperty('lpt_amount'))
          if (!$util.isString(message.lpt_amount)) return 'lpt_amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemTokenAmountRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} QueryEstimateRedeemTokenAmountRequest
       */
      QueryEstimateRedeemTokenAmountRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest) return object;
        let message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest();
        if (object.redeem_denom != null) message.redeem_denom = String(object.redeem_denom);
        if (object.lpt_amount != null) message.lpt_amount = String(object.lpt_amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemTokenAmountRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @static
       * @param {ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest} message QueryEstimateRedeemTokenAmountRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemTokenAmountRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.redeem_denom = '';
          object.lpt_amount = '';
        }
        if (message.redeem_denom != null && message.hasOwnProperty('redeem_denom')) object.redeem_denom = message.redeem_denom;
        if (message.lpt_amount != null && message.hasOwnProperty('lpt_amount')) object.lpt_amount = message.lpt_amount;
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemTokenAmountRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemTokenAmountRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemTokenAmountRequest;
    })();

    derivatives.QueryEstimateRedeemTokenAmountResponse = (function () {
      /**
       * Properties of a QueryEstimateRedeemTokenAmountResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryEstimateRedeemTokenAmountResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] QueryEstimateRedeemTokenAmountResponse amount
       * @property {cosmos.base.v1beta1.ICoin|null} [fee] QueryEstimateRedeemTokenAmountResponse fee
       */

      /**
       * Constructs a new QueryEstimateRedeemTokenAmountResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryEstimateRedeemTokenAmountResponse.
       * @implements IQueryEstimateRedeemTokenAmountResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountResponse=} [properties] Properties to set
       */
      function QueryEstimateRedeemTokenAmountResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemTokenAmountResponse amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @instance
       */
      QueryEstimateRedeemTokenAmountResponse.prototype.amount = null;

      /**
       * QueryEstimateRedeemTokenAmountResponse fee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @instance
       */
      QueryEstimateRedeemTokenAmountResponse.prototype.fee = null;

      /**
       * Encodes the specified QueryEstimateRedeemTokenAmountResponse message. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @static
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountResponse} message QueryEstimateRedeemTokenAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemTokenAmountResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
          $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemTokenAmountResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @static
       * @param {ununifi.derivatives.IQueryEstimateRedeemTokenAmountResponse} message QueryEstimateRedeemTokenAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemTokenAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemTokenAmountResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} QueryEstimateRedeemTokenAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemTokenAmountResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemTokenAmountResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} QueryEstimateRedeemTokenAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemTokenAmountResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemTokenAmountResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemTokenAmountResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.fee != null && message.hasOwnProperty('fee')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
          if (error) return 'fee.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemTokenAmountResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} QueryEstimateRedeemTokenAmountResponse
       */
      QueryEstimateRedeemTokenAmountResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse) return object;
        let message = new $root.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse();
        if (object.amount != null) {
          if (typeof object.amount !== 'object')
            throw TypeError('.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.fee != null) {
          if (typeof object.fee !== 'object')
            throw TypeError('.ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse.fee: object expected');
          message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemTokenAmountResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @static
       * @param {ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse} message QueryEstimateRedeemTokenAmountResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemTokenAmountResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.amount = null;
          object.fee = null;
        }
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.fee != null && message.hasOwnProperty('fee'))
          object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemTokenAmountResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryEstimateRedeemTokenAmountResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemTokenAmountResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemTokenAmountResponse;
    })();

    derivatives.QueryAvailableAssetsInPoolRequest = (function () {
      /**
       * Properties of a QueryAvailableAssetsInPoolRequest.
       * @memberof ununifi.derivatives
       * @interface IQueryAvailableAssetsInPoolRequest
       * @property {string|null} [denom] QueryAvailableAssetsInPoolRequest denom
       */

      /**
       * Constructs a new QueryAvailableAssetsInPoolRequest.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAvailableAssetsInPoolRequest.
       * @implements IQueryAvailableAssetsInPoolRequest
       * @constructor
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest=} [properties] Properties to set
       */
      function QueryAvailableAssetsInPoolRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAvailableAssetsInPoolRequest denom.
       * @member {string} denom
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @instance
       */
      QueryAvailableAssetsInPoolRequest.prototype.denom = '';

      /**
       * Encodes the specified QueryAvailableAssetsInPoolRequest message. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @static
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} message QueryAvailableAssetsInPoolRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAvailableAssetsInPoolRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified QueryAvailableAssetsInPoolRequest message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @static
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolRequest} message QueryAvailableAssetsInPoolRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAvailableAssetsInPoolRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAvailableAssetsInPoolRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} QueryAvailableAssetsInPoolRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAvailableAssetsInPoolRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAvailableAssetsInPoolRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} QueryAvailableAssetsInPoolRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAvailableAssetsInPoolRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAvailableAssetsInPoolRequest message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAvailableAssetsInPoolRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        return null;
      };

      /**
       * Creates a QueryAvailableAssetsInPoolRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} QueryAvailableAssetsInPoolRequest
       */
      QueryAvailableAssetsInPoolRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest) return object;
        let message = new $root.ununifi.derivatives.QueryAvailableAssetsInPoolRequest();
        if (object.denom != null) message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a QueryAvailableAssetsInPoolRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @static
       * @param {ununifi.derivatives.QueryAvailableAssetsInPoolRequest} message QueryAvailableAssetsInPoolRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAvailableAssetsInPoolRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.denom = '';
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        return object;
      };

      /**
       * Converts this QueryAvailableAssetsInPoolRequest to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAvailableAssetsInPoolRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAvailableAssetsInPoolRequest;
    })();

    derivatives.QueryAvailableAssetsInPoolResponse = (function () {
      /**
       * Properties of a QueryAvailableAssetsInPoolResponse.
       * @memberof ununifi.derivatives
       * @interface IQueryAvailableAssetsInPoolResponse
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [available_assets] QueryAvailableAssetsInPoolResponse available_assets
       */

      /**
       * Constructs a new QueryAvailableAssetsInPoolResponse.
       * @memberof ununifi.derivatives
       * @classdesc Represents a QueryAvailableAssetsInPoolResponse.
       * @implements IQueryAvailableAssetsInPoolResponse
       * @constructor
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolResponse=} [properties] Properties to set
       */
      function QueryAvailableAssetsInPoolResponse(properties) {
        this.available_assets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAvailableAssetsInPoolResponse available_assets.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} available_assets
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @instance
       */
      QueryAvailableAssetsInPoolResponse.prototype.available_assets = $util.emptyArray;

      /**
       * Encodes the specified QueryAvailableAssetsInPoolResponse message. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @static
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolResponse} message QueryAvailableAssetsInPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAvailableAssetsInPoolResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.available_assets != null && message.available_assets.length)
          for (let i = 0; i < message.available_assets.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.available_assets[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAvailableAssetsInPoolResponse message, length delimited. Does not implicitly {@link ununifi.derivatives.QueryAvailableAssetsInPoolResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @static
       * @param {ununifi.derivatives.IQueryAvailableAssetsInPoolResponse} message QueryAvailableAssetsInPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAvailableAssetsInPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAvailableAssetsInPoolResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} QueryAvailableAssetsInPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAvailableAssetsInPoolResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.available_assets && message.available_assets.length)) message.available_assets = [];
              message.available_assets.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAvailableAssetsInPoolResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} QueryAvailableAssetsInPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAvailableAssetsInPoolResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAvailableAssetsInPoolResponse message.
       * @function verify
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAvailableAssetsInPoolResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.available_assets != null && message.hasOwnProperty('available_assets')) {
          if (!Array.isArray(message.available_assets)) return 'available_assets: array expected';
          for (let i = 0; i < message.available_assets.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.available_assets[i]);
            if (error) return 'available_assets.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryAvailableAssetsInPoolResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} QueryAvailableAssetsInPoolResponse
       */
      QueryAvailableAssetsInPoolResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse) return object;
        let message = new $root.ununifi.derivatives.QueryAvailableAssetsInPoolResponse();
        if (object.available_assets) {
          if (!Array.isArray(object.available_assets))
            throw TypeError('.ununifi.derivatives.QueryAvailableAssetsInPoolResponse.available_assets: array expected');
          message.available_assets = [];
          for (let i = 0; i < object.available_assets.length; ++i) {
            if (typeof object.available_assets[i] !== 'object')
              throw TypeError('.ununifi.derivatives.QueryAvailableAssetsInPoolResponse.available_assets: object expected');
            message.available_assets[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.available_assets[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAvailableAssetsInPoolResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @static
       * @param {ununifi.derivatives.QueryAvailableAssetsInPoolResponse} message QueryAvailableAssetsInPoolResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAvailableAssetsInPoolResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.available_assets = [];
        if (message.available_assets && message.available_assets.length) {
          object.available_assets = [];
          for (let j = 0; j < message.available_assets.length; ++j)
            object.available_assets[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.available_assets[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryAvailableAssetsInPoolResponse to JSON.
       * @function toJSON
       * @memberof ununifi.derivatives.QueryAvailableAssetsInPoolResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAvailableAssetsInPoolResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAvailableAssetsInPoolResponse;
    })();

    return derivatives;
  })();

  ununifi.ecosystemincentive = (function () {
    /**
     * Namespace ecosystemincentive.
     * @memberof ununifi
     * @namespace
     */
    const ecosystemincentive = {};

    ecosystemincentive.FrontendTxMemo = (function () {
      /**
       * Properties of a FrontendTxMemo.
       * @memberof ununifi.ecosystemincentive
       * @interface IFrontendTxMemo
       * @property {ununifi.ecosystemincentive.IFrontendMetadata|null} [frontend] FrontendTxMemo frontend
       */

      /**
       * Constructs a new FrontendTxMemo.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a FrontendTxMemo.
       * @implements IFrontendTxMemo
       * @constructor
       * @param {ununifi.ecosystemincentive.IFrontendTxMemo=} [properties] Properties to set
       */
      function FrontendTxMemo(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FrontendTxMemo frontend.
       * @member {ununifi.ecosystemincentive.IFrontendMetadata|null|undefined} frontend
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @instance
       */
      FrontendTxMemo.prototype.frontend = null;

      /**
       * Encodes the specified FrontendTxMemo message. Does not implicitly {@link ununifi.ecosystemincentive.FrontendTxMemo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @static
       * @param {ununifi.ecosystemincentive.IFrontendTxMemo} message FrontendTxMemo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FrontendTxMemo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.frontend != null && Object.hasOwnProperty.call(message, 'frontend'))
          $root.ununifi.ecosystemincentive.FrontendMetadata.encode(
            message.frontend,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FrontendTxMemo message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.FrontendTxMemo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @static
       * @param {ununifi.ecosystemincentive.IFrontendTxMemo} message FrontendTxMemo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FrontendTxMemo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FrontendTxMemo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.FrontendTxMemo} FrontendTxMemo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FrontendTxMemo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.FrontendTxMemo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.frontend = $root.ununifi.ecosystemincentive.FrontendMetadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FrontendTxMemo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.FrontendTxMemo} FrontendTxMemo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FrontendTxMemo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FrontendTxMemo message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FrontendTxMemo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.frontend != null && message.hasOwnProperty('frontend')) {
          let error = $root.ununifi.ecosystemincentive.FrontendMetadata.verify(message.frontend);
          if (error) return 'frontend.' + error;
        }
        return null;
      };

      /**
       * Creates a FrontendTxMemo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.FrontendTxMemo} FrontendTxMemo
       */
      FrontendTxMemo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.FrontendTxMemo) return object;
        let message = new $root.ununifi.ecosystemincentive.FrontendTxMemo();
        if (object.frontend != null) {
          if (typeof object.frontend !== 'object') throw TypeError('.ununifi.ecosystemincentive.FrontendTxMemo.frontend: object expected');
          message.frontend = $root.ununifi.ecosystemincentive.FrontendMetadata.fromObject(object.frontend);
        }
        return message;
      };

      /**
       * Creates a plain object from a FrontendTxMemo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @static
       * @param {ununifi.ecosystemincentive.FrontendTxMemo} message FrontendTxMemo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FrontendTxMemo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.frontend = null;
        if (message.frontend != null && message.hasOwnProperty('frontend'))
          object.frontend = $root.ununifi.ecosystemincentive.FrontendMetadata.toObject(message.frontend, options);
        return object;
      };

      /**
       * Converts this FrontendTxMemo to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.FrontendTxMemo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FrontendTxMemo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FrontendTxMemo;
    })();

    ecosystemincentive.FrontendMetadata = (function () {
      /**
       * Properties of a FrontendMetadata.
       * @memberof ununifi.ecosystemincentive
       * @interface IFrontendMetadata
       * @property {number|null} [version] FrontendMetadata version
       * @property {string|null} [recipient] FrontendMetadata recipient
       */

      /**
       * Constructs a new FrontendMetadata.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a FrontendMetadata.
       * @implements IFrontendMetadata
       * @constructor
       * @param {ununifi.ecosystemincentive.IFrontendMetadata=} [properties] Properties to set
       */
      function FrontendMetadata(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FrontendMetadata version.
       * @member {number} version
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @instance
       */
      FrontendMetadata.prototype.version = 0;

      /**
       * FrontendMetadata recipient.
       * @member {string} recipient
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @instance
       */
      FrontendMetadata.prototype.recipient = '';

      /**
       * Encodes the specified FrontendMetadata message. Does not implicitly {@link ununifi.ecosystemincentive.FrontendMetadata.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @static
       * @param {ununifi.ecosystemincentive.IFrontendMetadata} message FrontendMetadata message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FrontendMetadata.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.version != null && Object.hasOwnProperty.call(message, 'version'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.version);
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.recipient);
        return writer;
      };

      /**
       * Encodes the specified FrontendMetadata message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.FrontendMetadata.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @static
       * @param {ununifi.ecosystemincentive.IFrontendMetadata} message FrontendMetadata message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FrontendMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FrontendMetadata message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.FrontendMetadata} FrontendMetadata
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FrontendMetadata.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.FrontendMetadata();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.uint32();
              break;
            case 2:
              message.recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FrontendMetadata message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.FrontendMetadata} FrontendMetadata
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FrontendMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FrontendMetadata message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FrontendMetadata.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.version != null && message.hasOwnProperty('version'))
          if (!$util.isInteger(message.version)) return 'version: integer expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        return null;
      };

      /**
       * Creates a FrontendMetadata message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.FrontendMetadata} FrontendMetadata
       */
      FrontendMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.FrontendMetadata) return object;
        let message = new $root.ununifi.ecosystemincentive.FrontendMetadata();
        if (object.version != null) message.version = object.version >>> 0;
        if (object.recipient != null) message.recipient = String(object.recipient);
        return message;
      };

      /**
       * Creates a plain object from a FrontendMetadata message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @static
       * @param {ununifi.ecosystemincentive.FrontendMetadata} message FrontendMetadata
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FrontendMetadata.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.version = 0;
          object.recipient = '';
        }
        if (message.version != null && message.hasOwnProperty('version')) object.version = message.version;
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        return object;
      };

      /**
       * Converts this FrontendMetadata to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.FrontendMetadata
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FrontendMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FrontendMetadata;
    })();

    ecosystemincentive.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawAllRewards}.
       * @memberof ununifi.ecosystemincentive.Msg
       * @typedef WithdrawAllRewardsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} [response] MsgWithdrawAllRewardsResponse
       */

      /**
       * Calls WithdrawAllRewards.
       * @function withdrawAllRewards
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
       * @param {ununifi.ecosystemincentive.Msg.WithdrawAllRewardsCallback} callback Node-style callback called with the error, if any, and MsgWithdrawAllRewardsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawAllRewards = function withdrawAllRewards(request, callback) {
          return this.rpcCall(
            withdrawAllRewards,
            $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards,
            $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawAllRewards' },
      );

      /**
       * Calls WithdrawAllRewards.
       * @function withdrawAllRewards
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} request MsgWithdrawAllRewards message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Msg#withdrawReward}.
       * @memberof ununifi.ecosystemincentive.Msg
       * @typedef WithdrawRewardCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} [response] MsgWithdrawRewardResponse
       */

      /**
       * Calls WithdrawReward.
       * @function withdrawReward
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
       * @param {ununifi.ecosystemincentive.Msg.WithdrawRewardCallback} callback Node-style callback called with the error, if any, and MsgWithdrawRewardResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawReward = function withdrawReward(request, callback) {
          return this.rpcCall(
            withdrawReward,
            $root.ununifi.ecosystemincentive.MsgWithdrawReward,
            $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawReward' },
      );

      /**
       * Calls WithdrawReward.
       * @function withdrawReward
       * @memberof ununifi.ecosystemincentive.Msg
       * @instance
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} request MsgWithdrawReward message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.MsgWithdrawRewardResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    ecosystemincentive.MsgWithdrawAllRewards = (function () {
      /**
       * Properties of a MsgWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawAllRewards
       * @property {string|null} [sender] MsgWithdrawAllRewards sender
       */

      /**
       * Constructs a new MsgWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawAllRewards.
       * @implements IMsgWithdrawAllRewards
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards=} [properties] Properties to set
       */
      function MsgWithdrawAllRewards(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawAllRewards sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @instance
       */
      MsgWithdrawAllRewards.prototype.sender = '';

      /**
       * Encodes the specified MsgWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewards.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewards.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewards} message MsgWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewards.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawAllRewards message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawAllRewards message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawAllRewards.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewards} MsgWithdrawAllRewards
       */
      MsgWithdrawAllRewards.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards) return object;
        let message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewards();
        if (object.sender != null) message.sender = String(object.sender);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawAllRewards message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewards} message MsgWithdrawAllRewards
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawAllRewards.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        return object;
      };

      /**
       * Converts this MsgWithdrawAllRewards to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewards
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawAllRewards.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawAllRewards;
    })();

    ecosystemincentive.MsgWithdrawAllRewardsResponse = (function () {
      /**
       * Properties of a MsgWithdrawAllRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawAllRewardsResponse
       */

      /**
       * Constructs a new MsgWithdrawAllRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawAllRewardsResponse.
       * @implements IMsgWithdrawAllRewardsResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse=} [properties] Properties to set
       */
      function MsgWithdrawAllRewardsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawAllRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewardsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawAllRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawAllRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewardsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawAllRewardsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawAllRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawAllRewardsResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawAllRewardsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawAllRewardsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} MsgWithdrawAllRewardsResponse
       */
      MsgWithdrawAllRewardsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse) return object;
        return new $root.ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawAllRewardsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse} message MsgWithdrawAllRewardsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawAllRewardsResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawAllRewardsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawAllRewardsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawAllRewardsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawAllRewardsResponse;
    })();

    ecosystemincentive.MsgWithdrawReward = (function () {
      /**
       * Properties of a MsgWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawReward
       * @property {string|null} [sender] MsgWithdrawReward sender
       * @property {string|null} [denom] MsgWithdrawReward denom
       */

      /**
       * Constructs a new MsgWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawReward.
       * @implements IMsgWithdrawReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward=} [properties] Properties to set
       */
      function MsgWithdrawReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawReward sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @instance
       */
      MsgWithdrawReward.prototype.sender = '';

      /**
       * MsgWithdrawReward denom.
       * @member {string} denom
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @instance
       */
      MsgWithdrawReward.prototype.denom = '';

      /**
       * Encodes the specified MsgWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawReward} message MsgWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawReward} MsgWithdrawReward
       */
      MsgWithdrawReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawReward) return object;
        let message = new $root.ununifi.ecosystemincentive.MsgWithdrawReward();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.denom != null) message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawReward} message MsgWithdrawReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.denom = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        return object;
      };

      /**
       * Converts this MsgWithdrawReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawReward;
    })();

    ecosystemincentive.MsgWithdrawRewardResponse = (function () {
      /**
       * Properties of a MsgWithdrawRewardResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IMsgWithdrawRewardResponse
       */

      /**
       * Constructs a new MsgWithdrawRewardResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a MsgWithdrawRewardResponse.
       * @implements IMsgWithdrawRewardResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse=} [properties] Properties to set
       */
      function MsgWithdrawRewardResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawRewardResponse message. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawRewardResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawRewardResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.MsgWithdrawRewardResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.IMsgWithdrawRewardResponse} message MsgWithdrawRewardResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawRewardResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawRewardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawRewardResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawRewardResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawRewardResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawRewardResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawRewardResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} MsgWithdrawRewardResponse
       */
      MsgWithdrawRewardResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse) return object;
        return new $root.ununifi.ecosystemincentive.MsgWithdrawRewardResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawRewardResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @static
       * @param {ununifi.ecosystemincentive.MsgWithdrawRewardResponse} message MsgWithdrawRewardResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawRewardResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawRewardResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.MsgWithdrawRewardResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawRewardResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawRewardResponse;
    })();

    ecosystemincentive.RewardRecord = (function () {
      /**
       * Properties of a RewardRecord.
       * @memberof ununifi.ecosystemincentive
       * @interface IRewardRecord
       * @property {string|null} [address] RewardRecord address
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] RewardRecord rewards
       */

      /**
       * Constructs a new RewardRecord.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a RewardRecord.
       * @implements IRewardRecord
       * @constructor
       * @param {ununifi.ecosystemincentive.IRewardRecord=} [properties] Properties to set
       */
      function RewardRecord(properties) {
        this.rewards = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardRecord address.
       * @member {string} address
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @instance
       */
      RewardRecord.prototype.address = '';

      /**
       * RewardRecord rewards.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @instance
       */
      RewardRecord.prototype.rewards = $util.emptyArray;

      /**
       * Encodes the specified RewardRecord message. Does not implicitly {@link ununifi.ecosystemincentive.RewardRecord.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @static
       * @param {ununifi.ecosystemincentive.IRewardRecord} message RewardRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardRecord.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
        if (message.rewards != null && message.rewards.length)
          for (let i = 0; i < message.rewards.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified RewardRecord message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardRecord.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @static
       * @param {ununifi.ecosystemincentive.IRewardRecord} message RewardRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardRecord.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardRecord message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.RewardRecord} RewardRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardRecord.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.RewardRecord();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              if (!(message.rewards && message.rewards.length)) message.rewards = [];
              message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardRecord message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.RewardRecord} RewardRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardRecord.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardRecord message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardRecord.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        if (message.rewards != null && message.hasOwnProperty('rewards')) {
          if (!Array.isArray(message.rewards)) return 'rewards: array expected';
          for (let i = 0; i < message.rewards.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
            if (error) return 'rewards.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a RewardRecord message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.RewardRecord} RewardRecord
       */
      RewardRecord.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.RewardRecord) return object;
        let message = new $root.ununifi.ecosystemincentive.RewardRecord();
        if (object.address != null) message.address = String(object.address);
        if (object.rewards) {
          if (!Array.isArray(object.rewards)) throw TypeError('.ununifi.ecosystemincentive.RewardRecord.rewards: array expected');
          message.rewards = [];
          for (let i = 0; i < object.rewards.length; ++i) {
            if (typeof object.rewards[i] !== 'object') throw TypeError('.ununifi.ecosystemincentive.RewardRecord.rewards: object expected');
            message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a RewardRecord message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @static
       * @param {ununifi.ecosystemincentive.RewardRecord} message RewardRecord
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardRecord.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rewards = [];
        if (options.defaults) object.address = '';
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        if (message.rewards && message.rewards.length) {
          object.rewards = [];
          for (let j = 0; j < message.rewards.length; ++j)
            object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
        }
        return object;
      };

      /**
       * Converts this RewardRecord to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.RewardRecord
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardRecord.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardRecord;
    })();

    ecosystemincentive.EventWithdrawAllRewards = (function () {
      /**
       * Properties of an EventWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventWithdrawAllRewards
       * @property {string|null} [sender] EventWithdrawAllRewards sender
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [all_withdrawn_rewards] EventWithdrawAllRewards all_withdrawn_rewards
       */

      /**
       * Constructs a new EventWithdrawAllRewards.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventWithdrawAllRewards.
       * @implements IEventWithdrawAllRewards
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards=} [properties] Properties to set
       */
      function EventWithdrawAllRewards(properties) {
        this.all_withdrawn_rewards = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventWithdrawAllRewards sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @instance
       */
      EventWithdrawAllRewards.prototype.sender = '';

      /**
       * EventWithdrawAllRewards all_withdrawn_rewards.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} all_withdrawn_rewards
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @instance
       */
      EventWithdrawAllRewards.prototype.all_withdrawn_rewards = $util.emptyArray;

      /**
       * Encodes the specified EventWithdrawAllRewards message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawAllRewards.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.all_withdrawn_rewards != null && message.all_withdrawn_rewards.length)
          for (let i = 0; i < message.all_withdrawn_rewards.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(
              message.all_withdrawn_rewards[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EventWithdrawAllRewards message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawAllRewards.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawAllRewards} message EventWithdrawAllRewards message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawAllRewards.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventWithdrawAllRewards message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawAllRewards.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              if (!(message.all_withdrawn_rewards && message.all_withdrawn_rewards.length)) message.all_withdrawn_rewards = [];
              message.all_withdrawn_rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventWithdrawAllRewards message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawAllRewards.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventWithdrawAllRewards message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventWithdrawAllRewards.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.all_withdrawn_rewards != null && message.hasOwnProperty('all_withdrawn_rewards')) {
          if (!Array.isArray(message.all_withdrawn_rewards)) return 'all_withdrawn_rewards: array expected';
          for (let i = 0; i < message.all_withdrawn_rewards.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.all_withdrawn_rewards[i]);
            if (error) return 'all_withdrawn_rewards.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an EventWithdrawAllRewards message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventWithdrawAllRewards} EventWithdrawAllRewards
       */
      EventWithdrawAllRewards.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawAllRewards) return object;
        let message = new $root.ununifi.ecosystemincentive.EventWithdrawAllRewards();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.all_withdrawn_rewards) {
          if (!Array.isArray(object.all_withdrawn_rewards))
            throw TypeError('.ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: array expected');
          message.all_withdrawn_rewards = [];
          for (let i = 0; i < object.all_withdrawn_rewards.length; ++i) {
            if (typeof object.all_withdrawn_rewards[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.EventWithdrawAllRewards.all_withdrawn_rewards: object expected');
            message.all_withdrawn_rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.all_withdrawn_rewards[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EventWithdrawAllRewards message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @static
       * @param {ununifi.ecosystemincentive.EventWithdrawAllRewards} message EventWithdrawAllRewards
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventWithdrawAllRewards.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.all_withdrawn_rewards = [];
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.all_withdrawn_rewards && message.all_withdrawn_rewards.length) {
          object.all_withdrawn_rewards = [];
          for (let j = 0; j < message.all_withdrawn_rewards.length; ++j)
            object.all_withdrawn_rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.all_withdrawn_rewards[j], options);
        }
        return object;
      };

      /**
       * Converts this EventWithdrawAllRewards to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventWithdrawAllRewards
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventWithdrawAllRewards.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventWithdrawAllRewards;
    })();

    ecosystemincentive.EventWithdrawReward = (function () {
      /**
       * Properties of an EventWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventWithdrawReward
       * @property {string|null} [sender] EventWithdrawReward sender
       * @property {cosmos.base.v1beta1.ICoin|null} [withdrawn_reward] EventWithdrawReward withdrawn_reward
       */

      /**
       * Constructs a new EventWithdrawReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventWithdrawReward.
       * @implements IEventWithdrawReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventWithdrawReward=} [properties] Properties to set
       */
      function EventWithdrawReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventWithdrawReward sender.
       * @member {string} sender
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @instance
       */
      EventWithdrawReward.prototype.sender = '';

      /**
       * EventWithdrawReward withdrawn_reward.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} withdrawn_reward
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @instance
       */
      EventWithdrawReward.prototype.withdrawn_reward = null;

      /**
       * Encodes the specified EventWithdrawReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.withdrawn_reward != null && Object.hasOwnProperty.call(message, 'withdrawn_reward'))
          $root.cosmos.base.v1beta1.Coin.encode(message.withdrawn_reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EventWithdrawReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventWithdrawReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventWithdrawReward} message EventWithdrawReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventWithdrawReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventWithdrawReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventWithdrawReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventWithdrawReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventWithdrawReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventWithdrawReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.withdrawn_reward != null && message.hasOwnProperty('withdrawn_reward')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.withdrawn_reward);
          if (error) return 'withdrawn_reward.' + error;
        }
        return null;
      };

      /**
       * Creates an EventWithdrawReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventWithdrawReward} EventWithdrawReward
       */
      EventWithdrawReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventWithdrawReward) return object;
        let message = new $root.ununifi.ecosystemincentive.EventWithdrawReward();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.withdrawn_reward != null) {
          if (typeof object.withdrawn_reward !== 'object')
            throw TypeError('.ununifi.ecosystemincentive.EventWithdrawReward.withdrawn_reward: object expected');
          message.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.withdrawn_reward);
        }
        return message;
      };

      /**
       * Creates a plain object from an EventWithdrawReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @static
       * @param {ununifi.ecosystemincentive.EventWithdrawReward} message EventWithdrawReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventWithdrawReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.withdrawn_reward = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.withdrawn_reward != null && message.hasOwnProperty('withdrawn_reward'))
          object.withdrawn_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.withdrawn_reward, options);
        return object;
      };

      /**
       * Converts this EventWithdrawReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventWithdrawReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventWithdrawReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventWithdrawReward;
    })();

    ecosystemincentive.EventRecordedRecipientWithNftId = (function () {
      /**
       * Properties of an EventRecordedRecipientWithNftId.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventRecordedRecipientWithNftId
       * @property {string|null} [recipient] EventRecordedRecipientWithNftId recipient
       * @property {string|null} [class_id] EventRecordedRecipientWithNftId class_id
       * @property {string|null} [token_id] EventRecordedRecipientWithNftId token_id
       */

      /**
       * Constructs a new EventRecordedRecipientWithNftId.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventRecordedRecipientWithNftId.
       * @implements IEventRecordedRecipientWithNftId
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventRecordedRecipientWithNftId=} [properties] Properties to set
       */
      function EventRecordedRecipientWithNftId(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventRecordedRecipientWithNftId recipient.
       * @member {string} recipient
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @instance
       */
      EventRecordedRecipientWithNftId.prototype.recipient = '';

      /**
       * EventRecordedRecipientWithNftId class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @instance
       */
      EventRecordedRecipientWithNftId.prototype.class_id = '';

      /**
       * EventRecordedRecipientWithNftId token_id.
       * @member {string} token_id
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @instance
       */
      EventRecordedRecipientWithNftId.prototype.token_id = '';

      /**
       * Encodes the specified EventRecordedRecipientWithNftId message. Does not implicitly {@link ununifi.ecosystemincentive.EventRecordedRecipientWithNftId.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @static
       * @param {ununifi.ecosystemincentive.IEventRecordedRecipientWithNftId} message EventRecordedRecipientWithNftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRecordedRecipientWithNftId.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.recipient);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventRecordedRecipientWithNftId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventRecordedRecipientWithNftId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @static
       * @param {ununifi.ecosystemincentive.IEventRecordedRecipientWithNftId} message EventRecordedRecipientWithNftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRecordedRecipientWithNftId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventRecordedRecipientWithNftId message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventRecordedRecipientWithNftId} EventRecordedRecipientWithNftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRecordedRecipientWithNftId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventRecordedRecipientWithNftId();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.recipient = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventRecordedRecipientWithNftId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventRecordedRecipientWithNftId} EventRecordedRecipientWithNftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRecordedRecipientWithNftId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventRecordedRecipientWithNftId message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventRecordedRecipientWithNftId.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventRecordedRecipientWithNftId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventRecordedRecipientWithNftId} EventRecordedRecipientWithNftId
       */
      EventRecordedRecipientWithNftId.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventRecordedRecipientWithNftId) return object;
        let message = new $root.ununifi.ecosystemincentive.EventRecordedRecipientWithNftId();
        if (object.recipient != null) message.recipient = String(object.recipient);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventRecordedRecipientWithNftId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @static
       * @param {ununifi.ecosystemincentive.EventRecordedRecipientWithNftId} message EventRecordedRecipientWithNftId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventRecordedRecipientWithNftId.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.recipient = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventRecordedRecipientWithNftId to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventRecordedRecipientWithNftId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventRecordedRecipientWithNftId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventRecordedRecipientWithNftId;
    })();

    ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward = (function () {
      /**
       * Properties of an EventDeletedNftIdRecordedForFrontendReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventDeletedNftIdRecordedForFrontendReward
       * @property {string|null} [recipient] EventDeletedNftIdRecordedForFrontendReward recipient
       * @property {string|null} [class_id] EventDeletedNftIdRecordedForFrontendReward class_id
       * @property {string|null} [token_id] EventDeletedNftIdRecordedForFrontendReward token_id
       */

      /**
       * Constructs a new EventDeletedNftIdRecordedForFrontendReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventDeletedNftIdRecordedForFrontendReward.
       * @implements IEventDeletedNftIdRecordedForFrontendReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward=} [properties] Properties to set
       */
      function EventDeletedNftIdRecordedForFrontendReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventDeletedNftIdRecordedForFrontendReward recipient.
       * @member {string} recipient
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.recipient = '';

      /**
       * EventDeletedNftIdRecordedForFrontendReward class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.class_id = '';

      /**
       * EventDeletedNftIdRecordedForFrontendReward token_id.
       * @member {string} token_id
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.token_id = '';

      /**
       * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventDeletedNftIdRecordedForFrontendReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.recipient);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventDeletedNftIdRecordedForFrontendReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventDeletedNftIdRecordedForFrontendReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventDeletedNftIdRecordedForFrontendReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.recipient = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventDeletedNftIdRecordedForFrontendReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventDeletedNftIdRecordedForFrontendReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventDeletedNftIdRecordedForFrontendReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventDeletedNftIdRecordedForFrontendReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventDeletedNftIdRecordedForFrontendReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} EventDeletedNftIdRecordedForFrontendReward
       */
      EventDeletedNftIdRecordedForFrontendReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward) return object;
        let message = new $root.ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward();
        if (object.recipient != null) message.recipient = String(object.recipient);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventDeletedNftIdRecordedForFrontendReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @static
       * @param {ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward} message EventDeletedNftIdRecordedForFrontendReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventDeletedNftIdRecordedForFrontendReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.recipient = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventDeletedNftIdRecordedForFrontendReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventDeletedNftIdRecordedForFrontendReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventDeletedNftIdRecordedForFrontendReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventDeletedNftIdRecordedForFrontendReward;
    })();

    ecosystemincentive.EventNotRecordedNftId = (function () {
      /**
       * Properties of an EventNotRecordedNftId.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventNotRecordedNftId
       * @property {string|null} [class_id] EventNotRecordedNftId class_id
       * @property {string|null} [token_id] EventNotRecordedNftId token_id
       */

      /**
       * Constructs a new EventNotRecordedNftId.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventNotRecordedNftId.
       * @implements IEventNotRecordedNftId
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId=} [properties] Properties to set
       */
      function EventNotRecordedNftId(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventNotRecordedNftId class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @instance
       */
      EventNotRecordedNftId.prototype.class_id = '';

      /**
       * EventNotRecordedNftId token_id.
       * @member {string} token_id
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @instance
       */
      EventNotRecordedNftId.prototype.token_id = '';

      /**
       * Encodes the specified EventNotRecordedNftId message. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventNotRecordedNftId.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventNotRecordedNftId message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventNotRecordedNftId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {ununifi.ecosystemincentive.IEventNotRecordedNftId} message EventNotRecordedNftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventNotRecordedNftId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventNotRecordedNftId message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventNotRecordedNftId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventNotRecordedNftId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventNotRecordedNftId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventNotRecordedNftId message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventNotRecordedNftId.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventNotRecordedNftId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventNotRecordedNftId} EventNotRecordedNftId
       */
      EventNotRecordedNftId.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventNotRecordedNftId) return object;
        let message = new $root.ununifi.ecosystemincentive.EventNotRecordedNftId();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventNotRecordedNftId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @static
       * @param {ununifi.ecosystemincentive.EventNotRecordedNftId} message EventNotRecordedNftId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventNotRecordedNftId.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.token_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventNotRecordedNftId to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventNotRecordedNftId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventNotRecordedNftId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventNotRecordedNftId;
    })();

    ecosystemincentive.EventUpdatedReward = (function () {
      /**
       * Properties of an EventUpdatedReward.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventUpdatedReward
       * @property {string|null} [recipient] EventUpdatedReward recipient
       * @property {cosmos.base.v1beta1.ICoin|null} [earned_reward] EventUpdatedReward earned_reward
       */

      /**
       * Constructs a new EventUpdatedReward.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventUpdatedReward.
       * @implements IEventUpdatedReward
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventUpdatedReward=} [properties] Properties to set
       */
      function EventUpdatedReward(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventUpdatedReward recipient.
       * @member {string} recipient
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @instance
       */
      EventUpdatedReward.prototype.recipient = '';

      /**
       * EventUpdatedReward earned_reward.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} earned_reward
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @instance
       */
      EventUpdatedReward.prototype.earned_reward = null;

      /**
       * Encodes the specified EventUpdatedReward message. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdatedReward.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.recipient);
        if (message.earned_reward != null && Object.hasOwnProperty.call(message, 'earned_reward'))
          $root.cosmos.base.v1beta1.Coin.encode(message.earned_reward, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EventUpdatedReward message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventUpdatedReward.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {ununifi.ecosystemincentive.IEventUpdatedReward} message EventUpdatedReward message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdatedReward.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventUpdatedReward message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdatedReward.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.recipient = reader.string();
              break;
            case 2:
              message.earned_reward = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventUpdatedReward message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdatedReward.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventUpdatedReward message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventUpdatedReward.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        if (message.earned_reward != null && message.hasOwnProperty('earned_reward')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.earned_reward);
          if (error) return 'earned_reward.' + error;
        }
        return null;
      };

      /**
       * Creates an EventUpdatedReward message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventUpdatedReward} EventUpdatedReward
       */
      EventUpdatedReward.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventUpdatedReward) return object;
        let message = new $root.ununifi.ecosystemincentive.EventUpdatedReward();
        if (object.recipient != null) message.recipient = String(object.recipient);
        if (object.earned_reward != null) {
          if (typeof object.earned_reward !== 'object')
            throw TypeError('.ununifi.ecosystemincentive.EventUpdatedReward.earned_reward: object expected');
          message.earned_reward = $root.cosmos.base.v1beta1.Coin.fromObject(object.earned_reward);
        }
        return message;
      };

      /**
       * Creates a plain object from an EventUpdatedReward message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @static
       * @param {ununifi.ecosystemincentive.EventUpdatedReward} message EventUpdatedReward
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventUpdatedReward.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.recipient = '';
          object.earned_reward = null;
        }
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        if (message.earned_reward != null && message.hasOwnProperty('earned_reward'))
          object.earned_reward = $root.cosmos.base.v1beta1.Coin.toObject(message.earned_reward, options);
        return object;
      };

      /**
       * Converts this EventUpdatedReward to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventUpdatedReward
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventUpdatedReward.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventUpdatedReward;
    })();

    ecosystemincentive.EventDistributionForStakers = (function () {
      /**
       * Properties of an EventDistributionForStakers.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventDistributionForStakers
       * @property {cosmos.base.v1beta1.ICoin|null} [distributed_amount] EventDistributionForStakers distributed_amount
       * @property {Long|null} [block_height] EventDistributionForStakers block_height
       */

      /**
       * Constructs a new EventDistributionForStakers.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventDistributionForStakers.
       * @implements IEventDistributionForStakers
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventDistributionForStakers=} [properties] Properties to set
       */
      function EventDistributionForStakers(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventDistributionForStakers distributed_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} distributed_amount
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @instance
       */
      EventDistributionForStakers.prototype.distributed_amount = null;

      /**
       * EventDistributionForStakers block_height.
       * @member {Long} block_height
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @instance
       */
      EventDistributionForStakers.prototype.block_height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Encodes the specified EventDistributionForStakers message. Does not implicitly {@link ununifi.ecosystemincentive.EventDistributionForStakers.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @static
       * @param {ununifi.ecosystemincentive.IEventDistributionForStakers} message EventDistributionForStakers message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventDistributionForStakers.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.distributed_amount != null && Object.hasOwnProperty.call(message, 'distributed_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.distributed_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.block_height != null && Object.hasOwnProperty.call(message, 'block_height'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.block_height);
        return writer;
      };

      /**
       * Encodes the specified EventDistributionForStakers message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventDistributionForStakers.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @static
       * @param {ununifi.ecosystemincentive.IEventDistributionForStakers} message EventDistributionForStakers message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventDistributionForStakers.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventDistributionForStakers message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventDistributionForStakers} EventDistributionForStakers
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventDistributionForStakers.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventDistributionForStakers();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.distributed_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.block_height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventDistributionForStakers message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventDistributionForStakers} EventDistributionForStakers
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventDistributionForStakers.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventDistributionForStakers message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventDistributionForStakers.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.distributed_amount != null && message.hasOwnProperty('distributed_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.distributed_amount);
          if (error) return 'distributed_amount.' + error;
        }
        if (message.block_height != null && message.hasOwnProperty('block_height'))
          if (
            !$util.isInteger(message.block_height) &&
            !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high))
          )
            return 'block_height: integer|Long expected';
        return null;
      };

      /**
       * Creates an EventDistributionForStakers message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventDistributionForStakers} EventDistributionForStakers
       */
      EventDistributionForStakers.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventDistributionForStakers) return object;
        let message = new $root.ununifi.ecosystemincentive.EventDistributionForStakers();
        if (object.distributed_amount != null) {
          if (typeof object.distributed_amount !== 'object')
            throw TypeError('.ununifi.ecosystemincentive.EventDistributionForStakers.distributed_amount: object expected');
          message.distributed_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.distributed_amount);
        }
        if (object.block_height != null)
          if ($util.Long) (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = false;
          else if (typeof object.block_height === 'string') message.block_height = parseInt(object.block_height, 10);
          else if (typeof object.block_height === 'number') message.block_height = object.block_height;
          else if (typeof object.block_height === 'object')
            message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber();
        return message;
      };

      /**
       * Creates a plain object from an EventDistributionForStakers message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @static
       * @param {ununifi.ecosystemincentive.EventDistributionForStakers} message EventDistributionForStakers
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventDistributionForStakers.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.distributed_amount = null;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.block_height = options.longs === String ? '0' : 0;
        }
        if (message.distributed_amount != null && message.hasOwnProperty('distributed_amount'))
          object.distributed_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.distributed_amount, options);
        if (message.block_height != null && message.hasOwnProperty('block_height'))
          if (typeof message.block_height === 'number')
            object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
          else
            object.block_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.block_height)
                : options.longs === Number
                ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber()
                : message.block_height;
        return object;
      };

      /**
       * Converts this EventDistributionForStakers to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventDistributionForStakers
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventDistributionForStakers.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventDistributionForStakers;
    })();

    ecosystemincentive.EventVersionUnmatched = (function () {
      /**
       * Properties of an EventVersionUnmatched.
       * @memberof ununifi.ecosystemincentive
       * @interface IEventVersionUnmatched
       * @property {number|null} [unmatched_version] EventVersionUnmatched unmatched_version
       * @property {string|null} [class_id] EventVersionUnmatched class_id
       * @property {string|null} [token_id] EventVersionUnmatched token_id
       */

      /**
       * Constructs a new EventVersionUnmatched.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents an EventVersionUnmatched.
       * @implements IEventVersionUnmatched
       * @constructor
       * @param {ununifi.ecosystemincentive.IEventVersionUnmatched=} [properties] Properties to set
       */
      function EventVersionUnmatched(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventVersionUnmatched unmatched_version.
       * @member {number} unmatched_version
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       */
      EventVersionUnmatched.prototype.unmatched_version = 0;

      /**
       * EventVersionUnmatched class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       */
      EventVersionUnmatched.prototype.class_id = '';

      /**
       * EventVersionUnmatched token_id.
       * @member {string} token_id
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       */
      EventVersionUnmatched.prototype.token_id = '';

      /**
       * Encodes the specified EventVersionUnmatched message. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventVersionUnmatched.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.unmatched_version != null && Object.hasOwnProperty.call(message, 'unmatched_version'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint32(message.unmatched_version);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventVersionUnmatched message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.EventVersionUnmatched.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {ununifi.ecosystemincentive.IEventVersionUnmatched} message EventVersionUnmatched message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventVersionUnmatched.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventVersionUnmatched message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventVersionUnmatched.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unmatched_version = reader.uint32();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventVersionUnmatched message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventVersionUnmatched.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventVersionUnmatched message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventVersionUnmatched.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.unmatched_version != null && message.hasOwnProperty('unmatched_version'))
          if (!$util.isInteger(message.unmatched_version)) return 'unmatched_version: integer expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventVersionUnmatched message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.EventVersionUnmatched} EventVersionUnmatched
       */
      EventVersionUnmatched.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.EventVersionUnmatched) return object;
        let message = new $root.ununifi.ecosystemincentive.EventVersionUnmatched();
        if (object.unmatched_version != null) message.unmatched_version = object.unmatched_version >>> 0;
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventVersionUnmatched message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @static
       * @param {ununifi.ecosystemincentive.EventVersionUnmatched} message EventVersionUnmatched
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventVersionUnmatched.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.unmatched_version = 0;
          object.class_id = '';
          object.token_id = '';
        }
        if (message.unmatched_version != null && message.hasOwnProperty('unmatched_version'))
          object.unmatched_version = message.unmatched_version;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventVersionUnmatched to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.EventVersionUnmatched
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventVersionUnmatched.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventVersionUnmatched;
    })();

    ecosystemincentive.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.ecosystemincentive
       * @interface IGenesisState
       * @property {ununifi.ecosystemincentive.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.ecosystemincentive.IRewardRecord>|null} [reward_records] GenesisState reward_records
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.ecosystemincentive.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.reward_records = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState reward_records.
       * @member {Array.<ununifi.ecosystemincentive.IRewardRecord>} reward_records
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @instance
       */
      GenesisState.prototype.reward_records = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.reward_records != null && message.reward_records.length)
          for (let i = 0; i < message.reward_records.length; ++i)
            $root.ununifi.ecosystemincentive.RewardRecord.encode(
              message.reward_records[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {ununifi.ecosystemincentive.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.reward_records && message.reward_records.length)) message.reward_records = [];
              message.reward_records.push($root.ununifi.ecosystemincentive.RewardRecord.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.reward_records != null && message.hasOwnProperty('reward_records')) {
          if (!Array.isArray(message.reward_records)) return 'reward_records: array expected';
          for (let i = 0; i < message.reward_records.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.RewardRecord.verify(message.reward_records[i]);
            if (error) return 'reward_records.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.GenesisState) return object;
        let message = new $root.ununifi.ecosystemincentive.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.ecosystemincentive.GenesisState.params: object expected');
          message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
        }
        if (object.reward_records) {
          if (!Array.isArray(object.reward_records))
            throw TypeError('.ununifi.ecosystemincentive.GenesisState.reward_records: array expected');
          message.reward_records = [];
          for (let i = 0; i < object.reward_records.length; ++i) {
            if (typeof object.reward_records[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.GenesisState.reward_records: object expected');
            message.reward_records[i] = $root.ununifi.ecosystemincentive.RewardRecord.fromObject(object.reward_records[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @static
       * @param {ununifi.ecosystemincentive.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.reward_records = [];
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
        if (message.reward_records && message.reward_records.length) {
          object.reward_records = [];
          for (let j = 0; j < message.reward_records.length; ++j)
            object.reward_records[j] = $root.ununifi.ecosystemincentive.RewardRecord.toObject(message.reward_records[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    ecosystemincentive.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.ecosystemincentive
       * @interface IParams
       * @property {Array.<ununifi.ecosystemincentive.IRewardParams>|null} [reward_params] Params reward_params
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.ecosystemincentive.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.reward_params = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params reward_params.
       * @member {Array.<ununifi.ecosystemincentive.IRewardParams>} reward_params
       * @memberof ununifi.ecosystemincentive.Params
       * @instance
       */
      Params.prototype.reward_params = $util.emptyArray;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.reward_params != null && message.reward_params.length)
          for (let i = 0; i < message.reward_params.length; ++i)
            $root.ununifi.ecosystemincentive.RewardParams.encode(
              message.reward_params[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {ununifi.ecosystemincentive.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.reward_params && message.reward_params.length)) message.reward_params = [];
              message.reward_params.push($root.ununifi.ecosystemincentive.RewardParams.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.reward_params != null && message.hasOwnProperty('reward_params')) {
          if (!Array.isArray(message.reward_params)) return 'reward_params: array expected';
          for (let i = 0; i < message.reward_params.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.RewardParams.verify(message.reward_params[i]);
            if (error) return 'reward_params.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.Params) return object;
        let message = new $root.ununifi.ecosystemincentive.Params();
        if (object.reward_params) {
          if (!Array.isArray(object.reward_params)) throw TypeError('.ununifi.ecosystemincentive.Params.reward_params: array expected');
          message.reward_params = [];
          for (let i = 0; i < object.reward_params.length; ++i) {
            if (typeof object.reward_params[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.Params.reward_params: object expected');
            message.reward_params[i] = $root.ununifi.ecosystemincentive.RewardParams.fromObject(object.reward_params[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.Params
       * @static
       * @param {ununifi.ecosystemincentive.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.reward_params = [];
        if (message.reward_params && message.reward_params.length) {
          object.reward_params = [];
          for (let j = 0; j < message.reward_params.length; ++j)
            object.reward_params[j] = $root.ununifi.ecosystemincentive.RewardParams.toObject(message.reward_params[j], options);
        }
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    ecosystemincentive.RewardParams = (function () {
      /**
       * Properties of a RewardParams.
       * @memberof ununifi.ecosystemincentive
       * @interface IRewardParams
       * @property {string|null} [module_name] RewardParams module_name
       * @property {Array.<ununifi.ecosystemincentive.IRewardRate>|null} [reward_rate] RewardParams reward_rate
       */

      /**
       * Constructs a new RewardParams.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a RewardParams.
       * @implements IRewardParams
       * @constructor
       * @param {ununifi.ecosystemincentive.IRewardParams=} [properties] Properties to set
       */
      function RewardParams(properties) {
        this.reward_rate = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardParams module_name.
       * @member {string} module_name
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @instance
       */
      RewardParams.prototype.module_name = '';

      /**
       * RewardParams reward_rate.
       * @member {Array.<ununifi.ecosystemincentive.IRewardRate>} reward_rate
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @instance
       */
      RewardParams.prototype.reward_rate = $util.emptyArray;

      /**
       * Encodes the specified RewardParams message. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.module_name != null && Object.hasOwnProperty.call(message, 'module_name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.module_name);
        if (message.reward_rate != null && message.reward_rate.length)
          for (let i = 0; i < message.reward_rate.length; ++i)
            $root.ununifi.ecosystemincentive.RewardRate.encode(
              message.reward_rate[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified RewardParams message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {ununifi.ecosystemincentive.IRewardParams} message RewardParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.RewardParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.module_name = reader.string();
              break;
            case 2:
              if (!(message.reward_rate && message.reward_rate.length)) message.reward_rate = [];
              message.reward_rate.push($root.ununifi.ecosystemincentive.RewardRate.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardParams message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.module_name != null && message.hasOwnProperty('module_name'))
          if (!$util.isString(message.module_name)) return 'module_name: string expected';
        if (message.reward_rate != null && message.hasOwnProperty('reward_rate')) {
          if (!Array.isArray(message.reward_rate)) return 'reward_rate: array expected';
          for (let i = 0; i < message.reward_rate.length; ++i) {
            let error = $root.ununifi.ecosystemincentive.RewardRate.verify(message.reward_rate[i]);
            if (error) return 'reward_rate.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a RewardParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.RewardParams} RewardParams
       */
      RewardParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.RewardParams) return object;
        let message = new $root.ununifi.ecosystemincentive.RewardParams();
        if (object.module_name != null) message.module_name = String(object.module_name);
        if (object.reward_rate) {
          if (!Array.isArray(object.reward_rate)) throw TypeError('.ununifi.ecosystemincentive.RewardParams.reward_rate: array expected');
          message.reward_rate = [];
          for (let i = 0; i < object.reward_rate.length; ++i) {
            if (typeof object.reward_rate[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.RewardParams.reward_rate: object expected');
            message.reward_rate[i] = $root.ununifi.ecosystemincentive.RewardRate.fromObject(object.reward_rate[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a RewardParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @static
       * @param {ununifi.ecosystemincentive.RewardParams} message RewardParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.reward_rate = [];
        if (options.defaults) object.module_name = '';
        if (message.module_name != null && message.hasOwnProperty('module_name')) object.module_name = message.module_name;
        if (message.reward_rate && message.reward_rate.length) {
          object.reward_rate = [];
          for (let j = 0; j < message.reward_rate.length; ++j)
            object.reward_rate[j] = $root.ununifi.ecosystemincentive.RewardRate.toObject(message.reward_rate[j], options);
        }
        return object;
      };

      /**
       * Converts this RewardParams to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.RewardParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardParams;
    })();

    ecosystemincentive.RewardRate = (function () {
      /**
       * Properties of a RewardRate.
       * @memberof ununifi.ecosystemincentive
       * @interface IRewardRate
       * @property {ununifi.ecosystemincentive.RewardType|null} [reward_type] RewardRate reward_type
       * @property {string|null} [rate] RewardRate rate
       */

      /**
       * Constructs a new RewardRate.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a RewardRate.
       * @implements IRewardRate
       * @constructor
       * @param {ununifi.ecosystemincentive.IRewardRate=} [properties] Properties to set
       */
      function RewardRate(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RewardRate reward_type.
       * @member {ununifi.ecosystemincentive.RewardType} reward_type
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @instance
       */
      RewardRate.prototype.reward_type = 0;

      /**
       * RewardRate rate.
       * @member {string} rate
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @instance
       */
      RewardRate.prototype.rate = '';

      /**
       * Encodes the specified RewardRate message. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardRate.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.reward_type != null && Object.hasOwnProperty.call(message, 'reward_type'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.reward_type);
        if (message.rate != null && Object.hasOwnProperty.call(message, 'rate'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.rate);
        return writer;
      };

      /**
       * Encodes the specified RewardRate message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.RewardRate.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {ununifi.ecosystemincentive.IRewardRate} message RewardRate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RewardRate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RewardRate message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardRate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.RewardRate();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.reward_type = reader.int32();
              break;
            case 2:
              message.rate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RewardRate message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RewardRate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RewardRate message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RewardRate.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.reward_type != null && message.hasOwnProperty('reward_type'))
          switch (message.reward_type) {
            default:
              return 'reward_type: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        if (message.rate != null && message.hasOwnProperty('rate')) if (!$util.isString(message.rate)) return 'rate: string expected';
        return null;
      };

      /**
       * Creates a RewardRate message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.RewardRate} RewardRate
       */
      RewardRate.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.RewardRate) return object;
        let message = new $root.ununifi.ecosystemincentive.RewardRate();
        switch (object.reward_type) {
          case 'UNKNOWN':
          case 0:
            message.reward_type = 0;
            break;
          case 'STAKERS':
          case 1:
            message.reward_type = 1;
            break;
          case 'FRONTEND_DEVELOPERS':
          case 2:
            message.reward_type = 2;
            break;
          case 'COMMUNITY_POOL':
          case 3:
            message.reward_type = 3;
            break;
        }
        if (object.rate != null) message.rate = String(object.rate);
        return message;
      };

      /**
       * Creates a plain object from a RewardRate message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @static
       * @param {ununifi.ecosystemincentive.RewardRate} message RewardRate
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RewardRate.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.reward_type = options.enums === String ? 'UNKNOWN' : 0;
          object.rate = '';
        }
        if (message.reward_type != null && message.hasOwnProperty('reward_type'))
          object.reward_type =
            options.enums === String ? $root.ununifi.ecosystemincentive.RewardType[message.reward_type] : message.reward_type;
        if (message.rate != null && message.hasOwnProperty('rate')) object.rate = message.rate;
        return object;
      };

      /**
       * Converts this RewardRate to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.RewardRate
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RewardRate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RewardRate;
    })();

    /**
     * RewardType enum.
     * @name ununifi.ecosystemincentive.RewardType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} STAKERS=1 STAKERS value
     * @property {number} FRONTEND_DEVELOPERS=2 FRONTEND_DEVELOPERS value
     * @property {number} COMMUNITY_POOL=3 COMMUNITY_POOL value
     */
    ecosystemincentive.RewardType = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'UNKNOWN')] = 0;
      values[(valuesById[1] = 'STAKERS')] = 1;
      values[(valuesById[2] = 'FRONTEND_DEVELOPERS')] = 2;
      values[(valuesById[3] = 'COMMUNITY_POOL')] = 3;
      return values;
    })();

    ecosystemincentive.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#params}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.ecosystemincentive.QueryParamsRequest,
            $root.ununifi.ecosystemincentive.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#ecosystemRewards}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef EcosystemRewardsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryEcosystemRewardsResponse} [response] QueryEcosystemRewardsResponse
       */

      /**
       * Calls EcosystemRewards.
       * @function ecosystemRewards
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsRequest} request QueryEcosystemRewardsRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.EcosystemRewardsCallback} callback Node-style callback called with the error, if any, and QueryEcosystemRewardsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.ecosystemRewards = function ecosystemRewards(request, callback) {
          return this.rpcCall(
            ecosystemRewards,
            $root.ununifi.ecosystemincentive.QueryEcosystemRewardsRequest,
            $root.ununifi.ecosystemincentive.QueryEcosystemRewardsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EcosystemRewards' },
      );

      /**
       * Calls EcosystemRewards.
       * @function ecosystemRewards
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsRequest} request QueryEcosystemRewardsRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryEcosystemRewardsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.ecosystemincentive.Query#recipientAddressWithNftId}.
       * @memberof ununifi.ecosystemincentive.Query
       * @typedef RecipientAddressWithNftIdCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse} [response] QueryRecipientAddressWithNftIdResponse
       */

      /**
       * Calls RecipientAddressWithNftId.
       * @function recipientAddressWithNftId
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdRequest} request QueryRecipientAddressWithNftIdRequest message or plain object
       * @param {ununifi.ecosystemincentive.Query.RecipientAddressWithNftIdCallback} callback Node-style callback called with the error, if any, and QueryRecipientAddressWithNftIdResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.recipientAddressWithNftId = function recipientAddressWithNftId(request, callback) {
          return this.rpcCall(
            recipientAddressWithNftId,
            $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest,
            $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RecipientAddressWithNftId' },
      );

      /**
       * Calls RecipientAddressWithNftId.
       * @function recipientAddressWithNftId
       * @memberof ununifi.ecosystemincentive.Query
       * @instance
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdRequest} request QueryRecipientAddressWithNftIdRequest message or plain object
       * @returns {Promise<ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    ecosystemincentive.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsRequest) return object;
        return new $root.ununifi.ecosystemincentive.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    ecosystemincentive.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryParamsResponse
       * @property {ununifi.ecosystemincentive.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.ecosystemincentive.IParams|null|undefined} params
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.ecosystemincentive.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.ecosystemincentive.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.ecosystemincentive.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryParamsResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.ecosystemincentive.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.ecosystemincentive.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.ecosystemincentive.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    ecosystemincentive.QueryEcosystemRewardsRequest = (function () {
      /**
       * Properties of a QueryEcosystemRewardsRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryEcosystemRewardsRequest
       * @property {string|null} [address] QueryEcosystemRewardsRequest address
       * @property {string|null} [denom] QueryEcosystemRewardsRequest denom
       */

      /**
       * Constructs a new QueryEcosystemRewardsRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryEcosystemRewardsRequest.
       * @implements IQueryEcosystemRewardsRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsRequest=} [properties] Properties to set
       */
      function QueryEcosystemRewardsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEcosystemRewardsRequest address.
       * @member {string} address
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @instance
       */
      QueryEcosystemRewardsRequest.prototype.address = '';

      /**
       * QueryEcosystemRewardsRequest denom.
       * @member {string} denom
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @instance
       */
      QueryEcosystemRewardsRequest.prototype.denom = '';

      /**
       * Encodes the specified QueryEcosystemRewardsRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryEcosystemRewardsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsRequest} message QueryEcosystemRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEcosystemRewardsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        return writer;
      };

      /**
       * Encodes the specified QueryEcosystemRewardsRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryEcosystemRewardsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsRequest} message QueryEcosystemRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEcosystemRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEcosystemRewardsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryEcosystemRewardsRequest} QueryEcosystemRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEcosystemRewardsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryEcosystemRewardsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEcosystemRewardsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryEcosystemRewardsRequest} QueryEcosystemRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEcosystemRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEcosystemRewardsRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEcosystemRewardsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        return null;
      };

      /**
       * Creates a QueryEcosystemRewardsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryEcosystemRewardsRequest} QueryEcosystemRewardsRequest
       */
      QueryEcosystemRewardsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryEcosystemRewardsRequest) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryEcosystemRewardsRequest();
        if (object.address != null) message.address = String(object.address);
        if (object.denom != null) message.denom = String(object.denom);
        return message;
      };

      /**
       * Creates a plain object from a QueryEcosystemRewardsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryEcosystemRewardsRequest} message QueryEcosystemRewardsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEcosystemRewardsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.address = '';
          object.denom = '';
        }
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        return object;
      };

      /**
       * Converts this QueryEcosystemRewardsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEcosystemRewardsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEcosystemRewardsRequest;
    })();

    ecosystemincentive.QueryEcosystemRewardsResponse = (function () {
      /**
       * Properties of a QueryEcosystemRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryEcosystemRewardsResponse
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] QueryEcosystemRewardsResponse rewards
       */

      /**
       * Constructs a new QueryEcosystemRewardsResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryEcosystemRewardsResponse.
       * @implements IQueryEcosystemRewardsResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsResponse=} [properties] Properties to set
       */
      function QueryEcosystemRewardsResponse(properties) {
        this.rewards = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEcosystemRewardsResponse rewards.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @instance
       */
      QueryEcosystemRewardsResponse.prototype.rewards = $util.emptyArray;

      /**
       * Encodes the specified QueryEcosystemRewardsResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryEcosystemRewardsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsResponse} message QueryEcosystemRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEcosystemRewardsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.rewards != null && message.rewards.length)
          for (let i = 0; i < message.rewards.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEcosystemRewardsResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryEcosystemRewardsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryEcosystemRewardsResponse} message QueryEcosystemRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEcosystemRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEcosystemRewardsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryEcosystemRewardsResponse} QueryEcosystemRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEcosystemRewardsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryEcosystemRewardsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.rewards && message.rewards.length)) message.rewards = [];
              message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEcosystemRewardsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryEcosystemRewardsResponse} QueryEcosystemRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEcosystemRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEcosystemRewardsResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEcosystemRewardsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.rewards != null && message.hasOwnProperty('rewards')) {
          if (!Array.isArray(message.rewards)) return 'rewards: array expected';
          for (let i = 0; i < message.rewards.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
            if (error) return 'rewards.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryEcosystemRewardsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryEcosystemRewardsResponse} QueryEcosystemRewardsResponse
       */
      QueryEcosystemRewardsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryEcosystemRewardsResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryEcosystemRewardsResponse();
        if (object.rewards) {
          if (!Array.isArray(object.rewards))
            throw TypeError('.ununifi.ecosystemincentive.QueryEcosystemRewardsResponse.rewards: array expected');
          message.rewards = [];
          for (let i = 0; i < object.rewards.length; ++i) {
            if (typeof object.rewards[i] !== 'object')
              throw TypeError('.ununifi.ecosystemincentive.QueryEcosystemRewardsResponse.rewards: object expected');
            message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEcosystemRewardsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryEcosystemRewardsResponse} message QueryEcosystemRewardsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEcosystemRewardsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rewards = [];
        if (message.rewards && message.rewards.length) {
          object.rewards = [];
          for (let j = 0; j < message.rewards.length; ++j)
            object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryEcosystemRewardsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryEcosystemRewardsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEcosystemRewardsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEcosystemRewardsResponse;
    })();

    ecosystemincentive.QueryRecipientAddressWithNftIdRequest = (function () {
      /**
       * Properties of a QueryRecipientAddressWithNftIdRequest.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryRecipientAddressWithNftIdRequest
       * @property {string|null} [class_id] QueryRecipientAddressWithNftIdRequest class_id
       * @property {string|null} [token_id] QueryRecipientAddressWithNftIdRequest token_id
       */

      /**
       * Constructs a new QueryRecipientAddressWithNftIdRequest.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryRecipientAddressWithNftIdRequest.
       * @implements IQueryRecipientAddressWithNftIdRequest
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdRequest=} [properties] Properties to set
       */
      function QueryRecipientAddressWithNftIdRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRecipientAddressWithNftIdRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @instance
       */
      QueryRecipientAddressWithNftIdRequest.prototype.class_id = '';

      /**
       * QueryRecipientAddressWithNftIdRequest token_id.
       * @member {string} token_id
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @instance
       */
      QueryRecipientAddressWithNftIdRequest.prototype.token_id = '';

      /**
       * Encodes the specified QueryRecipientAddressWithNftIdRequest message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdRequest} message QueryRecipientAddressWithNftIdRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecipientAddressWithNftIdRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified QueryRecipientAddressWithNftIdRequest message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdRequest} message QueryRecipientAddressWithNftIdRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecipientAddressWithNftIdRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRecipientAddressWithNftIdRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest} QueryRecipientAddressWithNftIdRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecipientAddressWithNftIdRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRecipientAddressWithNftIdRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest} QueryRecipientAddressWithNftIdRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecipientAddressWithNftIdRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRecipientAddressWithNftIdRequest message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRecipientAddressWithNftIdRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates a QueryRecipientAddressWithNftIdRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest} QueryRecipientAddressWithNftIdRequest
       */
      QueryRecipientAddressWithNftIdRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryRecipientAddressWithNftIdRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @static
       * @param {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest} message QueryRecipientAddressWithNftIdRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRecipientAddressWithNftIdRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.token_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this QueryRecipientAddressWithNftIdRequest to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRecipientAddressWithNftIdRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRecipientAddressWithNftIdRequest;
    })();

    ecosystemincentive.QueryRecipientAddressWithNftIdResponse = (function () {
      /**
       * Properties of a QueryRecipientAddressWithNftIdResponse.
       * @memberof ununifi.ecosystemincentive
       * @interface IQueryRecipientAddressWithNftIdResponse
       * @property {string|null} [address] QueryRecipientAddressWithNftIdResponse address
       */

      /**
       * Constructs a new QueryRecipientAddressWithNftIdResponse.
       * @memberof ununifi.ecosystemincentive
       * @classdesc Represents a QueryRecipientAddressWithNftIdResponse.
       * @implements IQueryRecipientAddressWithNftIdResponse
       * @constructor
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdResponse=} [properties] Properties to set
       */
      function QueryRecipientAddressWithNftIdResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRecipientAddressWithNftIdResponse address.
       * @member {string} address
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @instance
       */
      QueryRecipientAddressWithNftIdResponse.prototype.address = '';

      /**
       * Encodes the specified QueryRecipientAddressWithNftIdResponse message. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdResponse} message QueryRecipientAddressWithNftIdResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecipientAddressWithNftIdResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryRecipientAddressWithNftIdResponse message, length delimited. Does not implicitly {@link ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @static
       * @param {ununifi.ecosystemincentive.IQueryRecipientAddressWithNftIdResponse} message QueryRecipientAddressWithNftIdResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRecipientAddressWithNftIdResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRecipientAddressWithNftIdResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse} QueryRecipientAddressWithNftIdResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecipientAddressWithNftIdResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRecipientAddressWithNftIdResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse} QueryRecipientAddressWithNftIdResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRecipientAddressWithNftIdResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRecipientAddressWithNftIdResponse message.
       * @function verify
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRecipientAddressWithNftIdResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        return null;
      };

      /**
       * Creates a QueryRecipientAddressWithNftIdResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse} QueryRecipientAddressWithNftIdResponse
       */
      QueryRecipientAddressWithNftIdResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse) return object;
        let message = new $root.ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse();
        if (object.address != null) message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a QueryRecipientAddressWithNftIdResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @static
       * @param {ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse} message QueryRecipientAddressWithNftIdResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRecipientAddressWithNftIdResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.address = '';
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        return object;
      };

      /**
       * Converts this QueryRecipientAddressWithNftIdResponse to JSON.
       * @function toJSON
       * @memberof ununifi.ecosystemincentive.QueryRecipientAddressWithNftIdResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRecipientAddressWithNftIdResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRecipientAddressWithNftIdResponse;
    })();

    return ecosystemincentive;
  })();

  ununifi.epochs = (function () {
    /**
     * Namespace epochs.
     * @memberof ununifi
     * @namespace
     */
    const epochs = {};

    epochs.EpochInfo = (function () {
      /**
       * Properties of an EpochInfo.
       * @memberof ununifi.epochs
       * @interface IEpochInfo
       * @property {string|null} [identifier] EpochInfo identifier
       * @property {google.protobuf.ITimestamp|null} [start_time] EpochInfo start_time
       * @property {google.protobuf.IDuration|null} [duration] EpochInfo duration
       * @property {Long|null} [current_epoch] EpochInfo current_epoch
       * @property {google.protobuf.ITimestamp|null} [current_epoch_start_time] EpochInfo current_epoch_start_time
       * @property {boolean|null} [epoch_counting_started] EpochInfo epoch_counting_started
       * @property {Long|null} [current_epoch_start_height] EpochInfo current_epoch_start_height
       */

      /**
       * Constructs a new EpochInfo.
       * @memberof ununifi.epochs
       * @classdesc Represents an EpochInfo.
       * @implements IEpochInfo
       * @constructor
       * @param {ununifi.epochs.IEpochInfo=} [properties] Properties to set
       */
      function EpochInfo(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EpochInfo identifier.
       * @member {string} identifier
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       */
      EpochInfo.prototype.identifier = '';

      /**
       * EpochInfo start_time.
       * @member {google.protobuf.ITimestamp|null|undefined} start_time
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       */
      EpochInfo.prototype.start_time = null;

      /**
       * EpochInfo duration.
       * @member {google.protobuf.IDuration|null|undefined} duration
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       */
      EpochInfo.prototype.duration = null;

      /**
       * EpochInfo current_epoch.
       * @member {Long} current_epoch
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       */
      EpochInfo.prototype.current_epoch = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * EpochInfo current_epoch_start_time.
       * @member {google.protobuf.ITimestamp|null|undefined} current_epoch_start_time
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       */
      EpochInfo.prototype.current_epoch_start_time = null;

      /**
       * EpochInfo epoch_counting_started.
       * @member {boolean} epoch_counting_started
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       */
      EpochInfo.prototype.epoch_counting_started = false;

      /**
       * EpochInfo current_epoch_start_height.
       * @member {Long} current_epoch_start_height
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       */
      EpochInfo.prototype.current_epoch_start_height = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Encodes the specified EpochInfo message. Does not implicitly {@link ununifi.epochs.EpochInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.EpochInfo
       * @static
       * @param {ununifi.epochs.IEpochInfo} message EpochInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EpochInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.identifier != null && Object.hasOwnProperty.call(message, 'identifier'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.identifier);
        if (message.start_time != null && Object.hasOwnProperty.call(message, 'start_time'))
          $root.google.protobuf.Timestamp.encode(message.start_time, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.duration != null && Object.hasOwnProperty.call(message, 'duration'))
          $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.current_epoch != null && Object.hasOwnProperty.call(message, 'current_epoch'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.current_epoch);
        if (message.current_epoch_start_time != null && Object.hasOwnProperty.call(message, 'current_epoch_start_time'))
          $root.google.protobuf.Timestamp.encode(
            message.current_epoch_start_time,
            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
          ).ldelim();
        if (message.epoch_counting_started != null && Object.hasOwnProperty.call(message, 'epoch_counting_started'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.epoch_counting_started);
        if (message.current_epoch_start_height != null && Object.hasOwnProperty.call(message, 'current_epoch_start_height'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).int64(message.current_epoch_start_height);
        return writer;
      };

      /**
       * Encodes the specified EpochInfo message, length delimited. Does not implicitly {@link ununifi.epochs.EpochInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.EpochInfo
       * @static
       * @param {ununifi.epochs.IEpochInfo} message EpochInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EpochInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EpochInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.EpochInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.EpochInfo} EpochInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EpochInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.EpochInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            case 2:
              message.start_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.current_epoch = reader.int64();
              break;
            case 5:
              message.current_epoch_start_time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.epoch_counting_started = reader.bool();
              break;
            case 7:
              message.current_epoch_start_height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EpochInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.EpochInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.EpochInfo} EpochInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EpochInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EpochInfo message.
       * @function verify
       * @memberof ununifi.epochs.EpochInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EpochInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.identifier != null && message.hasOwnProperty('identifier'))
          if (!$util.isString(message.identifier)) return 'identifier: string expected';
        if (message.start_time != null && message.hasOwnProperty('start_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.start_time);
          if (error) return 'start_time.' + error;
        }
        if (message.duration != null && message.hasOwnProperty('duration')) {
          let error = $root.google.protobuf.Duration.verify(message.duration);
          if (error) return 'duration.' + error;
        }
        if (message.current_epoch != null && message.hasOwnProperty('current_epoch'))
          if (
            !$util.isInteger(message.current_epoch) &&
            !(message.current_epoch && $util.isInteger(message.current_epoch.low) && $util.isInteger(message.current_epoch.high))
          )
            return 'current_epoch: integer|Long expected';
        if (message.current_epoch_start_time != null && message.hasOwnProperty('current_epoch_start_time')) {
          let error = $root.google.protobuf.Timestamp.verify(message.current_epoch_start_time);
          if (error) return 'current_epoch_start_time.' + error;
        }
        if (message.epoch_counting_started != null && message.hasOwnProperty('epoch_counting_started'))
          if (typeof message.epoch_counting_started !== 'boolean') return 'epoch_counting_started: boolean expected';
        if (message.current_epoch_start_height != null && message.hasOwnProperty('current_epoch_start_height'))
          if (
            !$util.isInteger(message.current_epoch_start_height) &&
            !(
              message.current_epoch_start_height &&
              $util.isInteger(message.current_epoch_start_height.low) &&
              $util.isInteger(message.current_epoch_start_height.high)
            )
          )
            return 'current_epoch_start_height: integer|Long expected';
        return null;
      };

      /**
       * Creates an EpochInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.EpochInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.EpochInfo} EpochInfo
       */
      EpochInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.EpochInfo) return object;
        let message = new $root.ununifi.epochs.EpochInfo();
        if (object.identifier != null) message.identifier = String(object.identifier);
        if (object.start_time != null) {
          if (typeof object.start_time !== 'object') throw TypeError('.ununifi.epochs.EpochInfo.start_time: object expected');
          message.start_time = $root.google.protobuf.Timestamp.fromObject(object.start_time);
        }
        if (object.duration != null) {
          if (typeof object.duration !== 'object') throw TypeError('.ununifi.epochs.EpochInfo.duration: object expected');
          message.duration = $root.google.protobuf.Duration.fromObject(object.duration);
        }
        if (object.current_epoch != null)
          if ($util.Long) (message.current_epoch = $util.Long.fromValue(object.current_epoch)).unsigned = false;
          else if (typeof object.current_epoch === 'string') message.current_epoch = parseInt(object.current_epoch, 10);
          else if (typeof object.current_epoch === 'number') message.current_epoch = object.current_epoch;
          else if (typeof object.current_epoch === 'object')
            message.current_epoch = new $util.LongBits(object.current_epoch.low >>> 0, object.current_epoch.high >>> 0).toNumber();
        if (object.current_epoch_start_time != null) {
          if (typeof object.current_epoch_start_time !== 'object')
            throw TypeError('.ununifi.epochs.EpochInfo.current_epoch_start_time: object expected');
          message.current_epoch_start_time = $root.google.protobuf.Timestamp.fromObject(object.current_epoch_start_time);
        }
        if (object.epoch_counting_started != null) message.epoch_counting_started = Boolean(object.epoch_counting_started);
        if (object.current_epoch_start_height != null)
          if ($util.Long) (message.current_epoch_start_height = $util.Long.fromValue(object.current_epoch_start_height)).unsigned = false;
          else if (typeof object.current_epoch_start_height === 'string')
            message.current_epoch_start_height = parseInt(object.current_epoch_start_height, 10);
          else if (typeof object.current_epoch_start_height === 'number')
            message.current_epoch_start_height = object.current_epoch_start_height;
          else if (typeof object.current_epoch_start_height === 'object')
            message.current_epoch_start_height = new $util.LongBits(
              object.current_epoch_start_height.low >>> 0,
              object.current_epoch_start_height.high >>> 0,
            ).toNumber();
        return message;
      };

      /**
       * Creates a plain object from an EpochInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.EpochInfo
       * @static
       * @param {ununifi.epochs.EpochInfo} message EpochInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EpochInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.identifier = '';
          object.start_time = null;
          object.duration = null;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.current_epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.current_epoch = options.longs === String ? '0' : 0;
          object.current_epoch_start_time = null;
          object.epoch_counting_started = false;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.current_epoch_start_height =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.current_epoch_start_height = options.longs === String ? '0' : 0;
        }
        if (message.identifier != null && message.hasOwnProperty('identifier')) object.identifier = message.identifier;
        if (message.start_time != null && message.hasOwnProperty('start_time'))
          object.start_time = $root.google.protobuf.Timestamp.toObject(message.start_time, options);
        if (message.duration != null && message.hasOwnProperty('duration'))
          object.duration = $root.google.protobuf.Duration.toObject(message.duration, options);
        if (message.current_epoch != null && message.hasOwnProperty('current_epoch'))
          if (typeof message.current_epoch === 'number')
            object.current_epoch = options.longs === String ? String(message.current_epoch) : message.current_epoch;
          else
            object.current_epoch =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.current_epoch)
                : options.longs === Number
                ? new $util.LongBits(message.current_epoch.low >>> 0, message.current_epoch.high >>> 0).toNumber()
                : message.current_epoch;
        if (message.current_epoch_start_time != null && message.hasOwnProperty('current_epoch_start_time'))
          object.current_epoch_start_time = $root.google.protobuf.Timestamp.toObject(message.current_epoch_start_time, options);
        if (message.epoch_counting_started != null && message.hasOwnProperty('epoch_counting_started'))
          object.epoch_counting_started = message.epoch_counting_started;
        if (message.current_epoch_start_height != null && message.hasOwnProperty('current_epoch_start_height'))
          if (typeof message.current_epoch_start_height === 'number')
            object.current_epoch_start_height =
              options.longs === String ? String(message.current_epoch_start_height) : message.current_epoch_start_height;
          else
            object.current_epoch_start_height =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.current_epoch_start_height)
                : options.longs === Number
                ? new $util.LongBits(message.current_epoch_start_height.low >>> 0, message.current_epoch_start_height.high >>> 0).toNumber()
                : message.current_epoch_start_height;
        return object;
      };

      /**
       * Converts this EpochInfo to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.EpochInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EpochInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EpochInfo;
    })();

    epochs.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.epochs
       * @interface IGenesisState
       * @property {Array.<ununifi.epochs.IEpochInfo>|null} [epochs] GenesisState epochs
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.epochs
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.epochs.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.epochs = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState epochs.
       * @member {Array.<ununifi.epochs.IEpochInfo>} epochs
       * @memberof ununifi.epochs.GenesisState
       * @instance
       */
      GenesisState.prototype.epochs = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.epochs.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.GenesisState
       * @static
       * @param {ununifi.epochs.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.epochs != null && message.epochs.length)
          for (let i = 0; i < message.epochs.length; ++i)
            $root.ununifi.epochs.EpochInfo.encode(message.epochs[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.epochs.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.GenesisState
       * @static
       * @param {ununifi.epochs.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.epochs && message.epochs.length)) message.epochs = [];
              message.epochs.push($root.ununifi.epochs.EpochInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.epochs.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.epochs != null && message.hasOwnProperty('epochs')) {
          if (!Array.isArray(message.epochs)) return 'epochs: array expected';
          for (let i = 0; i < message.epochs.length; ++i) {
            let error = $root.ununifi.epochs.EpochInfo.verify(message.epochs[i]);
            if (error) return 'epochs.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.GenesisState) return object;
        let message = new $root.ununifi.epochs.GenesisState();
        if (object.epochs) {
          if (!Array.isArray(object.epochs)) throw TypeError('.ununifi.epochs.GenesisState.epochs: array expected');
          message.epochs = [];
          for (let i = 0; i < object.epochs.length; ++i) {
            if (typeof object.epochs[i] !== 'object') throw TypeError('.ununifi.epochs.GenesisState.epochs: object expected');
            message.epochs[i] = $root.ununifi.epochs.EpochInfo.fromObject(object.epochs[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.GenesisState
       * @static
       * @param {ununifi.epochs.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.epochs = [];
        if (message.epochs && message.epochs.length) {
          object.epochs = [];
          for (let j = 0; j < message.epochs.length; ++j)
            object.epochs[j] = $root.ununifi.epochs.EpochInfo.toObject(message.epochs[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    epochs.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.epochs
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.epochs.Query#epochInfos}.
       * @memberof ununifi.epochs.Query
       * @typedef EpochInfosCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.epochs.QueryEpochsInfoResponse} [response] QueryEpochsInfoResponse
       */

      /**
       * Calls EpochInfos.
       * @function epochInfos
       * @memberof ununifi.epochs.Query
       * @instance
       * @param {ununifi.epochs.IQueryEpochsInfoRequest} request QueryEpochsInfoRequest message or plain object
       * @param {ununifi.epochs.Query.EpochInfosCallback} callback Node-style callback called with the error, if any, and QueryEpochsInfoResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.epochInfos = function epochInfos(request, callback) {
          return this.rpcCall(
            epochInfos,
            $root.ununifi.epochs.QueryEpochsInfoRequest,
            $root.ununifi.epochs.QueryEpochsInfoResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EpochInfos' },
      );

      /**
       * Calls EpochInfos.
       * @function epochInfos
       * @memberof ununifi.epochs.Query
       * @instance
       * @param {ununifi.epochs.IQueryEpochsInfoRequest} request QueryEpochsInfoRequest message or plain object
       * @returns {Promise<ununifi.epochs.QueryEpochsInfoResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.epochs.Query#currentEpoch}.
       * @memberof ununifi.epochs.Query
       * @typedef CurrentEpochCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.epochs.QueryCurrentEpochResponse} [response] QueryCurrentEpochResponse
       */

      /**
       * Calls CurrentEpoch.
       * @function currentEpoch
       * @memberof ununifi.epochs.Query
       * @instance
       * @param {ununifi.epochs.IQueryCurrentEpochRequest} request QueryCurrentEpochRequest message or plain object
       * @param {ununifi.epochs.Query.CurrentEpochCallback} callback Node-style callback called with the error, if any, and QueryCurrentEpochResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.currentEpoch = function currentEpoch(request, callback) {
          return this.rpcCall(
            currentEpoch,
            $root.ununifi.epochs.QueryCurrentEpochRequest,
            $root.ununifi.epochs.QueryCurrentEpochResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CurrentEpoch' },
      );

      /**
       * Calls CurrentEpoch.
       * @function currentEpoch
       * @memberof ununifi.epochs.Query
       * @instance
       * @param {ununifi.epochs.IQueryCurrentEpochRequest} request QueryCurrentEpochRequest message or plain object
       * @returns {Promise<ununifi.epochs.QueryCurrentEpochResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.epochs.Query#epochInfo}.
       * @memberof ununifi.epochs.Query
       * @typedef EpochInfoCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.epochs.QueryEpochInfoResponse} [response] QueryEpochInfoResponse
       */

      /**
       * Calls EpochInfo.
       * @function epochInfo
       * @memberof ununifi.epochs.Query
       * @instance
       * @param {ununifi.epochs.IQueryEpochInfoRequest} request QueryEpochInfoRequest message or plain object
       * @param {ununifi.epochs.Query.EpochInfoCallback} callback Node-style callback called with the error, if any, and QueryEpochInfoResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.epochInfo = function epochInfo(request, callback) {
          return this.rpcCall(
            epochInfo,
            $root.ununifi.epochs.QueryEpochInfoRequest,
            $root.ununifi.epochs.QueryEpochInfoResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EpochInfo' },
      );

      /**
       * Calls EpochInfo.
       * @function epochInfo
       * @memberof ununifi.epochs.Query
       * @instance
       * @param {ununifi.epochs.IQueryEpochInfoRequest} request QueryEpochInfoRequest message or plain object
       * @returns {Promise<ununifi.epochs.QueryEpochInfoResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    epochs.QueryEpochsInfoRequest = (function () {
      /**
       * Properties of a QueryEpochsInfoRequest.
       * @memberof ununifi.epochs
       * @interface IQueryEpochsInfoRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryEpochsInfoRequest pagination
       */

      /**
       * Constructs a new QueryEpochsInfoRequest.
       * @memberof ununifi.epochs
       * @classdesc Represents a QueryEpochsInfoRequest.
       * @implements IQueryEpochsInfoRequest
       * @constructor
       * @param {ununifi.epochs.IQueryEpochsInfoRequest=} [properties] Properties to set
       */
      function QueryEpochsInfoRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEpochsInfoRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @instance
       */
      QueryEpochsInfoRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryEpochsInfoRequest message. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @static
       * @param {ununifi.epochs.IQueryEpochsInfoRequest} message QueryEpochsInfoRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochsInfoRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEpochsInfoRequest message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @static
       * @param {ununifi.epochs.IQueryEpochsInfoRequest} message QueryEpochsInfoRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochsInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEpochsInfoRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.QueryEpochsInfoRequest} QueryEpochsInfoRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochsInfoRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.QueryEpochsInfoRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEpochsInfoRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.QueryEpochsInfoRequest} QueryEpochsInfoRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochsInfoRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEpochsInfoRequest message.
       * @function verify
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEpochsInfoRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEpochsInfoRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.QueryEpochsInfoRequest} QueryEpochsInfoRequest
       */
      QueryEpochsInfoRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.QueryEpochsInfoRequest) return object;
        let message = new $root.ununifi.epochs.QueryEpochsInfoRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.ununifi.epochs.QueryEpochsInfoRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEpochsInfoRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @static
       * @param {ununifi.epochs.QueryEpochsInfoRequest} message QueryEpochsInfoRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEpochsInfoRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryEpochsInfoRequest to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.QueryEpochsInfoRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEpochsInfoRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEpochsInfoRequest;
    })();

    epochs.QueryEpochsInfoResponse = (function () {
      /**
       * Properties of a QueryEpochsInfoResponse.
       * @memberof ununifi.epochs
       * @interface IQueryEpochsInfoResponse
       * @property {Array.<ununifi.epochs.IEpochInfo>|null} [epochs] QueryEpochsInfoResponse epochs
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryEpochsInfoResponse pagination
       */

      /**
       * Constructs a new QueryEpochsInfoResponse.
       * @memberof ununifi.epochs
       * @classdesc Represents a QueryEpochsInfoResponse.
       * @implements IQueryEpochsInfoResponse
       * @constructor
       * @param {ununifi.epochs.IQueryEpochsInfoResponse=} [properties] Properties to set
       */
      function QueryEpochsInfoResponse(properties) {
        this.epochs = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEpochsInfoResponse epochs.
       * @member {Array.<ununifi.epochs.IEpochInfo>} epochs
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @instance
       */
      QueryEpochsInfoResponse.prototype.epochs = $util.emptyArray;

      /**
       * QueryEpochsInfoResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @instance
       */
      QueryEpochsInfoResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryEpochsInfoResponse message. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @static
       * @param {ununifi.epochs.IQueryEpochsInfoResponse} message QueryEpochsInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochsInfoResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.epochs != null && message.epochs.length)
          for (let i = 0; i < message.epochs.length; ++i)
            $root.ununifi.epochs.EpochInfo.encode(message.epochs[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEpochsInfoResponse message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochsInfoResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @static
       * @param {ununifi.epochs.IQueryEpochsInfoResponse} message QueryEpochsInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochsInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEpochsInfoResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.QueryEpochsInfoResponse} QueryEpochsInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochsInfoResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.QueryEpochsInfoResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.epochs && message.epochs.length)) message.epochs = [];
              message.epochs.push($root.ununifi.epochs.EpochInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEpochsInfoResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.QueryEpochsInfoResponse} QueryEpochsInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochsInfoResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEpochsInfoResponse message.
       * @function verify
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEpochsInfoResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.epochs != null && message.hasOwnProperty('epochs')) {
          if (!Array.isArray(message.epochs)) return 'epochs: array expected';
          for (let i = 0; i < message.epochs.length; ++i) {
            let error = $root.ununifi.epochs.EpochInfo.verify(message.epochs[i]);
            if (error) return 'epochs.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEpochsInfoResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.QueryEpochsInfoResponse} QueryEpochsInfoResponse
       */
      QueryEpochsInfoResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.QueryEpochsInfoResponse) return object;
        let message = new $root.ununifi.epochs.QueryEpochsInfoResponse();
        if (object.epochs) {
          if (!Array.isArray(object.epochs)) throw TypeError('.ununifi.epochs.QueryEpochsInfoResponse.epochs: array expected');
          message.epochs = [];
          for (let i = 0; i < object.epochs.length; ++i) {
            if (typeof object.epochs[i] !== 'object') throw TypeError('.ununifi.epochs.QueryEpochsInfoResponse.epochs: object expected');
            message.epochs[i] = $root.ununifi.epochs.EpochInfo.fromObject(object.epochs[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.ununifi.epochs.QueryEpochsInfoResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEpochsInfoResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @static
       * @param {ununifi.epochs.QueryEpochsInfoResponse} message QueryEpochsInfoResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEpochsInfoResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.epochs = [];
        if (options.defaults) object.pagination = null;
        if (message.epochs && message.epochs.length) {
          object.epochs = [];
          for (let j = 0; j < message.epochs.length; ++j)
            object.epochs[j] = $root.ununifi.epochs.EpochInfo.toObject(message.epochs[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryEpochsInfoResponse to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.QueryEpochsInfoResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEpochsInfoResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEpochsInfoResponse;
    })();

    epochs.QueryCurrentEpochRequest = (function () {
      /**
       * Properties of a QueryCurrentEpochRequest.
       * @memberof ununifi.epochs
       * @interface IQueryCurrentEpochRequest
       * @property {string|null} [identifier] QueryCurrentEpochRequest identifier
       */

      /**
       * Constructs a new QueryCurrentEpochRequest.
       * @memberof ununifi.epochs
       * @classdesc Represents a QueryCurrentEpochRequest.
       * @implements IQueryCurrentEpochRequest
       * @constructor
       * @param {ununifi.epochs.IQueryCurrentEpochRequest=} [properties] Properties to set
       */
      function QueryCurrentEpochRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryCurrentEpochRequest identifier.
       * @member {string} identifier
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @instance
       */
      QueryCurrentEpochRequest.prototype.identifier = '';

      /**
       * Encodes the specified QueryCurrentEpochRequest message. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @static
       * @param {ununifi.epochs.IQueryCurrentEpochRequest} message QueryCurrentEpochRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentEpochRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.identifier != null && Object.hasOwnProperty.call(message, 'identifier'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.identifier);
        return writer;
      };

      /**
       * Encodes the specified QueryCurrentEpochRequest message, length delimited. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @static
       * @param {ununifi.epochs.IQueryCurrentEpochRequest} message QueryCurrentEpochRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentEpochRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryCurrentEpochRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.QueryCurrentEpochRequest} QueryCurrentEpochRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentEpochRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.QueryCurrentEpochRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryCurrentEpochRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.QueryCurrentEpochRequest} QueryCurrentEpochRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentEpochRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryCurrentEpochRequest message.
       * @function verify
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryCurrentEpochRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.identifier != null && message.hasOwnProperty('identifier'))
          if (!$util.isString(message.identifier)) return 'identifier: string expected';
        return null;
      };

      /**
       * Creates a QueryCurrentEpochRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.QueryCurrentEpochRequest} QueryCurrentEpochRequest
       */
      QueryCurrentEpochRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.QueryCurrentEpochRequest) return object;
        let message = new $root.ununifi.epochs.QueryCurrentEpochRequest();
        if (object.identifier != null) message.identifier = String(object.identifier);
        return message;
      };

      /**
       * Creates a plain object from a QueryCurrentEpochRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @static
       * @param {ununifi.epochs.QueryCurrentEpochRequest} message QueryCurrentEpochRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryCurrentEpochRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.identifier = '';
        if (message.identifier != null && message.hasOwnProperty('identifier')) object.identifier = message.identifier;
        return object;
      };

      /**
       * Converts this QueryCurrentEpochRequest to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.QueryCurrentEpochRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryCurrentEpochRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryCurrentEpochRequest;
    })();

    epochs.QueryCurrentEpochResponse = (function () {
      /**
       * Properties of a QueryCurrentEpochResponse.
       * @memberof ununifi.epochs
       * @interface IQueryCurrentEpochResponse
       * @property {Long|null} [current_epoch] QueryCurrentEpochResponse current_epoch
       */

      /**
       * Constructs a new QueryCurrentEpochResponse.
       * @memberof ununifi.epochs
       * @classdesc Represents a QueryCurrentEpochResponse.
       * @implements IQueryCurrentEpochResponse
       * @constructor
       * @param {ununifi.epochs.IQueryCurrentEpochResponse=} [properties] Properties to set
       */
      function QueryCurrentEpochResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryCurrentEpochResponse current_epoch.
       * @member {Long} current_epoch
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @instance
       */
      QueryCurrentEpochResponse.prototype.current_epoch = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Encodes the specified QueryCurrentEpochResponse message. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @static
       * @param {ununifi.epochs.IQueryCurrentEpochResponse} message QueryCurrentEpochResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentEpochResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.current_epoch != null && Object.hasOwnProperty.call(message, 'current_epoch'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.current_epoch);
        return writer;
      };

      /**
       * Encodes the specified QueryCurrentEpochResponse message, length delimited. Does not implicitly {@link ununifi.epochs.QueryCurrentEpochResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @static
       * @param {ununifi.epochs.IQueryCurrentEpochResponse} message QueryCurrentEpochResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryCurrentEpochResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryCurrentEpochResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.QueryCurrentEpochResponse} QueryCurrentEpochResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentEpochResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.QueryCurrentEpochResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.current_epoch = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryCurrentEpochResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.QueryCurrentEpochResponse} QueryCurrentEpochResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryCurrentEpochResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryCurrentEpochResponse message.
       * @function verify
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryCurrentEpochResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.current_epoch != null && message.hasOwnProperty('current_epoch'))
          if (
            !$util.isInteger(message.current_epoch) &&
            !(message.current_epoch && $util.isInteger(message.current_epoch.low) && $util.isInteger(message.current_epoch.high))
          )
            return 'current_epoch: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryCurrentEpochResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.QueryCurrentEpochResponse} QueryCurrentEpochResponse
       */
      QueryCurrentEpochResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.QueryCurrentEpochResponse) return object;
        let message = new $root.ununifi.epochs.QueryCurrentEpochResponse();
        if (object.current_epoch != null)
          if ($util.Long) (message.current_epoch = $util.Long.fromValue(object.current_epoch)).unsigned = false;
          else if (typeof object.current_epoch === 'string') message.current_epoch = parseInt(object.current_epoch, 10);
          else if (typeof object.current_epoch === 'number') message.current_epoch = object.current_epoch;
          else if (typeof object.current_epoch === 'object')
            message.current_epoch = new $util.LongBits(object.current_epoch.low >>> 0, object.current_epoch.high >>> 0).toNumber();
        return message;
      };

      /**
       * Creates a plain object from a QueryCurrentEpochResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @static
       * @param {ununifi.epochs.QueryCurrentEpochResponse} message QueryCurrentEpochResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryCurrentEpochResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.current_epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.current_epoch = options.longs === String ? '0' : 0;
        if (message.current_epoch != null && message.hasOwnProperty('current_epoch'))
          if (typeof message.current_epoch === 'number')
            object.current_epoch = options.longs === String ? String(message.current_epoch) : message.current_epoch;
          else
            object.current_epoch =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.current_epoch)
                : options.longs === Number
                ? new $util.LongBits(message.current_epoch.low >>> 0, message.current_epoch.high >>> 0).toNumber()
                : message.current_epoch;
        return object;
      };

      /**
       * Converts this QueryCurrentEpochResponse to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.QueryCurrentEpochResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryCurrentEpochResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryCurrentEpochResponse;
    })();

    epochs.QueryEpochInfoRequest = (function () {
      /**
       * Properties of a QueryEpochInfoRequest.
       * @memberof ununifi.epochs
       * @interface IQueryEpochInfoRequest
       * @property {string|null} [identifier] QueryEpochInfoRequest identifier
       */

      /**
       * Constructs a new QueryEpochInfoRequest.
       * @memberof ununifi.epochs
       * @classdesc Represents a QueryEpochInfoRequest.
       * @implements IQueryEpochInfoRequest
       * @constructor
       * @param {ununifi.epochs.IQueryEpochInfoRequest=} [properties] Properties to set
       */
      function QueryEpochInfoRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEpochInfoRequest identifier.
       * @member {string} identifier
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @instance
       */
      QueryEpochInfoRequest.prototype.identifier = '';

      /**
       * Encodes the specified QueryEpochInfoRequest message. Does not implicitly {@link ununifi.epochs.QueryEpochInfoRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @static
       * @param {ununifi.epochs.IQueryEpochInfoRequest} message QueryEpochInfoRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochInfoRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.identifier != null && Object.hasOwnProperty.call(message, 'identifier'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.identifier);
        return writer;
      };

      /**
       * Encodes the specified QueryEpochInfoRequest message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochInfoRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @static
       * @param {ununifi.epochs.IQueryEpochInfoRequest} message QueryEpochInfoRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEpochInfoRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.QueryEpochInfoRequest} QueryEpochInfoRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochInfoRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.QueryEpochInfoRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEpochInfoRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.QueryEpochInfoRequest} QueryEpochInfoRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochInfoRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEpochInfoRequest message.
       * @function verify
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEpochInfoRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.identifier != null && message.hasOwnProperty('identifier'))
          if (!$util.isString(message.identifier)) return 'identifier: string expected';
        return null;
      };

      /**
       * Creates a QueryEpochInfoRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.QueryEpochInfoRequest} QueryEpochInfoRequest
       */
      QueryEpochInfoRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.QueryEpochInfoRequest) return object;
        let message = new $root.ununifi.epochs.QueryEpochInfoRequest();
        if (object.identifier != null) message.identifier = String(object.identifier);
        return message;
      };

      /**
       * Creates a plain object from a QueryEpochInfoRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @static
       * @param {ununifi.epochs.QueryEpochInfoRequest} message QueryEpochInfoRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEpochInfoRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.identifier = '';
        if (message.identifier != null && message.hasOwnProperty('identifier')) object.identifier = message.identifier;
        return object;
      };

      /**
       * Converts this QueryEpochInfoRequest to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.QueryEpochInfoRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEpochInfoRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEpochInfoRequest;
    })();

    epochs.QueryEpochInfoResponse = (function () {
      /**
       * Properties of a QueryEpochInfoResponse.
       * @memberof ununifi.epochs
       * @interface IQueryEpochInfoResponse
       * @property {ununifi.epochs.IEpochInfo|null} [epoch] QueryEpochInfoResponse epoch
       */

      /**
       * Constructs a new QueryEpochInfoResponse.
       * @memberof ununifi.epochs
       * @classdesc Represents a QueryEpochInfoResponse.
       * @implements IQueryEpochInfoResponse
       * @constructor
       * @param {ununifi.epochs.IQueryEpochInfoResponse=} [properties] Properties to set
       */
      function QueryEpochInfoResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEpochInfoResponse epoch.
       * @member {ununifi.epochs.IEpochInfo|null|undefined} epoch
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @instance
       */
      QueryEpochInfoResponse.prototype.epoch = null;

      /**
       * Encodes the specified QueryEpochInfoResponse message. Does not implicitly {@link ununifi.epochs.QueryEpochInfoResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @static
       * @param {ununifi.epochs.IQueryEpochInfoResponse} message QueryEpochInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochInfoResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.epoch != null && Object.hasOwnProperty.call(message, 'epoch'))
          $root.ununifi.epochs.EpochInfo.encode(message.epoch, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEpochInfoResponse message, length delimited. Does not implicitly {@link ununifi.epochs.QueryEpochInfoResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @static
       * @param {ununifi.epochs.IQueryEpochInfoResponse} message QueryEpochInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEpochInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEpochInfoResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.epochs.QueryEpochInfoResponse} QueryEpochInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochInfoResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.epochs.QueryEpochInfoResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.epoch = $root.ununifi.epochs.EpochInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEpochInfoResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.epochs.QueryEpochInfoResponse} QueryEpochInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEpochInfoResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEpochInfoResponse message.
       * @function verify
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEpochInfoResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.epoch != null && message.hasOwnProperty('epoch')) {
          let error = $root.ununifi.epochs.EpochInfo.verify(message.epoch);
          if (error) return 'epoch.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEpochInfoResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.epochs.QueryEpochInfoResponse} QueryEpochInfoResponse
       */
      QueryEpochInfoResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.epochs.QueryEpochInfoResponse) return object;
        let message = new $root.ununifi.epochs.QueryEpochInfoResponse();
        if (object.epoch != null) {
          if (typeof object.epoch !== 'object') throw TypeError('.ununifi.epochs.QueryEpochInfoResponse.epoch: object expected');
          message.epoch = $root.ununifi.epochs.EpochInfo.fromObject(object.epoch);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEpochInfoResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @static
       * @param {ununifi.epochs.QueryEpochInfoResponse} message QueryEpochInfoResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEpochInfoResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.epoch = null;
        if (message.epoch != null && message.hasOwnProperty('epoch'))
          object.epoch = $root.ununifi.epochs.EpochInfo.toObject(message.epoch, options);
        return object;
      };

      /**
       * Converts this QueryEpochInfoResponse to JSON.
       * @function toJSON
       * @memberof ununifi.epochs.QueryEpochInfoResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEpochInfoResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEpochInfoResponse;
    })();

    return epochs;
  })();

  ununifi.irs = (function () {
    /**
     * Namespace irs.
     * @memberof ununifi
     * @namespace
     */
    const irs = {};

    irs.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.irs
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.irs.Msg#updateParams}.
       * @memberof ununifi.irs.Msg
       * @typedef UpdateParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.MsgUpdateParamsResponse} [response] MsgUpdateParamsResponse
       */

      /**
       * Calls UpdateParams.
       * @function updateParams
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgUpdateParams} request MsgUpdateParams message or plain object
       * @param {ununifi.irs.Msg.UpdateParamsCallback} callback Node-style callback called with the error, if any, and MsgUpdateParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateParams = function updateParams(request, callback) {
          return this.rpcCall(
            updateParams,
            $root.ununifi.irs.MsgUpdateParams,
            $root.ununifi.irs.MsgUpdateParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateParams' },
      );

      /**
       * Calls UpdateParams.
       * @function updateParams
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgUpdateParams} request MsgUpdateParams message or plain object
       * @returns {Promise<ununifi.irs.MsgUpdateParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Msg#registerInterestRateSwapVault}.
       * @memberof ununifi.irs.Msg
       * @typedef RegisterInterestRateSwapVaultCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.MsgRegisterInterestRateSwapVaultResponse} [response] MsgRegisterInterestRateSwapVaultResponse
       */

      /**
       * Calls RegisterInterestRateSwapVault.
       * @function registerInterestRateSwapVault
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVault} request MsgRegisterInterestRateSwapVault message or plain object
       * @param {ununifi.irs.Msg.RegisterInterestRateSwapVaultCallback} callback Node-style callback called with the error, if any, and MsgRegisterInterestRateSwapVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.registerInterestRateSwapVault = function registerInterestRateSwapVault(request, callback) {
          return this.rpcCall(
            registerInterestRateSwapVault,
            $root.ununifi.irs.MsgRegisterInterestRateSwapVault,
            $root.ununifi.irs.MsgRegisterInterestRateSwapVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RegisterInterestRateSwapVault' },
      );

      /**
       * Calls RegisterInterestRateSwapVault.
       * @function registerInterestRateSwapVault
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVault} request MsgRegisterInterestRateSwapVault message or plain object
       * @returns {Promise<ununifi.irs.MsgRegisterInterestRateSwapVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Msg#depositLiquidity}.
       * @memberof ununifi.irs.Msg
       * @typedef DepositLiquidityCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.MsgDepositLiquidityResponse} [response] MsgDepositLiquidityResponse
       */

      /**
       * Calls DepositLiquidity.
       * @function depositLiquidity
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgDepositLiquidity} request MsgDepositLiquidity message or plain object
       * @param {ununifi.irs.Msg.DepositLiquidityCallback} callback Node-style callback called with the error, if any, and MsgDepositLiquidityResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.depositLiquidity = function depositLiquidity(request, callback) {
          return this.rpcCall(
            depositLiquidity,
            $root.ununifi.irs.MsgDepositLiquidity,
            $root.ununifi.irs.MsgDepositLiquidityResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DepositLiquidity' },
      );

      /**
       * Calls DepositLiquidity.
       * @function depositLiquidity
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgDepositLiquidity} request MsgDepositLiquidity message or plain object
       * @returns {Promise<ununifi.irs.MsgDepositLiquidityResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Msg#withdrawLiquidity}.
       * @memberof ununifi.irs.Msg
       * @typedef WithdrawLiquidityCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.MsgWithdrawLiquidityResponse} [response] MsgWithdrawLiquidityResponse
       */

      /**
       * Calls WithdrawLiquidity.
       * @function withdrawLiquidity
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgWithdrawLiquidity} request MsgWithdrawLiquidity message or plain object
       * @param {ununifi.irs.Msg.WithdrawLiquidityCallback} callback Node-style callback called with the error, if any, and MsgWithdrawLiquidityResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawLiquidity = function withdrawLiquidity(request, callback) {
          return this.rpcCall(
            withdrawLiquidity,
            $root.ununifi.irs.MsgWithdrawLiquidity,
            $root.ununifi.irs.MsgWithdrawLiquidityResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawLiquidity' },
      );

      /**
       * Calls WithdrawLiquidity.
       * @function withdrawLiquidity
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgWithdrawLiquidity} request MsgWithdrawLiquidity message or plain object
       * @returns {Promise<ununifi.irs.MsgWithdrawLiquidityResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Msg#depositToTranche}.
       * @memberof ununifi.irs.Msg
       * @typedef DepositToTrancheCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.MsgDepositToTrancheResponse} [response] MsgDepositToTrancheResponse
       */

      /**
       * Calls DepositToTranche.
       * @function depositToTranche
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgDepositToTranche} request MsgDepositToTranche message or plain object
       * @param {ununifi.irs.Msg.DepositToTrancheCallback} callback Node-style callback called with the error, if any, and MsgDepositToTrancheResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.depositToTranche = function depositToTranche(request, callback) {
          return this.rpcCall(
            depositToTranche,
            $root.ununifi.irs.MsgDepositToTranche,
            $root.ununifi.irs.MsgDepositToTrancheResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DepositToTranche' },
      );

      /**
       * Calls DepositToTranche.
       * @function depositToTranche
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgDepositToTranche} request MsgDepositToTranche message or plain object
       * @returns {Promise<ununifi.irs.MsgDepositToTrancheResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Msg#withdrawFromTranche}.
       * @memberof ununifi.irs.Msg
       * @typedef WithdrawFromTrancheCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.MsgWithdrawFromTrancheResponse} [response] MsgWithdrawFromTrancheResponse
       */

      /**
       * Calls WithdrawFromTranche.
       * @function withdrawFromTranche
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgWithdrawFromTranche} request MsgWithdrawFromTranche message or plain object
       * @param {ununifi.irs.Msg.WithdrawFromTrancheCallback} callback Node-style callback called with the error, if any, and MsgWithdrawFromTrancheResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawFromTranche = function withdrawFromTranche(request, callback) {
          return this.rpcCall(
            withdrawFromTranche,
            $root.ununifi.irs.MsgWithdrawFromTranche,
            $root.ununifi.irs.MsgWithdrawFromTrancheResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawFromTranche' },
      );

      /**
       * Calls WithdrawFromTranche.
       * @function withdrawFromTranche
       * @memberof ununifi.irs.Msg
       * @instance
       * @param {ununifi.irs.IMsgWithdrawFromTranche} request MsgWithdrawFromTranche message or plain object
       * @returns {Promise<ununifi.irs.MsgWithdrawFromTrancheResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    irs.MsgUpdateParams = (function () {
      /**
       * Properties of a MsgUpdateParams.
       * @memberof ununifi.irs
       * @interface IMsgUpdateParams
       * @property {string|null} [sender] MsgUpdateParams sender
       * @property {ununifi.irs.IParams|null} [params] MsgUpdateParams params
       */

      /**
       * Constructs a new MsgUpdateParams.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgUpdateParams.
       * @implements IMsgUpdateParams
       * @constructor
       * @param {ununifi.irs.IMsgUpdateParams=} [properties] Properties to set
       */
      function MsgUpdateParams(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateParams sender.
       * @member {string} sender
       * @memberof ununifi.irs.MsgUpdateParams
       * @instance
       */
      MsgUpdateParams.prototype.sender = '';

      /**
       * MsgUpdateParams params.
       * @member {ununifi.irs.IParams|null|undefined} params
       * @memberof ununifi.irs.MsgUpdateParams
       * @instance
       */
      MsgUpdateParams.prototype.params = null;

      /**
       * Encodes the specified MsgUpdateParams message. Does not implicitly {@link ununifi.irs.MsgUpdateParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgUpdateParams
       * @static
       * @param {ununifi.irs.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.irs.Params.encode(message.params, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateParams message, length delimited. Does not implicitly {@link ununifi.irs.MsgUpdateParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgUpdateParams
       * @static
       * @param {ununifi.irs.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgUpdateParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgUpdateParams} MsgUpdateParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgUpdateParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.params = $root.ununifi.irs.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgUpdateParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgUpdateParams} MsgUpdateParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateParams message.
       * @function verify
       * @memberof ununifi.irs.MsgUpdateParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.irs.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgUpdateParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgUpdateParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgUpdateParams} MsgUpdateParams
       */
      MsgUpdateParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgUpdateParams) return object;
        let message = new $root.ununifi.irs.MsgUpdateParams();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.irs.MsgUpdateParams.params: object expected');
          message.params = $root.ununifi.irs.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgUpdateParams
       * @static
       * @param {ununifi.irs.MsgUpdateParams} message MsgUpdateParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.params = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.irs.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this MsgUpdateParams to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgUpdateParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateParams;
    })();

    irs.MsgUpdateParamsResponse = (function () {
      /**
       * Properties of a MsgUpdateParamsResponse.
       * @memberof ununifi.irs
       * @interface IMsgUpdateParamsResponse
       */

      /**
       * Constructs a new MsgUpdateParamsResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgUpdateParamsResponse.
       * @implements IMsgUpdateParamsResponse
       * @constructor
       * @param {ununifi.irs.IMsgUpdateParamsResponse=} [properties] Properties to set
       */
      function MsgUpdateParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateParamsResponse message. Does not implicitly {@link ununifi.irs.MsgUpdateParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.irs.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateParamsResponse message, length delimited. Does not implicitly {@link ununifi.irs.MsgUpdateParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.irs.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgUpdateParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateParamsResponse message.
       * @function verify
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       */
      MsgUpdateParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgUpdateParamsResponse) return object;
        return new $root.ununifi.irs.MsgUpdateParamsResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.irs.MsgUpdateParamsResponse} message MsgUpdateParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateParamsResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgUpdateParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateParamsResponse;
    })();

    irs.MsgRegisterInterestRateSwapVault = (function () {
      /**
       * Properties of a MsgRegisterInterestRateSwapVault.
       * @memberof ununifi.irs
       * @interface IMsgRegisterInterestRateSwapVault
       * @property {string|null} [sender] MsgRegisterInterestRateSwapVault sender
       * @property {string|null} [strategy_contract] MsgRegisterInterestRateSwapVault strategy_contract
       * @property {string|null} [name] MsgRegisterInterestRateSwapVault name
       * @property {string|null} [description] MsgRegisterInterestRateSwapVault description
       * @property {Long|null} [max_maturity] MsgRegisterInterestRateSwapVault max_maturity
       * @property {Long|null} [cycle] MsgRegisterInterestRateSwapVault cycle
       */

      /**
       * Constructs a new MsgRegisterInterestRateSwapVault.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgRegisterInterestRateSwapVault.
       * @implements IMsgRegisterInterestRateSwapVault
       * @constructor
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVault=} [properties] Properties to set
       */
      function MsgRegisterInterestRateSwapVault(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRegisterInterestRateSwapVault sender.
       * @member {string} sender
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @instance
       */
      MsgRegisterInterestRateSwapVault.prototype.sender = '';

      /**
       * MsgRegisterInterestRateSwapVault strategy_contract.
       * @member {string} strategy_contract
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @instance
       */
      MsgRegisterInterestRateSwapVault.prototype.strategy_contract = '';

      /**
       * MsgRegisterInterestRateSwapVault name.
       * @member {string} name
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @instance
       */
      MsgRegisterInterestRateSwapVault.prototype.name = '';

      /**
       * MsgRegisterInterestRateSwapVault description.
       * @member {string} description
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @instance
       */
      MsgRegisterInterestRateSwapVault.prototype.description = '';

      /**
       * MsgRegisterInterestRateSwapVault max_maturity.
       * @member {Long} max_maturity
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @instance
       */
      MsgRegisterInterestRateSwapVault.prototype.max_maturity = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgRegisterInterestRateSwapVault cycle.
       * @member {Long} cycle
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @instance
       */
      MsgRegisterInterestRateSwapVault.prototype.cycle = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified MsgRegisterInterestRateSwapVault message. Does not implicitly {@link ununifi.irs.MsgRegisterInterestRateSwapVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @static
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVault} message MsgRegisterInterestRateSwapVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterInterestRateSwapVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.strategy_contract != null && Object.hasOwnProperty.call(message, 'strategy_contract'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.strategy_contract);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.description);
        if (message.max_maturity != null && Object.hasOwnProperty.call(message, 'max_maturity'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.max_maturity);
        if (message.cycle != null && Object.hasOwnProperty.call(message, 'cycle'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.cycle);
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterInterestRateSwapVault message, length delimited. Does not implicitly {@link ununifi.irs.MsgRegisterInterestRateSwapVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @static
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVault} message MsgRegisterInterestRateSwapVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterInterestRateSwapVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterInterestRateSwapVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgRegisterInterestRateSwapVault} MsgRegisterInterestRateSwapVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterInterestRateSwapVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgRegisterInterestRateSwapVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.strategy_contract = reader.string();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.description = reader.string();
              break;
            case 5:
              message.max_maturity = reader.uint64();
              break;
            case 6:
              message.cycle = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterInterestRateSwapVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgRegisterInterestRateSwapVault} MsgRegisterInterestRateSwapVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterInterestRateSwapVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterInterestRateSwapVault message.
       * @function verify
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterInterestRateSwapVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          if (!$util.isString(message.strategy_contract)) return 'strategy_contract: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.max_maturity != null && message.hasOwnProperty('max_maturity'))
          if (
            !$util.isInteger(message.max_maturity) &&
            !(message.max_maturity && $util.isInteger(message.max_maturity.low) && $util.isInteger(message.max_maturity.high))
          )
            return 'max_maturity: integer|Long expected';
        if (message.cycle != null && message.hasOwnProperty('cycle'))
          if (
            !$util.isInteger(message.cycle) &&
            !(message.cycle && $util.isInteger(message.cycle.low) && $util.isInteger(message.cycle.high))
          )
            return 'cycle: integer|Long expected';
        return null;
      };

      /**
       * Creates a MsgRegisterInterestRateSwapVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgRegisterInterestRateSwapVault} MsgRegisterInterestRateSwapVault
       */
      MsgRegisterInterestRateSwapVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgRegisterInterestRateSwapVault) return object;
        let message = new $root.ununifi.irs.MsgRegisterInterestRateSwapVault();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.strategy_contract != null) message.strategy_contract = String(object.strategy_contract);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.max_maturity != null)
          if ($util.Long) (message.max_maturity = $util.Long.fromValue(object.max_maturity)).unsigned = true;
          else if (typeof object.max_maturity === 'string') message.max_maturity = parseInt(object.max_maturity, 10);
          else if (typeof object.max_maturity === 'number') message.max_maturity = object.max_maturity;
          else if (typeof object.max_maturity === 'object')
            message.max_maturity = new $util.LongBits(object.max_maturity.low >>> 0, object.max_maturity.high >>> 0).toNumber(true);
        if (object.cycle != null)
          if ($util.Long) (message.cycle = $util.Long.fromValue(object.cycle)).unsigned = true;
          else if (typeof object.cycle === 'string') message.cycle = parseInt(object.cycle, 10);
          else if (typeof object.cycle === 'number') message.cycle = object.cycle;
          else if (typeof object.cycle === 'object')
            message.cycle = new $util.LongBits(object.cycle.low >>> 0, object.cycle.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a MsgRegisterInterestRateSwapVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @static
       * @param {ununifi.irs.MsgRegisterInterestRateSwapVault} message MsgRegisterInterestRateSwapVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterInterestRateSwapVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.strategy_contract = '';
          object.name = '';
          object.description = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.max_maturity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.max_maturity = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.cycle = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.cycle = options.longs === String ? '0' : 0;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          object.strategy_contract = message.strategy_contract;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.max_maturity != null && message.hasOwnProperty('max_maturity'))
          if (typeof message.max_maturity === 'number')
            object.max_maturity = options.longs === String ? String(message.max_maturity) : message.max_maturity;
          else
            object.max_maturity =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.max_maturity)
                : options.longs === Number
                ? new $util.LongBits(message.max_maturity.low >>> 0, message.max_maturity.high >>> 0).toNumber(true)
                : message.max_maturity;
        if (message.cycle != null && message.hasOwnProperty('cycle'))
          if (typeof message.cycle === 'number') object.cycle = options.longs === String ? String(message.cycle) : message.cycle;
          else
            object.cycle =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.cycle)
                : options.longs === Number
                ? new $util.LongBits(message.cycle.low >>> 0, message.cycle.high >>> 0).toNumber(true)
                : message.cycle;
        return object;
      };

      /**
       * Converts this MsgRegisterInterestRateSwapVault to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterInterestRateSwapVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterInterestRateSwapVault;
    })();

    irs.MsgRegisterInterestRateSwapVaultResponse = (function () {
      /**
       * Properties of a MsgRegisterInterestRateSwapVaultResponse.
       * @memberof ununifi.irs
       * @interface IMsgRegisterInterestRateSwapVaultResponse
       */

      /**
       * Constructs a new MsgRegisterInterestRateSwapVaultResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgRegisterInterestRateSwapVaultResponse.
       * @implements IMsgRegisterInterestRateSwapVaultResponse
       * @constructor
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVaultResponse=} [properties] Properties to set
       */
      function MsgRegisterInterestRateSwapVaultResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRegisterInterestRateSwapVaultResponse message. Does not implicitly {@link ununifi.irs.MsgRegisterInterestRateSwapVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @static
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVaultResponse} message MsgRegisterInterestRateSwapVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterInterestRateSwapVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterInterestRateSwapVaultResponse message, length delimited. Does not implicitly {@link ununifi.irs.MsgRegisterInterestRateSwapVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @static
       * @param {ununifi.irs.IMsgRegisterInterestRateSwapVaultResponse} message MsgRegisterInterestRateSwapVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterInterestRateSwapVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterInterestRateSwapVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgRegisterInterestRateSwapVaultResponse} MsgRegisterInterestRateSwapVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterInterestRateSwapVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgRegisterInterestRateSwapVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterInterestRateSwapVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgRegisterInterestRateSwapVaultResponse} MsgRegisterInterestRateSwapVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterInterestRateSwapVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterInterestRateSwapVaultResponse message.
       * @function verify
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterInterestRateSwapVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRegisterInterestRateSwapVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgRegisterInterestRateSwapVaultResponse} MsgRegisterInterestRateSwapVaultResponse
       */
      MsgRegisterInterestRateSwapVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgRegisterInterestRateSwapVaultResponse) return object;
        return new $root.ununifi.irs.MsgRegisterInterestRateSwapVaultResponse();
      };

      /**
       * Creates a plain object from a MsgRegisterInterestRateSwapVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @static
       * @param {ununifi.irs.MsgRegisterInterestRateSwapVaultResponse} message MsgRegisterInterestRateSwapVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterInterestRateSwapVaultResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRegisterInterestRateSwapVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgRegisterInterestRateSwapVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterInterestRateSwapVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterInterestRateSwapVaultResponse;
    })();

    irs.MsgDepositLiquidity = (function () {
      /**
       * Properties of a MsgDepositLiquidity.
       * @memberof ununifi.irs
       * @interface IMsgDepositLiquidity
       * @property {string|null} [sender] MsgDepositLiquidity sender
       * @property {Long|null} [tranche_id] MsgDepositLiquidity tranche_id
       * @property {string|null} [share_out_amount] MsgDepositLiquidity share_out_amount
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [token_in_maxs] MsgDepositLiquidity token_in_maxs
       */

      /**
       * Constructs a new MsgDepositLiquidity.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgDepositLiquidity.
       * @implements IMsgDepositLiquidity
       * @constructor
       * @param {ununifi.irs.IMsgDepositLiquidity=} [properties] Properties to set
       */
      function MsgDepositLiquidity(properties) {
        this.token_in_maxs = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgDepositLiquidity sender.
       * @member {string} sender
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @instance
       */
      MsgDepositLiquidity.prototype.sender = '';

      /**
       * MsgDepositLiquidity tranche_id.
       * @member {Long} tranche_id
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @instance
       */
      MsgDepositLiquidity.prototype.tranche_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgDepositLiquidity share_out_amount.
       * @member {string} share_out_amount
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @instance
       */
      MsgDepositLiquidity.prototype.share_out_amount = '';

      /**
       * MsgDepositLiquidity token_in_maxs.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} token_in_maxs
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @instance
       */
      MsgDepositLiquidity.prototype.token_in_maxs = $util.emptyArray;

      /**
       * Encodes the specified MsgDepositLiquidity message. Does not implicitly {@link ununifi.irs.MsgDepositLiquidity.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @static
       * @param {ununifi.irs.IMsgDepositLiquidity} message MsgDepositLiquidity message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositLiquidity.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.tranche_id != null && Object.hasOwnProperty.call(message, 'tranche_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.tranche_id);
        if (message.share_out_amount != null && Object.hasOwnProperty.call(message, 'share_out_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.share_out_amount);
        if (message.token_in_maxs != null && message.token_in_maxs.length)
          for (let i = 0; i < message.token_in_maxs.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.token_in_maxs[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositLiquidity message, length delimited. Does not implicitly {@link ununifi.irs.MsgDepositLiquidity.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @static
       * @param {ununifi.irs.IMsgDepositLiquidity} message MsgDepositLiquidity message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositLiquidity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositLiquidity message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgDepositLiquidity} MsgDepositLiquidity
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositLiquidity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgDepositLiquidity();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.tranche_id = reader.uint64();
              break;
            case 3:
              message.share_out_amount = reader.string();
              break;
            case 4:
              if (!(message.token_in_maxs && message.token_in_maxs.length)) message.token_in_maxs = [];
              message.token_in_maxs.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositLiquidity message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgDepositLiquidity} MsgDepositLiquidity
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositLiquidity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositLiquidity message.
       * @function verify
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositLiquidity.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (
            !$util.isInteger(message.tranche_id) &&
            !(message.tranche_id && $util.isInteger(message.tranche_id.low) && $util.isInteger(message.tranche_id.high))
          )
            return 'tranche_id: integer|Long expected';
        if (message.share_out_amount != null && message.hasOwnProperty('share_out_amount'))
          if (!$util.isString(message.share_out_amount)) return 'share_out_amount: string expected';
        if (message.token_in_maxs != null && message.hasOwnProperty('token_in_maxs')) {
          if (!Array.isArray(message.token_in_maxs)) return 'token_in_maxs: array expected';
          for (let i = 0; i < message.token_in_maxs.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.token_in_maxs[i]);
            if (error) return 'token_in_maxs.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgDepositLiquidity message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgDepositLiquidity} MsgDepositLiquidity
       */
      MsgDepositLiquidity.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgDepositLiquidity) return object;
        let message = new $root.ununifi.irs.MsgDepositLiquidity();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.tranche_id != null)
          if ($util.Long) (message.tranche_id = $util.Long.fromValue(object.tranche_id)).unsigned = true;
          else if (typeof object.tranche_id === 'string') message.tranche_id = parseInt(object.tranche_id, 10);
          else if (typeof object.tranche_id === 'number') message.tranche_id = object.tranche_id;
          else if (typeof object.tranche_id === 'object')
            message.tranche_id = new $util.LongBits(object.tranche_id.low >>> 0, object.tranche_id.high >>> 0).toNumber(true);
        if (object.share_out_amount != null) message.share_out_amount = String(object.share_out_amount);
        if (object.token_in_maxs) {
          if (!Array.isArray(object.token_in_maxs)) throw TypeError('.ununifi.irs.MsgDepositLiquidity.token_in_maxs: array expected');
          message.token_in_maxs = [];
          for (let i = 0; i < object.token_in_maxs.length; ++i) {
            if (typeof object.token_in_maxs[i] !== 'object')
              throw TypeError('.ununifi.irs.MsgDepositLiquidity.token_in_maxs: object expected');
            message.token_in_maxs[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.token_in_maxs[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgDepositLiquidity message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @static
       * @param {ununifi.irs.MsgDepositLiquidity} message MsgDepositLiquidity
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositLiquidity.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.token_in_maxs = [];
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.tranche_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.tranche_id = options.longs === String ? '0' : 0;
          object.share_out_amount = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (typeof message.tranche_id === 'number')
            object.tranche_id = options.longs === String ? String(message.tranche_id) : message.tranche_id;
          else
            object.tranche_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.tranche_id)
                : options.longs === Number
                ? new $util.LongBits(message.tranche_id.low >>> 0, message.tranche_id.high >>> 0).toNumber(true)
                : message.tranche_id;
        if (message.share_out_amount != null && message.hasOwnProperty('share_out_amount'))
          object.share_out_amount = message.share_out_amount;
        if (message.token_in_maxs && message.token_in_maxs.length) {
          object.token_in_maxs = [];
          for (let j = 0; j < message.token_in_maxs.length; ++j)
            object.token_in_maxs[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.token_in_maxs[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgDepositLiquidity to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgDepositLiquidity
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositLiquidity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositLiquidity;
    })();

    irs.MsgDepositLiquidityResponse = (function () {
      /**
       * Properties of a MsgDepositLiquidityResponse.
       * @memberof ununifi.irs
       * @interface IMsgDepositLiquidityResponse
       */

      /**
       * Constructs a new MsgDepositLiquidityResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgDepositLiquidityResponse.
       * @implements IMsgDepositLiquidityResponse
       * @constructor
       * @param {ununifi.irs.IMsgDepositLiquidityResponse=} [properties] Properties to set
       */
      function MsgDepositLiquidityResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgDepositLiquidityResponse message. Does not implicitly {@link ununifi.irs.MsgDepositLiquidityResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @static
       * @param {ununifi.irs.IMsgDepositLiquidityResponse} message MsgDepositLiquidityResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositLiquidityResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositLiquidityResponse message, length delimited. Does not implicitly {@link ununifi.irs.MsgDepositLiquidityResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @static
       * @param {ununifi.irs.IMsgDepositLiquidityResponse} message MsgDepositLiquidityResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositLiquidityResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositLiquidityResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgDepositLiquidityResponse} MsgDepositLiquidityResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositLiquidityResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgDepositLiquidityResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositLiquidityResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgDepositLiquidityResponse} MsgDepositLiquidityResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositLiquidityResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositLiquidityResponse message.
       * @function verify
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositLiquidityResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgDepositLiquidityResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgDepositLiquidityResponse} MsgDepositLiquidityResponse
       */
      MsgDepositLiquidityResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgDepositLiquidityResponse) return object;
        return new $root.ununifi.irs.MsgDepositLiquidityResponse();
      };

      /**
       * Creates a plain object from a MsgDepositLiquidityResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @static
       * @param {ununifi.irs.MsgDepositLiquidityResponse} message MsgDepositLiquidityResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositLiquidityResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgDepositLiquidityResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgDepositLiquidityResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositLiquidityResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositLiquidityResponse;
    })();

    irs.MsgWithdrawLiquidity = (function () {
      /**
       * Properties of a MsgWithdrawLiquidity.
       * @memberof ununifi.irs
       * @interface IMsgWithdrawLiquidity
       * @property {string|null} [sender] MsgWithdrawLiquidity sender
       * @property {Long|null} [tranche_id] MsgWithdrawLiquidity tranche_id
       * @property {string|null} [share_amount] MsgWithdrawLiquidity share_amount
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [token_out_mins] MsgWithdrawLiquidity token_out_mins
       */

      /**
       * Constructs a new MsgWithdrawLiquidity.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgWithdrawLiquidity.
       * @implements IMsgWithdrawLiquidity
       * @constructor
       * @param {ununifi.irs.IMsgWithdrawLiquidity=} [properties] Properties to set
       */
      function MsgWithdrawLiquidity(properties) {
        this.token_out_mins = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawLiquidity sender.
       * @member {string} sender
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @instance
       */
      MsgWithdrawLiquidity.prototype.sender = '';

      /**
       * MsgWithdrawLiquidity tranche_id.
       * @member {Long} tranche_id
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @instance
       */
      MsgWithdrawLiquidity.prototype.tranche_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgWithdrawLiquidity share_amount.
       * @member {string} share_amount
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @instance
       */
      MsgWithdrawLiquidity.prototype.share_amount = '';

      /**
       * MsgWithdrawLiquidity token_out_mins.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} token_out_mins
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @instance
       */
      MsgWithdrawLiquidity.prototype.token_out_mins = $util.emptyArray;

      /**
       * Encodes the specified MsgWithdrawLiquidity message. Does not implicitly {@link ununifi.irs.MsgWithdrawLiquidity.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @static
       * @param {ununifi.irs.IMsgWithdrawLiquidity} message MsgWithdrawLiquidity message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawLiquidity.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.tranche_id != null && Object.hasOwnProperty.call(message, 'tranche_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.tranche_id);
        if (message.share_amount != null && Object.hasOwnProperty.call(message, 'share_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.share_amount);
        if (message.token_out_mins != null && message.token_out_mins.length)
          for (let i = 0; i < message.token_out_mins.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.token_out_mins[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawLiquidity message, length delimited. Does not implicitly {@link ununifi.irs.MsgWithdrawLiquidity.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @static
       * @param {ununifi.irs.IMsgWithdrawLiquidity} message MsgWithdrawLiquidity message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawLiquidity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawLiquidity message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgWithdrawLiquidity} MsgWithdrawLiquidity
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawLiquidity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgWithdrawLiquidity();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.tranche_id = reader.uint64();
              break;
            case 3:
              message.share_amount = reader.string();
              break;
            case 4:
              if (!(message.token_out_mins && message.token_out_mins.length)) message.token_out_mins = [];
              message.token_out_mins.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawLiquidity message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgWithdrawLiquidity} MsgWithdrawLiquidity
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawLiquidity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawLiquidity message.
       * @function verify
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawLiquidity.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (
            !$util.isInteger(message.tranche_id) &&
            !(message.tranche_id && $util.isInteger(message.tranche_id.low) && $util.isInteger(message.tranche_id.high))
          )
            return 'tranche_id: integer|Long expected';
        if (message.share_amount != null && message.hasOwnProperty('share_amount'))
          if (!$util.isString(message.share_amount)) return 'share_amount: string expected';
        if (message.token_out_mins != null && message.hasOwnProperty('token_out_mins')) {
          if (!Array.isArray(message.token_out_mins)) return 'token_out_mins: array expected';
          for (let i = 0; i < message.token_out_mins.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.token_out_mins[i]);
            if (error) return 'token_out_mins.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgWithdrawLiquidity message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgWithdrawLiquidity} MsgWithdrawLiquidity
       */
      MsgWithdrawLiquidity.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgWithdrawLiquidity) return object;
        let message = new $root.ununifi.irs.MsgWithdrawLiquidity();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.tranche_id != null)
          if ($util.Long) (message.tranche_id = $util.Long.fromValue(object.tranche_id)).unsigned = true;
          else if (typeof object.tranche_id === 'string') message.tranche_id = parseInt(object.tranche_id, 10);
          else if (typeof object.tranche_id === 'number') message.tranche_id = object.tranche_id;
          else if (typeof object.tranche_id === 'object')
            message.tranche_id = new $util.LongBits(object.tranche_id.low >>> 0, object.tranche_id.high >>> 0).toNumber(true);
        if (object.share_amount != null) message.share_amount = String(object.share_amount);
        if (object.token_out_mins) {
          if (!Array.isArray(object.token_out_mins)) throw TypeError('.ununifi.irs.MsgWithdrawLiquidity.token_out_mins: array expected');
          message.token_out_mins = [];
          for (let i = 0; i < object.token_out_mins.length; ++i) {
            if (typeof object.token_out_mins[i] !== 'object')
              throw TypeError('.ununifi.irs.MsgWithdrawLiquidity.token_out_mins: object expected');
            message.token_out_mins[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.token_out_mins[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawLiquidity message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @static
       * @param {ununifi.irs.MsgWithdrawLiquidity} message MsgWithdrawLiquidity
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawLiquidity.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.token_out_mins = [];
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.tranche_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.tranche_id = options.longs === String ? '0' : 0;
          object.share_amount = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (typeof message.tranche_id === 'number')
            object.tranche_id = options.longs === String ? String(message.tranche_id) : message.tranche_id;
          else
            object.tranche_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.tranche_id)
                : options.longs === Number
                ? new $util.LongBits(message.tranche_id.low >>> 0, message.tranche_id.high >>> 0).toNumber(true)
                : message.tranche_id;
        if (message.share_amount != null && message.hasOwnProperty('share_amount')) object.share_amount = message.share_amount;
        if (message.token_out_mins && message.token_out_mins.length) {
          object.token_out_mins = [];
          for (let j = 0; j < message.token_out_mins.length; ++j)
            object.token_out_mins[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.token_out_mins[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgWithdrawLiquidity to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgWithdrawLiquidity
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawLiquidity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawLiquidity;
    })();

    irs.MsgWithdrawLiquidityResponse = (function () {
      /**
       * Properties of a MsgWithdrawLiquidityResponse.
       * @memberof ununifi.irs
       * @interface IMsgWithdrawLiquidityResponse
       */

      /**
       * Constructs a new MsgWithdrawLiquidityResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgWithdrawLiquidityResponse.
       * @implements IMsgWithdrawLiquidityResponse
       * @constructor
       * @param {ununifi.irs.IMsgWithdrawLiquidityResponse=} [properties] Properties to set
       */
      function MsgWithdrawLiquidityResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawLiquidityResponse message. Does not implicitly {@link ununifi.irs.MsgWithdrawLiquidityResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @static
       * @param {ununifi.irs.IMsgWithdrawLiquidityResponse} message MsgWithdrawLiquidityResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawLiquidityResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawLiquidityResponse message, length delimited. Does not implicitly {@link ununifi.irs.MsgWithdrawLiquidityResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @static
       * @param {ununifi.irs.IMsgWithdrawLiquidityResponse} message MsgWithdrawLiquidityResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawLiquidityResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawLiquidityResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgWithdrawLiquidityResponse} MsgWithdrawLiquidityResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawLiquidityResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgWithdrawLiquidityResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawLiquidityResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgWithdrawLiquidityResponse} MsgWithdrawLiquidityResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawLiquidityResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawLiquidityResponse message.
       * @function verify
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawLiquidityResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawLiquidityResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgWithdrawLiquidityResponse} MsgWithdrawLiquidityResponse
       */
      MsgWithdrawLiquidityResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgWithdrawLiquidityResponse) return object;
        return new $root.ununifi.irs.MsgWithdrawLiquidityResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawLiquidityResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @static
       * @param {ununifi.irs.MsgWithdrawLiquidityResponse} message MsgWithdrawLiquidityResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawLiquidityResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawLiquidityResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgWithdrawLiquidityResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawLiquidityResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawLiquidityResponse;
    })();

    /**
     * TrancheType enum.
     * @name ununifi.irs.TrancheType
     * @enum {number}
     * @property {number} NORMAL_YIELD=0 NORMAL_YIELD value
     * @property {number} FIXED_YIELD=1 FIXED_YIELD value
     * @property {number} LEVERAGED_VARIABLE_YIELD=2 LEVERAGED_VARIABLE_YIELD value
     */
    irs.TrancheType = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'NORMAL_YIELD')] = 0;
      values[(valuesById[1] = 'FIXED_YIELD')] = 1;
      values[(valuesById[2] = 'LEVERAGED_VARIABLE_YIELD')] = 2;
      return values;
    })();

    irs.MsgDepositToTranche = (function () {
      /**
       * Properties of a MsgDepositToTranche.
       * @memberof ununifi.irs
       * @interface IMsgDepositToTranche
       * @property {string|null} [sender] MsgDepositToTranche sender
       * @property {Long|null} [tranche_id] MsgDepositToTranche tranche_id
       * @property {ununifi.irs.TrancheType|null} [tranche_type] MsgDepositToTranche tranche_type
       * @property {cosmos.base.v1beta1.ICoin|null} [token] MsgDepositToTranche token
       * @property {string|null} [required_yt] MsgDepositToTranche required_yt
       */

      /**
       * Constructs a new MsgDepositToTranche.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgDepositToTranche.
       * @implements IMsgDepositToTranche
       * @constructor
       * @param {ununifi.irs.IMsgDepositToTranche=} [properties] Properties to set
       */
      function MsgDepositToTranche(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgDepositToTranche sender.
       * @member {string} sender
       * @memberof ununifi.irs.MsgDepositToTranche
       * @instance
       */
      MsgDepositToTranche.prototype.sender = '';

      /**
       * MsgDepositToTranche tranche_id.
       * @member {Long} tranche_id
       * @memberof ununifi.irs.MsgDepositToTranche
       * @instance
       */
      MsgDepositToTranche.prototype.tranche_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgDepositToTranche tranche_type.
       * @member {ununifi.irs.TrancheType} tranche_type
       * @memberof ununifi.irs.MsgDepositToTranche
       * @instance
       */
      MsgDepositToTranche.prototype.tranche_type = 0;

      /**
       * MsgDepositToTranche token.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} token
       * @memberof ununifi.irs.MsgDepositToTranche
       * @instance
       */
      MsgDepositToTranche.prototype.token = null;

      /**
       * MsgDepositToTranche required_yt.
       * @member {string} required_yt
       * @memberof ununifi.irs.MsgDepositToTranche
       * @instance
       */
      MsgDepositToTranche.prototype.required_yt = '';

      /**
       * Encodes the specified MsgDepositToTranche message. Does not implicitly {@link ununifi.irs.MsgDepositToTranche.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgDepositToTranche
       * @static
       * @param {ununifi.irs.IMsgDepositToTranche} message MsgDepositToTranche message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToTranche.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.tranche_id != null && Object.hasOwnProperty.call(message, 'tranche_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.tranche_id);
        if (message.tranche_type != null && Object.hasOwnProperty.call(message, 'tranche_type'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.tranche_type);
        if (message.token != null && Object.hasOwnProperty.call(message, 'token'))
          $root.cosmos.base.v1beta1.Coin.encode(message.token, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.required_yt != null && Object.hasOwnProperty.call(message, 'required_yt'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.required_yt);
        return writer;
      };

      /**
       * Encodes the specified MsgDepositToTranche message, length delimited. Does not implicitly {@link ununifi.irs.MsgDepositToTranche.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgDepositToTranche
       * @static
       * @param {ununifi.irs.IMsgDepositToTranche} message MsgDepositToTranche message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToTranche.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositToTranche message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgDepositToTranche
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgDepositToTranche} MsgDepositToTranche
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToTranche.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgDepositToTranche();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.tranche_id = reader.uint64();
              break;
            case 3:
              message.tranche_type = reader.int32();
              break;
            case 4:
              message.token = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 5:
              message.required_yt = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositToTranche message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgDepositToTranche
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgDepositToTranche} MsgDepositToTranche
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToTranche.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositToTranche message.
       * @function verify
       * @memberof ununifi.irs.MsgDepositToTranche
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositToTranche.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (
            !$util.isInteger(message.tranche_id) &&
            !(message.tranche_id && $util.isInteger(message.tranche_id.low) && $util.isInteger(message.tranche_id.high))
          )
            return 'tranche_id: integer|Long expected';
        if (message.tranche_type != null && message.hasOwnProperty('tranche_type'))
          switch (message.tranche_type) {
            default:
              return 'tranche_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.token != null && message.hasOwnProperty('token')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.token);
          if (error) return 'token.' + error;
        }
        if (message.required_yt != null && message.hasOwnProperty('required_yt'))
          if (!$util.isString(message.required_yt)) return 'required_yt: string expected';
        return null;
      };

      /**
       * Creates a MsgDepositToTranche message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgDepositToTranche
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgDepositToTranche} MsgDepositToTranche
       */
      MsgDepositToTranche.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgDepositToTranche) return object;
        let message = new $root.ununifi.irs.MsgDepositToTranche();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.tranche_id != null)
          if ($util.Long) (message.tranche_id = $util.Long.fromValue(object.tranche_id)).unsigned = true;
          else if (typeof object.tranche_id === 'string') message.tranche_id = parseInt(object.tranche_id, 10);
          else if (typeof object.tranche_id === 'number') message.tranche_id = object.tranche_id;
          else if (typeof object.tranche_id === 'object')
            message.tranche_id = new $util.LongBits(object.tranche_id.low >>> 0, object.tranche_id.high >>> 0).toNumber(true);
        switch (object.tranche_type) {
          case 'NORMAL_YIELD':
          case 0:
            message.tranche_type = 0;
            break;
          case 'FIXED_YIELD':
          case 1:
            message.tranche_type = 1;
            break;
          case 'LEVERAGED_VARIABLE_YIELD':
          case 2:
            message.tranche_type = 2;
            break;
        }
        if (object.token != null) {
          if (typeof object.token !== 'object') throw TypeError('.ununifi.irs.MsgDepositToTranche.token: object expected');
          message.token = $root.cosmos.base.v1beta1.Coin.fromObject(object.token);
        }
        if (object.required_yt != null) message.required_yt = String(object.required_yt);
        return message;
      };

      /**
       * Creates a plain object from a MsgDepositToTranche message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgDepositToTranche
       * @static
       * @param {ununifi.irs.MsgDepositToTranche} message MsgDepositToTranche
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositToTranche.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.tranche_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.tranche_id = options.longs === String ? '0' : 0;
          object.tranche_type = options.enums === String ? 'NORMAL_YIELD' : 0;
          object.token = null;
          object.required_yt = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (typeof message.tranche_id === 'number')
            object.tranche_id = options.longs === String ? String(message.tranche_id) : message.tranche_id;
          else
            object.tranche_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.tranche_id)
                : options.longs === Number
                ? new $util.LongBits(message.tranche_id.low >>> 0, message.tranche_id.high >>> 0).toNumber(true)
                : message.tranche_id;
        if (message.tranche_type != null && message.hasOwnProperty('tranche_type'))
          object.tranche_type = options.enums === String ? $root.ununifi.irs.TrancheType[message.tranche_type] : message.tranche_type;
        if (message.token != null && message.hasOwnProperty('token'))
          object.token = $root.cosmos.base.v1beta1.Coin.toObject(message.token, options);
        if (message.required_yt != null && message.hasOwnProperty('required_yt')) object.required_yt = message.required_yt;
        return object;
      };

      /**
       * Converts this MsgDepositToTranche to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgDepositToTranche
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositToTranche.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositToTranche;
    })();

    irs.MsgDepositToTrancheResponse = (function () {
      /**
       * Properties of a MsgDepositToTrancheResponse.
       * @memberof ununifi.irs
       * @interface IMsgDepositToTrancheResponse
       */

      /**
       * Constructs a new MsgDepositToTrancheResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgDepositToTrancheResponse.
       * @implements IMsgDepositToTrancheResponse
       * @constructor
       * @param {ununifi.irs.IMsgDepositToTrancheResponse=} [properties] Properties to set
       */
      function MsgDepositToTrancheResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgDepositToTrancheResponse message. Does not implicitly {@link ununifi.irs.MsgDepositToTrancheResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @static
       * @param {ununifi.irs.IMsgDepositToTrancheResponse} message MsgDepositToTrancheResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToTrancheResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositToTrancheResponse message, length delimited. Does not implicitly {@link ununifi.irs.MsgDepositToTrancheResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @static
       * @param {ununifi.irs.IMsgDepositToTrancheResponse} message MsgDepositToTrancheResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToTrancheResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositToTrancheResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgDepositToTrancheResponse} MsgDepositToTrancheResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToTrancheResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgDepositToTrancheResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositToTrancheResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgDepositToTrancheResponse} MsgDepositToTrancheResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToTrancheResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositToTrancheResponse message.
       * @function verify
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositToTrancheResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgDepositToTrancheResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgDepositToTrancheResponse} MsgDepositToTrancheResponse
       */
      MsgDepositToTrancheResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgDepositToTrancheResponse) return object;
        return new $root.ununifi.irs.MsgDepositToTrancheResponse();
      };

      /**
       * Creates a plain object from a MsgDepositToTrancheResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @static
       * @param {ununifi.irs.MsgDepositToTrancheResponse} message MsgDepositToTrancheResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositToTrancheResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgDepositToTrancheResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgDepositToTrancheResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositToTrancheResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositToTrancheResponse;
    })();

    irs.MsgWithdrawFromTranche = (function () {
      /**
       * Properties of a MsgWithdrawFromTranche.
       * @memberof ununifi.irs
       * @interface IMsgWithdrawFromTranche
       * @property {string|null} [sender] MsgWithdrawFromTranche sender
       * @property {Long|null} [tranche_id] MsgWithdrawFromTranche tranche_id
       * @property {ununifi.irs.TrancheType|null} [tranche_type] MsgWithdrawFromTranche tranche_type
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [tokens] MsgWithdrawFromTranche tokens
       * @property {string|null} [required_ut] MsgWithdrawFromTranche required_ut
       */

      /**
       * Constructs a new MsgWithdrawFromTranche.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgWithdrawFromTranche.
       * @implements IMsgWithdrawFromTranche
       * @constructor
       * @param {ununifi.irs.IMsgWithdrawFromTranche=} [properties] Properties to set
       */
      function MsgWithdrawFromTranche(properties) {
        this.tokens = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawFromTranche sender.
       * @member {string} sender
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @instance
       */
      MsgWithdrawFromTranche.prototype.sender = '';

      /**
       * MsgWithdrawFromTranche tranche_id.
       * @member {Long} tranche_id
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @instance
       */
      MsgWithdrawFromTranche.prototype.tranche_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgWithdrawFromTranche tranche_type.
       * @member {ununifi.irs.TrancheType} tranche_type
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @instance
       */
      MsgWithdrawFromTranche.prototype.tranche_type = 0;

      /**
       * MsgWithdrawFromTranche tokens.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} tokens
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @instance
       */
      MsgWithdrawFromTranche.prototype.tokens = $util.emptyArray;

      /**
       * MsgWithdrawFromTranche required_ut.
       * @member {string} required_ut
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @instance
       */
      MsgWithdrawFromTranche.prototype.required_ut = '';

      /**
       * Encodes the specified MsgWithdrawFromTranche message. Does not implicitly {@link ununifi.irs.MsgWithdrawFromTranche.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @static
       * @param {ununifi.irs.IMsgWithdrawFromTranche} message MsgWithdrawFromTranche message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromTranche.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.tranche_id != null && Object.hasOwnProperty.call(message, 'tranche_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.tranche_id);
        if (message.tranche_type != null && Object.hasOwnProperty.call(message, 'tranche_type'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.tranche_type);
        if (message.tokens != null && message.tokens.length)
          for (let i = 0; i < message.tokens.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.tokens[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.required_ut != null && Object.hasOwnProperty.call(message, 'required_ut'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.required_ut);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromTranche message, length delimited. Does not implicitly {@link ununifi.irs.MsgWithdrawFromTranche.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @static
       * @param {ununifi.irs.IMsgWithdrawFromTranche} message MsgWithdrawFromTranche message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromTranche.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromTranche message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgWithdrawFromTranche} MsgWithdrawFromTranche
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromTranche.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgWithdrawFromTranche();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.tranche_id = reader.uint64();
              break;
            case 3:
              message.tranche_type = reader.int32();
              break;
            case 4:
              if (!(message.tokens && message.tokens.length)) message.tokens = [];
              message.tokens.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.required_ut = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromTranche message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgWithdrawFromTranche} MsgWithdrawFromTranche
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromTranche.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromTranche message.
       * @function verify
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromTranche.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (
            !$util.isInteger(message.tranche_id) &&
            !(message.tranche_id && $util.isInteger(message.tranche_id.low) && $util.isInteger(message.tranche_id.high))
          )
            return 'tranche_id: integer|Long expected';
        if (message.tranche_type != null && message.hasOwnProperty('tranche_type'))
          switch (message.tranche_type) {
            default:
              return 'tranche_type: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.tokens != null && message.hasOwnProperty('tokens')) {
          if (!Array.isArray(message.tokens)) return 'tokens: array expected';
          for (let i = 0; i < message.tokens.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.tokens[i]);
            if (error) return 'tokens.' + error;
          }
        }
        if (message.required_ut != null && message.hasOwnProperty('required_ut'))
          if (!$util.isString(message.required_ut)) return 'required_ut: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromTranche message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgWithdrawFromTranche} MsgWithdrawFromTranche
       */
      MsgWithdrawFromTranche.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgWithdrawFromTranche) return object;
        let message = new $root.ununifi.irs.MsgWithdrawFromTranche();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.tranche_id != null)
          if ($util.Long) (message.tranche_id = $util.Long.fromValue(object.tranche_id)).unsigned = true;
          else if (typeof object.tranche_id === 'string') message.tranche_id = parseInt(object.tranche_id, 10);
          else if (typeof object.tranche_id === 'number') message.tranche_id = object.tranche_id;
          else if (typeof object.tranche_id === 'object')
            message.tranche_id = new $util.LongBits(object.tranche_id.low >>> 0, object.tranche_id.high >>> 0).toNumber(true);
        switch (object.tranche_type) {
          case 'NORMAL_YIELD':
          case 0:
            message.tranche_type = 0;
            break;
          case 'FIXED_YIELD':
          case 1:
            message.tranche_type = 1;
            break;
          case 'LEVERAGED_VARIABLE_YIELD':
          case 2:
            message.tranche_type = 2;
            break;
        }
        if (object.tokens) {
          if (!Array.isArray(object.tokens)) throw TypeError('.ununifi.irs.MsgWithdrawFromTranche.tokens: array expected');
          message.tokens = [];
          for (let i = 0; i < object.tokens.length; ++i) {
            if (typeof object.tokens[i] !== 'object') throw TypeError('.ununifi.irs.MsgWithdrawFromTranche.tokens: object expected');
            message.tokens[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.tokens[i]);
          }
        }
        if (object.required_ut != null) message.required_ut = String(object.required_ut);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawFromTranche message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @static
       * @param {ununifi.irs.MsgWithdrawFromTranche} message MsgWithdrawFromTranche
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromTranche.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.tokens = [];
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.tranche_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.tranche_id = options.longs === String ? '0' : 0;
          object.tranche_type = options.enums === String ? 'NORMAL_YIELD' : 0;
          object.required_ut = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.tranche_id != null && message.hasOwnProperty('tranche_id'))
          if (typeof message.tranche_id === 'number')
            object.tranche_id = options.longs === String ? String(message.tranche_id) : message.tranche_id;
          else
            object.tranche_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.tranche_id)
                : options.longs === Number
                ? new $util.LongBits(message.tranche_id.low >>> 0, message.tranche_id.high >>> 0).toNumber(true)
                : message.tranche_id;
        if (message.tranche_type != null && message.hasOwnProperty('tranche_type'))
          object.tranche_type = options.enums === String ? $root.ununifi.irs.TrancheType[message.tranche_type] : message.tranche_type;
        if (message.tokens && message.tokens.length) {
          object.tokens = [];
          for (let j = 0; j < message.tokens.length; ++j)
            object.tokens[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.tokens[j], options);
        }
        if (message.required_ut != null && message.hasOwnProperty('required_ut')) object.required_ut = message.required_ut;
        return object;
      };

      /**
       * Converts this MsgWithdrawFromTranche to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgWithdrawFromTranche
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromTranche.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromTranche;
    })();

    irs.MsgWithdrawFromTrancheResponse = (function () {
      /**
       * Properties of a MsgWithdrawFromTrancheResponse.
       * @memberof ununifi.irs
       * @interface IMsgWithdrawFromTrancheResponse
       */

      /**
       * Constructs a new MsgWithdrawFromTrancheResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a MsgWithdrawFromTrancheResponse.
       * @implements IMsgWithdrawFromTrancheResponse
       * @constructor
       * @param {ununifi.irs.IMsgWithdrawFromTrancheResponse=} [properties] Properties to set
       */
      function MsgWithdrawFromTrancheResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawFromTrancheResponse message. Does not implicitly {@link ununifi.irs.MsgWithdrawFromTrancheResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @static
       * @param {ununifi.irs.IMsgWithdrawFromTrancheResponse} message MsgWithdrawFromTrancheResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromTrancheResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromTrancheResponse message, length delimited. Does not implicitly {@link ununifi.irs.MsgWithdrawFromTrancheResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @static
       * @param {ununifi.irs.IMsgWithdrawFromTrancheResponse} message MsgWithdrawFromTrancheResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromTrancheResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromTrancheResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.MsgWithdrawFromTrancheResponse} MsgWithdrawFromTrancheResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromTrancheResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.MsgWithdrawFromTrancheResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromTrancheResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.MsgWithdrawFromTrancheResponse} MsgWithdrawFromTrancheResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromTrancheResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromTrancheResponse message.
       * @function verify
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromTrancheResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromTrancheResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.MsgWithdrawFromTrancheResponse} MsgWithdrawFromTrancheResponse
       */
      MsgWithdrawFromTrancheResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.MsgWithdrawFromTrancheResponse) return object;
        return new $root.ununifi.irs.MsgWithdrawFromTrancheResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawFromTrancheResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @static
       * @param {ununifi.irs.MsgWithdrawFromTrancheResponse} message MsgWithdrawFromTrancheResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromTrancheResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawFromTrancheResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.MsgWithdrawFromTrancheResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromTrancheResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromTrancheResponse;
    })();

    irs.InterestRateSwapVault = (function () {
      /**
       * Properties of an InterestRateSwapVault.
       * @memberof ununifi.irs
       * @interface IInterestRateSwapVault
       * @property {string|null} [strategy_contract] InterestRateSwapVault strategy_contract
       * @property {string|null} [name] InterestRateSwapVault name
       * @property {string|null} [description] InterestRateSwapVault description
       * @property {Long|null} [max_maturity] InterestRateSwapVault max_maturity
       * @property {Long|null} [cycle] InterestRateSwapVault cycle
       * @property {Long|null} [last_tranche_time] InterestRateSwapVault last_tranche_time
       */

      /**
       * Constructs a new InterestRateSwapVault.
       * @memberof ununifi.irs
       * @classdesc Represents an InterestRateSwapVault.
       * @implements IInterestRateSwapVault
       * @constructor
       * @param {ununifi.irs.IInterestRateSwapVault=} [properties] Properties to set
       */
      function InterestRateSwapVault(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * InterestRateSwapVault strategy_contract.
       * @member {string} strategy_contract
       * @memberof ununifi.irs.InterestRateSwapVault
       * @instance
       */
      InterestRateSwapVault.prototype.strategy_contract = '';

      /**
       * InterestRateSwapVault name.
       * @member {string} name
       * @memberof ununifi.irs.InterestRateSwapVault
       * @instance
       */
      InterestRateSwapVault.prototype.name = '';

      /**
       * InterestRateSwapVault description.
       * @member {string} description
       * @memberof ununifi.irs.InterestRateSwapVault
       * @instance
       */
      InterestRateSwapVault.prototype.description = '';

      /**
       * InterestRateSwapVault max_maturity.
       * @member {Long} max_maturity
       * @memberof ununifi.irs.InterestRateSwapVault
       * @instance
       */
      InterestRateSwapVault.prototype.max_maturity = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * InterestRateSwapVault cycle.
       * @member {Long} cycle
       * @memberof ununifi.irs.InterestRateSwapVault
       * @instance
       */
      InterestRateSwapVault.prototype.cycle = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * InterestRateSwapVault last_tranche_time.
       * @member {Long} last_tranche_time
       * @memberof ununifi.irs.InterestRateSwapVault
       * @instance
       */
      InterestRateSwapVault.prototype.last_tranche_time = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified InterestRateSwapVault message. Does not implicitly {@link ununifi.irs.InterestRateSwapVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.InterestRateSwapVault
       * @static
       * @param {ununifi.irs.IInterestRateSwapVault} message InterestRateSwapVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      InterestRateSwapVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategy_contract != null && Object.hasOwnProperty.call(message, 'strategy_contract'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.strategy_contract);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.description);
        if (message.max_maturity != null && Object.hasOwnProperty.call(message, 'max_maturity'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.max_maturity);
        if (message.cycle != null && Object.hasOwnProperty.call(message, 'cycle'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.cycle);
        if (message.last_tranche_time != null && Object.hasOwnProperty.call(message, 'last_tranche_time'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.last_tranche_time);
        return writer;
      };

      /**
       * Encodes the specified InterestRateSwapVault message, length delimited. Does not implicitly {@link ununifi.irs.InterestRateSwapVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.InterestRateSwapVault
       * @static
       * @param {ununifi.irs.IInterestRateSwapVault} message InterestRateSwapVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      InterestRateSwapVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an InterestRateSwapVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.InterestRateSwapVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.InterestRateSwapVault} InterestRateSwapVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      InterestRateSwapVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.InterestRateSwapVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.strategy_contract = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.description = reader.string();
              break;
            case 4:
              message.max_maturity = reader.uint64();
              break;
            case 5:
              message.cycle = reader.uint64();
              break;
            case 6:
              message.last_tranche_time = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an InterestRateSwapVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.InterestRateSwapVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.InterestRateSwapVault} InterestRateSwapVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      InterestRateSwapVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an InterestRateSwapVault message.
       * @function verify
       * @memberof ununifi.irs.InterestRateSwapVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      InterestRateSwapVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          if (!$util.isString(message.strategy_contract)) return 'strategy_contract: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.max_maturity != null && message.hasOwnProperty('max_maturity'))
          if (
            !$util.isInteger(message.max_maturity) &&
            !(message.max_maturity && $util.isInteger(message.max_maturity.low) && $util.isInteger(message.max_maturity.high))
          )
            return 'max_maturity: integer|Long expected';
        if (message.cycle != null && message.hasOwnProperty('cycle'))
          if (
            !$util.isInteger(message.cycle) &&
            !(message.cycle && $util.isInteger(message.cycle.low) && $util.isInteger(message.cycle.high))
          )
            return 'cycle: integer|Long expected';
        if (message.last_tranche_time != null && message.hasOwnProperty('last_tranche_time'))
          if (
            !$util.isInteger(message.last_tranche_time) &&
            !(
              message.last_tranche_time &&
              $util.isInteger(message.last_tranche_time.low) &&
              $util.isInteger(message.last_tranche_time.high)
            )
          )
            return 'last_tranche_time: integer|Long expected';
        return null;
      };

      /**
       * Creates an InterestRateSwapVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.InterestRateSwapVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.InterestRateSwapVault} InterestRateSwapVault
       */
      InterestRateSwapVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.InterestRateSwapVault) return object;
        let message = new $root.ununifi.irs.InterestRateSwapVault();
        if (object.strategy_contract != null) message.strategy_contract = String(object.strategy_contract);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.max_maturity != null)
          if ($util.Long) (message.max_maturity = $util.Long.fromValue(object.max_maturity)).unsigned = true;
          else if (typeof object.max_maturity === 'string') message.max_maturity = parseInt(object.max_maturity, 10);
          else if (typeof object.max_maturity === 'number') message.max_maturity = object.max_maturity;
          else if (typeof object.max_maturity === 'object')
            message.max_maturity = new $util.LongBits(object.max_maturity.low >>> 0, object.max_maturity.high >>> 0).toNumber(true);
        if (object.cycle != null)
          if ($util.Long) (message.cycle = $util.Long.fromValue(object.cycle)).unsigned = true;
          else if (typeof object.cycle === 'string') message.cycle = parseInt(object.cycle, 10);
          else if (typeof object.cycle === 'number') message.cycle = object.cycle;
          else if (typeof object.cycle === 'object')
            message.cycle = new $util.LongBits(object.cycle.low >>> 0, object.cycle.high >>> 0).toNumber(true);
        if (object.last_tranche_time != null)
          if ($util.Long) (message.last_tranche_time = $util.Long.fromValue(object.last_tranche_time)).unsigned = true;
          else if (typeof object.last_tranche_time === 'string') message.last_tranche_time = parseInt(object.last_tranche_time, 10);
          else if (typeof object.last_tranche_time === 'number') message.last_tranche_time = object.last_tranche_time;
          else if (typeof object.last_tranche_time === 'object')
            message.last_tranche_time = new $util.LongBits(
              object.last_tranche_time.low >>> 0,
              object.last_tranche_time.high >>> 0,
            ).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from an InterestRateSwapVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.InterestRateSwapVault
       * @static
       * @param {ununifi.irs.InterestRateSwapVault} message InterestRateSwapVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      InterestRateSwapVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.strategy_contract = '';
          object.name = '';
          object.description = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.max_maturity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.max_maturity = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.cycle = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.cycle = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.last_tranche_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.last_tranche_time = options.longs === String ? '0' : 0;
        }
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          object.strategy_contract = message.strategy_contract;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.max_maturity != null && message.hasOwnProperty('max_maturity'))
          if (typeof message.max_maturity === 'number')
            object.max_maturity = options.longs === String ? String(message.max_maturity) : message.max_maturity;
          else
            object.max_maturity =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.max_maturity)
                : options.longs === Number
                ? new $util.LongBits(message.max_maturity.low >>> 0, message.max_maturity.high >>> 0).toNumber(true)
                : message.max_maturity;
        if (message.cycle != null && message.hasOwnProperty('cycle'))
          if (typeof message.cycle === 'number') object.cycle = options.longs === String ? String(message.cycle) : message.cycle;
          else
            object.cycle =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.cycle)
                : options.longs === Number
                ? new $util.LongBits(message.cycle.low >>> 0, message.cycle.high >>> 0).toNumber(true)
                : message.cycle;
        if (message.last_tranche_time != null && message.hasOwnProperty('last_tranche_time'))
          if (typeof message.last_tranche_time === 'number')
            object.last_tranche_time = options.longs === String ? String(message.last_tranche_time) : message.last_tranche_time;
          else
            object.last_tranche_time =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.last_tranche_time)
                : options.longs === Number
                ? new $util.LongBits(message.last_tranche_time.low >>> 0, message.last_tranche_time.high >>> 0).toNumber(true)
                : message.last_tranche_time;
        return object;
      };

      /**
       * Converts this InterestRateSwapVault to JSON.
       * @function toJSON
       * @memberof ununifi.irs.InterestRateSwapVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      InterestRateSwapVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return InterestRateSwapVault;
    })();

    irs.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.irs
       * @interface IParams
       * @property {string|null} [authority] Params authority
       * @property {string|null} [trade_fee_rate] Params trade_fee_rate
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.irs
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.irs.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params authority.
       * @member {string} authority
       * @memberof ununifi.irs.Params
       * @instance
       */
      Params.prototype.authority = '';

      /**
       * Params trade_fee_rate.
       * @member {string} trade_fee_rate
       * @memberof ununifi.irs.Params
       * @instance
       */
      Params.prototype.trade_fee_rate = '';

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.irs.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.Params
       * @static
       * @param {ununifi.irs.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.authority != null && Object.hasOwnProperty.call(message, 'authority'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.authority);
        if (message.trade_fee_rate != null && Object.hasOwnProperty.call(message, 'trade_fee_rate'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.trade_fee_rate);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.irs.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.Params
       * @static
       * @param {ununifi.irs.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.trade_fee_rate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.irs.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.authority != null && message.hasOwnProperty('authority'))
          if (!$util.isString(message.authority)) return 'authority: string expected';
        if (message.trade_fee_rate != null && message.hasOwnProperty('trade_fee_rate'))
          if (!$util.isString(message.trade_fee_rate)) return 'trade_fee_rate: string expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.Params) return object;
        let message = new $root.ununifi.irs.Params();
        if (object.authority != null) message.authority = String(object.authority);
        if (object.trade_fee_rate != null) message.trade_fee_rate = String(object.trade_fee_rate);
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.Params
       * @static
       * @param {ununifi.irs.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.authority = '';
          object.trade_fee_rate = '';
        }
        if (message.authority != null && message.hasOwnProperty('authority')) object.authority = message.authority;
        if (message.trade_fee_rate != null && message.hasOwnProperty('trade_fee_rate')) object.trade_fee_rate = message.trade_fee_rate;
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.irs.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    irs.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.irs
       * @interface IGenesisState
       * @property {ununifi.irs.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.irs.IInterestRateSwapVault>|null} [vaults] GenesisState vaults
       * @property {Array.<ununifi.irs.ITranchePool>|null} [tranche_pools] GenesisState tranche_pools
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.irs
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.irs.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.vaults = [];
        this.tranche_pools = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.irs.IParams|null|undefined} params
       * @memberof ununifi.irs.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState vaults.
       * @member {Array.<ununifi.irs.IInterestRateSwapVault>} vaults
       * @memberof ununifi.irs.GenesisState
       * @instance
       */
      GenesisState.prototype.vaults = $util.emptyArray;

      /**
       * GenesisState tranche_pools.
       * @member {Array.<ununifi.irs.ITranchePool>} tranche_pools
       * @memberof ununifi.irs.GenesisState
       * @instance
       */
      GenesisState.prototype.tranche_pools = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.irs.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.GenesisState
       * @static
       * @param {ununifi.irs.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.irs.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.vaults != null && message.vaults.length)
          for (let i = 0; i < message.vaults.length; ++i)
            $root.ununifi.irs.InterestRateSwapVault.encode(message.vaults[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.tranche_pools != null && message.tranche_pools.length)
          for (let i = 0; i < message.tranche_pools.length; ++i)
            $root.ununifi.irs.TranchePool.encode(message.tranche_pools[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.irs.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.GenesisState
       * @static
       * @param {ununifi.irs.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.irs.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.vaults && message.vaults.length)) message.vaults = [];
              message.vaults.push($root.ununifi.irs.InterestRateSwapVault.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.tranche_pools && message.tranche_pools.length)) message.tranche_pools = [];
              message.tranche_pools.push($root.ununifi.irs.TranchePool.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.irs.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.irs.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.vaults != null && message.hasOwnProperty('vaults')) {
          if (!Array.isArray(message.vaults)) return 'vaults: array expected';
          for (let i = 0; i < message.vaults.length; ++i) {
            let error = $root.ununifi.irs.InterestRateSwapVault.verify(message.vaults[i]);
            if (error) return 'vaults.' + error;
          }
        }
        if (message.tranche_pools != null && message.hasOwnProperty('tranche_pools')) {
          if (!Array.isArray(message.tranche_pools)) return 'tranche_pools: array expected';
          for (let i = 0; i < message.tranche_pools.length; ++i) {
            let error = $root.ununifi.irs.TranchePool.verify(message.tranche_pools[i]);
            if (error) return 'tranche_pools.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.GenesisState) return object;
        let message = new $root.ununifi.irs.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.irs.GenesisState.params: object expected');
          message.params = $root.ununifi.irs.Params.fromObject(object.params);
        }
        if (object.vaults) {
          if (!Array.isArray(object.vaults)) throw TypeError('.ununifi.irs.GenesisState.vaults: array expected');
          message.vaults = [];
          for (let i = 0; i < object.vaults.length; ++i) {
            if (typeof object.vaults[i] !== 'object') throw TypeError('.ununifi.irs.GenesisState.vaults: object expected');
            message.vaults[i] = $root.ununifi.irs.InterestRateSwapVault.fromObject(object.vaults[i]);
          }
        }
        if (object.tranche_pools) {
          if (!Array.isArray(object.tranche_pools)) throw TypeError('.ununifi.irs.GenesisState.tranche_pools: array expected');
          message.tranche_pools = [];
          for (let i = 0; i < object.tranche_pools.length; ++i) {
            if (typeof object.tranche_pools[i] !== 'object') throw TypeError('.ununifi.irs.GenesisState.tranche_pools: object expected');
            message.tranche_pools[i] = $root.ununifi.irs.TranchePool.fromObject(object.tranche_pools[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.GenesisState
       * @static
       * @param {ununifi.irs.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.vaults = [];
          object.tranche_pools = [];
        }
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.irs.Params.toObject(message.params, options);
        if (message.vaults && message.vaults.length) {
          object.vaults = [];
          for (let j = 0; j < message.vaults.length; ++j)
            object.vaults[j] = $root.ununifi.irs.InterestRateSwapVault.toObject(message.vaults[j], options);
        }
        if (message.tranche_pools && message.tranche_pools.length) {
          object.tranche_pools = [];
          for (let j = 0; j < message.tranche_pools.length; ++j)
            object.tranche_pools[j] = $root.ununifi.irs.TranchePool.toObject(message.tranche_pools[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.irs.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    irs.TranchePool = (function () {
      /**
       * Properties of a TranchePool.
       * @memberof ununifi.irs
       * @interface ITranchePool
       * @property {Long|null} [id] TranchePool id
       * @property {string|null} [strategy_contract] TranchePool strategy_contract
       * @property {Long|null} [start_time] TranchePool start_time
       * @property {Long|null} [maturity] TranchePool maturity
       * @property {string|null} [swap_fee] TranchePool swap_fee
       * @property {string|null} [exit_fee] TranchePool exit_fee
       * @property {cosmos.base.v1beta1.ICoin|null} [total_shares] TranchePool total_shares
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [pool_assets] TranchePool pool_assets
       */

      /**
       * Constructs a new TranchePool.
       * @memberof ununifi.irs
       * @classdesc Represents a TranchePool.
       * @implements ITranchePool
       * @constructor
       * @param {ununifi.irs.ITranchePool=} [properties] Properties to set
       */
      function TranchePool(properties) {
        this.pool_assets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * TranchePool id.
       * @member {Long} id
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * TranchePool strategy_contract.
       * @member {string} strategy_contract
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.strategy_contract = '';

      /**
       * TranchePool start_time.
       * @member {Long} start_time
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.start_time = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * TranchePool maturity.
       * @member {Long} maturity
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.maturity = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * TranchePool swap_fee.
       * @member {string} swap_fee
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.swap_fee = '';

      /**
       * TranchePool exit_fee.
       * @member {string} exit_fee
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.exit_fee = '';

      /**
       * TranchePool total_shares.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} total_shares
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.total_shares = null;

      /**
       * TranchePool pool_assets.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} pool_assets
       * @memberof ununifi.irs.TranchePool
       * @instance
       */
      TranchePool.prototype.pool_assets = $util.emptyArray;

      /**
       * Encodes the specified TranchePool message. Does not implicitly {@link ununifi.irs.TranchePool.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.TranchePool
       * @static
       * @param {ununifi.irs.ITranchePool} message TranchePool message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TranchePool.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.strategy_contract != null && Object.hasOwnProperty.call(message, 'strategy_contract'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.strategy_contract);
        if (message.start_time != null && Object.hasOwnProperty.call(message, 'start_time'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.start_time);
        if (message.maturity != null && Object.hasOwnProperty.call(message, 'maturity'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.maturity);
        if (message.swap_fee != null && Object.hasOwnProperty.call(message, 'swap_fee'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.swap_fee);
        if (message.exit_fee != null && Object.hasOwnProperty.call(message, 'exit_fee'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.exit_fee);
        if (message.total_shares != null && Object.hasOwnProperty.call(message, 'total_shares'))
          $root.cosmos.base.v1beta1.Coin.encode(message.total_shares, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.pool_assets != null && message.pool_assets.length)
          for (let i = 0; i < message.pool_assets.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.pool_assets[i], writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified TranchePool message, length delimited. Does not implicitly {@link ununifi.irs.TranchePool.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.TranchePool
       * @static
       * @param {ununifi.irs.ITranchePool} message TranchePool message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TranchePool.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a TranchePool message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.TranchePool
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.TranchePool} TranchePool
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TranchePool.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.TranchePool();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.strategy_contract = reader.string();
              break;
            case 3:
              message.start_time = reader.uint64();
              break;
            case 4:
              message.maturity = reader.uint64();
              break;
            case 5:
              message.swap_fee = reader.string();
              break;
            case 6:
              message.exit_fee = reader.string();
              break;
            case 7:
              message.total_shares = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 8:
              if (!(message.pool_assets && message.pool_assets.length)) message.pool_assets = [];
              message.pool_assets.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a TranchePool message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.TranchePool
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.TranchePool} TranchePool
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TranchePool.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a TranchePool message.
       * @function verify
       * @memberof ununifi.irs.TranchePool
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      TranchePool.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          if (!$util.isString(message.strategy_contract)) return 'strategy_contract: string expected';
        if (message.start_time != null && message.hasOwnProperty('start_time'))
          if (
            !$util.isInteger(message.start_time) &&
            !(message.start_time && $util.isInteger(message.start_time.low) && $util.isInteger(message.start_time.high))
          )
            return 'start_time: integer|Long expected';
        if (message.maturity != null && message.hasOwnProperty('maturity'))
          if (
            !$util.isInteger(message.maturity) &&
            !(message.maturity && $util.isInteger(message.maturity.low) && $util.isInteger(message.maturity.high))
          )
            return 'maturity: integer|Long expected';
        if (message.swap_fee != null && message.hasOwnProperty('swap_fee'))
          if (!$util.isString(message.swap_fee)) return 'swap_fee: string expected';
        if (message.exit_fee != null && message.hasOwnProperty('exit_fee'))
          if (!$util.isString(message.exit_fee)) return 'exit_fee: string expected';
        if (message.total_shares != null && message.hasOwnProperty('total_shares')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.total_shares);
          if (error) return 'total_shares.' + error;
        }
        if (message.pool_assets != null && message.hasOwnProperty('pool_assets')) {
          if (!Array.isArray(message.pool_assets)) return 'pool_assets: array expected';
          for (let i = 0; i < message.pool_assets.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.pool_assets[i]);
            if (error) return 'pool_assets.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a TranchePool message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.TranchePool
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.TranchePool} TranchePool
       */
      TranchePool.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.TranchePool) return object;
        let message = new $root.ununifi.irs.TranchePool();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.strategy_contract != null) message.strategy_contract = String(object.strategy_contract);
        if (object.start_time != null)
          if ($util.Long) (message.start_time = $util.Long.fromValue(object.start_time)).unsigned = true;
          else if (typeof object.start_time === 'string') message.start_time = parseInt(object.start_time, 10);
          else if (typeof object.start_time === 'number') message.start_time = object.start_time;
          else if (typeof object.start_time === 'object')
            message.start_time = new $util.LongBits(object.start_time.low >>> 0, object.start_time.high >>> 0).toNumber(true);
        if (object.maturity != null)
          if ($util.Long) (message.maturity = $util.Long.fromValue(object.maturity)).unsigned = true;
          else if (typeof object.maturity === 'string') message.maturity = parseInt(object.maturity, 10);
          else if (typeof object.maturity === 'number') message.maturity = object.maturity;
          else if (typeof object.maturity === 'object')
            message.maturity = new $util.LongBits(object.maturity.low >>> 0, object.maturity.high >>> 0).toNumber(true);
        if (object.swap_fee != null) message.swap_fee = String(object.swap_fee);
        if (object.exit_fee != null) message.exit_fee = String(object.exit_fee);
        if (object.total_shares != null) {
          if (typeof object.total_shares !== 'object') throw TypeError('.ununifi.irs.TranchePool.total_shares: object expected');
          message.total_shares = $root.cosmos.base.v1beta1.Coin.fromObject(object.total_shares);
        }
        if (object.pool_assets) {
          if (!Array.isArray(object.pool_assets)) throw TypeError('.ununifi.irs.TranchePool.pool_assets: array expected');
          message.pool_assets = [];
          for (let i = 0; i < object.pool_assets.length; ++i) {
            if (typeof object.pool_assets[i] !== 'object') throw TypeError('.ununifi.irs.TranchePool.pool_assets: object expected');
            message.pool_assets[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.pool_assets[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a TranchePool message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.TranchePool
       * @static
       * @param {ununifi.irs.TranchePool} message TranchePool
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      TranchePool.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.pool_assets = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.strategy_contract = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.start_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.start_time = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.maturity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.maturity = options.longs === String ? '0' : 0;
          object.swap_fee = '';
          object.exit_fee = '';
          object.total_shares = null;
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          object.strategy_contract = message.strategy_contract;
        if (message.start_time != null && message.hasOwnProperty('start_time'))
          if (typeof message.start_time === 'number')
            object.start_time = options.longs === String ? String(message.start_time) : message.start_time;
          else
            object.start_time =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.start_time)
                : options.longs === Number
                ? new $util.LongBits(message.start_time.low >>> 0, message.start_time.high >>> 0).toNumber(true)
                : message.start_time;
        if (message.maturity != null && message.hasOwnProperty('maturity'))
          if (typeof message.maturity === 'number')
            object.maturity = options.longs === String ? String(message.maturity) : message.maturity;
          else
            object.maturity =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.maturity)
                : options.longs === Number
                ? new $util.LongBits(message.maturity.low >>> 0, message.maturity.high >>> 0).toNumber(true)
                : message.maturity;
        if (message.swap_fee != null && message.hasOwnProperty('swap_fee')) object.swap_fee = message.swap_fee;
        if (message.exit_fee != null && message.hasOwnProperty('exit_fee')) object.exit_fee = message.exit_fee;
        if (message.total_shares != null && message.hasOwnProperty('total_shares'))
          object.total_shares = $root.cosmos.base.v1beta1.Coin.toObject(message.total_shares, options);
        if (message.pool_assets && message.pool_assets.length) {
          object.pool_assets = [];
          for (let j = 0; j < message.pool_assets.length; ++j)
            object.pool_assets[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.pool_assets[j], options);
        }
        return object;
      };

      /**
       * Converts this TranchePool to JSON.
       * @function toJSON
       * @memberof ununifi.irs.TranchePool
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      TranchePool.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return TranchePool;
    })();

    irs.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.irs
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.irs.Query#params}.
       * @memberof ununifi.irs.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.irs.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(params, $root.ununifi.irs.QueryParamsRequest, $root.ununifi.irs.QueryParamsResponse, request, callback);
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#vaults}.
       * @memberof ununifi.irs.Query
       * @typedef VaultsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryVaultsResponse} [response] QueryVaultsResponse
       */

      /**
       * Calls Vaults.
       * @function vaults
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryVaultsRequest} request QueryVaultsRequest message or plain object
       * @param {ununifi.irs.Query.VaultsCallback} callback Node-style callback called with the error, if any, and QueryVaultsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.vaults = function vaults(request, callback) {
          return this.rpcCall(vaults, $root.ununifi.irs.QueryVaultsRequest, $root.ununifi.irs.QueryVaultsResponse, request, callback);
        }),
        'name',
        { value: 'Vaults' },
      );

      /**
       * Calls Vaults.
       * @function vaults
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryVaultsRequest} request QueryVaultsRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryVaultsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#vaultByContract}.
       * @memberof ununifi.irs.Query
       * @typedef VaultByContractCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryVaultByContractResponse} [response] QueryVaultByContractResponse
       */

      /**
       * Calls VaultByContract.
       * @function vaultByContract
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryVaultByContractRequest} request QueryVaultByContractRequest message or plain object
       * @param {ununifi.irs.Query.VaultByContractCallback} callback Node-style callback called with the error, if any, and QueryVaultByContractResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.vaultByContract = function vaultByContract(request, callback) {
          return this.rpcCall(
            vaultByContract,
            $root.ununifi.irs.QueryVaultByContractRequest,
            $root.ununifi.irs.QueryVaultByContractResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'VaultByContract' },
      );

      /**
       * Calls VaultByContract.
       * @function vaultByContract
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryVaultByContractRequest} request QueryVaultByContractRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryVaultByContractResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#vaultDetails}.
       * @memberof ununifi.irs.Query
       * @typedef VaultDetailsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryVaultDetailsResponse} [response] QueryVaultDetailsResponse
       */

      /**
       * Calls VaultDetails.
       * @function vaultDetails
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryVaultDetailsRequest} request QueryVaultDetailsRequest message or plain object
       * @param {ununifi.irs.Query.VaultDetailsCallback} callback Node-style callback called with the error, if any, and QueryVaultDetailsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.vaultDetails = function vaultDetails(request, callback) {
          return this.rpcCall(
            vaultDetails,
            $root.ununifi.irs.QueryVaultDetailsRequest,
            $root.ununifi.irs.QueryVaultDetailsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'VaultDetails' },
      );

      /**
       * Calls VaultDetails.
       * @function vaultDetails
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryVaultDetailsRequest} request QueryVaultDetailsRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryVaultDetailsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#allTranches}.
       * @memberof ununifi.irs.Query
       * @typedef AllTranchesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryTranchesResponse} [response] QueryTranchesResponse
       */

      /**
       * Calls AllTranches.
       * @function allTranches
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryAllTranchesRequest} request QueryAllTranchesRequest message or plain object
       * @param {ununifi.irs.Query.AllTranchesCallback} callback Node-style callback called with the error, if any, and QueryTranchesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.allTranches = function allTranches(request, callback) {
          return this.rpcCall(
            allTranches,
            $root.ununifi.irs.QueryAllTranchesRequest,
            $root.ununifi.irs.QueryTranchesResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'AllTranches' },
      );

      /**
       * Calls AllTranches.
       * @function allTranches
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryAllTranchesRequest} request QueryAllTranchesRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryTranchesResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#tranches}.
       * @memberof ununifi.irs.Query
       * @typedef TranchesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryTranchesResponse} [response] QueryTranchesResponse
       */

      /**
       * Calls Tranches.
       * @function tranches
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryTranchesRequest} request QueryTranchesRequest message or plain object
       * @param {ununifi.irs.Query.TranchesCallback} callback Node-style callback called with the error, if any, and QueryTranchesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.tranches = function tranches(request, callback) {
          return this.rpcCall(tranches, $root.ununifi.irs.QueryTranchesRequest, $root.ununifi.irs.QueryTranchesResponse, request, callback);
        }),
        'name',
        { value: 'Tranches' },
      );

      /**
       * Calls Tranches.
       * @function tranches
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryTranchesRequest} request QueryTranchesRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryTranchesResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#tranche}.
       * @memberof ununifi.irs.Query
       * @typedef TrancheCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryTrancheResponse} [response] QueryTrancheResponse
       */

      /**
       * Calls Tranche.
       * @function tranche
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryTrancheRequest} request QueryTrancheRequest message or plain object
       * @param {ununifi.irs.Query.TrancheCallback} callback Node-style callback called with the error, if any, and QueryTrancheResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.tranche = function tranche(request, callback) {
          return this.rpcCall(tranche, $root.ununifi.irs.QueryTrancheRequest, $root.ununifi.irs.QueryTrancheResponse, request, callback);
        }),
        'name',
        { value: 'Tranche' },
      );

      /**
       * Calls Tranche.
       * @function tranche
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryTrancheRequest} request QueryTrancheRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryTrancheResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateSwapInPool}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateSwapInPoolCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateSwapInPoolResponse} [response] QueryEstimateSwapInPoolResponse
       */

      /**
       * Calls EstimateSwapInPool.
       * @function estimateSwapInPool
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateSwapInPoolRequest} request QueryEstimateSwapInPoolRequest message or plain object
       * @param {ununifi.irs.Query.EstimateSwapInPoolCallback} callback Node-style callback called with the error, if any, and QueryEstimateSwapInPoolResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateSwapInPool = function estimateSwapInPool(request, callback) {
          return this.rpcCall(
            estimateSwapInPool,
            $root.ununifi.irs.QueryEstimateSwapInPoolRequest,
            $root.ununifi.irs.QueryEstimateSwapInPoolResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateSwapInPool' },
      );

      /**
       * Calls EstimateSwapInPool.
       * @function estimateSwapInPool
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateSwapInPoolRequest} request QueryEstimateSwapInPoolRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateSwapInPoolResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateMintPtYtPair}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateMintPtYtPairCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateMintPtYtPairResponse} [response] QueryEstimateMintPtYtPairResponse
       */

      /**
       * Calls EstimateMintPtYtPair.
       * @function estimateMintPtYtPair
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairRequest} request QueryEstimateMintPtYtPairRequest message or plain object
       * @param {ununifi.irs.Query.EstimateMintPtYtPairCallback} callback Node-style callback called with the error, if any, and QueryEstimateMintPtYtPairResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateMintPtYtPair = function estimateMintPtYtPair(request, callback) {
          return this.rpcCall(
            estimateMintPtYtPair,
            $root.ununifi.irs.QueryEstimateMintPtYtPairRequest,
            $root.ununifi.irs.QueryEstimateMintPtYtPairResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateMintPtYtPair' },
      );

      /**
       * Calls EstimateMintPtYtPair.
       * @function estimateMintPtYtPair
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairRequest} request QueryEstimateMintPtYtPairRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateMintPtYtPairResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateRedeemPtYtPair}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateRedeemPtYtPairCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateRedeemPtYtPairResponse} [response] QueryEstimateRedeemPtYtPairResponse
       */

      /**
       * Calls EstimateRedeemPtYtPair.
       * @function estimateRedeemPtYtPair
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairRequest} request QueryEstimateRedeemPtYtPairRequest message or plain object
       * @param {ununifi.irs.Query.EstimateRedeemPtYtPairCallback} callback Node-style callback called with the error, if any, and QueryEstimateRedeemPtYtPairResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateRedeemPtYtPair = function estimateRedeemPtYtPair(request, callback) {
          return this.rpcCall(
            estimateRedeemPtYtPair,
            $root.ununifi.irs.QueryEstimateRedeemPtYtPairRequest,
            $root.ununifi.irs.QueryEstimateRedeemPtYtPairResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateRedeemPtYtPair' },
      );

      /**
       * Calls EstimateRedeemPtYtPair.
       * @function estimateRedeemPtYtPair
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairRequest} request QueryEstimateRedeemPtYtPairRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateRedeemPtYtPairResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateRedeemYt}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateRedeemYtCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateRedeemYtResponse} [response] QueryEstimateRedeemYtResponse
       */

      /**
       * Calls EstimateRedeemYt.
       * @function estimateRedeemYt
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRedeemYtRequest} request QueryEstimateRedeemYtRequest message or plain object
       * @param {ununifi.irs.Query.EstimateRedeemYtCallback} callback Node-style callback called with the error, if any, and QueryEstimateRedeemYtResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateRedeemYt = function estimateRedeemYt(request, callback) {
          return this.rpcCall(
            estimateRedeemYt,
            $root.ununifi.irs.QueryEstimateRedeemYtRequest,
            $root.ununifi.irs.QueryEstimateRedeemYtResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateRedeemYt' },
      );

      /**
       * Calls EstimateRedeemYt.
       * @function estimateRedeemYt
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRedeemYtRequest} request QueryEstimateRedeemYtRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateRedeemYtResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateMintLiquidityPoolToken}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateMintLiquidityPoolTokenCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse} [response] QueryEstimateMintLiquidityPoolTokenResponse
       */

      /**
       * Calls EstimateMintLiquidityPoolToken.
       * @function estimateMintLiquidityPoolToken
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenRequest} request QueryEstimateMintLiquidityPoolTokenRequest message or plain object
       * @param {ununifi.irs.Query.EstimateMintLiquidityPoolTokenCallback} callback Node-style callback called with the error, if any, and QueryEstimateMintLiquidityPoolTokenResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateMintLiquidityPoolToken = function estimateMintLiquidityPoolToken(request, callback) {
          return this.rpcCall(
            estimateMintLiquidityPoolToken,
            $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest,
            $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateMintLiquidityPoolToken' },
      );

      /**
       * Calls EstimateMintLiquidityPoolToken.
       * @function estimateMintLiquidityPoolToken
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenRequest} request QueryEstimateMintLiquidityPoolTokenRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateRedeemLiquidityPoolToken}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateRedeemLiquidityPoolTokenCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse} [response] QueryEstimateRedeemLiquidityPoolTokenResponse
       */

      /**
       * Calls EstimateRedeemLiquidityPoolToken.
       * @function estimateRedeemLiquidityPoolToken
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenRequest} request QueryEstimateRedeemLiquidityPoolTokenRequest message or plain object
       * @param {ununifi.irs.Query.EstimateRedeemLiquidityPoolTokenCallback} callback Node-style callback called with the error, if any, and QueryEstimateRedeemLiquidityPoolTokenResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateRedeemLiquidityPoolToken = function estimateRedeemLiquidityPoolToken(request, callback) {
          return this.rpcCall(
            estimateRedeemLiquidityPoolToken,
            $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest,
            $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateRedeemLiquidityPoolToken' },
      );

      /**
       * Calls EstimateRedeemLiquidityPoolToken.
       * @function estimateRedeemLiquidityPoolToken
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenRequest} request QueryEstimateRedeemLiquidityPoolTokenRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateRequiredUtSwapToYt}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateRequiredUtSwapToYtCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse} [response] QueryEstimateRequiredUtSwapToYtResponse
       */

      /**
       * Calls EstimateRequiredUtSwapToYt.
       * @function estimateRequiredUtSwapToYt
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtRequest} request QueryEstimateRequiredUtSwapToYtRequest message or plain object
       * @param {ununifi.irs.Query.EstimateRequiredUtSwapToYtCallback} callback Node-style callback called with the error, if any, and QueryEstimateRequiredUtSwapToYtResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateRequiredUtSwapToYt = function estimateRequiredUtSwapToYt(request, callback) {
          return this.rpcCall(
            estimateRequiredUtSwapToYt,
            $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest,
            $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateRequiredUtSwapToYt' },
      );

      /**
       * Calls EstimateRequiredUtSwapToYt.
       * @function estimateRequiredUtSwapToYt
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtRequest} request QueryEstimateRequiredUtSwapToYtRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.irs.Query#estimateSwapMaturedYtToUt}.
       * @memberof ununifi.irs.Query
       * @typedef EstimateSwapMaturedYtToUtCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse} [response] QueryEstimateSwapMaturedYtToUtResponse
       */

      /**
       * Calls EstimateSwapMaturedYtToUt.
       * @function estimateSwapMaturedYtToUt
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtRequest} request QueryEstimateSwapMaturedYtToUtRequest message or plain object
       * @param {ununifi.irs.Query.EstimateSwapMaturedYtToUtCallback} callback Node-style callback called with the error, if any, and QueryEstimateSwapMaturedYtToUtResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateSwapMaturedYtToUt = function estimateSwapMaturedYtToUt(request, callback) {
          return this.rpcCall(
            estimateSwapMaturedYtToUt,
            $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest,
            $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateSwapMaturedYtToUt' },
      );

      /**
       * Calls EstimateSwapMaturedYtToUt.
       * @function estimateSwapMaturedYtToUt
       * @memberof ununifi.irs.Query
       * @instance
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtRequest} request QueryEstimateSwapMaturedYtToUtRequest message or plain object
       * @returns {Promise<ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    irs.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.irs
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.irs.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.irs.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryParamsRequest
       * @static
       * @param {ununifi.irs.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryParamsRequest
       * @static
       * @param {ununifi.irs.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryParamsRequest) return object;
        return new $root.ununifi.irs.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryParamsRequest
       * @static
       * @param {ununifi.irs.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    irs.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.irs
       * @interface IQueryParamsResponse
       * @property {ununifi.irs.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.irs.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.irs.IParams|null|undefined} params
       * @memberof ununifi.irs.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.irs.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryParamsResponse
       * @static
       * @param {ununifi.irs.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.irs.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryParamsResponse
       * @static
       * @param {ununifi.irs.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.irs.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.irs.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryParamsResponse) return object;
        let message = new $root.ununifi.irs.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.irs.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.irs.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryParamsResponse
       * @static
       * @param {ununifi.irs.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.irs.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    irs.QueryVaultsRequest = (function () {
      /**
       * Properties of a QueryVaultsRequest.
       * @memberof ununifi.irs
       * @interface IQueryVaultsRequest
       */

      /**
       * Constructs a new QueryVaultsRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryVaultsRequest.
       * @implements IQueryVaultsRequest
       * @constructor
       * @param {ununifi.irs.IQueryVaultsRequest=} [properties] Properties to set
       */
      function QueryVaultsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryVaultsRequest message. Does not implicitly {@link ununifi.irs.QueryVaultsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryVaultsRequest
       * @static
       * @param {ununifi.irs.IQueryVaultsRequest} message QueryVaultsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryVaultsRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryVaultsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryVaultsRequest
       * @static
       * @param {ununifi.irs.IQueryVaultsRequest} message QueryVaultsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryVaultsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryVaultsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryVaultsRequest} QueryVaultsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryVaultsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryVaultsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryVaultsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryVaultsRequest} QueryVaultsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryVaultsRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryVaultsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryVaultsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryVaultsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryVaultsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryVaultsRequest} QueryVaultsRequest
       */
      QueryVaultsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryVaultsRequest) return object;
        return new $root.ununifi.irs.QueryVaultsRequest();
      };

      /**
       * Creates a plain object from a QueryVaultsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryVaultsRequest
       * @static
       * @param {ununifi.irs.QueryVaultsRequest} message QueryVaultsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryVaultsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryVaultsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryVaultsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryVaultsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryVaultsRequest;
    })();

    irs.QueryVaultsResponse = (function () {
      /**
       * Properties of a QueryVaultsResponse.
       * @memberof ununifi.irs
       * @interface IQueryVaultsResponse
       * @property {Array.<ununifi.irs.IInterestRateSwapVault>|null} [vaults] QueryVaultsResponse vaults
       */

      /**
       * Constructs a new QueryVaultsResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryVaultsResponse.
       * @implements IQueryVaultsResponse
       * @constructor
       * @param {ununifi.irs.IQueryVaultsResponse=} [properties] Properties to set
       */
      function QueryVaultsResponse(properties) {
        this.vaults = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryVaultsResponse vaults.
       * @member {Array.<ununifi.irs.IInterestRateSwapVault>} vaults
       * @memberof ununifi.irs.QueryVaultsResponse
       * @instance
       */
      QueryVaultsResponse.prototype.vaults = $util.emptyArray;

      /**
       * Encodes the specified QueryVaultsResponse message. Does not implicitly {@link ununifi.irs.QueryVaultsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryVaultsResponse
       * @static
       * @param {ununifi.irs.IQueryVaultsResponse} message QueryVaultsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vaults != null && message.vaults.length)
          for (let i = 0; i < message.vaults.length; ++i)
            $root.ununifi.irs.InterestRateSwapVault.encode(message.vaults[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryVaultsResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryVaultsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryVaultsResponse
       * @static
       * @param {ununifi.irs.IQueryVaultsResponse} message QueryVaultsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryVaultsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryVaultsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryVaultsResponse} QueryVaultsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryVaultsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.vaults && message.vaults.length)) message.vaults = [];
              message.vaults.push($root.ununifi.irs.InterestRateSwapVault.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryVaultsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryVaultsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryVaultsResponse} QueryVaultsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryVaultsResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryVaultsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryVaultsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vaults != null && message.hasOwnProperty('vaults')) {
          if (!Array.isArray(message.vaults)) return 'vaults: array expected';
          for (let i = 0; i < message.vaults.length; ++i) {
            let error = $root.ununifi.irs.InterestRateSwapVault.verify(message.vaults[i]);
            if (error) return 'vaults.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryVaultsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryVaultsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryVaultsResponse} QueryVaultsResponse
       */
      QueryVaultsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryVaultsResponse) return object;
        let message = new $root.ununifi.irs.QueryVaultsResponse();
        if (object.vaults) {
          if (!Array.isArray(object.vaults)) throw TypeError('.ununifi.irs.QueryVaultsResponse.vaults: array expected');
          message.vaults = [];
          for (let i = 0; i < object.vaults.length; ++i) {
            if (typeof object.vaults[i] !== 'object') throw TypeError('.ununifi.irs.QueryVaultsResponse.vaults: object expected');
            message.vaults[i] = $root.ununifi.irs.InterestRateSwapVault.fromObject(object.vaults[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryVaultsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryVaultsResponse
       * @static
       * @param {ununifi.irs.QueryVaultsResponse} message QueryVaultsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryVaultsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.vaults = [];
        if (message.vaults && message.vaults.length) {
          object.vaults = [];
          for (let j = 0; j < message.vaults.length; ++j)
            object.vaults[j] = $root.ununifi.irs.InterestRateSwapVault.toObject(message.vaults[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryVaultsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryVaultsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryVaultsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryVaultsResponse;
    })();

    irs.QueryVaultByContractRequest = (function () {
      /**
       * Properties of a QueryVaultByContractRequest.
       * @memberof ununifi.irs
       * @interface IQueryVaultByContractRequest
       * @property {string|null} [strategy_contract] QueryVaultByContractRequest strategy_contract
       */

      /**
       * Constructs a new QueryVaultByContractRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryVaultByContractRequest.
       * @implements IQueryVaultByContractRequest
       * @constructor
       * @param {ununifi.irs.IQueryVaultByContractRequest=} [properties] Properties to set
       */
      function QueryVaultByContractRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryVaultByContractRequest strategy_contract.
       * @member {string} strategy_contract
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @instance
       */
      QueryVaultByContractRequest.prototype.strategy_contract = '';

      /**
       * Encodes the specified QueryVaultByContractRequest message. Does not implicitly {@link ununifi.irs.QueryVaultByContractRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @static
       * @param {ununifi.irs.IQueryVaultByContractRequest} message QueryVaultByContractRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultByContractRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategy_contract != null && Object.hasOwnProperty.call(message, 'strategy_contract'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.strategy_contract);
        return writer;
      };

      /**
       * Encodes the specified QueryVaultByContractRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryVaultByContractRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @static
       * @param {ununifi.irs.IQueryVaultByContractRequest} message QueryVaultByContractRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultByContractRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryVaultByContractRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryVaultByContractRequest} QueryVaultByContractRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultByContractRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryVaultByContractRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.strategy_contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryVaultByContractRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryVaultByContractRequest} QueryVaultByContractRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultByContractRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryVaultByContractRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryVaultByContractRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          if (!$util.isString(message.strategy_contract)) return 'strategy_contract: string expected';
        return null;
      };

      /**
       * Creates a QueryVaultByContractRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryVaultByContractRequest} QueryVaultByContractRequest
       */
      QueryVaultByContractRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryVaultByContractRequest) return object;
        let message = new $root.ununifi.irs.QueryVaultByContractRequest();
        if (object.strategy_contract != null) message.strategy_contract = String(object.strategy_contract);
        return message;
      };

      /**
       * Creates a plain object from a QueryVaultByContractRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @static
       * @param {ununifi.irs.QueryVaultByContractRequest} message QueryVaultByContractRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryVaultByContractRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.strategy_contract = '';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          object.strategy_contract = message.strategy_contract;
        return object;
      };

      /**
       * Converts this QueryVaultByContractRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryVaultByContractRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryVaultByContractRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryVaultByContractRequest;
    })();

    irs.QueryVaultByContractResponse = (function () {
      /**
       * Properties of a QueryVaultByContractResponse.
       * @memberof ununifi.irs
       * @interface IQueryVaultByContractResponse
       * @property {ununifi.irs.IInterestRateSwapVault|null} [vault] QueryVaultByContractResponse vault
       */

      /**
       * Constructs a new QueryVaultByContractResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryVaultByContractResponse.
       * @implements IQueryVaultByContractResponse
       * @constructor
       * @param {ununifi.irs.IQueryVaultByContractResponse=} [properties] Properties to set
       */
      function QueryVaultByContractResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryVaultByContractResponse vault.
       * @member {ununifi.irs.IInterestRateSwapVault|null|undefined} vault
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @instance
       */
      QueryVaultByContractResponse.prototype.vault = null;

      /**
       * Encodes the specified QueryVaultByContractResponse message. Does not implicitly {@link ununifi.irs.QueryVaultByContractResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @static
       * @param {ununifi.irs.IQueryVaultByContractResponse} message QueryVaultByContractResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultByContractResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vault != null && Object.hasOwnProperty.call(message, 'vault'))
          $root.ununifi.irs.InterestRateSwapVault.encode(message.vault, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryVaultByContractResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryVaultByContractResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @static
       * @param {ununifi.irs.IQueryVaultByContractResponse} message QueryVaultByContractResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultByContractResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryVaultByContractResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryVaultByContractResponse} QueryVaultByContractResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultByContractResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryVaultByContractResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vault = $root.ununifi.irs.InterestRateSwapVault.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryVaultByContractResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryVaultByContractResponse} QueryVaultByContractResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultByContractResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryVaultByContractResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryVaultByContractResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vault != null && message.hasOwnProperty('vault')) {
          let error = $root.ununifi.irs.InterestRateSwapVault.verify(message.vault);
          if (error) return 'vault.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryVaultByContractResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryVaultByContractResponse} QueryVaultByContractResponse
       */
      QueryVaultByContractResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryVaultByContractResponse) return object;
        let message = new $root.ununifi.irs.QueryVaultByContractResponse();
        if (object.vault != null) {
          if (typeof object.vault !== 'object') throw TypeError('.ununifi.irs.QueryVaultByContractResponse.vault: object expected');
          message.vault = $root.ununifi.irs.InterestRateSwapVault.fromObject(object.vault);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryVaultByContractResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @static
       * @param {ununifi.irs.QueryVaultByContractResponse} message QueryVaultByContractResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryVaultByContractResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.vault = null;
        if (message.vault != null && message.hasOwnProperty('vault'))
          object.vault = $root.ununifi.irs.InterestRateSwapVault.toObject(message.vault, options);
        return object;
      };

      /**
       * Converts this QueryVaultByContractResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryVaultByContractResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryVaultByContractResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryVaultByContractResponse;
    })();

    irs.QueryVaultDetailsRequest = (function () {
      /**
       * Properties of a QueryVaultDetailsRequest.
       * @memberof ununifi.irs
       * @interface IQueryVaultDetailsRequest
       * @property {string|null} [strategy_contract] QueryVaultDetailsRequest strategy_contract
       * @property {string|null} [maturity] QueryVaultDetailsRequest maturity
       */

      /**
       * Constructs a new QueryVaultDetailsRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryVaultDetailsRequest.
       * @implements IQueryVaultDetailsRequest
       * @constructor
       * @param {ununifi.irs.IQueryVaultDetailsRequest=} [properties] Properties to set
       */
      function QueryVaultDetailsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryVaultDetailsRequest strategy_contract.
       * @member {string} strategy_contract
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @instance
       */
      QueryVaultDetailsRequest.prototype.strategy_contract = '';

      /**
       * QueryVaultDetailsRequest maturity.
       * @member {string} maturity
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @instance
       */
      QueryVaultDetailsRequest.prototype.maturity = '';

      /**
       * Encodes the specified QueryVaultDetailsRequest message. Does not implicitly {@link ununifi.irs.QueryVaultDetailsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @static
       * @param {ununifi.irs.IQueryVaultDetailsRequest} message QueryVaultDetailsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultDetailsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategy_contract != null && Object.hasOwnProperty.call(message, 'strategy_contract'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.strategy_contract);
        if (message.maturity != null && Object.hasOwnProperty.call(message, 'maturity'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.maturity);
        return writer;
      };

      /**
       * Encodes the specified QueryVaultDetailsRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryVaultDetailsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @static
       * @param {ununifi.irs.IQueryVaultDetailsRequest} message QueryVaultDetailsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultDetailsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryVaultDetailsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryVaultDetailsRequest} QueryVaultDetailsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultDetailsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryVaultDetailsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.strategy_contract = reader.string();
              break;
            case 2:
              message.maturity = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryVaultDetailsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryVaultDetailsRequest} QueryVaultDetailsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultDetailsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryVaultDetailsRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryVaultDetailsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          if (!$util.isString(message.strategy_contract)) return 'strategy_contract: string expected';
        if (message.maturity != null && message.hasOwnProperty('maturity'))
          if (!$util.isString(message.maturity)) return 'maturity: string expected';
        return null;
      };

      /**
       * Creates a QueryVaultDetailsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryVaultDetailsRequest} QueryVaultDetailsRequest
       */
      QueryVaultDetailsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryVaultDetailsRequest) return object;
        let message = new $root.ununifi.irs.QueryVaultDetailsRequest();
        if (object.strategy_contract != null) message.strategy_contract = String(object.strategy_contract);
        if (object.maturity != null) message.maturity = String(object.maturity);
        return message;
      };

      /**
       * Creates a plain object from a QueryVaultDetailsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @static
       * @param {ununifi.irs.QueryVaultDetailsRequest} message QueryVaultDetailsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryVaultDetailsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.strategy_contract = '';
          object.maturity = '';
        }
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          object.strategy_contract = message.strategy_contract;
        if (message.maturity != null && message.hasOwnProperty('maturity')) object.maturity = message.maturity;
        return object;
      };

      /**
       * Converts this QueryVaultDetailsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryVaultDetailsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryVaultDetailsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryVaultDetailsRequest;
    })();

    irs.QueryVaultDetailsResponse = (function () {
      /**
       * Properties of a QueryVaultDetailsResponse.
       * @memberof ununifi.irs
       * @interface IQueryVaultDetailsResponse
       * @property {string|null} [liquidity_pool] QueryVaultDetailsResponse liquidity_pool
       * @property {string|null} [fy_rate] QueryVaultDetailsResponse fy_rate
       * @property {string|null} [lvy_rate] QueryVaultDetailsResponse lvy_rate
       */

      /**
       * Constructs a new QueryVaultDetailsResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryVaultDetailsResponse.
       * @implements IQueryVaultDetailsResponse
       * @constructor
       * @param {ununifi.irs.IQueryVaultDetailsResponse=} [properties] Properties to set
       */
      function QueryVaultDetailsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryVaultDetailsResponse liquidity_pool.
       * @member {string} liquidity_pool
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @instance
       */
      QueryVaultDetailsResponse.prototype.liquidity_pool = '';

      /**
       * QueryVaultDetailsResponse fy_rate.
       * @member {string} fy_rate
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @instance
       */
      QueryVaultDetailsResponse.prototype.fy_rate = '';

      /**
       * QueryVaultDetailsResponse lvy_rate.
       * @member {string} lvy_rate
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @instance
       */
      QueryVaultDetailsResponse.prototype.lvy_rate = '';

      /**
       * Encodes the specified QueryVaultDetailsResponse message. Does not implicitly {@link ununifi.irs.QueryVaultDetailsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @static
       * @param {ununifi.irs.IQueryVaultDetailsResponse} message QueryVaultDetailsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultDetailsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.liquidity_pool != null && Object.hasOwnProperty.call(message, 'liquidity_pool'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.liquidity_pool);
        if (message.fy_rate != null && Object.hasOwnProperty.call(message, 'fy_rate'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.fy_rate);
        if (message.lvy_rate != null && Object.hasOwnProperty.call(message, 'lvy_rate'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.lvy_rate);
        return writer;
      };

      /**
       * Encodes the specified QueryVaultDetailsResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryVaultDetailsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @static
       * @param {ununifi.irs.IQueryVaultDetailsResponse} message QueryVaultDetailsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryVaultDetailsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryVaultDetailsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryVaultDetailsResponse} QueryVaultDetailsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultDetailsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryVaultDetailsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.liquidity_pool = reader.string();
              break;
            case 2:
              message.fy_rate = reader.string();
              break;
            case 3:
              message.lvy_rate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryVaultDetailsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryVaultDetailsResponse} QueryVaultDetailsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryVaultDetailsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryVaultDetailsResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryVaultDetailsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.liquidity_pool != null && message.hasOwnProperty('liquidity_pool'))
          if (!$util.isString(message.liquidity_pool)) return 'liquidity_pool: string expected';
        if (message.fy_rate != null && message.hasOwnProperty('fy_rate'))
          if (!$util.isString(message.fy_rate)) return 'fy_rate: string expected';
        if (message.lvy_rate != null && message.hasOwnProperty('lvy_rate'))
          if (!$util.isString(message.lvy_rate)) return 'lvy_rate: string expected';
        return null;
      };

      /**
       * Creates a QueryVaultDetailsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryVaultDetailsResponse} QueryVaultDetailsResponse
       */
      QueryVaultDetailsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryVaultDetailsResponse) return object;
        let message = new $root.ununifi.irs.QueryVaultDetailsResponse();
        if (object.liquidity_pool != null) message.liquidity_pool = String(object.liquidity_pool);
        if (object.fy_rate != null) message.fy_rate = String(object.fy_rate);
        if (object.lvy_rate != null) message.lvy_rate = String(object.lvy_rate);
        return message;
      };

      /**
       * Creates a plain object from a QueryVaultDetailsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @static
       * @param {ununifi.irs.QueryVaultDetailsResponse} message QueryVaultDetailsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryVaultDetailsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.liquidity_pool = '';
          object.fy_rate = '';
          object.lvy_rate = '';
        }
        if (message.liquidity_pool != null && message.hasOwnProperty('liquidity_pool')) object.liquidity_pool = message.liquidity_pool;
        if (message.fy_rate != null && message.hasOwnProperty('fy_rate')) object.fy_rate = message.fy_rate;
        if (message.lvy_rate != null && message.hasOwnProperty('lvy_rate')) object.lvy_rate = message.lvy_rate;
        return object;
      };

      /**
       * Converts this QueryVaultDetailsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryVaultDetailsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryVaultDetailsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryVaultDetailsResponse;
    })();

    irs.QueryAllTranchesRequest = (function () {
      /**
       * Properties of a QueryAllTranchesRequest.
       * @memberof ununifi.irs
       * @interface IQueryAllTranchesRequest
       */

      /**
       * Constructs a new QueryAllTranchesRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryAllTranchesRequest.
       * @implements IQueryAllTranchesRequest
       * @constructor
       * @param {ununifi.irs.IQueryAllTranchesRequest=} [properties] Properties to set
       */
      function QueryAllTranchesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryAllTranchesRequest message. Does not implicitly {@link ununifi.irs.QueryAllTranchesRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @static
       * @param {ununifi.irs.IQueryAllTranchesRequest} message QueryAllTranchesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllTranchesRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryAllTranchesRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryAllTranchesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @static
       * @param {ununifi.irs.IQueryAllTranchesRequest} message QueryAllTranchesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllTranchesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllTranchesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryAllTranchesRequest} QueryAllTranchesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllTranchesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryAllTranchesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllTranchesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryAllTranchesRequest} QueryAllTranchesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllTranchesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllTranchesRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllTranchesRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryAllTranchesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryAllTranchesRequest} QueryAllTranchesRequest
       */
      QueryAllTranchesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryAllTranchesRequest) return object;
        return new $root.ununifi.irs.QueryAllTranchesRequest();
      };

      /**
       * Creates a plain object from a QueryAllTranchesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @static
       * @param {ununifi.irs.QueryAllTranchesRequest} message QueryAllTranchesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllTranchesRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryAllTranchesRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryAllTranchesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllTranchesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllTranchesRequest;
    })();

    irs.QueryTranchesRequest = (function () {
      /**
       * Properties of a QueryTranchesRequest.
       * @memberof ununifi.irs
       * @interface IQueryTranchesRequest
       * @property {string|null} [strategy_contract] QueryTranchesRequest strategy_contract
       */

      /**
       * Constructs a new QueryTranchesRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryTranchesRequest.
       * @implements IQueryTranchesRequest
       * @constructor
       * @param {ununifi.irs.IQueryTranchesRequest=} [properties] Properties to set
       */
      function QueryTranchesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryTranchesRequest strategy_contract.
       * @member {string} strategy_contract
       * @memberof ununifi.irs.QueryTranchesRequest
       * @instance
       */
      QueryTranchesRequest.prototype.strategy_contract = '';

      /**
       * Encodes the specified QueryTranchesRequest message. Does not implicitly {@link ununifi.irs.QueryTranchesRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryTranchesRequest
       * @static
       * @param {ununifi.irs.IQueryTranchesRequest} message QueryTranchesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTranchesRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategy_contract != null && Object.hasOwnProperty.call(message, 'strategy_contract'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.strategy_contract);
        return writer;
      };

      /**
       * Encodes the specified QueryTranchesRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryTranchesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryTranchesRequest
       * @static
       * @param {ununifi.irs.IQueryTranchesRequest} message QueryTranchesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTranchesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryTranchesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryTranchesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryTranchesRequest} QueryTranchesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTranchesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryTranchesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.strategy_contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryTranchesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryTranchesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryTranchesRequest} QueryTranchesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTranchesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryTranchesRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryTranchesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryTranchesRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          if (!$util.isString(message.strategy_contract)) return 'strategy_contract: string expected';
        return null;
      };

      /**
       * Creates a QueryTranchesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryTranchesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryTranchesRequest} QueryTranchesRequest
       */
      QueryTranchesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryTranchesRequest) return object;
        let message = new $root.ununifi.irs.QueryTranchesRequest();
        if (object.strategy_contract != null) message.strategy_contract = String(object.strategy_contract);
        return message;
      };

      /**
       * Creates a plain object from a QueryTranchesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryTranchesRequest
       * @static
       * @param {ununifi.irs.QueryTranchesRequest} message QueryTranchesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryTranchesRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.strategy_contract = '';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          object.strategy_contract = message.strategy_contract;
        return object;
      };

      /**
       * Converts this QueryTranchesRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryTranchesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryTranchesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryTranchesRequest;
    })();

    irs.QueryTranchesResponse = (function () {
      /**
       * Properties of a QueryTranchesResponse.
       * @memberof ununifi.irs
       * @interface IQueryTranchesResponse
       * @property {Array.<ununifi.irs.ITranchePool>|null} [tranches] QueryTranchesResponse tranches
       */

      /**
       * Constructs a new QueryTranchesResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryTranchesResponse.
       * @implements IQueryTranchesResponse
       * @constructor
       * @param {ununifi.irs.IQueryTranchesResponse=} [properties] Properties to set
       */
      function QueryTranchesResponse(properties) {
        this.tranches = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryTranchesResponse tranches.
       * @member {Array.<ununifi.irs.ITranchePool>} tranches
       * @memberof ununifi.irs.QueryTranchesResponse
       * @instance
       */
      QueryTranchesResponse.prototype.tranches = $util.emptyArray;

      /**
       * Encodes the specified QueryTranchesResponse message. Does not implicitly {@link ununifi.irs.QueryTranchesResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryTranchesResponse
       * @static
       * @param {ununifi.irs.IQueryTranchesResponse} message QueryTranchesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTranchesResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.tranches != null && message.tranches.length)
          for (let i = 0; i < message.tranches.length; ++i)
            $root.ununifi.irs.TranchePool.encode(message.tranches[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryTranchesResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryTranchesResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryTranchesResponse
       * @static
       * @param {ununifi.irs.IQueryTranchesResponse} message QueryTranchesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTranchesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryTranchesResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryTranchesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryTranchesResponse} QueryTranchesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTranchesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryTranchesResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.tranches && message.tranches.length)) message.tranches = [];
              message.tranches.push($root.ununifi.irs.TranchePool.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryTranchesResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryTranchesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryTranchesResponse} QueryTranchesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTranchesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryTranchesResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryTranchesResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryTranchesResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.tranches != null && message.hasOwnProperty('tranches')) {
          if (!Array.isArray(message.tranches)) return 'tranches: array expected';
          for (let i = 0; i < message.tranches.length; ++i) {
            let error = $root.ununifi.irs.TranchePool.verify(message.tranches[i]);
            if (error) return 'tranches.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryTranchesResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryTranchesResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryTranchesResponse} QueryTranchesResponse
       */
      QueryTranchesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryTranchesResponse) return object;
        let message = new $root.ununifi.irs.QueryTranchesResponse();
        if (object.tranches) {
          if (!Array.isArray(object.tranches)) throw TypeError('.ununifi.irs.QueryTranchesResponse.tranches: array expected');
          message.tranches = [];
          for (let i = 0; i < object.tranches.length; ++i) {
            if (typeof object.tranches[i] !== 'object') throw TypeError('.ununifi.irs.QueryTranchesResponse.tranches: object expected');
            message.tranches[i] = $root.ununifi.irs.TranchePool.fromObject(object.tranches[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryTranchesResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryTranchesResponse
       * @static
       * @param {ununifi.irs.QueryTranchesResponse} message QueryTranchesResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryTranchesResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.tranches = [];
        if (message.tranches && message.tranches.length) {
          object.tranches = [];
          for (let j = 0; j < message.tranches.length; ++j)
            object.tranches[j] = $root.ununifi.irs.TranchePool.toObject(message.tranches[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryTranchesResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryTranchesResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryTranchesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryTranchesResponse;
    })();

    irs.QueryTrancheRequest = (function () {
      /**
       * Properties of a QueryTrancheRequest.
       * @memberof ununifi.irs
       * @interface IQueryTrancheRequest
       * @property {Long|null} [id] QueryTrancheRequest id
       */

      /**
       * Constructs a new QueryTrancheRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryTrancheRequest.
       * @implements IQueryTrancheRequest
       * @constructor
       * @param {ununifi.irs.IQueryTrancheRequest=} [properties] Properties to set
       */
      function QueryTrancheRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryTrancheRequest id.
       * @member {Long} id
       * @memberof ununifi.irs.QueryTrancheRequest
       * @instance
       */
      QueryTrancheRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryTrancheRequest message. Does not implicitly {@link ununifi.irs.QueryTrancheRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryTrancheRequest
       * @static
       * @param {ununifi.irs.IQueryTrancheRequest} message QueryTrancheRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTrancheRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified QueryTrancheRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryTrancheRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryTrancheRequest
       * @static
       * @param {ununifi.irs.IQueryTrancheRequest} message QueryTrancheRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTrancheRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryTrancheRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryTrancheRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryTrancheRequest} QueryTrancheRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTrancheRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryTrancheRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryTrancheRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryTrancheRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryTrancheRequest} QueryTrancheRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTrancheRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryTrancheRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryTrancheRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryTrancheRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryTrancheRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryTrancheRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryTrancheRequest} QueryTrancheRequest
       */
      QueryTrancheRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryTrancheRequest) return object;
        let message = new $root.ununifi.irs.QueryTrancheRequest();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryTrancheRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryTrancheRequest
       * @static
       * @param {ununifi.irs.QueryTrancheRequest} message QueryTrancheRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryTrancheRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this QueryTrancheRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryTrancheRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryTrancheRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryTrancheRequest;
    })();

    irs.QueryTrancheResponse = (function () {
      /**
       * Properties of a QueryTrancheResponse.
       * @memberof ununifi.irs
       * @interface IQueryTrancheResponse
       * @property {ununifi.irs.ITranchePool|null} [tranche] QueryTrancheResponse tranche
       */

      /**
       * Constructs a new QueryTrancheResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryTrancheResponse.
       * @implements IQueryTrancheResponse
       * @constructor
       * @param {ununifi.irs.IQueryTrancheResponse=} [properties] Properties to set
       */
      function QueryTrancheResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryTrancheResponse tranche.
       * @member {ununifi.irs.ITranchePool|null|undefined} tranche
       * @memberof ununifi.irs.QueryTrancheResponse
       * @instance
       */
      QueryTrancheResponse.prototype.tranche = null;

      /**
       * Encodes the specified QueryTrancheResponse message. Does not implicitly {@link ununifi.irs.QueryTrancheResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryTrancheResponse
       * @static
       * @param {ununifi.irs.IQueryTrancheResponse} message QueryTrancheResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTrancheResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.tranche != null && Object.hasOwnProperty.call(message, 'tranche'))
          $root.ununifi.irs.TranchePool.encode(message.tranche, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryTrancheResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryTrancheResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryTrancheResponse
       * @static
       * @param {ununifi.irs.IQueryTrancheResponse} message QueryTrancheResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryTrancheResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryTrancheResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryTrancheResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryTrancheResponse} QueryTrancheResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTrancheResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryTrancheResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tranche = $root.ununifi.irs.TranchePool.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryTrancheResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryTrancheResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryTrancheResponse} QueryTrancheResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryTrancheResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryTrancheResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryTrancheResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryTrancheResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.tranche != null && message.hasOwnProperty('tranche')) {
          let error = $root.ununifi.irs.TranchePool.verify(message.tranche);
          if (error) return 'tranche.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryTrancheResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryTrancheResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryTrancheResponse} QueryTrancheResponse
       */
      QueryTrancheResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryTrancheResponse) return object;
        let message = new $root.ununifi.irs.QueryTrancheResponse();
        if (object.tranche != null) {
          if (typeof object.tranche !== 'object') throw TypeError('.ununifi.irs.QueryTrancheResponse.tranche: object expected');
          message.tranche = $root.ununifi.irs.TranchePool.fromObject(object.tranche);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryTrancheResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryTrancheResponse
       * @static
       * @param {ununifi.irs.QueryTrancheResponse} message QueryTrancheResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryTrancheResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.tranche = null;
        if (message.tranche != null && message.hasOwnProperty('tranche'))
          object.tranche = $root.ununifi.irs.TranchePool.toObject(message.tranche, options);
        return object;
      };

      /**
       * Converts this QueryTrancheResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryTrancheResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryTrancheResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryTrancheResponse;
    })();

    irs.QueryEstimateSwapInPoolRequest = (function () {
      /**
       * Properties of a QueryEstimateSwapInPoolRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateSwapInPoolRequest
       * @property {Long|null} [pool_id] QueryEstimateSwapInPoolRequest pool_id
       * @property {string|null} [denom] QueryEstimateSwapInPoolRequest denom
       * @property {string|null} [amount] QueryEstimateSwapInPoolRequest amount
       */

      /**
       * Constructs a new QueryEstimateSwapInPoolRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateSwapInPoolRequest.
       * @implements IQueryEstimateSwapInPoolRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateSwapInPoolRequest=} [properties] Properties to set
       */
      function QueryEstimateSwapInPoolRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateSwapInPoolRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @instance
       */
      QueryEstimateSwapInPoolRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateSwapInPoolRequest denom.
       * @member {string} denom
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @instance
       */
      QueryEstimateSwapInPoolRequest.prototype.denom = '';

      /**
       * QueryEstimateSwapInPoolRequest amount.
       * @member {string} amount
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @instance
       */
      QueryEstimateSwapInPoolRequest.prototype.amount = '';

      /**
       * Encodes the specified QueryEstimateSwapInPoolRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateSwapInPoolRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapInPoolRequest} message QueryEstimateSwapInPoolRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapInPoolRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateSwapInPoolRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateSwapInPoolRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapInPoolRequest} message QueryEstimateSwapInPoolRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapInPoolRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateSwapInPoolRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateSwapInPoolRequest} QueryEstimateSwapInPoolRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapInPoolRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateSwapInPoolRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 2:
              message.denom = reader.string();
              break;
            case 3:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateSwapInPoolRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateSwapInPoolRequest} QueryEstimateSwapInPoolRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapInPoolRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateSwapInPoolRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateSwapInPoolRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateSwapInPoolRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateSwapInPoolRequest} QueryEstimateSwapInPoolRequest
       */
      QueryEstimateSwapInPoolRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateSwapInPoolRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateSwapInPoolRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateSwapInPoolRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @static
       * @param {ununifi.irs.QueryEstimateSwapInPoolRequest} message QueryEstimateSwapInPoolRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateSwapInPoolRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.denom = '';
          object.amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this QueryEstimateSwapInPoolRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateSwapInPoolRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateSwapInPoolRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateSwapInPoolRequest;
    })();

    irs.QueryEstimateSwapInPoolResponse = (function () {
      /**
       * Properties of a QueryEstimateSwapInPoolResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateSwapInPoolResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] QueryEstimateSwapInPoolResponse amount
       */

      /**
       * Constructs a new QueryEstimateSwapInPoolResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateSwapInPoolResponse.
       * @implements IQueryEstimateSwapInPoolResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateSwapInPoolResponse=} [properties] Properties to set
       */
      function QueryEstimateSwapInPoolResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateSwapInPoolResponse amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @instance
       */
      QueryEstimateSwapInPoolResponse.prototype.amount = null;

      /**
       * Encodes the specified QueryEstimateSwapInPoolResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateSwapInPoolResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapInPoolResponse} message QueryEstimateSwapInPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapInPoolResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateSwapInPoolResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateSwapInPoolResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapInPoolResponse} message QueryEstimateSwapInPoolResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapInPoolResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateSwapInPoolResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateSwapInPoolResponse} QueryEstimateSwapInPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapInPoolResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateSwapInPoolResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateSwapInPoolResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateSwapInPoolResponse} QueryEstimateSwapInPoolResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapInPoolResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateSwapInPoolResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateSwapInPoolResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateSwapInPoolResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateSwapInPoolResponse} QueryEstimateSwapInPoolResponse
       */
      QueryEstimateSwapInPoolResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateSwapInPoolResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateSwapInPoolResponse();
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.irs.QueryEstimateSwapInPoolResponse.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateSwapInPoolResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @static
       * @param {ununifi.irs.QueryEstimateSwapInPoolResponse} message QueryEstimateSwapInPoolResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateSwapInPoolResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.amount = null;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this QueryEstimateSwapInPoolResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateSwapInPoolResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateSwapInPoolResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateSwapInPoolResponse;
    })();

    irs.QueryEstimateMintPtYtPairRequest = (function () {
      /**
       * Properties of a QueryEstimateMintPtYtPairRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateMintPtYtPairRequest
       * @property {Long|null} [pool_id] QueryEstimateMintPtYtPairRequest pool_id
       * @property {string|null} [denom] QueryEstimateMintPtYtPairRequest denom
       * @property {string|null} [amount] QueryEstimateMintPtYtPairRequest amount
       */

      /**
       * Constructs a new QueryEstimateMintPtYtPairRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateMintPtYtPairRequest.
       * @implements IQueryEstimateMintPtYtPairRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairRequest=} [properties] Properties to set
       */
      function QueryEstimateMintPtYtPairRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateMintPtYtPairRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @instance
       */
      QueryEstimateMintPtYtPairRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateMintPtYtPairRequest denom.
       * @member {string} denom
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @instance
       */
      QueryEstimateMintPtYtPairRequest.prototype.denom = '';

      /**
       * QueryEstimateMintPtYtPairRequest amount.
       * @member {string} amount
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @instance
       */
      QueryEstimateMintPtYtPairRequest.prototype.amount = '';

      /**
       * Encodes the specified QueryEstimateMintPtYtPairRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateMintPtYtPairRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairRequest} message QueryEstimateMintPtYtPairRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintPtYtPairRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateMintPtYtPairRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateMintPtYtPairRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairRequest} message QueryEstimateMintPtYtPairRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintPtYtPairRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateMintPtYtPairRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateMintPtYtPairRequest} QueryEstimateMintPtYtPairRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintPtYtPairRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateMintPtYtPairRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 2:
              message.denom = reader.string();
              break;
            case 3:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateMintPtYtPairRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateMintPtYtPairRequest} QueryEstimateMintPtYtPairRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintPtYtPairRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateMintPtYtPairRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateMintPtYtPairRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateMintPtYtPairRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateMintPtYtPairRequest} QueryEstimateMintPtYtPairRequest
       */
      QueryEstimateMintPtYtPairRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateMintPtYtPairRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateMintPtYtPairRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateMintPtYtPairRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @static
       * @param {ununifi.irs.QueryEstimateMintPtYtPairRequest} message QueryEstimateMintPtYtPairRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateMintPtYtPairRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.denom = '';
          object.amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this QueryEstimateMintPtYtPairRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateMintPtYtPairRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateMintPtYtPairRequest;
    })();

    irs.QueryEstimateMintPtYtPairResponse = (function () {
      /**
       * Properties of a QueryEstimateMintPtYtPairResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateMintPtYtPairResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [pt_amount] QueryEstimateMintPtYtPairResponse pt_amount
       * @property {cosmos.base.v1beta1.ICoin|null} [yt_amount] QueryEstimateMintPtYtPairResponse yt_amount
       */

      /**
       * Constructs a new QueryEstimateMintPtYtPairResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateMintPtYtPairResponse.
       * @implements IQueryEstimateMintPtYtPairResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairResponse=} [properties] Properties to set
       */
      function QueryEstimateMintPtYtPairResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateMintPtYtPairResponse pt_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} pt_amount
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @instance
       */
      QueryEstimateMintPtYtPairResponse.prototype.pt_amount = null;

      /**
       * QueryEstimateMintPtYtPairResponse yt_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} yt_amount
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @instance
       */
      QueryEstimateMintPtYtPairResponse.prototype.yt_amount = null;

      /**
       * Encodes the specified QueryEstimateMintPtYtPairResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateMintPtYtPairResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairResponse} message QueryEstimateMintPtYtPairResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintPtYtPairResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pt_amount != null && Object.hasOwnProperty.call(message, 'pt_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.pt_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.yt_amount != null && Object.hasOwnProperty.call(message, 'yt_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.yt_amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateMintPtYtPairResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateMintPtYtPairResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateMintPtYtPairResponse} message QueryEstimateMintPtYtPairResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintPtYtPairResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateMintPtYtPairResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateMintPtYtPairResponse} QueryEstimateMintPtYtPairResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintPtYtPairResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateMintPtYtPairResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pt_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.yt_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateMintPtYtPairResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateMintPtYtPairResponse} QueryEstimateMintPtYtPairResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintPtYtPairResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateMintPtYtPairResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateMintPtYtPairResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pt_amount != null && message.hasOwnProperty('pt_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.pt_amount);
          if (error) return 'pt_amount.' + error;
        }
        if (message.yt_amount != null && message.hasOwnProperty('yt_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.yt_amount);
          if (error) return 'yt_amount.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateMintPtYtPairResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateMintPtYtPairResponse} QueryEstimateMintPtYtPairResponse
       */
      QueryEstimateMintPtYtPairResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateMintPtYtPairResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateMintPtYtPairResponse();
        if (object.pt_amount != null) {
          if (typeof object.pt_amount !== 'object')
            throw TypeError('.ununifi.irs.QueryEstimateMintPtYtPairResponse.pt_amount: object expected');
          message.pt_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.pt_amount);
        }
        if (object.yt_amount != null) {
          if (typeof object.yt_amount !== 'object')
            throw TypeError('.ununifi.irs.QueryEstimateMintPtYtPairResponse.yt_amount: object expected');
          message.yt_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.yt_amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateMintPtYtPairResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @static
       * @param {ununifi.irs.QueryEstimateMintPtYtPairResponse} message QueryEstimateMintPtYtPairResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateMintPtYtPairResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.pt_amount = null;
          object.yt_amount = null;
        }
        if (message.pt_amount != null && message.hasOwnProperty('pt_amount'))
          object.pt_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.pt_amount, options);
        if (message.yt_amount != null && message.hasOwnProperty('yt_amount'))
          object.yt_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.yt_amount, options);
        return object;
      };

      /**
       * Converts this QueryEstimateMintPtYtPairResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateMintPtYtPairResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateMintPtYtPairResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateMintPtYtPairResponse;
    })();

    irs.QueryEstimateRedeemPtYtPairRequest = (function () {
      /**
       * Properties of a QueryEstimateRedeemPtYtPairRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRedeemPtYtPairRequest
       * @property {Long|null} [pool_id] QueryEstimateRedeemPtYtPairRequest pool_id
       * @property {string|null} [yt_amount] QueryEstimateRedeemPtYtPairRequest yt_amount
       */

      /**
       * Constructs a new QueryEstimateRedeemPtYtPairRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRedeemPtYtPairRequest.
       * @implements IQueryEstimateRedeemPtYtPairRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairRequest=} [properties] Properties to set
       */
      function QueryEstimateRedeemPtYtPairRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemPtYtPairRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @instance
       */
      QueryEstimateRedeemPtYtPairRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateRedeemPtYtPairRequest yt_amount.
       * @member {string} yt_amount
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @instance
       */
      QueryEstimateRedeemPtYtPairRequest.prototype.yt_amount = '';

      /**
       * Encodes the specified QueryEstimateRedeemPtYtPairRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemPtYtPairRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairRequest} message QueryEstimateRedeemPtYtPairRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemPtYtPairRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.yt_amount != null && Object.hasOwnProperty.call(message, 'yt_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.yt_amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemPtYtPairRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemPtYtPairRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairRequest} message QueryEstimateRedeemPtYtPairRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemPtYtPairRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemPtYtPairRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRedeemPtYtPairRequest} QueryEstimateRedeemPtYtPairRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemPtYtPairRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRedeemPtYtPairRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 2:
              message.yt_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemPtYtPairRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRedeemPtYtPairRequest} QueryEstimateRedeemPtYtPairRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemPtYtPairRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemPtYtPairRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemPtYtPairRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.yt_amount != null && message.hasOwnProperty('yt_amount'))
          if (!$util.isString(message.yt_amount)) return 'yt_amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemPtYtPairRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRedeemPtYtPairRequest} QueryEstimateRedeemPtYtPairRequest
       */
      QueryEstimateRedeemPtYtPairRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRedeemPtYtPairRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateRedeemPtYtPairRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.yt_amount != null) message.yt_amount = String(object.yt_amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemPtYtPairRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @static
       * @param {ununifi.irs.QueryEstimateRedeemPtYtPairRequest} message QueryEstimateRedeemPtYtPairRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemPtYtPairRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.yt_amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.yt_amount != null && message.hasOwnProperty('yt_amount')) object.yt_amount = message.yt_amount;
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemPtYtPairRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemPtYtPairRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemPtYtPairRequest;
    })();

    irs.QueryEstimateRedeemPtYtPairResponse = (function () {
      /**
       * Properties of a QueryEstimateRedeemPtYtPairResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRedeemPtYtPairResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [pt_amount] QueryEstimateRedeemPtYtPairResponse pt_amount
       */

      /**
       * Constructs a new QueryEstimateRedeemPtYtPairResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRedeemPtYtPairResponse.
       * @implements IQueryEstimateRedeemPtYtPairResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairResponse=} [properties] Properties to set
       */
      function QueryEstimateRedeemPtYtPairResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemPtYtPairResponse pt_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} pt_amount
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @instance
       */
      QueryEstimateRedeemPtYtPairResponse.prototype.pt_amount = null;

      /**
       * Encodes the specified QueryEstimateRedeemPtYtPairResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemPtYtPairResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairResponse} message QueryEstimateRedeemPtYtPairResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemPtYtPairResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pt_amount != null && Object.hasOwnProperty.call(message, 'pt_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.pt_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemPtYtPairResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemPtYtPairResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemPtYtPairResponse} message QueryEstimateRedeemPtYtPairResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemPtYtPairResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemPtYtPairResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRedeemPtYtPairResponse} QueryEstimateRedeemPtYtPairResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemPtYtPairResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRedeemPtYtPairResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pt_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemPtYtPairResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRedeemPtYtPairResponse} QueryEstimateRedeemPtYtPairResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemPtYtPairResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemPtYtPairResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemPtYtPairResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pt_amount != null && message.hasOwnProperty('pt_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.pt_amount);
          if (error) return 'pt_amount.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemPtYtPairResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRedeemPtYtPairResponse} QueryEstimateRedeemPtYtPairResponse
       */
      QueryEstimateRedeemPtYtPairResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRedeemPtYtPairResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateRedeemPtYtPairResponse();
        if (object.pt_amount != null) {
          if (typeof object.pt_amount !== 'object')
            throw TypeError('.ununifi.irs.QueryEstimateRedeemPtYtPairResponse.pt_amount: object expected');
          message.pt_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.pt_amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemPtYtPairResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @static
       * @param {ununifi.irs.QueryEstimateRedeemPtYtPairResponse} message QueryEstimateRedeemPtYtPairResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemPtYtPairResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pt_amount = null;
        if (message.pt_amount != null && message.hasOwnProperty('pt_amount'))
          object.pt_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.pt_amount, options);
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemPtYtPairResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRedeemPtYtPairResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemPtYtPairResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemPtYtPairResponse;
    })();

    irs.QueryEstimateRedeemYtRequest = (function () {
      /**
       * Properties of a QueryEstimateRedeemYtRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRedeemYtRequest
       * @property {Long|null} [pool_id] QueryEstimateRedeemYtRequest pool_id
       * @property {string|null} [denom] QueryEstimateRedeemYtRequest denom
       * @property {string|null} [amount] QueryEstimateRedeemYtRequest amount
       */

      /**
       * Constructs a new QueryEstimateRedeemYtRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRedeemYtRequest.
       * @implements IQueryEstimateRedeemYtRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRedeemYtRequest=} [properties] Properties to set
       */
      function QueryEstimateRedeemYtRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemYtRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @instance
       */
      QueryEstimateRedeemYtRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateRedeemYtRequest denom.
       * @member {string} denom
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @instance
       */
      QueryEstimateRedeemYtRequest.prototype.denom = '';

      /**
       * QueryEstimateRedeemYtRequest amount.
       * @member {string} amount
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @instance
       */
      QueryEstimateRedeemYtRequest.prototype.amount = '';

      /**
       * Encodes the specified QueryEstimateRedeemYtRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemYtRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemYtRequest} message QueryEstimateRedeemYtRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemYtRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemYtRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemYtRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemYtRequest} message QueryEstimateRedeemYtRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemYtRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemYtRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRedeemYtRequest} QueryEstimateRedeemYtRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemYtRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRedeemYtRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 2:
              message.denom = reader.string();
              break;
            case 3:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemYtRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRedeemYtRequest} QueryEstimateRedeemYtRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemYtRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemYtRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemYtRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemYtRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRedeemYtRequest} QueryEstimateRedeemYtRequest
       */
      QueryEstimateRedeemYtRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRedeemYtRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateRedeemYtRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemYtRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @static
       * @param {ununifi.irs.QueryEstimateRedeemYtRequest} message QueryEstimateRedeemYtRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemYtRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.denom = '';
          object.amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemYtRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRedeemYtRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemYtRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemYtRequest;
    })();

    irs.QueryEstimateRedeemYtResponse = (function () {
      /**
       * Properties of a QueryEstimateRedeemYtResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRedeemYtResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] QueryEstimateRedeemYtResponse amount
       */

      /**
       * Constructs a new QueryEstimateRedeemYtResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRedeemYtResponse.
       * @implements IQueryEstimateRedeemYtResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRedeemYtResponse=} [properties] Properties to set
       */
      function QueryEstimateRedeemYtResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemYtResponse amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @instance
       */
      QueryEstimateRedeemYtResponse.prototype.amount = null;

      /**
       * Encodes the specified QueryEstimateRedeemYtResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemYtResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemYtResponse} message QueryEstimateRedeemYtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemYtResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemYtResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemYtResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemYtResponse} message QueryEstimateRedeemYtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemYtResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemYtResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRedeemYtResponse} QueryEstimateRedeemYtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemYtResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRedeemYtResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemYtResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRedeemYtResponse} QueryEstimateRedeemYtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemYtResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemYtResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemYtResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemYtResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRedeemYtResponse} QueryEstimateRedeemYtResponse
       */
      QueryEstimateRedeemYtResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRedeemYtResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateRedeemYtResponse();
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.irs.QueryEstimateRedeemYtResponse.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemYtResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @static
       * @param {ununifi.irs.QueryEstimateRedeemYtResponse} message QueryEstimateRedeemYtResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemYtResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.amount = null;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemYtResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRedeemYtResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemYtResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemYtResponse;
    })();

    irs.QueryEstimateMintLiquidityPoolTokenRequest = (function () {
      /**
       * Properties of a QueryEstimateMintLiquidityPoolTokenRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateMintLiquidityPoolTokenRequest
       * @property {Long|null} [pool_id] QueryEstimateMintLiquidityPoolTokenRequest pool_id
       * @property {string|null} [desired_amount] QueryEstimateMintLiquidityPoolTokenRequest desired_amount
       */

      /**
       * Constructs a new QueryEstimateMintLiquidityPoolTokenRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateMintLiquidityPoolTokenRequest.
       * @implements IQueryEstimateMintLiquidityPoolTokenRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenRequest=} [properties] Properties to set
       */
      function QueryEstimateMintLiquidityPoolTokenRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateMintLiquidityPoolTokenRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @instance
       */
      QueryEstimateMintLiquidityPoolTokenRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateMintLiquidityPoolTokenRequest desired_amount.
       * @member {string} desired_amount
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @instance
       */
      QueryEstimateMintLiquidityPoolTokenRequest.prototype.desired_amount = '';

      /**
       * Encodes the specified QueryEstimateMintLiquidityPoolTokenRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenRequest} message QueryEstimateMintLiquidityPoolTokenRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintLiquidityPoolTokenRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.desired_amount != null && Object.hasOwnProperty.call(message, 'desired_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.desired_amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateMintLiquidityPoolTokenRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenRequest} message QueryEstimateMintLiquidityPoolTokenRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintLiquidityPoolTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateMintLiquidityPoolTokenRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest} QueryEstimateMintLiquidityPoolTokenRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintLiquidityPoolTokenRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 3:
              message.desired_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateMintLiquidityPoolTokenRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest} QueryEstimateMintLiquidityPoolTokenRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintLiquidityPoolTokenRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateMintLiquidityPoolTokenRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateMintLiquidityPoolTokenRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.desired_amount != null && message.hasOwnProperty('desired_amount'))
          if (!$util.isString(message.desired_amount)) return 'desired_amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateMintLiquidityPoolTokenRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest} QueryEstimateMintLiquidityPoolTokenRequest
       */
      QueryEstimateMintLiquidityPoolTokenRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.desired_amount != null) message.desired_amount = String(object.desired_amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateMintLiquidityPoolTokenRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @static
       * @param {ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest} message QueryEstimateMintLiquidityPoolTokenRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateMintLiquidityPoolTokenRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.desired_amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.desired_amount != null && message.hasOwnProperty('desired_amount')) object.desired_amount = message.desired_amount;
        return object;
      };

      /**
       * Converts this QueryEstimateMintLiquidityPoolTokenRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateMintLiquidityPoolTokenRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateMintLiquidityPoolTokenRequest;
    })();

    irs.QueryEstimateMintLiquidityPoolTokenResponse = (function () {
      /**
       * Properties of a QueryEstimateMintLiquidityPoolTokenResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateMintLiquidityPoolTokenResponse
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [required_amount] QueryEstimateMintLiquidityPoolTokenResponse required_amount
       */

      /**
       * Constructs a new QueryEstimateMintLiquidityPoolTokenResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateMintLiquidityPoolTokenResponse.
       * @implements IQueryEstimateMintLiquidityPoolTokenResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenResponse=} [properties] Properties to set
       */
      function QueryEstimateMintLiquidityPoolTokenResponse(properties) {
        this.required_amount = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateMintLiquidityPoolTokenResponse required_amount.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} required_amount
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @instance
       */
      QueryEstimateMintLiquidityPoolTokenResponse.prototype.required_amount = $util.emptyArray;

      /**
       * Encodes the specified QueryEstimateMintLiquidityPoolTokenResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenResponse} message QueryEstimateMintLiquidityPoolTokenResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintLiquidityPoolTokenResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.required_amount != null && message.required_amount.length)
          for (let i = 0; i < message.required_amount.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.required_amount[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateMintLiquidityPoolTokenResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateMintLiquidityPoolTokenResponse} message QueryEstimateMintLiquidityPoolTokenResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintLiquidityPoolTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateMintLiquidityPoolTokenResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse} QueryEstimateMintLiquidityPoolTokenResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintLiquidityPoolTokenResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.required_amount && message.required_amount.length)) message.required_amount = [];
              message.required_amount.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateMintLiquidityPoolTokenResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse} QueryEstimateMintLiquidityPoolTokenResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintLiquidityPoolTokenResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateMintLiquidityPoolTokenResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateMintLiquidityPoolTokenResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.required_amount != null && message.hasOwnProperty('required_amount')) {
          if (!Array.isArray(message.required_amount)) return 'required_amount: array expected';
          for (let i = 0; i < message.required_amount.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.required_amount[i]);
            if (error) return 'required_amount.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryEstimateMintLiquidityPoolTokenResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse} QueryEstimateMintLiquidityPoolTokenResponse
       */
      QueryEstimateMintLiquidityPoolTokenResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse();
        if (object.required_amount) {
          if (!Array.isArray(object.required_amount))
            throw TypeError('.ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse.required_amount: array expected');
          message.required_amount = [];
          for (let i = 0; i < object.required_amount.length; ++i) {
            if (typeof object.required_amount[i] !== 'object')
              throw TypeError('.ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse.required_amount: object expected');
            message.required_amount[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.required_amount[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateMintLiquidityPoolTokenResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @static
       * @param {ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse} message QueryEstimateMintLiquidityPoolTokenResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateMintLiquidityPoolTokenResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.required_amount = [];
        if (message.required_amount && message.required_amount.length) {
          object.required_amount = [];
          for (let j = 0; j < message.required_amount.length; ++j)
            object.required_amount[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.required_amount[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryEstimateMintLiquidityPoolTokenResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateMintLiquidityPoolTokenResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateMintLiquidityPoolTokenResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateMintLiquidityPoolTokenResponse;
    })();

    irs.QueryEstimateRedeemLiquidityPoolTokenRequest = (function () {
      /**
       * Properties of a QueryEstimateRedeemLiquidityPoolTokenRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRedeemLiquidityPoolTokenRequest
       * @property {Long|null} [pool_id] QueryEstimateRedeemLiquidityPoolTokenRequest pool_id
       * @property {string|null} [amount] QueryEstimateRedeemLiquidityPoolTokenRequest amount
       */

      /**
       * Constructs a new QueryEstimateRedeemLiquidityPoolTokenRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRedeemLiquidityPoolTokenRequest.
       * @implements IQueryEstimateRedeemLiquidityPoolTokenRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenRequest=} [properties] Properties to set
       */
      function QueryEstimateRedeemLiquidityPoolTokenRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemLiquidityPoolTokenRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @instance
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateRedeemLiquidityPoolTokenRequest amount.
       * @member {string} amount
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @instance
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.prototype.amount = '';

      /**
       * Encodes the specified QueryEstimateRedeemLiquidityPoolTokenRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenRequest} message QueryEstimateRedeemLiquidityPoolTokenRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemLiquidityPoolTokenRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenRequest} message QueryEstimateRedeemLiquidityPoolTokenRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemLiquidityPoolTokenRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest} QueryEstimateRedeemLiquidityPoolTokenRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 3:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemLiquidityPoolTokenRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest} QueryEstimateRedeemLiquidityPoolTokenRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemLiquidityPoolTokenRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemLiquidityPoolTokenRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest} QueryEstimateRedeemLiquidityPoolTokenRequest
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemLiquidityPoolTokenRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @static
       * @param {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest} message QueryEstimateRedeemLiquidityPoolTokenRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemLiquidityPoolTokenRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemLiquidityPoolTokenRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemLiquidityPoolTokenRequest;
    })();

    irs.QueryEstimateRedeemLiquidityPoolTokenResponse = (function () {
      /**
       * Properties of a QueryEstimateRedeemLiquidityPoolTokenResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRedeemLiquidityPoolTokenResponse
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [redeem_amount] QueryEstimateRedeemLiquidityPoolTokenResponse redeem_amount
       */

      /**
       * Constructs a new QueryEstimateRedeemLiquidityPoolTokenResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRedeemLiquidityPoolTokenResponse.
       * @implements IQueryEstimateRedeemLiquidityPoolTokenResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenResponse=} [properties] Properties to set
       */
      function QueryEstimateRedeemLiquidityPoolTokenResponse(properties) {
        this.redeem_amount = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemLiquidityPoolTokenResponse redeem_amount.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} redeem_amount
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @instance
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.prototype.redeem_amount = $util.emptyArray;

      /**
       * Encodes the specified QueryEstimateRedeemLiquidityPoolTokenResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenResponse} message QueryEstimateRedeemLiquidityPoolTokenResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.redeem_amount != null && message.redeem_amount.length)
          for (let i = 0; i < message.redeem_amount.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.redeem_amount[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemLiquidityPoolTokenResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRedeemLiquidityPoolTokenResponse} message QueryEstimateRedeemLiquidityPoolTokenResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemLiquidityPoolTokenResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse} QueryEstimateRedeemLiquidityPoolTokenResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.redeem_amount && message.redeem_amount.length)) message.redeem_amount = [];
              message.redeem_amount.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemLiquidityPoolTokenResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse} QueryEstimateRedeemLiquidityPoolTokenResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemLiquidityPoolTokenResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.redeem_amount != null && message.hasOwnProperty('redeem_amount')) {
          if (!Array.isArray(message.redeem_amount)) return 'redeem_amount: array expected';
          for (let i = 0; i < message.redeem_amount.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.redeem_amount[i]);
            if (error) return 'redeem_amount.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemLiquidityPoolTokenResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse} QueryEstimateRedeemLiquidityPoolTokenResponse
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse();
        if (object.redeem_amount) {
          if (!Array.isArray(object.redeem_amount))
            throw TypeError('.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse.redeem_amount: array expected');
          message.redeem_amount = [];
          for (let i = 0; i < object.redeem_amount.length; ++i) {
            if (typeof object.redeem_amount[i] !== 'object')
              throw TypeError('.ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse.redeem_amount: object expected');
            message.redeem_amount[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.redeem_amount[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemLiquidityPoolTokenResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @static
       * @param {ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse} message QueryEstimateRedeemLiquidityPoolTokenResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.redeem_amount = [];
        if (message.redeem_amount && message.redeem_amount.length) {
          object.redeem_amount = [];
          for (let j = 0; j < message.redeem_amount.length; ++j)
            object.redeem_amount[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.redeem_amount[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemLiquidityPoolTokenResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRedeemLiquidityPoolTokenResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemLiquidityPoolTokenResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemLiquidityPoolTokenResponse;
    })();

    irs.QueryEstimateRequiredUtSwapToYtRequest = (function () {
      /**
       * Properties of a QueryEstimateRequiredUtSwapToYtRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRequiredUtSwapToYtRequest
       * @property {Long|null} [pool_id] QueryEstimateRequiredUtSwapToYtRequest pool_id
       * @property {string|null} [desired_yt_amount] QueryEstimateRequiredUtSwapToYtRequest desired_yt_amount
       */

      /**
       * Constructs a new QueryEstimateRequiredUtSwapToYtRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRequiredUtSwapToYtRequest.
       * @implements IQueryEstimateRequiredUtSwapToYtRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtRequest=} [properties] Properties to set
       */
      function QueryEstimateRequiredUtSwapToYtRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRequiredUtSwapToYtRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @instance
       */
      QueryEstimateRequiredUtSwapToYtRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateRequiredUtSwapToYtRequest desired_yt_amount.
       * @member {string} desired_yt_amount
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @instance
       */
      QueryEstimateRequiredUtSwapToYtRequest.prototype.desired_yt_amount = '';

      /**
       * Encodes the specified QueryEstimateRequiredUtSwapToYtRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtRequest} message QueryEstimateRequiredUtSwapToYtRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRequiredUtSwapToYtRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.desired_yt_amount != null && Object.hasOwnProperty.call(message, 'desired_yt_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.desired_yt_amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRequiredUtSwapToYtRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtRequest} message QueryEstimateRequiredUtSwapToYtRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRequiredUtSwapToYtRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRequiredUtSwapToYtRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest} QueryEstimateRequiredUtSwapToYtRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRequiredUtSwapToYtRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 3:
              message.desired_yt_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRequiredUtSwapToYtRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest} QueryEstimateRequiredUtSwapToYtRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRequiredUtSwapToYtRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRequiredUtSwapToYtRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRequiredUtSwapToYtRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.desired_yt_amount != null && message.hasOwnProperty('desired_yt_amount'))
          if (!$util.isString(message.desired_yt_amount)) return 'desired_yt_amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateRequiredUtSwapToYtRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest} QueryEstimateRequiredUtSwapToYtRequest
       */
      QueryEstimateRequiredUtSwapToYtRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.desired_yt_amount != null) message.desired_yt_amount = String(object.desired_yt_amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRequiredUtSwapToYtRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @static
       * @param {ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest} message QueryEstimateRequiredUtSwapToYtRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRequiredUtSwapToYtRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.desired_yt_amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.desired_yt_amount != null && message.hasOwnProperty('desired_yt_amount'))
          object.desired_yt_amount = message.desired_yt_amount;
        return object;
      };

      /**
       * Converts this QueryEstimateRequiredUtSwapToYtRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRequiredUtSwapToYtRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRequiredUtSwapToYtRequest;
    })();

    irs.QueryEstimateRequiredUtSwapToYtResponse = (function () {
      /**
       * Properties of a QueryEstimateRequiredUtSwapToYtResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateRequiredUtSwapToYtResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [required_ut_amount] QueryEstimateRequiredUtSwapToYtResponse required_ut_amount
       */

      /**
       * Constructs a new QueryEstimateRequiredUtSwapToYtResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateRequiredUtSwapToYtResponse.
       * @implements IQueryEstimateRequiredUtSwapToYtResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtResponse=} [properties] Properties to set
       */
      function QueryEstimateRequiredUtSwapToYtResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRequiredUtSwapToYtResponse required_ut_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} required_ut_amount
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @instance
       */
      QueryEstimateRequiredUtSwapToYtResponse.prototype.required_ut_amount = null;

      /**
       * Encodes the specified QueryEstimateRequiredUtSwapToYtResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtResponse} message QueryEstimateRequiredUtSwapToYtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRequiredUtSwapToYtResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.required_ut_amount != null && Object.hasOwnProperty.call(message, 'required_ut_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.required_ut_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRequiredUtSwapToYtResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateRequiredUtSwapToYtResponse} message QueryEstimateRequiredUtSwapToYtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRequiredUtSwapToYtResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRequiredUtSwapToYtResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse} QueryEstimateRequiredUtSwapToYtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRequiredUtSwapToYtResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.required_ut_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRequiredUtSwapToYtResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse} QueryEstimateRequiredUtSwapToYtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRequiredUtSwapToYtResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRequiredUtSwapToYtResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRequiredUtSwapToYtResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.required_ut_amount != null && message.hasOwnProperty('required_ut_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.required_ut_amount);
          if (error) return 'required_ut_amount.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateRequiredUtSwapToYtResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse} QueryEstimateRequiredUtSwapToYtResponse
       */
      QueryEstimateRequiredUtSwapToYtResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse();
        if (object.required_ut_amount != null) {
          if (typeof object.required_ut_amount !== 'object')
            throw TypeError('.ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse.required_ut_amount: object expected');
          message.required_ut_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.required_ut_amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRequiredUtSwapToYtResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @static
       * @param {ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse} message QueryEstimateRequiredUtSwapToYtResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRequiredUtSwapToYtResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.required_ut_amount = null;
        if (message.required_ut_amount != null && message.hasOwnProperty('required_ut_amount'))
          object.required_ut_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.required_ut_amount, options);
        return object;
      };

      /**
       * Converts this QueryEstimateRequiredUtSwapToYtResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateRequiredUtSwapToYtResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRequiredUtSwapToYtResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRequiredUtSwapToYtResponse;
    })();

    irs.QueryEstimateSwapMaturedYtToUtRequest = (function () {
      /**
       * Properties of a QueryEstimateSwapMaturedYtToUtRequest.
       * @memberof ununifi.irs
       * @interface IQueryEstimateSwapMaturedYtToUtRequest
       * @property {Long|null} [pool_id] QueryEstimateSwapMaturedYtToUtRequest pool_id
       * @property {string|null} [yt_amount] QueryEstimateSwapMaturedYtToUtRequest yt_amount
       */

      /**
       * Constructs a new QueryEstimateSwapMaturedYtToUtRequest.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateSwapMaturedYtToUtRequest.
       * @implements IQueryEstimateSwapMaturedYtToUtRequest
       * @constructor
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtRequest=} [properties] Properties to set
       */
      function QueryEstimateSwapMaturedYtToUtRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateSwapMaturedYtToUtRequest pool_id.
       * @member {Long} pool_id
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @instance
       */
      QueryEstimateSwapMaturedYtToUtRequest.prototype.pool_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateSwapMaturedYtToUtRequest yt_amount.
       * @member {string} yt_amount
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @instance
       */
      QueryEstimateSwapMaturedYtToUtRequest.prototype.yt_amount = '';

      /**
       * Encodes the specified QueryEstimateSwapMaturedYtToUtRequest message. Does not implicitly {@link ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtRequest} message QueryEstimateSwapMaturedYtToUtRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapMaturedYtToUtRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pool_id != null && Object.hasOwnProperty.call(message, 'pool_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.pool_id);
        if (message.yt_amount != null && Object.hasOwnProperty.call(message, 'yt_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.yt_amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateSwapMaturedYtToUtRequest message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtRequest} message QueryEstimateSwapMaturedYtToUtRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapMaturedYtToUtRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateSwapMaturedYtToUtRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest} QueryEstimateSwapMaturedYtToUtRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapMaturedYtToUtRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool_id = reader.uint64();
              break;
            case 2:
              message.yt_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateSwapMaturedYtToUtRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest} QueryEstimateSwapMaturedYtToUtRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapMaturedYtToUtRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateSwapMaturedYtToUtRequest message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateSwapMaturedYtToUtRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (
            !$util.isInteger(message.pool_id) &&
            !(message.pool_id && $util.isInteger(message.pool_id.low) && $util.isInteger(message.pool_id.high))
          )
            return 'pool_id: integer|Long expected';
        if (message.yt_amount != null && message.hasOwnProperty('yt_amount'))
          if (!$util.isString(message.yt_amount)) return 'yt_amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateSwapMaturedYtToUtRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest} QueryEstimateSwapMaturedYtToUtRequest
       */
      QueryEstimateSwapMaturedYtToUtRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest) return object;
        let message = new $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest();
        if (object.pool_id != null)
          if ($util.Long) (message.pool_id = $util.Long.fromValue(object.pool_id)).unsigned = true;
          else if (typeof object.pool_id === 'string') message.pool_id = parseInt(object.pool_id, 10);
          else if (typeof object.pool_id === 'number') message.pool_id = object.pool_id;
          else if (typeof object.pool_id === 'object')
            message.pool_id = new $util.LongBits(object.pool_id.low >>> 0, object.pool_id.high >>> 0).toNumber(true);
        if (object.yt_amount != null) message.yt_amount = String(object.yt_amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateSwapMaturedYtToUtRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @static
       * @param {ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest} message QueryEstimateSwapMaturedYtToUtRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateSwapMaturedYtToUtRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.pool_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.pool_id = options.longs === String ? '0' : 0;
          object.yt_amount = '';
        }
        if (message.pool_id != null && message.hasOwnProperty('pool_id'))
          if (typeof message.pool_id === 'number') object.pool_id = options.longs === String ? String(message.pool_id) : message.pool_id;
          else
            object.pool_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.pool_id)
                : options.longs === Number
                ? new $util.LongBits(message.pool_id.low >>> 0, message.pool_id.high >>> 0).toNumber(true)
                : message.pool_id;
        if (message.yt_amount != null && message.hasOwnProperty('yt_amount')) object.yt_amount = message.yt_amount;
        return object;
      };

      /**
       * Converts this QueryEstimateSwapMaturedYtToUtRequest to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateSwapMaturedYtToUtRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateSwapMaturedYtToUtRequest;
    })();

    irs.QueryEstimateSwapMaturedYtToUtResponse = (function () {
      /**
       * Properties of a QueryEstimateSwapMaturedYtToUtResponse.
       * @memberof ununifi.irs
       * @interface IQueryEstimateSwapMaturedYtToUtResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [ut_amount] QueryEstimateSwapMaturedYtToUtResponse ut_amount
       */

      /**
       * Constructs a new QueryEstimateSwapMaturedYtToUtResponse.
       * @memberof ununifi.irs
       * @classdesc Represents a QueryEstimateSwapMaturedYtToUtResponse.
       * @implements IQueryEstimateSwapMaturedYtToUtResponse
       * @constructor
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtResponse=} [properties] Properties to set
       */
      function QueryEstimateSwapMaturedYtToUtResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateSwapMaturedYtToUtResponse ut_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} ut_amount
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @instance
       */
      QueryEstimateSwapMaturedYtToUtResponse.prototype.ut_amount = null;

      /**
       * Encodes the specified QueryEstimateSwapMaturedYtToUtResponse message. Does not implicitly {@link ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtResponse} message QueryEstimateSwapMaturedYtToUtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapMaturedYtToUtResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.ut_amount != null && Object.hasOwnProperty.call(message, 'ut_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.ut_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateSwapMaturedYtToUtResponse message, length delimited. Does not implicitly {@link ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @static
       * @param {ununifi.irs.IQueryEstimateSwapMaturedYtToUtResponse} message QueryEstimateSwapMaturedYtToUtResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateSwapMaturedYtToUtResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateSwapMaturedYtToUtResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse} QueryEstimateSwapMaturedYtToUtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapMaturedYtToUtResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ut_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateSwapMaturedYtToUtResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse} QueryEstimateSwapMaturedYtToUtResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateSwapMaturedYtToUtResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateSwapMaturedYtToUtResponse message.
       * @function verify
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateSwapMaturedYtToUtResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.ut_amount != null && message.hasOwnProperty('ut_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.ut_amount);
          if (error) return 'ut_amount.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateSwapMaturedYtToUtResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse} QueryEstimateSwapMaturedYtToUtResponse
       */
      QueryEstimateSwapMaturedYtToUtResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse) return object;
        let message = new $root.ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse();
        if (object.ut_amount != null) {
          if (typeof object.ut_amount !== 'object')
            throw TypeError('.ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse.ut_amount: object expected');
          message.ut_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.ut_amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateSwapMaturedYtToUtResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @static
       * @param {ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse} message QueryEstimateSwapMaturedYtToUtResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateSwapMaturedYtToUtResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.ut_amount = null;
        if (message.ut_amount != null && message.hasOwnProperty('ut_amount'))
          object.ut_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.ut_amount, options);
        return object;
      };

      /**
       * Converts this QueryEstimateSwapMaturedYtToUtResponse to JSON.
       * @function toJSON
       * @memberof ununifi.irs.QueryEstimateSwapMaturedYtToUtResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateSwapMaturedYtToUtResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateSwapMaturedYtToUtResponse;
    })();

    return irs;
  })();

  ununifi.nft = (function () {
    /**
     * Namespace nft.
     * @memberof ununifi
     * @namespace
     */
    const nft = {};

    nft.ClassData = (function () {
      /**
       * Properties of a ClassData.
       * @memberof ununifi.nft
       * @interface IClassData
       * @property {string|null} [send_prehook_contract] ClassData send_prehook_contract
       */

      /**
       * Constructs a new ClassData.
       * @memberof ununifi.nft
       * @classdesc Represents a ClassData.
       * @implements IClassData
       * @constructor
       * @param {ununifi.nft.IClassData=} [properties] Properties to set
       */
      function ClassData(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ClassData send_prehook_contract.
       * @member {string} send_prehook_contract
       * @memberof ununifi.nft.ClassData
       * @instance
       */
      ClassData.prototype.send_prehook_contract = '';

      /**
       * Encodes the specified ClassData message. Does not implicitly {@link ununifi.nft.ClassData.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nft.ClassData
       * @static
       * @param {ununifi.nft.IClassData} message ClassData message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassData.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.send_prehook_contract != null && Object.hasOwnProperty.call(message, 'send_prehook_contract'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.send_prehook_contract);
        return writer;
      };

      /**
       * Encodes the specified ClassData message, length delimited. Does not implicitly {@link ununifi.nft.ClassData.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nft.ClassData
       * @static
       * @param {ununifi.nft.IClassData} message ClassData message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ClassData message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nft.ClassData
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nft.ClassData} ClassData
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nft.ClassData();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.send_prehook_contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ClassData message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nft.ClassData
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nft.ClassData} ClassData
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ClassData message.
       * @function verify
       * @memberof ununifi.nft.ClassData
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ClassData.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.send_prehook_contract != null && message.hasOwnProperty('send_prehook_contract'))
          if (!$util.isString(message.send_prehook_contract)) return 'send_prehook_contract: string expected';
        return null;
      };

      /**
       * Creates a ClassData message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nft.ClassData
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nft.ClassData} ClassData
       */
      ClassData.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nft.ClassData) return object;
        let message = new $root.ununifi.nft.ClassData();
        if (object.send_prehook_contract != null) message.send_prehook_contract = String(object.send_prehook_contract);
        return message;
      };

      /**
       * Creates a plain object from a ClassData message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nft.ClassData
       * @static
       * @param {ununifi.nft.ClassData} message ClassData
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ClassData.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.send_prehook_contract = '';
        if (message.send_prehook_contract != null && message.hasOwnProperty('send_prehook_contract'))
          object.send_prehook_contract = message.send_prehook_contract;
        return object;
      };

      /**
       * Converts this ClassData to JSON.
       * @function toJSON
       * @memberof ununifi.nft.ClassData
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ClassData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ClassData;
    })();

    nft.NftData = (function () {
      /**
       * Properties of a NftData.
       * @memberof ununifi.nft
       * @interface INftData
       * @property {boolean|null} [send_disabled] NftData send_disabled
       */

      /**
       * Constructs a new NftData.
       * @memberof ununifi.nft
       * @classdesc Represents a NftData.
       * @implements INftData
       * @constructor
       * @param {ununifi.nft.INftData=} [properties] Properties to set
       */
      function NftData(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * NftData send_disabled.
       * @member {boolean} send_disabled
       * @memberof ununifi.nft.NftData
       * @instance
       */
      NftData.prototype.send_disabled = false;

      /**
       * Encodes the specified NftData message. Does not implicitly {@link ununifi.nft.NftData.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nft.NftData
       * @static
       * @param {ununifi.nft.INftData} message NftData message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftData.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.send_disabled != null && Object.hasOwnProperty.call(message, 'send_disabled'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.send_disabled);
        return writer;
      };

      /**
       * Encodes the specified NftData message, length delimited. Does not implicitly {@link ununifi.nft.NftData.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nft.NftData
       * @static
       * @param {ununifi.nft.INftData} message NftData message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a NftData message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nft.NftData
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nft.NftData} NftData
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nft.NftData();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.send_disabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a NftData message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nft.NftData
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nft.NftData} NftData
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a NftData message.
       * @function verify
       * @memberof ununifi.nft.NftData
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      NftData.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.send_disabled != null && message.hasOwnProperty('send_disabled'))
          if (typeof message.send_disabled !== 'boolean') return 'send_disabled: boolean expected';
        return null;
      };

      /**
       * Creates a NftData message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nft.NftData
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nft.NftData} NftData
       */
      NftData.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nft.NftData) return object;
        let message = new $root.ununifi.nft.NftData();
        if (object.send_disabled != null) message.send_disabled = Boolean(object.send_disabled);
        return message;
      };

      /**
       * Creates a plain object from a NftData message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nft.NftData
       * @static
       * @param {ununifi.nft.NftData} message NftData
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      NftData.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.send_disabled = false;
        if (message.send_disabled != null && message.hasOwnProperty('send_disabled')) object.send_disabled = message.send_disabled;
        return object;
      };

      /**
       * Converts this NftData to JSON.
       * @function toJSON
       * @memberof ununifi.nft.NftData
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      NftData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return NftData;
    })();

    return nft;
  })();

  ununifi.nftbackedloan = (function () {
    /**
     * Namespace nftbackedloan.
     * @memberof ununifi
     * @namespace
     */
    const nftbackedloan = {};

    nftbackedloan.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#listNft}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef ListNftCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgListNftResponse} [response] MsgListNftResponse
       */

      /**
       * Calls ListNft.
       * @function listNft
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgListNft} request MsgListNft message or plain object
       * @param {ununifi.nftbackedloan.Msg.ListNftCallback} callback Node-style callback called with the error, if any, and MsgListNftResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.listNft = function listNft(request, callback) {
          return this.rpcCall(
            listNft,
            $root.ununifi.nftbackedloan.MsgListNft,
            $root.ununifi.nftbackedloan.MsgListNftResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListNft' },
      );

      /**
       * Calls ListNft.
       * @function listNft
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgListNft} request MsgListNft message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgListNftResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#cancelListing}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef CancelListingCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgCancelListingResponse} [response] MsgCancelListingResponse
       */

      /**
       * Calls CancelListing.
       * @function cancelListing
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgCancelListing} request MsgCancelListing message or plain object
       * @param {ununifi.nftbackedloan.Msg.CancelListingCallback} callback Node-style callback called with the error, if any, and MsgCancelListingResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.cancelListing = function cancelListing(request, callback) {
          return this.rpcCall(
            cancelListing,
            $root.ununifi.nftbackedloan.MsgCancelListing,
            $root.ununifi.nftbackedloan.MsgCancelListingResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CancelListing' },
      );

      /**
       * Calls CancelListing.
       * @function cancelListing
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgCancelListing} request MsgCancelListing message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgCancelListingResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#placeBid}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef PlaceBidCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgPlaceBidResponse} [response] MsgPlaceBidResponse
       */

      /**
       * Calls PlaceBid.
       * @function placeBid
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgPlaceBid} request MsgPlaceBid message or plain object
       * @param {ununifi.nftbackedloan.Msg.PlaceBidCallback} callback Node-style callback called with the error, if any, and MsgPlaceBidResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.placeBid = function placeBid(request, callback) {
          return this.rpcCall(
            placeBid,
            $root.ununifi.nftbackedloan.MsgPlaceBid,
            $root.ununifi.nftbackedloan.MsgPlaceBidResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PlaceBid' },
      );

      /**
       * Calls PlaceBid.
       * @function placeBid
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgPlaceBid} request MsgPlaceBid message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgPlaceBidResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#cancelBid}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef CancelBidCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgCancelBidResponse} [response] MsgCancelBidResponse
       */

      /**
       * Calls CancelBid.
       * @function cancelBid
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgCancelBid} request MsgCancelBid message or plain object
       * @param {ununifi.nftbackedloan.Msg.CancelBidCallback} callback Node-style callback called with the error, if any, and MsgCancelBidResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.cancelBid = function cancelBid(request, callback) {
          return this.rpcCall(
            cancelBid,
            $root.ununifi.nftbackedloan.MsgCancelBid,
            $root.ununifi.nftbackedloan.MsgCancelBidResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CancelBid' },
      );

      /**
       * Calls CancelBid.
       * @function cancelBid
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgCancelBid} request MsgCancelBid message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgCancelBidResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#sellingDecision}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef SellingDecisionCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgSellingDecisionResponse} [response] MsgSellingDecisionResponse
       */

      /**
       * Calls SellingDecision.
       * @function sellingDecision
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgSellingDecision} request MsgSellingDecision message or plain object
       * @param {ununifi.nftbackedloan.Msg.SellingDecisionCallback} callback Node-style callback called with the error, if any, and MsgSellingDecisionResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.sellingDecision = function sellingDecision(request, callback) {
          return this.rpcCall(
            sellingDecision,
            $root.ununifi.nftbackedloan.MsgSellingDecision,
            $root.ununifi.nftbackedloan.MsgSellingDecisionResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'SellingDecision' },
      );

      /**
       * Calls SellingDecision.
       * @function sellingDecision
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgSellingDecision} request MsgSellingDecision message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgSellingDecisionResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#payRemainder}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef PayRemainderCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgPayRemainderResponse} [response] MsgPayRemainderResponse
       */

      /**
       * Calls PayRemainder.
       * @function payRemainder
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgPayRemainder} request MsgPayRemainder message or plain object
       * @param {ununifi.nftbackedloan.Msg.PayRemainderCallback} callback Node-style callback called with the error, if any, and MsgPayRemainderResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.payRemainder = function payRemainder(request, callback) {
          return this.rpcCall(
            payRemainder,
            $root.ununifi.nftbackedloan.MsgPayRemainder,
            $root.ununifi.nftbackedloan.MsgPayRemainderResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PayRemainder' },
      );

      /**
       * Calls PayRemainder.
       * @function payRemainder
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgPayRemainder} request MsgPayRemainder message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgPayRemainderResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#borrow}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef BorrowCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgBorrowResponse} [response] MsgBorrowResponse
       */

      /**
       * Calls Borrow.
       * @function borrow
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgBorrow} request MsgBorrow message or plain object
       * @param {ununifi.nftbackedloan.Msg.BorrowCallback} callback Node-style callback called with the error, if any, and MsgBorrowResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.borrow = function borrow(request, callback) {
          return this.rpcCall(
            borrow,
            $root.ununifi.nftbackedloan.MsgBorrow,
            $root.ununifi.nftbackedloan.MsgBorrowResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Borrow' },
      );

      /**
       * Calls Borrow.
       * @function borrow
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgBorrow} request MsgBorrow message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgBorrowResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Msg#repay}.
       * @memberof ununifi.nftbackedloan.Msg
       * @typedef RepayCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.MsgRepayResponse} [response] MsgRepayResponse
       */

      /**
       * Calls Repay.
       * @function repay
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgRepay} request MsgRepay message or plain object
       * @param {ununifi.nftbackedloan.Msg.RepayCallback} callback Node-style callback called with the error, if any, and MsgRepayResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.repay = function repay(request, callback) {
          return this.rpcCall(repay, $root.ununifi.nftbackedloan.MsgRepay, $root.ununifi.nftbackedloan.MsgRepayResponse, request, callback);
        }),
        'name',
        { value: 'Repay' },
      );

      /**
       * Calls Repay.
       * @function repay
       * @memberof ununifi.nftbackedloan.Msg
       * @instance
       * @param {ununifi.nftbackedloan.IMsgRepay} request MsgRepay message or plain object
       * @returns {Promise<ununifi.nftbackedloan.MsgRepayResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    nftbackedloan.MsgListNft = (function () {
      /**
       * Properties of a MsgListNft.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgListNft
       * @property {string|null} [sender] MsgListNft sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgListNft nft_id
       * @property {string|null} [bid_denom] MsgListNft bid_denom
       * @property {string|null} [min_deposit_rate] MsgListNft min_deposit_rate
       * @property {google.protobuf.IDuration|null} [min_bid_period] MsgListNft min_bid_period
       */

      /**
       * Constructs a new MsgListNft.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgListNft.
       * @implements IMsgListNft
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgListNft=} [properties] Properties to set
       */
      function MsgListNft(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgListNft sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @instance
       */
      MsgListNft.prototype.sender = '';

      /**
       * MsgListNft nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @instance
       */
      MsgListNft.prototype.nft_id = null;

      /**
       * MsgListNft bid_denom.
       * @member {string} bid_denom
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @instance
       */
      MsgListNft.prototype.bid_denom = '';

      /**
       * MsgListNft min_deposit_rate.
       * @member {string} min_deposit_rate
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @instance
       */
      MsgListNft.prototype.min_deposit_rate = '';

      /**
       * MsgListNft min_bid_period.
       * @member {google.protobuf.IDuration|null|undefined} min_bid_period
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @instance
       */
      MsgListNft.prototype.min_bid_period = null;

      /**
       * Encodes the specified MsgListNft message. Does not implicitly {@link ununifi.nftbackedloan.MsgListNft.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @static
       * @param {ununifi.nftbackedloan.IMsgListNft} message MsgListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNft.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.bid_denom != null && Object.hasOwnProperty.call(message, 'bid_denom'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.bid_denom);
        if (message.min_deposit_rate != null && Object.hasOwnProperty.call(message, 'min_deposit_rate'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.min_deposit_rate);
        if (message.min_bid_period != null && Object.hasOwnProperty.call(message, 'min_bid_period'))
          $root.google.protobuf.Duration.encode(message.min_bid_period, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgListNft message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgListNft.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @static
       * @param {ununifi.nftbackedloan.IMsgListNft} message MsgListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNft.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgListNft message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgListNft} MsgListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgListNft();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            case 3:
              message.bid_denom = reader.string();
              break;
            case 4:
              message.min_deposit_rate = reader.string();
              break;
            case 5:
              message.min_bid_period = $root.google.protobuf.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgListNft message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgListNft} MsgListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNft.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgListNft message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgListNft.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.bid_denom != null && message.hasOwnProperty('bid_denom'))
          if (!$util.isString(message.bid_denom)) return 'bid_denom: string expected';
        if (message.min_deposit_rate != null && message.hasOwnProperty('min_deposit_rate'))
          if (!$util.isString(message.min_deposit_rate)) return 'min_deposit_rate: string expected';
        if (message.min_bid_period != null && message.hasOwnProperty('min_bid_period')) {
          let error = $root.google.protobuf.Duration.verify(message.min_bid_period);
          if (error) return 'min_bid_period.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgListNft message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgListNft} MsgListNft
       */
      MsgListNft.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgListNft) return object;
        let message = new $root.ununifi.nftbackedloan.MsgListNft();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgListNft.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        if (object.bid_denom != null) message.bid_denom = String(object.bid_denom);
        if (object.min_deposit_rate != null) message.min_deposit_rate = String(object.min_deposit_rate);
        if (object.min_bid_period != null) {
          if (typeof object.min_bid_period !== 'object')
            throw TypeError('.ununifi.nftbackedloan.MsgListNft.min_bid_period: object expected');
          message.min_bid_period = $root.google.protobuf.Duration.fromObject(object.min_bid_period);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgListNft message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @static
       * @param {ununifi.nftbackedloan.MsgListNft} message MsgListNft
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgListNft.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
          object.bid_denom = '';
          object.min_deposit_rate = '';
          object.min_bid_period = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        if (message.bid_denom != null && message.hasOwnProperty('bid_denom')) object.bid_denom = message.bid_denom;
        if (message.min_deposit_rate != null && message.hasOwnProperty('min_deposit_rate'))
          object.min_deposit_rate = message.min_deposit_rate;
        if (message.min_bid_period != null && message.hasOwnProperty('min_bid_period'))
          object.min_bid_period = $root.google.protobuf.Duration.toObject(message.min_bid_period, options);
        return object;
      };

      /**
       * Converts this MsgListNft to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgListNft
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgListNft.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgListNft;
    })();

    nftbackedloan.MsgListNftResponse = (function () {
      /**
       * Properties of a MsgListNftResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgListNftResponse
       */

      /**
       * Constructs a new MsgListNftResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgListNftResponse.
       * @implements IMsgListNftResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgListNftResponse=} [properties] Properties to set
       */
      function MsgListNftResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgListNftResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgListNftResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNftResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgListNftResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgListNftResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgListNftResponse} message MsgListNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgListNftResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgListNftResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgListNftResponse} MsgListNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNftResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgListNftResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgListNftResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgListNftResponse} MsgListNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgListNftResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgListNftResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgListNftResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgListNftResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgListNftResponse} MsgListNftResponse
       */
      MsgListNftResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgListNftResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgListNftResponse();
      };

      /**
       * Creates a plain object from a MsgListNftResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgListNftResponse} message MsgListNftResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgListNftResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgListNftResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgListNftResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgListNftResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgListNftResponse;
    })();

    nftbackedloan.MsgCancelListing = (function () {
      /**
       * Properties of a MsgCancelListing.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgCancelListing
       * @property {string|null} [sender] MsgCancelListing sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgCancelListing nft_id
       */

      /**
       * Constructs a new MsgCancelListing.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgCancelListing.
       * @implements IMsgCancelListing
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgCancelListing=} [properties] Properties to set
       */
      function MsgCancelListing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCancelListing sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @instance
       */
      MsgCancelListing.prototype.sender = '';

      /**
       * MsgCancelListing nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @instance
       */
      MsgCancelListing.prototype.nft_id = null;

      /**
       * Encodes the specified MsgCancelListing message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelListing} message MsgCancelListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelListing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelListing} message MsgCancelListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelListing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgCancelListing} MsgCancelListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgCancelListing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelListing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgCancelListing} MsgCancelListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelListing message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelListing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgCancelListing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgCancelListing} MsgCancelListing
       */
      MsgCancelListing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgCancelListing) return object;
        let message = new $root.ununifi.nftbackedloan.MsgCancelListing();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgCancelListing.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgCancelListing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @static
       * @param {ununifi.nftbackedloan.MsgCancelListing} message MsgCancelListing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelListing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgCancelListing to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgCancelListing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelListing;
    })();

    nftbackedloan.MsgCancelListingResponse = (function () {
      /**
       * Properties of a MsgCancelListingResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgCancelListingResponse
       */

      /**
       * Constructs a new MsgCancelListingResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgCancelListingResponse.
       * @implements IMsgCancelListingResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgCancelListingResponse=} [properties] Properties to set
       */
      function MsgCancelListingResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgCancelListingResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListingResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelListingResponse} message MsgCancelListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelListingResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelListingResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelListingResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelListingResponse} message MsgCancelListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelListingResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgCancelListingResponse} MsgCancelListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelListingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgCancelListingResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelListingResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgCancelListingResponse} MsgCancelListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelListingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelListingResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelListingResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgCancelListingResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgCancelListingResponse} MsgCancelListingResponse
       */
      MsgCancelListingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgCancelListingResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgCancelListingResponse();
      };

      /**
       * Creates a plain object from a MsgCancelListingResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgCancelListingResponse} message MsgCancelListingResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelListingResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCancelListingResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgCancelListingResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelListingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelListingResponse;
    })();

    nftbackedloan.MsgPlaceBid = (function () {
      /**
       * Properties of a MsgPlaceBid.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgPlaceBid
       * @property {string|null} [sender] MsgPlaceBid sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgPlaceBid nft_id
       * @property {cosmos.base.v1beta1.ICoin|null} [price] MsgPlaceBid price
       * @property {google.protobuf.ITimestamp|null} [expiry] MsgPlaceBid expiry
       * @property {string|null} [interest_rate] MsgPlaceBid interest_rate
       * @property {boolean|null} [automatic_payment] MsgPlaceBid automatic_payment
       * @property {cosmos.base.v1beta1.ICoin|null} [deposit] MsgPlaceBid deposit
       */

      /**
       * Constructs a new MsgPlaceBid.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgPlaceBid.
       * @implements IMsgPlaceBid
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgPlaceBid=} [properties] Properties to set
       */
      function MsgPlaceBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgPlaceBid sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.sender = '';

      /**
       * MsgPlaceBid nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.nft_id = null;

      /**
       * MsgPlaceBid price.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} price
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.price = null;

      /**
       * MsgPlaceBid expiry.
       * @member {google.protobuf.ITimestamp|null|undefined} expiry
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.expiry = null;

      /**
       * MsgPlaceBid interest_rate.
       * @member {string} interest_rate
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.interest_rate = '';

      /**
       * MsgPlaceBid automatic_payment.
       * @member {boolean} automatic_payment
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.automatic_payment = false;

      /**
       * MsgPlaceBid deposit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       */
      MsgPlaceBid.prototype.deposit = null;

      /**
       * Encodes the specified MsgPlaceBid message. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @static
       * @param {ununifi.nftbackedloan.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          $root.cosmos.base.v1beta1.Coin.encode(message.price, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
          $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.interest_rate != null && Object.hasOwnProperty.call(message, 'interest_rate'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.interest_rate);
        if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.automatic_payment);
        if (message.deposit != null && Object.hasOwnProperty.call(message, 'deposit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.deposit, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @static
       * @param {ununifi.nftbackedloan.IMsgPlaceBid} message MsgPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPlaceBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgPlaceBid} MsgPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgPlaceBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            case 3:
              message.price = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.interest_rate = reader.string();
              break;
            case 6:
              message.automatic_payment = reader.bool();
              break;
            case 7:
              message.deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPlaceBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgPlaceBid} MsgPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPlaceBid message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPlaceBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.price != null && message.hasOwnProperty('price')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.price);
          if (error) return 'price.' + error;
        }
        if (message.expiry != null && message.hasOwnProperty('expiry')) {
          let error = $root.google.protobuf.Timestamp.verify(message.expiry);
          if (error) return 'expiry.' + error;
        }
        if (message.interest_rate != null && message.hasOwnProperty('interest_rate'))
          if (!$util.isString(message.interest_rate)) return 'interest_rate: string expected';
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
        if (message.deposit != null && message.hasOwnProperty('deposit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit);
          if (error) return 'deposit.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgPlaceBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgPlaceBid} MsgPlaceBid
       */
      MsgPlaceBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgPlaceBid) return object;
        let message = new $root.ununifi.nftbackedloan.MsgPlaceBid();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgPlaceBid.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        if (object.price != null) {
          if (typeof object.price !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgPlaceBid.price: object expected');
          message.price = $root.cosmos.base.v1beta1.Coin.fromObject(object.price);
        }
        if (object.expiry != null) {
          if (typeof object.expiry !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgPlaceBid.expiry: object expected');
          message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
        }
        if (object.interest_rate != null) message.interest_rate = String(object.interest_rate);
        if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
        if (object.deposit != null) {
          if (typeof object.deposit !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgPlaceBid.deposit: object expected');
          message.deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgPlaceBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @static
       * @param {ununifi.nftbackedloan.MsgPlaceBid} message MsgPlaceBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPlaceBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
          object.price = null;
          object.expiry = null;
          object.interest_rate = '';
          object.automatic_payment = false;
          object.deposit = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        if (message.price != null && message.hasOwnProperty('price'))
          object.price = $root.cosmos.base.v1beta1.Coin.toObject(message.price, options);
        if (message.expiry != null && message.hasOwnProperty('expiry'))
          object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
        if (message.interest_rate != null && message.hasOwnProperty('interest_rate')) object.interest_rate = message.interest_rate;
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          object.automatic_payment = message.automatic_payment;
        if (message.deposit != null && message.hasOwnProperty('deposit'))
          object.deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit, options);
        return object;
      };

      /**
       * Converts this MsgPlaceBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgPlaceBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPlaceBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPlaceBid;
    })();

    nftbackedloan.MsgPlaceBidResponse = (function () {
      /**
       * Properties of a MsgPlaceBidResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgPlaceBidResponse
       */

      /**
       * Constructs a new MsgPlaceBidResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgPlaceBidResponse.
       * @implements IMsgPlaceBidResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgPlaceBidResponse=} [properties] Properties to set
       */
      function MsgPlaceBidResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgPlaceBidResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBidResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBidResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgPlaceBidResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPlaceBidResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgPlaceBidResponse} message MsgPlaceBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPlaceBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPlaceBidResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgPlaceBidResponse} MsgPlaceBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBidResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgPlaceBidResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPlaceBidResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgPlaceBidResponse} MsgPlaceBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPlaceBidResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPlaceBidResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPlaceBidResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgPlaceBidResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgPlaceBidResponse} MsgPlaceBidResponse
       */
      MsgPlaceBidResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgPlaceBidResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgPlaceBidResponse();
      };

      /**
       * Creates a plain object from a MsgPlaceBidResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgPlaceBidResponse} message MsgPlaceBidResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPlaceBidResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgPlaceBidResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgPlaceBidResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPlaceBidResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPlaceBidResponse;
    })();

    nftbackedloan.MsgCancelBid = (function () {
      /**
       * Properties of a MsgCancelBid.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgCancelBid
       * @property {string|null} [sender] MsgCancelBid sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgCancelBid nft_id
       */

      /**
       * Constructs a new MsgCancelBid.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgCancelBid.
       * @implements IMsgCancelBid
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgCancelBid=} [properties] Properties to set
       */
      function MsgCancelBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCancelBid sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @instance
       */
      MsgCancelBid.prototype.sender = '';

      /**
       * MsgCancelBid nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @instance
       */
      MsgCancelBid.prototype.nft_id = null;

      /**
       * Encodes the specified MsgCancelBid message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelBid} message MsgCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelBid} message MsgCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgCancelBid} MsgCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgCancelBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgCancelBid} MsgCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelBid message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgCancelBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgCancelBid} MsgCancelBid
       */
      MsgCancelBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgCancelBid) return object;
        let message = new $root.ununifi.nftbackedloan.MsgCancelBid();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgCancelBid.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgCancelBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @static
       * @param {ununifi.nftbackedloan.MsgCancelBid} message MsgCancelBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgCancelBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgCancelBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelBid;
    })();

    nftbackedloan.MsgCancelBidResponse = (function () {
      /**
       * Properties of a MsgCancelBidResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgCancelBidResponse
       */

      /**
       * Constructs a new MsgCancelBidResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgCancelBidResponse.
       * @implements IMsgCancelBidResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgCancelBidResponse=} [properties] Properties to set
       */
      function MsgCancelBidResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgCancelBidResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBidResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBidResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCancelBidResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgCancelBidResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgCancelBidResponse} message MsgCancelBidResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCancelBidResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCancelBidResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgCancelBidResponse} MsgCancelBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBidResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgCancelBidResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCancelBidResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgCancelBidResponse} MsgCancelBidResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCancelBidResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCancelBidResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCancelBidResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgCancelBidResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgCancelBidResponse} MsgCancelBidResponse
       */
      MsgCancelBidResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgCancelBidResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgCancelBidResponse();
      };

      /**
       * Creates a plain object from a MsgCancelBidResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgCancelBidResponse} message MsgCancelBidResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCancelBidResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCancelBidResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgCancelBidResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCancelBidResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCancelBidResponse;
    })();

    nftbackedloan.MsgEndNftListing = (function () {
      /**
       * Properties of a MsgEndNftListing.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgEndNftListing
       * @property {string|null} [sender] MsgEndNftListing sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgEndNftListing nft_id
       */

      /**
       * Constructs a new MsgEndNftListing.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgEndNftListing.
       * @implements IMsgEndNftListing
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgEndNftListing=} [properties] Properties to set
       */
      function MsgEndNftListing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgEndNftListing sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @instance
       */
      MsgEndNftListing.prototype.sender = '';

      /**
       * MsgEndNftListing nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @instance
       */
      MsgEndNftListing.prototype.nft_id = null;

      /**
       * Encodes the specified MsgEndNftListing message. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @static
       * @param {ununifi.nftbackedloan.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgEndNftListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @static
       * @param {ununifi.nftbackedloan.IMsgEndNftListing} message MsgEndNftListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgEndNftListing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgEndNftListing} MsgEndNftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgEndNftListing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgEndNftListing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgEndNftListing} MsgEndNftListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgEndNftListing message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgEndNftListing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgEndNftListing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgEndNftListing} MsgEndNftListing
       */
      MsgEndNftListing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgEndNftListing) return object;
        let message = new $root.ununifi.nftbackedloan.MsgEndNftListing();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgEndNftListing.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgEndNftListing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @static
       * @param {ununifi.nftbackedloan.MsgEndNftListing} message MsgEndNftListing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgEndNftListing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgEndNftListing to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgEndNftListing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgEndNftListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgEndNftListing;
    })();

    nftbackedloan.MsgEndNftListingResponse = (function () {
      /**
       * Properties of a MsgEndNftListingResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgEndNftListingResponse
       */

      /**
       * Constructs a new MsgEndNftListingResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgEndNftListingResponse.
       * @implements IMsgEndNftListingResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgEndNftListingResponse=} [properties] Properties to set
       */
      function MsgEndNftListingResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgEndNftListingResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListingResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListingResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgEndNftListingResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgEndNftListingResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgEndNftListingResponse} message MsgEndNftListingResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgEndNftListingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgEndNftListingResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgEndNftListingResponse} MsgEndNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgEndNftListingResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgEndNftListingResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgEndNftListingResponse} MsgEndNftListingResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgEndNftListingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgEndNftListingResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgEndNftListingResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgEndNftListingResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgEndNftListingResponse} MsgEndNftListingResponse
       */
      MsgEndNftListingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgEndNftListingResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgEndNftListingResponse();
      };

      /**
       * Creates a plain object from a MsgEndNftListingResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgEndNftListingResponse} message MsgEndNftListingResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgEndNftListingResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgEndNftListingResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgEndNftListingResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgEndNftListingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgEndNftListingResponse;
    })();

    nftbackedloan.MsgSellingDecision = (function () {
      /**
       * Properties of a MsgSellingDecision.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgSellingDecision
       * @property {string|null} [sender] MsgSellingDecision sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgSellingDecision nft_id
       */

      /**
       * Constructs a new MsgSellingDecision.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgSellingDecision.
       * @implements IMsgSellingDecision
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgSellingDecision=} [properties] Properties to set
       */
      function MsgSellingDecision(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSellingDecision sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @instance
       */
      MsgSellingDecision.prototype.sender = '';

      /**
       * MsgSellingDecision nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @instance
       */
      MsgSellingDecision.prototype.nft_id = null;

      /**
       * Encodes the specified MsgSellingDecision message. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecision.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @static
       * @param {ununifi.nftbackedloan.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecision.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecision.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @static
       * @param {ununifi.nftbackedloan.IMsgSellingDecision} message MsgSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSellingDecision message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgSellingDecision} MsgSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecision.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgSellingDecision();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSellingDecision message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgSellingDecision} MsgSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecision.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSellingDecision message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSellingDecision.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgSellingDecision message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgSellingDecision} MsgSellingDecision
       */
      MsgSellingDecision.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgSellingDecision) return object;
        let message = new $root.ununifi.nftbackedloan.MsgSellingDecision();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgSellingDecision.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgSellingDecision message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @static
       * @param {ununifi.nftbackedloan.MsgSellingDecision} message MsgSellingDecision
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSellingDecision.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgSellingDecision to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgSellingDecision
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSellingDecision.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSellingDecision;
    })();

    nftbackedloan.MsgSellingDecisionResponse = (function () {
      /**
       * Properties of a MsgSellingDecisionResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgSellingDecisionResponse
       */

      /**
       * Constructs a new MsgSellingDecisionResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgSellingDecisionResponse.
       * @implements IMsgSellingDecisionResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgSellingDecisionResponse=} [properties] Properties to set
       */
      function MsgSellingDecisionResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgSellingDecisionResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecisionResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecisionResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSellingDecisionResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgSellingDecisionResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgSellingDecisionResponse} message MsgSellingDecisionResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSellingDecisionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgSellingDecisionResponse} MsgSellingDecisionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecisionResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgSellingDecisionResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSellingDecisionResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgSellingDecisionResponse} MsgSellingDecisionResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSellingDecisionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSellingDecisionResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSellingDecisionResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgSellingDecisionResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgSellingDecisionResponse} MsgSellingDecisionResponse
       */
      MsgSellingDecisionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgSellingDecisionResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgSellingDecisionResponse();
      };

      /**
       * Creates a plain object from a MsgSellingDecisionResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgSellingDecisionResponse} message MsgSellingDecisionResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSellingDecisionResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSellingDecisionResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgSellingDecisionResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSellingDecisionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSellingDecisionResponse;
    })();

    nftbackedloan.MsgPayRemainder = (function () {
      /**
       * Properties of a MsgPayRemainder.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgPayRemainder
       * @property {string|null} [sender] MsgPayRemainder sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgPayRemainder nft_id
       */

      /**
       * Constructs a new MsgPayRemainder.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgPayRemainder.
       * @implements IMsgPayRemainder
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgPayRemainder=} [properties] Properties to set
       */
      function MsgPayRemainder(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgPayRemainder sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @instance
       */
      MsgPayRemainder.prototype.sender = '';

      /**
       * MsgPayRemainder nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @instance
       */
      MsgPayRemainder.prototype.nft_id = null;

      /**
       * Encodes the specified MsgPayRemainder message. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainder.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @static
       * @param {ununifi.nftbackedloan.IMsgPayRemainder} message MsgPayRemainder message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayRemainder.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgPayRemainder message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainder.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @static
       * @param {ununifi.nftbackedloan.IMsgPayRemainder} message MsgPayRemainder message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayRemainder.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPayRemainder message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgPayRemainder} MsgPayRemainder
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayRemainder.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgPayRemainder();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPayRemainder message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgPayRemainder} MsgPayRemainder
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayRemainder.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPayRemainder message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPayRemainder.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgPayRemainder message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgPayRemainder} MsgPayRemainder
       */
      MsgPayRemainder.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgPayRemainder) return object;
        let message = new $root.ununifi.nftbackedloan.MsgPayRemainder();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgPayRemainder.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgPayRemainder message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @static
       * @param {ununifi.nftbackedloan.MsgPayRemainder} message MsgPayRemainder
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPayRemainder.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        return object;
      };

      /**
       * Converts this MsgPayRemainder to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgPayRemainder
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPayRemainder.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPayRemainder;
    })();

    nftbackedloan.MsgPayRemainderResponse = (function () {
      /**
       * Properties of a MsgPayRemainderResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgPayRemainderResponse
       */

      /**
       * Constructs a new MsgPayRemainderResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgPayRemainderResponse.
       * @implements IMsgPayRemainderResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgPayRemainderResponse=} [properties] Properties to set
       */
      function MsgPayRemainderResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgPayRemainderResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainderResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgPayRemainderResponse} message MsgPayRemainderResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayRemainderResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgPayRemainderResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgPayRemainderResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgPayRemainderResponse} message MsgPayRemainderResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPayRemainderResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPayRemainderResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgPayRemainderResponse} MsgPayRemainderResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayRemainderResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgPayRemainderResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPayRemainderResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgPayRemainderResponse} MsgPayRemainderResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPayRemainderResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPayRemainderResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPayRemainderResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgPayRemainderResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgPayRemainderResponse} MsgPayRemainderResponse
       */
      MsgPayRemainderResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgPayRemainderResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgPayRemainderResponse();
      };

      /**
       * Creates a plain object from a MsgPayRemainderResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgPayRemainderResponse} message MsgPayRemainderResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPayRemainderResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgPayRemainderResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgPayRemainderResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPayRemainderResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPayRemainderResponse;
    })();

    nftbackedloan.BorrowBid = (function () {
      /**
       * Properties of a BorrowBid.
       * @memberof ununifi.nftbackedloan
       * @interface IBorrowBid
       * @property {string|null} [bidder] BorrowBid bidder
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] BorrowBid amount
       */

      /**
       * Constructs a new BorrowBid.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a BorrowBid.
       * @implements IBorrowBid
       * @constructor
       * @param {ununifi.nftbackedloan.IBorrowBid=} [properties] Properties to set
       */
      function BorrowBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * BorrowBid bidder.
       * @member {string} bidder
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @instance
       */
      BorrowBid.prototype.bidder = '';

      /**
       * BorrowBid amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @instance
       */
      BorrowBid.prototype.amount = null;

      /**
       * Encodes the specified BorrowBid message. Does not implicitly {@link ununifi.nftbackedloan.BorrowBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @static
       * @param {ununifi.nftbackedloan.IBorrowBid} message BorrowBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BorrowBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified BorrowBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.BorrowBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @static
       * @param {ununifi.nftbackedloan.IBorrowBid} message BorrowBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BorrowBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BorrowBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.BorrowBid} BorrowBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BorrowBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.BorrowBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            case 2:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a BorrowBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.BorrowBid} BorrowBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BorrowBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BorrowBid message.
       * @function verify
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BorrowBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a BorrowBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.BorrowBid} BorrowBid
       */
      BorrowBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.BorrowBid) return object;
        let message = new $root.ununifi.nftbackedloan.BorrowBid();
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftbackedloan.BorrowBid.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a BorrowBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @static
       * @param {ununifi.nftbackedloan.BorrowBid} message BorrowBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BorrowBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.bidder = '';
          object.amount = null;
        }
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this BorrowBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.BorrowBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BorrowBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return BorrowBid;
    })();

    nftbackedloan.MsgBorrow = (function () {
      /**
       * Properties of a MsgBorrow.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgBorrow
       * @property {string|null} [sender] MsgBorrow sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgBorrow nft_id
       * @property {Array.<ununifi.nftbackedloan.IBorrowBid>|null} [borrow_bids] MsgBorrow borrow_bids
       */

      /**
       * Constructs a new MsgBorrow.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgBorrow.
       * @implements IMsgBorrow
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgBorrow=} [properties] Properties to set
       */
      function MsgBorrow(properties) {
        this.borrow_bids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgBorrow sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @instance
       */
      MsgBorrow.prototype.sender = '';

      /**
       * MsgBorrow nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @instance
       */
      MsgBorrow.prototype.nft_id = null;

      /**
       * MsgBorrow borrow_bids.
       * @member {Array.<ununifi.nftbackedloan.IBorrowBid>} borrow_bids
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @instance
       */
      MsgBorrow.prototype.borrow_bids = $util.emptyArray;

      /**
       * Encodes the specified MsgBorrow message. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrow.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @static
       * @param {ununifi.nftbackedloan.IMsgBorrow} message MsgBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrow.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.borrow_bids != null && message.borrow_bids.length)
          for (let i = 0; i < message.borrow_bids.length; ++i)
            $root.ununifi.nftbackedloan.BorrowBid.encode(message.borrow_bids[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgBorrow message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrow.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @static
       * @param {ununifi.nftbackedloan.IMsgBorrow} message MsgBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrow.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBorrow message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgBorrow} MsgBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrow.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgBorrow();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.borrow_bids && message.borrow_bids.length)) message.borrow_bids = [];
              message.borrow_bids.push($root.ununifi.nftbackedloan.BorrowBid.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBorrow message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgBorrow} MsgBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrow.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBorrow message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBorrow.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.borrow_bids != null && message.hasOwnProperty('borrow_bids')) {
          if (!Array.isArray(message.borrow_bids)) return 'borrow_bids: array expected';
          for (let i = 0; i < message.borrow_bids.length; ++i) {
            let error = $root.ununifi.nftbackedloan.BorrowBid.verify(message.borrow_bids[i]);
            if (error) return 'borrow_bids.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgBorrow message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgBorrow} MsgBorrow
       */
      MsgBorrow.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgBorrow) return object;
        let message = new $root.ununifi.nftbackedloan.MsgBorrow();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgBorrow.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        if (object.borrow_bids) {
          if (!Array.isArray(object.borrow_bids)) throw TypeError('.ununifi.nftbackedloan.MsgBorrow.borrow_bids: array expected');
          message.borrow_bids = [];
          for (let i = 0; i < object.borrow_bids.length; ++i) {
            if (typeof object.borrow_bids[i] !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgBorrow.borrow_bids: object expected');
            message.borrow_bids[i] = $root.ununifi.nftbackedloan.BorrowBid.fromObject(object.borrow_bids[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgBorrow message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @static
       * @param {ununifi.nftbackedloan.MsgBorrow} message MsgBorrow
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBorrow.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.borrow_bids = [];
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        if (message.borrow_bids && message.borrow_bids.length) {
          object.borrow_bids = [];
          for (let j = 0; j < message.borrow_bids.length; ++j)
            object.borrow_bids[j] = $root.ununifi.nftbackedloan.BorrowBid.toObject(message.borrow_bids[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgBorrow to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgBorrow
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBorrow.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBorrow;
    })();

    nftbackedloan.MsgBorrowResponse = (function () {
      /**
       * Properties of a MsgBorrowResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgBorrowResponse
       */

      /**
       * Constructs a new MsgBorrowResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgBorrowResponse.
       * @implements IMsgBorrowResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgBorrowResponse=} [properties] Properties to set
       */
      function MsgBorrowResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgBorrowResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrowResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrowResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgBorrowResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgBorrowResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgBorrowResponse} message MsgBorrowResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBorrowResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBorrowResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgBorrowResponse} MsgBorrowResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrowResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgBorrowResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBorrowResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgBorrowResponse} MsgBorrowResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBorrowResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBorrowResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBorrowResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgBorrowResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgBorrowResponse} MsgBorrowResponse
       */
      MsgBorrowResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgBorrowResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgBorrowResponse();
      };

      /**
       * Creates a plain object from a MsgBorrowResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgBorrowResponse} message MsgBorrowResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBorrowResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgBorrowResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgBorrowResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBorrowResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBorrowResponse;
    })();

    nftbackedloan.MsgRepay = (function () {
      /**
       * Properties of a MsgRepay.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgRepay
       * @property {string|null} [sender] MsgRepay sender
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] MsgRepay nft_id
       * @property {Array.<ununifi.nftbackedloan.IBorrowBid>|null} [repay_bids] MsgRepay repay_bids
       */

      /**
       * Constructs a new MsgRepay.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgRepay.
       * @implements IMsgRepay
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgRepay=} [properties] Properties to set
       */
      function MsgRepay(properties) {
        this.repay_bids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRepay sender.
       * @member {string} sender
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @instance
       */
      MsgRepay.prototype.sender = '';

      /**
       * MsgRepay nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @instance
       */
      MsgRepay.prototype.nft_id = null;

      /**
       * MsgRepay repay_bids.
       * @member {Array.<ununifi.nftbackedloan.IBorrowBid>} repay_bids
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @instance
       */
      MsgRepay.prototype.repay_bids = $util.emptyArray;

      /**
       * Encodes the specified MsgRepay message. Does not implicitly {@link ununifi.nftbackedloan.MsgRepay.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @static
       * @param {ununifi.nftbackedloan.IMsgRepay} message MsgRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepay.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.repay_bids != null && message.repay_bids.length)
          for (let i = 0; i < message.repay_bids.length; ++i)
            $root.ununifi.nftbackedloan.BorrowBid.encode(message.repay_bids[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgRepay message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgRepay.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @static
       * @param {ununifi.nftbackedloan.IMsgRepay} message MsgRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepay.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRepay message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgRepay} MsgRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgRepay();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.repay_bids && message.repay_bids.length)) message.repay_bids = [];
              message.repay_bids.push($root.ununifi.nftbackedloan.BorrowBid.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRepay message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgRepay} MsgRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepay.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRepay message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRepay.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.repay_bids != null && message.hasOwnProperty('repay_bids')) {
          if (!Array.isArray(message.repay_bids)) return 'repay_bids: array expected';
          for (let i = 0; i < message.repay_bids.length; ++i) {
            let error = $root.ununifi.nftbackedloan.BorrowBid.verify(message.repay_bids[i]);
            if (error) return 'repay_bids.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgRepay message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgRepay} MsgRepay
       */
      MsgRepay.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgRepay) return object;
        let message = new $root.ununifi.nftbackedloan.MsgRepay();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgRepay.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        if (object.repay_bids) {
          if (!Array.isArray(object.repay_bids)) throw TypeError('.ununifi.nftbackedloan.MsgRepay.repay_bids: array expected');
          message.repay_bids = [];
          for (let i = 0; i < object.repay_bids.length; ++i) {
            if (typeof object.repay_bids[i] !== 'object') throw TypeError('.ununifi.nftbackedloan.MsgRepay.repay_bids: object expected');
            message.repay_bids[i] = $root.ununifi.nftbackedloan.BorrowBid.fromObject(object.repay_bids[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgRepay message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @static
       * @param {ununifi.nftbackedloan.MsgRepay} message MsgRepay
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRepay.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.repay_bids = [];
        if (options.defaults) {
          object.sender = '';
          object.nft_id = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        if (message.repay_bids && message.repay_bids.length) {
          object.repay_bids = [];
          for (let j = 0; j < message.repay_bids.length; ++j)
            object.repay_bids[j] = $root.ununifi.nftbackedloan.BorrowBid.toObject(message.repay_bids[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgRepay to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgRepay
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRepay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRepay;
    })();

    nftbackedloan.MsgRepayResponse = (function () {
      /**
       * Properties of a MsgRepayResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IMsgRepayResponse
       */

      /**
       * Constructs a new MsgRepayResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a MsgRepayResponse.
       * @implements IMsgRepayResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IMsgRepayResponse=} [properties] Properties to set
       */
      function MsgRepayResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRepayResponse message. Does not implicitly {@link ununifi.nftbackedloan.MsgRepayResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRepayResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.MsgRepayResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @static
       * @param {ununifi.nftbackedloan.IMsgRepayResponse} message MsgRepayResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRepayResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRepayResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.MsgRepayResponse} MsgRepayResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.MsgRepayResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRepayResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.MsgRepayResponse} MsgRepayResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRepayResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRepayResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRepayResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRepayResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.MsgRepayResponse} MsgRepayResponse
       */
      MsgRepayResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.MsgRepayResponse) return object;
        return new $root.ununifi.nftbackedloan.MsgRepayResponse();
      };

      /**
       * Creates a plain object from a MsgRepayResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @static
       * @param {ununifi.nftbackedloan.MsgRepayResponse} message MsgRepayResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRepayResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRepayResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.MsgRepayResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRepayResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRepayResponse;
    })();

    /**
     * ListingState enum.
     * @name ununifi.nftbackedloan.ListingState
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} LISTING=1 LISTING value
     * @property {number} BIDDING=2 BIDDING value
     * @property {number} SELLING_DECISION=3 SELLING_DECISION value
     * @property {number} LIQUIDATION=4 LIQUIDATION value
     * @property {number} SUCCESSFUL_BID=5 SUCCESSFUL_BID value
     */
    nftbackedloan.ListingState = (function () {
      const valuesById = {},
        values = Object.create(valuesById);
      values[(valuesById[0] = 'UNKNOWN')] = 0;
      values[(valuesById[1] = 'LISTING')] = 1;
      values[(valuesById[2] = 'BIDDING')] = 2;
      values[(valuesById[3] = 'SELLING_DECISION')] = 3;
      values[(valuesById[4] = 'LIQUIDATION')] = 4;
      values[(valuesById[5] = 'SUCCESSFUL_BID')] = 5;
      return values;
    })();

    nftbackedloan.NftId = (function () {
      /**
       * Properties of a NftId.
       * @memberof ununifi.nftbackedloan
       * @interface INftId
       * @property {string|null} [class_id] NftId class_id
       * @property {string|null} [token_id] NftId token_id
       */

      /**
       * Constructs a new NftId.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a NftId.
       * @implements INftId
       * @constructor
       * @param {ununifi.nftbackedloan.INftId=} [properties] Properties to set
       */
      function NftId(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * NftId class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.NftId
       * @instance
       */
      NftId.prototype.class_id = '';

      /**
       * NftId token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.NftId
       * @instance
       */
      NftId.prototype.token_id = '';

      /**
       * Encodes the specified NftId message. Does not implicitly {@link ununifi.nftbackedloan.NftId.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.NftId
       * @static
       * @param {ununifi.nftbackedloan.INftId} message NftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftId.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified NftId message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.NftId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.NftId
       * @static
       * @param {ununifi.nftbackedloan.INftId} message NftId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a NftId message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.NftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.NftId} NftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.NftId();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a NftId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.NftId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.NftId} NftId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a NftId message.
       * @function verify
       * @memberof ununifi.nftbackedloan.NftId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      NftId.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates a NftId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.NftId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.NftId} NftId
       */
      NftId.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.NftId) return object;
        let message = new $root.ununifi.nftbackedloan.NftId();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from a NftId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.NftId
       * @static
       * @param {ununifi.nftbackedloan.NftId} message NftId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      NftId.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.token_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this NftId to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.NftId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      NftId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return NftId;
    })();

    nftbackedloan.BidId = (function () {
      /**
       * Properties of a BidId.
       * @memberof ununifi.nftbackedloan
       * @interface IBidId
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] BidId nft_id
       * @property {string|null} [bidder] BidId bidder
       */

      /**
       * Constructs a new BidId.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a BidId.
       * @implements IBidId
       * @constructor
       * @param {ununifi.nftbackedloan.IBidId=} [properties] Properties to set
       */
      function BidId(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * BidId nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.BidId
       * @instance
       */
      BidId.prototype.nft_id = null;

      /**
       * BidId bidder.
       * @member {string} bidder
       * @memberof ununifi.nftbackedloan.BidId
       * @instance
       */
      BidId.prototype.bidder = '';

      /**
       * Encodes the specified BidId message. Does not implicitly {@link ununifi.nftbackedloan.BidId.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.BidId
       * @static
       * @param {ununifi.nftbackedloan.IBidId} message BidId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BidId.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bidder);
        return writer;
      };

      /**
       * Encodes the specified BidId message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.BidId.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.BidId
       * @static
       * @param {ununifi.nftbackedloan.IBidId} message BidId message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      BidId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a BidId message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.BidId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.BidId} BidId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BidId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.BidId();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            case 2:
              message.bidder = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a BidId message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.BidId
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.BidId} BidId
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      BidId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a BidId message.
       * @function verify
       * @memberof ununifi.nftbackedloan.BidId
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      BidId.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        return null;
      };

      /**
       * Creates a BidId message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.BidId
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.BidId} BidId
       */
      BidId.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.BidId) return object;
        let message = new $root.ununifi.nftbackedloan.BidId();
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.BidId.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        if (object.bidder != null) message.bidder = String(object.bidder);
        return message;
      };

      /**
       * Creates a plain object from a BidId message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.BidId
       * @static
       * @param {ununifi.nftbackedloan.BidId} message BidId
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      BidId.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.nft_id = null;
          object.bidder = '';
        }
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        return object;
      };

      /**
       * Converts this BidId to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.BidId
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      BidId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return BidId;
    })();

    nftbackedloan.ListedClass = (function () {
      /**
       * Properties of a ListedClass.
       * @memberof ununifi.nftbackedloan
       * @interface IListedClass
       * @property {string|null} [class_id] ListedClass class_id
       * @property {Array.<string>|null} [token_ids] ListedClass token_ids
       */

      /**
       * Constructs a new ListedClass.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a ListedClass.
       * @implements IListedClass
       * @constructor
       * @param {ununifi.nftbackedloan.IListedClass=} [properties] Properties to set
       */
      function ListedClass(properties) {
        this.token_ids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ListedClass class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.ListedClass
       * @instance
       */
      ListedClass.prototype.class_id = '';

      /**
       * ListedClass token_ids.
       * @member {Array.<string>} token_ids
       * @memberof ununifi.nftbackedloan.ListedClass
       * @instance
       */
      ListedClass.prototype.token_ids = $util.emptyArray;

      /**
       * Encodes the specified ListedClass message. Does not implicitly {@link ununifi.nftbackedloan.ListedClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.ListedClass
       * @static
       * @param {ununifi.nftbackedloan.IListedClass} message ListedClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_ids != null && message.token_ids.length)
          for (let i = 0; i < message.token_ids.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_ids[i]);
        return writer;
      };

      /**
       * Encodes the specified ListedClass message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.ListedClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.ListedClass
       * @static
       * @param {ununifi.nftbackedloan.IListedClass} message ListedClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ListedClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.ListedClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.ListedClass} ListedClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.ListedClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              if (!(message.token_ids && message.token_ids.length)) message.token_ids = [];
              message.token_ids.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ListedClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.ListedClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.ListedClass} ListedClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ListedClass message.
       * @function verify
       * @memberof ununifi.nftbackedloan.ListedClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ListedClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_ids != null && message.hasOwnProperty('token_ids')) {
          if (!Array.isArray(message.token_ids)) return 'token_ids: array expected';
          for (let i = 0; i < message.token_ids.length; ++i)
            if (!$util.isString(message.token_ids[i])) return 'token_ids: string[] expected';
        }
        return null;
      };

      /**
       * Creates a ListedClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.ListedClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.ListedClass} ListedClass
       */
      ListedClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.ListedClass) return object;
        let message = new $root.ununifi.nftbackedloan.ListedClass();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_ids) {
          if (!Array.isArray(object.token_ids)) throw TypeError('.ununifi.nftbackedloan.ListedClass.token_ids: array expected');
          message.token_ids = [];
          for (let i = 0; i < object.token_ids.length; ++i) message.token_ids[i] = String(object.token_ids[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a ListedClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.ListedClass
       * @static
       * @param {ununifi.nftbackedloan.ListedClass} message ListedClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ListedClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.token_ids = [];
        if (options.defaults) object.class_id = '';
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_ids && message.token_ids.length) {
          object.token_ids = [];
          for (let j = 0; j < message.token_ids.length; ++j) object.token_ids[j] = message.token_ids[j];
        }
        return object;
      };

      /**
       * Converts this ListedClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.ListedClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ListedClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ListedClass;
    })();

    nftbackedloan.NftInfo = (function () {
      /**
       * Properties of a NftInfo.
       * @memberof ununifi.nftbackedloan
       * @interface INftInfo
       * @property {string|null} [id] NftInfo id
       * @property {string|null} [uri] NftInfo uri
       * @property {string|null} [uri_hash] NftInfo uri_hash
       */

      /**
       * Constructs a new NftInfo.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a NftInfo.
       * @implements INftInfo
       * @constructor
       * @param {ununifi.nftbackedloan.INftInfo=} [properties] Properties to set
       */
      function NftInfo(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * NftInfo id.
       * @member {string} id
       * @memberof ununifi.nftbackedloan.NftInfo
       * @instance
       */
      NftInfo.prototype.id = '';

      /**
       * NftInfo uri.
       * @member {string} uri
       * @memberof ununifi.nftbackedloan.NftInfo
       * @instance
       */
      NftInfo.prototype.uri = '';

      /**
       * NftInfo uri_hash.
       * @member {string} uri_hash
       * @memberof ununifi.nftbackedloan.NftInfo
       * @instance
       */
      NftInfo.prototype.uri_hash = '';

      /**
       * Encodes the specified NftInfo message. Does not implicitly {@link ununifi.nftbackedloan.NftInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.NftInfo
       * @static
       * @param {ununifi.nftbackedloan.INftInfo} message NftInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.uri);
        if (message.uri_hash != null && Object.hasOwnProperty.call(message, 'uri_hash'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.uri_hash);
        return writer;
      };

      /**
       * Encodes the specified NftInfo message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.NftInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.NftInfo
       * @static
       * @param {ununifi.nftbackedloan.INftInfo} message NftInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      NftInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a NftInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.NftInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.NftInfo} NftInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.NftInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.uri = reader.string();
              break;
            case 3:
              message.uri_hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a NftInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.NftInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.NftInfo} NftInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      NftInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a NftInfo message.
       * @function verify
       * @memberof ununifi.nftbackedloan.NftInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      NftInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash'))
          if (!$util.isString(message.uri_hash)) return 'uri_hash: string expected';
        return null;
      };

      /**
       * Creates a NftInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.NftInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.NftInfo} NftInfo
       */
      NftInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.NftInfo) return object;
        let message = new $root.ununifi.nftbackedloan.NftInfo();
        if (object.id != null) message.id = String(object.id);
        if (object.uri != null) message.uri = String(object.uri);
        if (object.uri_hash != null) message.uri_hash = String(object.uri_hash);
        return message;
      };

      /**
       * Creates a plain object from a NftInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.NftInfo
       * @static
       * @param {ununifi.nftbackedloan.NftInfo} message NftInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      NftInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.id = '';
          object.uri = '';
          object.uri_hash = '';
        }
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash')) object.uri_hash = message.uri_hash;
        return object;
      };

      /**
       * Converts this NftInfo to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.NftInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      NftInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return NftInfo;
    })();

    nftbackedloan.Listing = (function () {
      /**
       * Properties of a Listing.
       * @memberof ununifi.nftbackedloan
       * @interface IListing
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] Listing nft_id
       * @property {string|null} [owner] Listing owner
       * @property {ununifi.nftbackedloan.ListingState|null} [state] Listing state
       * @property {string|null} [bid_denom] Listing bid_denom
       * @property {string|null} [min_deposit_rate] Listing min_deposit_rate
       * @property {google.protobuf.IDuration|null} [min_bid_period] Listing min_bid_period
       * @property {google.protobuf.ITimestamp|null} [started_at] Listing started_at
       * @property {google.protobuf.ITimestamp|null} [liquidated_at] Listing liquidated_at
       * @property {google.protobuf.ITimestamp|null} [full_payment_end_at] Listing full_payment_end_at
       * @property {google.protobuf.ITimestamp|null} [successful_bid_end_at] Listing successful_bid_end_at
       * @property {cosmos.base.v1beta1.ICoin|null} [collected_amount] Listing collected_amount
       * @property {boolean|null} [collected_amount_negative] Listing collected_amount_negative
       */

      /**
       * Constructs a new Listing.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Listing.
       * @implements IListing
       * @constructor
       * @param {ununifi.nftbackedloan.IListing=} [properties] Properties to set
       */
      function Listing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Listing nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.nft_id = null;

      /**
       * Listing owner.
       * @member {string} owner
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.owner = '';

      /**
       * Listing state.
       * @member {ununifi.nftbackedloan.ListingState} state
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.state = 0;

      /**
       * Listing bid_denom.
       * @member {string} bid_denom
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.bid_denom = '';

      /**
       * Listing min_deposit_rate.
       * @member {string} min_deposit_rate
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.min_deposit_rate = '';

      /**
       * Listing min_bid_period.
       * @member {google.protobuf.IDuration|null|undefined} min_bid_period
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.min_bid_period = null;

      /**
       * Listing started_at.
       * @member {google.protobuf.ITimestamp|null|undefined} started_at
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.started_at = null;

      /**
       * Listing liquidated_at.
       * @member {google.protobuf.ITimestamp|null|undefined} liquidated_at
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.liquidated_at = null;

      /**
       * Listing full_payment_end_at.
       * @member {google.protobuf.ITimestamp|null|undefined} full_payment_end_at
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.full_payment_end_at = null;

      /**
       * Listing successful_bid_end_at.
       * @member {google.protobuf.ITimestamp|null|undefined} successful_bid_end_at
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.successful_bid_end_at = null;

      /**
       * Listing collected_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} collected_amount
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.collected_amount = null;

      /**
       * Listing collected_amount_negative.
       * @member {boolean} collected_amount_negative
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       */
      Listing.prototype.collected_amount_negative = false;

      /**
       * Encodes the specified Listing message. Does not implicitly {@link ununifi.nftbackedloan.Listing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.Listing
       * @static
       * @param {ununifi.nftbackedloan.IListing} message Listing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Listing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.owner);
        if (message.state != null && Object.hasOwnProperty.call(message, 'state'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.state);
        if (message.bid_denom != null && Object.hasOwnProperty.call(message, 'bid_denom'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.bid_denom);
        if (message.min_deposit_rate != null && Object.hasOwnProperty.call(message, 'min_deposit_rate'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.min_deposit_rate);
        if (message.min_bid_period != null && Object.hasOwnProperty.call(message, 'min_bid_period'))
          $root.google.protobuf.Duration.encode(message.min_bid_period, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
        if (message.started_at != null && Object.hasOwnProperty.call(message, 'started_at'))
          $root.google.protobuf.Timestamp.encode(message.started_at, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.liquidated_at != null && Object.hasOwnProperty.call(message, 'liquidated_at'))
          $root.google.protobuf.Timestamp.encode(message.liquidated_at, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.full_payment_end_at != null && Object.hasOwnProperty.call(message, 'full_payment_end_at'))
          $root.google.protobuf.Timestamp.encode(message.full_payment_end_at, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        if (message.successful_bid_end_at != null && Object.hasOwnProperty.call(message, 'successful_bid_end_at'))
          $root.google.protobuf.Timestamp.encode(message.successful_bid_end_at, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
        if (message.collected_amount != null && Object.hasOwnProperty.call(message, 'collected_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.collected_amount, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
        if (message.collected_amount_negative != null && Object.hasOwnProperty.call(message, 'collected_amount_negative'))
          writer.uint32(/* id 12, wireType 0 =*/ 96).bool(message.collected_amount_negative);
        return writer;
      };

      /**
       * Encodes the specified Listing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Listing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.Listing
       * @static
       * @param {ununifi.nftbackedloan.IListing} message Listing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Listing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Listing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.Listing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.Listing} Listing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Listing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.Listing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            case 2:
              message.owner = reader.string();
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.bid_denom = reader.string();
              break;
            case 5:
              message.min_deposit_rate = reader.string();
              break;
            case 6:
              message.min_bid_period = $root.google.protobuf.Duration.decode(reader, reader.uint32());
              break;
            case 7:
              message.started_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 8:
              message.liquidated_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.full_payment_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.successful_bid_end_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.collected_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 12:
              message.collected_amount_negative = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Listing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.Listing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.Listing} Listing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Listing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Listing message.
       * @function verify
       * @memberof ununifi.nftbackedloan.Listing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Listing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.state != null && message.hasOwnProperty('state'))
          switch (message.state) {
            default:
              return 'state: enum value expected';
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
          }
        if (message.bid_denom != null && message.hasOwnProperty('bid_denom'))
          if (!$util.isString(message.bid_denom)) return 'bid_denom: string expected';
        if (message.min_deposit_rate != null && message.hasOwnProperty('min_deposit_rate'))
          if (!$util.isString(message.min_deposit_rate)) return 'min_deposit_rate: string expected';
        if (message.min_bid_period != null && message.hasOwnProperty('min_bid_period')) {
          let error = $root.google.protobuf.Duration.verify(message.min_bid_period);
          if (error) return 'min_bid_period.' + error;
        }
        if (message.started_at != null && message.hasOwnProperty('started_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.started_at);
          if (error) return 'started_at.' + error;
        }
        if (message.liquidated_at != null && message.hasOwnProperty('liquidated_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.liquidated_at);
          if (error) return 'liquidated_at.' + error;
        }
        if (message.full_payment_end_at != null && message.hasOwnProperty('full_payment_end_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.full_payment_end_at);
          if (error) return 'full_payment_end_at.' + error;
        }
        if (message.successful_bid_end_at != null && message.hasOwnProperty('successful_bid_end_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.successful_bid_end_at);
          if (error) return 'successful_bid_end_at.' + error;
        }
        if (message.collected_amount != null && message.hasOwnProperty('collected_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.collected_amount);
          if (error) return 'collected_amount.' + error;
        }
        if (message.collected_amount_negative != null && message.hasOwnProperty('collected_amount_negative'))
          if (typeof message.collected_amount_negative !== 'boolean') return 'collected_amount_negative: boolean expected';
        return null;
      };

      /**
       * Creates a Listing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.Listing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.Listing} Listing
       */
      Listing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.Listing) return object;
        let message = new $root.ununifi.nftbackedloan.Listing();
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.Listing.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        if (object.owner != null) message.owner = String(object.owner);
        switch (object.state) {
          case 'UNKNOWN':
          case 0:
            message.state = 0;
            break;
          case 'LISTING':
          case 1:
            message.state = 1;
            break;
          case 'BIDDING':
          case 2:
            message.state = 2;
            break;
          case 'SELLING_DECISION':
          case 3:
            message.state = 3;
            break;
          case 'LIQUIDATION':
          case 4:
            message.state = 4;
            break;
          case 'SUCCESSFUL_BID':
          case 5:
            message.state = 5;
            break;
        }
        if (object.bid_denom != null) message.bid_denom = String(object.bid_denom);
        if (object.min_deposit_rate != null) message.min_deposit_rate = String(object.min_deposit_rate);
        if (object.min_bid_period != null) {
          if (typeof object.min_bid_period !== 'object') throw TypeError('.ununifi.nftbackedloan.Listing.min_bid_period: object expected');
          message.min_bid_period = $root.google.protobuf.Duration.fromObject(object.min_bid_period);
        }
        if (object.started_at != null) {
          if (typeof object.started_at !== 'object') throw TypeError('.ununifi.nftbackedloan.Listing.started_at: object expected');
          message.started_at = $root.google.protobuf.Timestamp.fromObject(object.started_at);
        }
        if (object.liquidated_at != null) {
          if (typeof object.liquidated_at !== 'object') throw TypeError('.ununifi.nftbackedloan.Listing.liquidated_at: object expected');
          message.liquidated_at = $root.google.protobuf.Timestamp.fromObject(object.liquidated_at);
        }
        if (object.full_payment_end_at != null) {
          if (typeof object.full_payment_end_at !== 'object')
            throw TypeError('.ununifi.nftbackedloan.Listing.full_payment_end_at: object expected');
          message.full_payment_end_at = $root.google.protobuf.Timestamp.fromObject(object.full_payment_end_at);
        }
        if (object.successful_bid_end_at != null) {
          if (typeof object.successful_bid_end_at !== 'object')
            throw TypeError('.ununifi.nftbackedloan.Listing.successful_bid_end_at: object expected');
          message.successful_bid_end_at = $root.google.protobuf.Timestamp.fromObject(object.successful_bid_end_at);
        }
        if (object.collected_amount != null) {
          if (typeof object.collected_amount !== 'object')
            throw TypeError('.ununifi.nftbackedloan.Listing.collected_amount: object expected');
          message.collected_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.collected_amount);
        }
        if (object.collected_amount_negative != null) message.collected_amount_negative = Boolean(object.collected_amount_negative);
        return message;
      };

      /**
       * Creates a plain object from a Listing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.Listing
       * @static
       * @param {ununifi.nftbackedloan.Listing} message Listing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Listing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.nft_id = null;
          object.owner = '';
          object.state = options.enums === String ? 'UNKNOWN' : 0;
          object.bid_denom = '';
          object.min_deposit_rate = '';
          object.min_bid_period = null;
          object.started_at = null;
          object.liquidated_at = null;
          object.full_payment_end_at = null;
          object.successful_bid_end_at = null;
          object.collected_amount = null;
          object.collected_amount_negative = false;
        }
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.state != null && message.hasOwnProperty('state'))
          object.state = options.enums === String ? $root.ununifi.nftbackedloan.ListingState[message.state] : message.state;
        if (message.bid_denom != null && message.hasOwnProperty('bid_denom')) object.bid_denom = message.bid_denom;
        if (message.min_deposit_rate != null && message.hasOwnProperty('min_deposit_rate'))
          object.min_deposit_rate = message.min_deposit_rate;
        if (message.min_bid_period != null && message.hasOwnProperty('min_bid_period'))
          object.min_bid_period = $root.google.protobuf.Duration.toObject(message.min_bid_period, options);
        if (message.started_at != null && message.hasOwnProperty('started_at'))
          object.started_at = $root.google.protobuf.Timestamp.toObject(message.started_at, options);
        if (message.liquidated_at != null && message.hasOwnProperty('liquidated_at'))
          object.liquidated_at = $root.google.protobuf.Timestamp.toObject(message.liquidated_at, options);
        if (message.full_payment_end_at != null && message.hasOwnProperty('full_payment_end_at'))
          object.full_payment_end_at = $root.google.protobuf.Timestamp.toObject(message.full_payment_end_at, options);
        if (message.successful_bid_end_at != null && message.hasOwnProperty('successful_bid_end_at'))
          object.successful_bid_end_at = $root.google.protobuf.Timestamp.toObject(message.successful_bid_end_at, options);
        if (message.collected_amount != null && message.hasOwnProperty('collected_amount'))
          object.collected_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.collected_amount, options);
        if (message.collected_amount_negative != null && message.hasOwnProperty('collected_amount_negative'))
          object.collected_amount_negative = message.collected_amount_negative;
        return object;
      };

      /**
       * Converts this Listing to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.Listing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Listing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Listing;
    })();

    nftbackedloan.Bid = (function () {
      /**
       * Properties of a Bid.
       * @memberof ununifi.nftbackedloan
       * @interface IBid
       * @property {ununifi.nftbackedloan.IBidId|null} [id] Bid id
       * @property {cosmos.base.v1beta1.ICoin|null} [price] Bid price
       * @property {cosmos.base.v1beta1.ICoin|null} [deposit] Bid deposit
       * @property {cosmos.base.v1beta1.ICoin|null} [paid_amount] Bid paid_amount
       * @property {google.protobuf.ITimestamp|null} [expiry] Bid expiry
       * @property {string|null} [interest_rate] Bid interest_rate
       * @property {boolean|null} [automatic_payment] Bid automatic_payment
       * @property {google.protobuf.ITimestamp|null} [created_at] Bid created_at
       * @property {ununifi.nftbackedloan.ILoan|null} [loan] Bid loan
       */

      /**
       * Constructs a new Bid.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Bid.
       * @implements IBid
       * @constructor
       * @param {ununifi.nftbackedloan.IBid=} [properties] Properties to set
       */
      function Bid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Bid id.
       * @member {ununifi.nftbackedloan.IBidId|null|undefined} id
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.id = null;

      /**
       * Bid price.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} price
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.price = null;

      /**
       * Bid deposit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.deposit = null;

      /**
       * Bid paid_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} paid_amount
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.paid_amount = null;

      /**
       * Bid expiry.
       * @member {google.protobuf.ITimestamp|null|undefined} expiry
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.expiry = null;

      /**
       * Bid interest_rate.
       * @member {string} interest_rate
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.interest_rate = '';

      /**
       * Bid automatic_payment.
       * @member {boolean} automatic_payment
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.automatic_payment = false;

      /**
       * Bid created_at.
       * @member {google.protobuf.ITimestamp|null|undefined} created_at
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.created_at = null;

      /**
       * Bid loan.
       * @member {ununifi.nftbackedloan.ILoan|null|undefined} loan
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       */
      Bid.prototype.loan = null;

      /**
       * Encodes the specified Bid message. Does not implicitly {@link ununifi.nftbackedloan.Bid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.Bid
       * @static
       * @param {ununifi.nftbackedloan.IBid} message Bid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Bid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id'))
          $root.ununifi.nftbackedloan.BidId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          $root.cosmos.base.v1beta1.Coin.encode(message.price, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.deposit != null && Object.hasOwnProperty.call(message, 'deposit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.deposit, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.paid_amount != null && Object.hasOwnProperty.call(message, 'paid_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.paid_amount, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
          $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        if (message.interest_rate != null && Object.hasOwnProperty.call(message, 'interest_rate'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.interest_rate);
        if (message.automatic_payment != null && Object.hasOwnProperty.call(message, 'automatic_payment'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.automatic_payment);
        if (message.created_at != null && Object.hasOwnProperty.call(message, 'created_at'))
          $root.google.protobuf.Timestamp.encode(message.created_at, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.loan != null && Object.hasOwnProperty.call(message, 'loan'))
          $root.ununifi.nftbackedloan.Loan.encode(message.loan, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Bid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Bid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.Bid
       * @static
       * @param {ununifi.nftbackedloan.IBid} message Bid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Bid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Bid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.Bid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.Bid} Bid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Bid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.Bid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = $root.ununifi.nftbackedloan.BidId.decode(reader, reader.uint32());
              break;
            case 2:
              message.price = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.paid_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 5:
              message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.interest_rate = reader.string();
              break;
            case 7:
              message.automatic_payment = reader.bool();
              break;
            case 8:
              message.created_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.loan = $root.ununifi.nftbackedloan.Loan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Bid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.Bid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.Bid} Bid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Bid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Bid message.
       * @function verify
       * @memberof ununifi.nftbackedloan.Bid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Bid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) {
          let error = $root.ununifi.nftbackedloan.BidId.verify(message.id);
          if (error) return 'id.' + error;
        }
        if (message.price != null && message.hasOwnProperty('price')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.price);
          if (error) return 'price.' + error;
        }
        if (message.deposit != null && message.hasOwnProperty('deposit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit);
          if (error) return 'deposit.' + error;
        }
        if (message.paid_amount != null && message.hasOwnProperty('paid_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.paid_amount);
          if (error) return 'paid_amount.' + error;
        }
        if (message.expiry != null && message.hasOwnProperty('expiry')) {
          let error = $root.google.protobuf.Timestamp.verify(message.expiry);
          if (error) return 'expiry.' + error;
        }
        if (message.interest_rate != null && message.hasOwnProperty('interest_rate'))
          if (!$util.isString(message.interest_rate)) return 'interest_rate: string expected';
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          if (typeof message.automatic_payment !== 'boolean') return 'automatic_payment: boolean expected';
        if (message.created_at != null && message.hasOwnProperty('created_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.created_at);
          if (error) return 'created_at.' + error;
        }
        if (message.loan != null && message.hasOwnProperty('loan')) {
          let error = $root.ununifi.nftbackedloan.Loan.verify(message.loan);
          if (error) return 'loan.' + error;
        }
        return null;
      };

      /**
       * Creates a Bid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.Bid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.Bid} Bid
       */
      Bid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.Bid) return object;
        let message = new $root.ununifi.nftbackedloan.Bid();
        if (object.id != null) {
          if (typeof object.id !== 'object') throw TypeError('.ununifi.nftbackedloan.Bid.id: object expected');
          message.id = $root.ununifi.nftbackedloan.BidId.fromObject(object.id);
        }
        if (object.price != null) {
          if (typeof object.price !== 'object') throw TypeError('.ununifi.nftbackedloan.Bid.price: object expected');
          message.price = $root.cosmos.base.v1beta1.Coin.fromObject(object.price);
        }
        if (object.deposit != null) {
          if (typeof object.deposit !== 'object') throw TypeError('.ununifi.nftbackedloan.Bid.deposit: object expected');
          message.deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit);
        }
        if (object.paid_amount != null) {
          if (typeof object.paid_amount !== 'object') throw TypeError('.ununifi.nftbackedloan.Bid.paid_amount: object expected');
          message.paid_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.paid_amount);
        }
        if (object.expiry != null) {
          if (typeof object.expiry !== 'object') throw TypeError('.ununifi.nftbackedloan.Bid.expiry: object expected');
          message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
        }
        if (object.interest_rate != null) message.interest_rate = String(object.interest_rate);
        if (object.automatic_payment != null) message.automatic_payment = Boolean(object.automatic_payment);
        if (object.created_at != null) {
          if (typeof object.created_at !== 'object') throw TypeError('.ununifi.nftbackedloan.Bid.created_at: object expected');
          message.created_at = $root.google.protobuf.Timestamp.fromObject(object.created_at);
        }
        if (object.loan != null) {
          if (typeof object.loan !== 'object') throw TypeError('.ununifi.nftbackedloan.Bid.loan: object expected');
          message.loan = $root.ununifi.nftbackedloan.Loan.fromObject(object.loan);
        }
        return message;
      };

      /**
       * Creates a plain object from a Bid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.Bid
       * @static
       * @param {ununifi.nftbackedloan.Bid} message Bid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Bid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.id = null;
          object.price = null;
          object.deposit = null;
          object.paid_amount = null;
          object.expiry = null;
          object.interest_rate = '';
          object.automatic_payment = false;
          object.created_at = null;
          object.loan = null;
        }
        if (message.id != null && message.hasOwnProperty('id')) object.id = $root.ununifi.nftbackedloan.BidId.toObject(message.id, options);
        if (message.price != null && message.hasOwnProperty('price'))
          object.price = $root.cosmos.base.v1beta1.Coin.toObject(message.price, options);
        if (message.deposit != null && message.hasOwnProperty('deposit'))
          object.deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit, options);
        if (message.paid_amount != null && message.hasOwnProperty('paid_amount'))
          object.paid_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.paid_amount, options);
        if (message.expiry != null && message.hasOwnProperty('expiry'))
          object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
        if (message.interest_rate != null && message.hasOwnProperty('interest_rate')) object.interest_rate = message.interest_rate;
        if (message.automatic_payment != null && message.hasOwnProperty('automatic_payment'))
          object.automatic_payment = message.automatic_payment;
        if (message.created_at != null && message.hasOwnProperty('created_at'))
          object.created_at = $root.google.protobuf.Timestamp.toObject(message.created_at, options);
        if (message.loan != null && message.hasOwnProperty('loan'))
          object.loan = $root.ununifi.nftbackedloan.Loan.toObject(message.loan, options);
        return object;
      };

      /**
       * Converts this Bid to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.Bid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Bid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Bid;
    })();

    nftbackedloan.Loan = (function () {
      /**
       * Properties of a Loan.
       * @memberof ununifi.nftbackedloan
       * @interface ILoan
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] Loan amount
       * @property {google.protobuf.ITimestamp|null} [last_repaid_at] Loan last_repaid_at
       */

      /**
       * Constructs a new Loan.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Loan.
       * @implements ILoan
       * @constructor
       * @param {ununifi.nftbackedloan.ILoan=} [properties] Properties to set
       */
      function Loan(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Loan amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftbackedloan.Loan
       * @instance
       */
      Loan.prototype.amount = null;

      /**
       * Loan last_repaid_at.
       * @member {google.protobuf.ITimestamp|null|undefined} last_repaid_at
       * @memberof ununifi.nftbackedloan.Loan
       * @instance
       */
      Loan.prototype.last_repaid_at = null;

      /**
       * Encodes the specified Loan message. Does not implicitly {@link ununifi.nftbackedloan.Loan.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.Loan
       * @static
       * @param {ununifi.nftbackedloan.ILoan} message Loan message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Loan.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.last_repaid_at != null && Object.hasOwnProperty.call(message, 'last_repaid_at'))
          $root.google.protobuf.Timestamp.encode(message.last_repaid_at, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Loan message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Loan.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.Loan
       * @static
       * @param {ununifi.nftbackedloan.ILoan} message Loan message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Loan.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Loan message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.Loan
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.Loan} Loan
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Loan.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.Loan();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.last_repaid_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Loan message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.Loan
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.Loan} Loan
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Loan.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Loan message.
       * @function verify
       * @memberof ununifi.nftbackedloan.Loan
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Loan.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.last_repaid_at != null && message.hasOwnProperty('last_repaid_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.last_repaid_at);
          if (error) return 'last_repaid_at.' + error;
        }
        return null;
      };

      /**
       * Creates a Loan message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.Loan
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.Loan} Loan
       */
      Loan.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.Loan) return object;
        let message = new $root.ununifi.nftbackedloan.Loan();
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftbackedloan.Loan.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.last_repaid_at != null) {
          if (typeof object.last_repaid_at !== 'object') throw TypeError('.ununifi.nftbackedloan.Loan.last_repaid_at: object expected');
          message.last_repaid_at = $root.google.protobuf.Timestamp.fromObject(object.last_repaid_at);
        }
        return message;
      };

      /**
       * Creates a plain object from a Loan message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.Loan
       * @static
       * @param {ununifi.nftbackedloan.Loan} message Loan
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Loan.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.amount = null;
          object.last_repaid_at = null;
        }
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.last_repaid_at != null && message.hasOwnProperty('last_repaid_at'))
          object.last_repaid_at = $root.google.protobuf.Timestamp.toObject(message.last_repaid_at, options);
        return object;
      };

      /**
       * Converts this Loan to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.Loan
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Loan.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Loan;
    })();

    nftbackedloan.Liquidation = (function () {
      /**
       * Properties of a Liquidation.
       * @memberof ununifi.nftbackedloan
       * @interface ILiquidation
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] Liquidation amount
       * @property {google.protobuf.ITimestamp|null} [liquidation_date] Liquidation liquidation_date
       */

      /**
       * Constructs a new Liquidation.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Liquidation.
       * @implements ILiquidation
       * @constructor
       * @param {ununifi.nftbackedloan.ILiquidation=} [properties] Properties to set
       */
      function Liquidation(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Liquidation amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.nftbackedloan.Liquidation
       * @instance
       */
      Liquidation.prototype.amount = null;

      /**
       * Liquidation liquidation_date.
       * @member {google.protobuf.ITimestamp|null|undefined} liquidation_date
       * @memberof ununifi.nftbackedloan.Liquidation
       * @instance
       */
      Liquidation.prototype.liquidation_date = null;

      /**
       * Encodes the specified Liquidation message. Does not implicitly {@link ununifi.nftbackedloan.Liquidation.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.Liquidation
       * @static
       * @param {ununifi.nftbackedloan.ILiquidation} message Liquidation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Liquidation.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.liquidation_date != null && Object.hasOwnProperty.call(message, 'liquidation_date'))
          $root.google.protobuf.Timestamp.encode(message.liquidation_date, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Liquidation message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Liquidation.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.Liquidation
       * @static
       * @param {ununifi.nftbackedloan.ILiquidation} message Liquidation message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Liquidation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Liquidation message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.Liquidation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.Liquidation} Liquidation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Liquidation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.Liquidation();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.liquidation_date = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Liquidation message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.Liquidation
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.Liquidation} Liquidation
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Liquidation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Liquidation message.
       * @function verify
       * @memberof ununifi.nftbackedloan.Liquidation
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Liquidation.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        if (message.liquidation_date != null && message.hasOwnProperty('liquidation_date')) {
          let error = $root.google.protobuf.Timestamp.verify(message.liquidation_date);
          if (error) return 'liquidation_date.' + error;
        }
        return null;
      };

      /**
       * Creates a Liquidation message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.Liquidation
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.Liquidation} Liquidation
       */
      Liquidation.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.Liquidation) return object;
        let message = new $root.ununifi.nftbackedloan.Liquidation();
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.nftbackedloan.Liquidation.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        if (object.liquidation_date != null) {
          if (typeof object.liquidation_date !== 'object')
            throw TypeError('.ununifi.nftbackedloan.Liquidation.liquidation_date: object expected');
          message.liquidation_date = $root.google.protobuf.Timestamp.fromObject(object.liquidation_date);
        }
        return message;
      };

      /**
       * Creates a plain object from a Liquidation message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.Liquidation
       * @static
       * @param {ununifi.nftbackedloan.Liquidation} message Liquidation
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Liquidation.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.amount = null;
          object.liquidation_date = null;
        }
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        if (message.liquidation_date != null && message.hasOwnProperty('liquidation_date'))
          object.liquidation_date = $root.google.protobuf.Timestamp.toObject(message.liquidation_date, options);
        return object;
      };

      /**
       * Converts this Liquidation to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.Liquidation
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Liquidation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Liquidation;
    })();

    nftbackedloan.Liquidations = (function () {
      /**
       * Properties of a Liquidations.
       * @memberof ununifi.nftbackedloan
       * @interface ILiquidations
       * @property {ununifi.nftbackedloan.ILiquidation|null} [liquidation] Liquidations liquidation
       * @property {Array.<ununifi.nftbackedloan.ILiquidation>|null} [next_liquidation] Liquidations next_liquidation
       */

      /**
       * Constructs a new Liquidations.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Liquidations.
       * @implements ILiquidations
       * @constructor
       * @param {ununifi.nftbackedloan.ILiquidations=} [properties] Properties to set
       */
      function Liquidations(properties) {
        this.next_liquidation = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Liquidations liquidation.
       * @member {ununifi.nftbackedloan.ILiquidation|null|undefined} liquidation
       * @memberof ununifi.nftbackedloan.Liquidations
       * @instance
       */
      Liquidations.prototype.liquidation = null;

      /**
       * Liquidations next_liquidation.
       * @member {Array.<ununifi.nftbackedloan.ILiquidation>} next_liquidation
       * @memberof ununifi.nftbackedloan.Liquidations
       * @instance
       */
      Liquidations.prototype.next_liquidation = $util.emptyArray;

      /**
       * Encodes the specified Liquidations message. Does not implicitly {@link ununifi.nftbackedloan.Liquidations.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.Liquidations
       * @static
       * @param {ununifi.nftbackedloan.ILiquidations} message Liquidations message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Liquidations.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.liquidation != null && Object.hasOwnProperty.call(message, 'liquidation'))
          $root.ununifi.nftbackedloan.Liquidation.encode(message.liquidation, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.next_liquidation != null && message.next_liquidation.length)
          for (let i = 0; i < message.next_liquidation.length; ++i)
            $root.ununifi.nftbackedloan.Liquidation.encode(
              message.next_liquidation[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Liquidations message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Liquidations.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.Liquidations
       * @static
       * @param {ununifi.nftbackedloan.ILiquidations} message Liquidations message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Liquidations.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Liquidations message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.Liquidations
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.Liquidations} Liquidations
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Liquidations.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.Liquidations();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.liquidation = $root.ununifi.nftbackedloan.Liquidation.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.next_liquidation && message.next_liquidation.length)) message.next_liquidation = [];
              message.next_liquidation.push($root.ununifi.nftbackedloan.Liquidation.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Liquidations message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.Liquidations
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.Liquidations} Liquidations
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Liquidations.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Liquidations message.
       * @function verify
       * @memberof ununifi.nftbackedloan.Liquidations
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Liquidations.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.liquidation != null && message.hasOwnProperty('liquidation')) {
          let error = $root.ununifi.nftbackedloan.Liquidation.verify(message.liquidation);
          if (error) return 'liquidation.' + error;
        }
        if (message.next_liquidation != null && message.hasOwnProperty('next_liquidation')) {
          if (!Array.isArray(message.next_liquidation)) return 'next_liquidation: array expected';
          for (let i = 0; i < message.next_liquidation.length; ++i) {
            let error = $root.ununifi.nftbackedloan.Liquidation.verify(message.next_liquidation[i]);
            if (error) return 'next_liquidation.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Liquidations message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.Liquidations
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.Liquidations} Liquidations
       */
      Liquidations.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.Liquidations) return object;
        let message = new $root.ununifi.nftbackedloan.Liquidations();
        if (object.liquidation != null) {
          if (typeof object.liquidation !== 'object') throw TypeError('.ununifi.nftbackedloan.Liquidations.liquidation: object expected');
          message.liquidation = $root.ununifi.nftbackedloan.Liquidation.fromObject(object.liquidation);
        }
        if (object.next_liquidation) {
          if (!Array.isArray(object.next_liquidation))
            throw TypeError('.ununifi.nftbackedloan.Liquidations.next_liquidation: array expected');
          message.next_liquidation = [];
          for (let i = 0; i < object.next_liquidation.length; ++i) {
            if (typeof object.next_liquidation[i] !== 'object')
              throw TypeError('.ununifi.nftbackedloan.Liquidations.next_liquidation: object expected');
            message.next_liquidation[i] = $root.ununifi.nftbackedloan.Liquidation.fromObject(object.next_liquidation[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Liquidations message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.Liquidations
       * @static
       * @param {ununifi.nftbackedloan.Liquidations} message Liquidations
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Liquidations.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.next_liquidation = [];
        if (options.defaults) object.liquidation = null;
        if (message.liquidation != null && message.hasOwnProperty('liquidation'))
          object.liquidation = $root.ununifi.nftbackedloan.Liquidation.toObject(message.liquidation, options);
        if (message.next_liquidation && message.next_liquidation.length) {
          object.next_liquidation = [];
          for (let j = 0; j < message.next_liquidation.length; ++j)
            object.next_liquidation[j] = $root.ununifi.nftbackedloan.Liquidation.toObject(message.next_liquidation[j], options);
        }
        return object;
      };

      /**
       * Converts this Liquidations to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.Liquidations
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Liquidations.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Liquidations;
    })();

    nftbackedloan.RepayInfo = (function () {
      /**
       * Properties of a RepayInfo.
       * @memberof ununifi.nftbackedloan
       * @interface IRepayInfo
       * @property {cosmos.base.v1beta1.ICoin|null} [repaid_amount] RepayInfo repaid_amount
       * @property {cosmos.base.v1beta1.ICoin|null} [repaid_interest_amount] RepayInfo repaid_interest_amount
       * @property {cosmos.base.v1beta1.ICoin|null} [remaining_amount] RepayInfo remaining_amount
       * @property {google.protobuf.ITimestamp|null} [last_repaid_at] RepayInfo last_repaid_at
       */

      /**
       * Constructs a new RepayInfo.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a RepayInfo.
       * @implements IRepayInfo
       * @constructor
       * @param {ununifi.nftbackedloan.IRepayInfo=} [properties] Properties to set
       */
      function RepayInfo(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * RepayInfo repaid_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} repaid_amount
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @instance
       */
      RepayInfo.prototype.repaid_amount = null;

      /**
       * RepayInfo repaid_interest_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} repaid_interest_amount
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @instance
       */
      RepayInfo.prototype.repaid_interest_amount = null;

      /**
       * RepayInfo remaining_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} remaining_amount
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @instance
       */
      RepayInfo.prototype.remaining_amount = null;

      /**
       * RepayInfo last_repaid_at.
       * @member {google.protobuf.ITimestamp|null|undefined} last_repaid_at
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @instance
       */
      RepayInfo.prototype.last_repaid_at = null;

      /**
       * Encodes the specified RepayInfo message. Does not implicitly {@link ununifi.nftbackedloan.RepayInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @static
       * @param {ununifi.nftbackedloan.IRepayInfo} message RepayInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RepayInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.repaid_amount != null && Object.hasOwnProperty.call(message, 'repaid_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.repaid_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.repaid_interest_amount != null && Object.hasOwnProperty.call(message, 'repaid_interest_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.repaid_interest_amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.remaining_amount != null && Object.hasOwnProperty.call(message, 'remaining_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.remaining_amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.last_repaid_at != null && Object.hasOwnProperty.call(message, 'last_repaid_at'))
          $root.google.protobuf.Timestamp.encode(message.last_repaid_at, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified RepayInfo message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.RepayInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @static
       * @param {ununifi.nftbackedloan.IRepayInfo} message RepayInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      RepayInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a RepayInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.RepayInfo} RepayInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RepayInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.RepayInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.repaid_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.repaid_interest_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.remaining_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.last_repaid_at = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a RepayInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.RepayInfo} RepayInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      RepayInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a RepayInfo message.
       * @function verify
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      RepayInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.repaid_amount != null && message.hasOwnProperty('repaid_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.repaid_amount);
          if (error) return 'repaid_amount.' + error;
        }
        if (message.repaid_interest_amount != null && message.hasOwnProperty('repaid_interest_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.repaid_interest_amount);
          if (error) return 'repaid_interest_amount.' + error;
        }
        if (message.remaining_amount != null && message.hasOwnProperty('remaining_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.remaining_amount);
          if (error) return 'remaining_amount.' + error;
        }
        if (message.last_repaid_at != null && message.hasOwnProperty('last_repaid_at')) {
          let error = $root.google.protobuf.Timestamp.verify(message.last_repaid_at);
          if (error) return 'last_repaid_at.' + error;
        }
        return null;
      };

      /**
       * Creates a RepayInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.RepayInfo} RepayInfo
       */
      RepayInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.RepayInfo) return object;
        let message = new $root.ununifi.nftbackedloan.RepayInfo();
        if (object.repaid_amount != null) {
          if (typeof object.repaid_amount !== 'object') throw TypeError('.ununifi.nftbackedloan.RepayInfo.repaid_amount: object expected');
          message.repaid_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.repaid_amount);
        }
        if (object.repaid_interest_amount != null) {
          if (typeof object.repaid_interest_amount !== 'object')
            throw TypeError('.ununifi.nftbackedloan.RepayInfo.repaid_interest_amount: object expected');
          message.repaid_interest_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.repaid_interest_amount);
        }
        if (object.remaining_amount != null) {
          if (typeof object.remaining_amount !== 'object')
            throw TypeError('.ununifi.nftbackedloan.RepayInfo.remaining_amount: object expected');
          message.remaining_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.remaining_amount);
        }
        if (object.last_repaid_at != null) {
          if (typeof object.last_repaid_at !== 'object')
            throw TypeError('.ununifi.nftbackedloan.RepayInfo.last_repaid_at: object expected');
          message.last_repaid_at = $root.google.protobuf.Timestamp.fromObject(object.last_repaid_at);
        }
        return message;
      };

      /**
       * Creates a plain object from a RepayInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @static
       * @param {ununifi.nftbackedloan.RepayInfo} message RepayInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      RepayInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.repaid_amount = null;
          object.repaid_interest_amount = null;
          object.remaining_amount = null;
          object.last_repaid_at = null;
        }
        if (message.repaid_amount != null && message.hasOwnProperty('repaid_amount'))
          object.repaid_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.repaid_amount, options);
        if (message.repaid_interest_amount != null && message.hasOwnProperty('repaid_interest_amount'))
          object.repaid_interest_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.repaid_interest_amount, options);
        if (message.remaining_amount != null && message.hasOwnProperty('remaining_amount'))
          object.remaining_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.remaining_amount, options);
        if (message.last_repaid_at != null && message.hasOwnProperty('last_repaid_at'))
          object.last_repaid_at = $root.google.protobuf.Timestamp.toObject(message.last_repaid_at, options);
        return object;
      };

      /**
       * Converts this RepayInfo to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.RepayInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      RepayInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return RepayInfo;
    })();

    nftbackedloan.EventListNft = (function () {
      /**
       * Properties of an EventListNft.
       * @memberof ununifi.nftbackedloan
       * @interface IEventListNft
       * @property {string|null} [owner] EventListNft owner
       * @property {string|null} [class_id] EventListNft class_id
       * @property {string|null} [token_id] EventListNft token_id
       */

      /**
       * Constructs a new EventListNft.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventListNft.
       * @implements IEventListNft
       * @constructor
       * @param {ununifi.nftbackedloan.IEventListNft=} [properties] Properties to set
       */
      function EventListNft(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventListNft owner.
       * @member {string} owner
       * @memberof ununifi.nftbackedloan.EventListNft
       * @instance
       */
      EventListNft.prototype.owner = '';

      /**
       * EventListNft class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventListNft
       * @instance
       */
      EventListNft.prototype.class_id = '';

      /**
       * EventListNft token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventListNft
       * @instance
       */
      EventListNft.prototype.token_id = '';

      /**
       * Encodes the specified EventListNft message. Does not implicitly {@link ununifi.nftbackedloan.EventListNft.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventListNft
       * @static
       * @param {ununifi.nftbackedloan.IEventListNft} message EventListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventListNft.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventListNft message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventListNft.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventListNft
       * @static
       * @param {ununifi.nftbackedloan.IEventListNft} message EventListNft message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventListNft.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventListNft message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventListNft} EventListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventListNft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventListNft();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventListNft message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventListNft
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventListNft} EventListNft
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventListNft.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventListNft message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventListNft
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventListNft.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventListNft message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventListNft
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventListNft} EventListNft
       */
      EventListNft.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventListNft) return object;
        let message = new $root.ununifi.nftbackedloan.EventListNft();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventListNft message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventListNft
       * @static
       * @param {ununifi.nftbackedloan.EventListNft} message EventListNft
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventListNft.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventListNft to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventListNft
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventListNft.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventListNft;
    })();

    nftbackedloan.EventCancelListing = (function () {
      /**
       * Properties of an EventCancelListing.
       * @memberof ununifi.nftbackedloan
       * @interface IEventCancelListing
       * @property {string|null} [owner] EventCancelListing owner
       * @property {string|null} [class_id] EventCancelListing class_id
       * @property {string|null} [token_id] EventCancelListing token_id
       */

      /**
       * Constructs a new EventCancelListing.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventCancelListing.
       * @implements IEventCancelListing
       * @constructor
       * @param {ununifi.nftbackedloan.IEventCancelListing=} [properties] Properties to set
       */
      function EventCancelListing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventCancelListing owner.
       * @member {string} owner
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @instance
       */
      EventCancelListing.prototype.owner = '';

      /**
       * EventCancelListing class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @instance
       */
      EventCancelListing.prototype.class_id = '';

      /**
       * EventCancelListing token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @instance
       */
      EventCancelListing.prototype.token_id = '';

      /**
       * Encodes the specified EventCancelListing message. Does not implicitly {@link ununifi.nftbackedloan.EventCancelListing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @static
       * @param {ununifi.nftbackedloan.IEventCancelListing} message EventCancelListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelListing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventCancelListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventCancelListing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @static
       * @param {ununifi.nftbackedloan.IEventCancelListing} message EventCancelListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventCancelListing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventCancelListing} EventCancelListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventCancelListing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventCancelListing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventCancelListing} EventCancelListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventCancelListing message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventCancelListing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventCancelListing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventCancelListing} EventCancelListing
       */
      EventCancelListing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventCancelListing) return object;
        let message = new $root.ununifi.nftbackedloan.EventCancelListing();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventCancelListing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @static
       * @param {ununifi.nftbackedloan.EventCancelListing} message EventCancelListing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventCancelListing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventCancelListing to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventCancelListing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventCancelListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventCancelListing;
    })();

    nftbackedloan.EventSellingDecision = (function () {
      /**
       * Properties of an EventSellingDecision.
       * @memberof ununifi.nftbackedloan
       * @interface IEventSellingDecision
       * @property {string|null} [owner] EventSellingDecision owner
       * @property {string|null} [class_id] EventSellingDecision class_id
       * @property {string|null} [token_id] EventSellingDecision token_id
       */

      /**
       * Constructs a new EventSellingDecision.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventSellingDecision.
       * @implements IEventSellingDecision
       * @constructor
       * @param {ununifi.nftbackedloan.IEventSellingDecision=} [properties] Properties to set
       */
      function EventSellingDecision(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventSellingDecision owner.
       * @member {string} owner
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @instance
       */
      EventSellingDecision.prototype.owner = '';

      /**
       * EventSellingDecision class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @instance
       */
      EventSellingDecision.prototype.class_id = '';

      /**
       * EventSellingDecision token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @instance
       */
      EventSellingDecision.prototype.token_id = '';

      /**
       * Encodes the specified EventSellingDecision message. Does not implicitly {@link ununifi.nftbackedloan.EventSellingDecision.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @static
       * @param {ununifi.nftbackedloan.IEventSellingDecision} message EventSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventSellingDecision.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventSellingDecision message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventSellingDecision.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @static
       * @param {ununifi.nftbackedloan.IEventSellingDecision} message EventSellingDecision message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventSellingDecision.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventSellingDecision message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventSellingDecision} EventSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventSellingDecision.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventSellingDecision();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventSellingDecision message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventSellingDecision} EventSellingDecision
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventSellingDecision.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventSellingDecision message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventSellingDecision.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventSellingDecision message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventSellingDecision} EventSellingDecision
       */
      EventSellingDecision.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventSellingDecision) return object;
        let message = new $root.ununifi.nftbackedloan.EventSellingDecision();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventSellingDecision message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @static
       * @param {ununifi.nftbackedloan.EventSellingDecision} message EventSellingDecision
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventSellingDecision.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventSellingDecision to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventSellingDecision
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventSellingDecision.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventSellingDecision;
    })();

    nftbackedloan.EventEndListing = (function () {
      /**
       * Properties of an EventEndListing.
       * @memberof ununifi.nftbackedloan
       * @interface IEventEndListing
       * @property {string|null} [owner] EventEndListing owner
       * @property {string|null} [class_id] EventEndListing class_id
       * @property {string|null} [token_id] EventEndListing token_id
       */

      /**
       * Constructs a new EventEndListing.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventEndListing.
       * @implements IEventEndListing
       * @constructor
       * @param {ununifi.nftbackedloan.IEventEndListing=} [properties] Properties to set
       */
      function EventEndListing(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventEndListing owner.
       * @member {string} owner
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @instance
       */
      EventEndListing.prototype.owner = '';

      /**
       * EventEndListing class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @instance
       */
      EventEndListing.prototype.class_id = '';

      /**
       * EventEndListing token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @instance
       */
      EventEndListing.prototype.token_id = '';

      /**
       * Encodes the specified EventEndListing message. Does not implicitly {@link ununifi.nftbackedloan.EventEndListing.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @static
       * @param {ununifi.nftbackedloan.IEventEndListing} message EventEndListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventEndListing.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventEndListing message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventEndListing.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @static
       * @param {ununifi.nftbackedloan.IEventEndListing} message EventEndListing message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventEndListing.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventEndListing message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventEndListing} EventEndListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventEndListing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventEndListing();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventEndListing message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventEndListing} EventEndListing
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventEndListing.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventEndListing message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventEndListing.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventEndListing message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventEndListing} EventEndListing
       */
      EventEndListing.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventEndListing) return object;
        let message = new $root.ununifi.nftbackedloan.EventEndListing();
        if (object.owner != null) message.owner = String(object.owner);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventEndListing message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @static
       * @param {ununifi.nftbackedloan.EventEndListing} message EventEndListing
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventEndListing.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.owner = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventEndListing to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventEndListing
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventEndListing.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventEndListing;
    })();

    nftbackedloan.EventPlaceBid = (function () {
      /**
       * Properties of an EventPlaceBid.
       * @memberof ununifi.nftbackedloan
       * @interface IEventPlaceBid
       * @property {string|null} [bidder] EventPlaceBid bidder
       * @property {string|null} [class_id] EventPlaceBid class_id
       * @property {string|null} [token_id] EventPlaceBid token_id
       * @property {string|null} [amount] EventPlaceBid amount
       */

      /**
       * Constructs a new EventPlaceBid.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventPlaceBid.
       * @implements IEventPlaceBid
       * @constructor
       * @param {ununifi.nftbackedloan.IEventPlaceBid=} [properties] Properties to set
       */
      function EventPlaceBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPlaceBid bidder.
       * @member {string} bidder
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.bidder = '';

      /**
       * EventPlaceBid class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.class_id = '';

      /**
       * EventPlaceBid token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.token_id = '';

      /**
       * EventPlaceBid amount.
       * @member {string} amount
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @instance
       */
      EventPlaceBid.prototype.amount = '';

      /**
       * Encodes the specified EventPlaceBid message. Does not implicitly {@link ununifi.nftbackedloan.EventPlaceBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @static
       * @param {ununifi.nftbackedloan.IEventPlaceBid} message EventPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPlaceBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified EventPlaceBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventPlaceBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @static
       * @param {ununifi.nftbackedloan.IEventPlaceBid} message EventPlaceBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPlaceBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPlaceBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventPlaceBid} EventPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPlaceBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventPlaceBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPlaceBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventPlaceBid} EventPlaceBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPlaceBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPlaceBid message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPlaceBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates an EventPlaceBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventPlaceBid} EventPlaceBid
       */
      EventPlaceBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventPlaceBid) return object;
        let message = new $root.ununifi.nftbackedloan.EventPlaceBid();
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from an EventPlaceBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @static
       * @param {ununifi.nftbackedloan.EventPlaceBid} message EventPlaceBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPlaceBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.bidder = '';
          object.class_id = '';
          object.token_id = '';
          object.amount = '';
        }
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this EventPlaceBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventPlaceBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPlaceBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPlaceBid;
    })();

    nftbackedloan.EventCancelBid = (function () {
      /**
       * Properties of an EventCancelBid.
       * @memberof ununifi.nftbackedloan
       * @interface IEventCancelBid
       * @property {string|null} [bidder] EventCancelBid bidder
       * @property {string|null} [class_id] EventCancelBid class_id
       * @property {string|null} [token_id] EventCancelBid token_id
       */

      /**
       * Constructs a new EventCancelBid.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventCancelBid.
       * @implements IEventCancelBid
       * @constructor
       * @param {ununifi.nftbackedloan.IEventCancelBid=} [properties] Properties to set
       */
      function EventCancelBid(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventCancelBid bidder.
       * @member {string} bidder
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @instance
       */
      EventCancelBid.prototype.bidder = '';

      /**
       * EventCancelBid class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @instance
       */
      EventCancelBid.prototype.class_id = '';

      /**
       * EventCancelBid token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @instance
       */
      EventCancelBid.prototype.token_id = '';

      /**
       * Encodes the specified EventCancelBid message. Does not implicitly {@link ununifi.nftbackedloan.EventCancelBid.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @static
       * @param {ununifi.nftbackedloan.IEventCancelBid} message EventCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelBid.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventCancelBid message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventCancelBid.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @static
       * @param {ununifi.nftbackedloan.IEventCancelBid} message EventCancelBid message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCancelBid.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventCancelBid message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventCancelBid} EventCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelBid.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventCancelBid();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventCancelBid message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventCancelBid} EventCancelBid
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCancelBid.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventCancelBid message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventCancelBid.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventCancelBid message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventCancelBid} EventCancelBid
       */
      EventCancelBid.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventCancelBid) return object;
        let message = new $root.ununifi.nftbackedloan.EventCancelBid();
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventCancelBid message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @static
       * @param {ununifi.nftbackedloan.EventCancelBid} message EventCancelBid
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventCancelBid.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.bidder = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventCancelBid to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventCancelBid
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventCancelBid.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventCancelBid;
    })();

    nftbackedloan.EventPayRemainder = (function () {
      /**
       * Properties of an EventPayRemainder.
       * @memberof ununifi.nftbackedloan
       * @interface IEventPayRemainder
       * @property {string|null} [bidder] EventPayRemainder bidder
       * @property {string|null} [class_id] EventPayRemainder class_id
       * @property {string|null} [token_id] EventPayRemainder token_id
       */

      /**
       * Constructs a new EventPayRemainder.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventPayRemainder.
       * @implements IEventPayRemainder
       * @constructor
       * @param {ununifi.nftbackedloan.IEventPayRemainder=} [properties] Properties to set
       */
      function EventPayRemainder(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventPayRemainder bidder.
       * @member {string} bidder
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @instance
       */
      EventPayRemainder.prototype.bidder = '';

      /**
       * EventPayRemainder class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @instance
       */
      EventPayRemainder.prototype.class_id = '';

      /**
       * EventPayRemainder token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @instance
       */
      EventPayRemainder.prototype.token_id = '';

      /**
       * Encodes the specified EventPayRemainder message. Does not implicitly {@link ununifi.nftbackedloan.EventPayRemainder.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @static
       * @param {ununifi.nftbackedloan.IEventPayRemainder} message EventPayRemainder message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPayRemainder.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventPayRemainder message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventPayRemainder.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @static
       * @param {ununifi.nftbackedloan.IEventPayRemainder} message EventPayRemainder message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventPayRemainder.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventPayRemainder message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventPayRemainder} EventPayRemainder
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPayRemainder.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventPayRemainder();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventPayRemainder message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventPayRemainder} EventPayRemainder
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventPayRemainder.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventPayRemainder message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventPayRemainder.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventPayRemainder message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventPayRemainder} EventPayRemainder
       */
      EventPayRemainder.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventPayRemainder) return object;
        let message = new $root.ununifi.nftbackedloan.EventPayRemainder();
        if (object.bidder != null) message.bidder = String(object.bidder);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventPayRemainder message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @static
       * @param {ununifi.nftbackedloan.EventPayRemainder} message EventPayRemainder
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventPayRemainder.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.bidder = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventPayRemainder to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventPayRemainder
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventPayRemainder.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventPayRemainder;
    })();

    nftbackedloan.EventBorrow = (function () {
      /**
       * Properties of an EventBorrow.
       * @memberof ununifi.nftbackedloan
       * @interface IEventBorrow
       * @property {string|null} [borrower] EventBorrow borrower
       * @property {string|null} [class_id] EventBorrow class_id
       * @property {string|null} [token_id] EventBorrow token_id
       * @property {string|null} [amount] EventBorrow amount
       */

      /**
       * Constructs a new EventBorrow.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventBorrow.
       * @implements IEventBorrow
       * @constructor
       * @param {ununifi.nftbackedloan.IEventBorrow=} [properties] Properties to set
       */
      function EventBorrow(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventBorrow borrower.
       * @member {string} borrower
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @instance
       */
      EventBorrow.prototype.borrower = '';

      /**
       * EventBorrow class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @instance
       */
      EventBorrow.prototype.class_id = '';

      /**
       * EventBorrow token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @instance
       */
      EventBorrow.prototype.token_id = '';

      /**
       * EventBorrow amount.
       * @member {string} amount
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @instance
       */
      EventBorrow.prototype.amount = '';

      /**
       * Encodes the specified EventBorrow message. Does not implicitly {@link ununifi.nftbackedloan.EventBorrow.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @static
       * @param {ununifi.nftbackedloan.IEventBorrow} message EventBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBorrow.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.borrower != null && Object.hasOwnProperty.call(message, 'borrower'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.borrower);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified EventBorrow message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventBorrow.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @static
       * @param {ununifi.nftbackedloan.IEventBorrow} message EventBorrow message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBorrow.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventBorrow message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventBorrow} EventBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBorrow.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventBorrow();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.borrower = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventBorrow message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventBorrow} EventBorrow
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBorrow.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventBorrow message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventBorrow.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.borrower != null && message.hasOwnProperty('borrower'))
          if (!$util.isString(message.borrower)) return 'borrower: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates an EventBorrow message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventBorrow} EventBorrow
       */
      EventBorrow.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventBorrow) return object;
        let message = new $root.ununifi.nftbackedloan.EventBorrow();
        if (object.borrower != null) message.borrower = String(object.borrower);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from an EventBorrow message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @static
       * @param {ununifi.nftbackedloan.EventBorrow} message EventBorrow
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventBorrow.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.borrower = '';
          object.class_id = '';
          object.token_id = '';
          object.amount = '';
        }
        if (message.borrower != null && message.hasOwnProperty('borrower')) object.borrower = message.borrower;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this EventBorrow to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventBorrow
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventBorrow.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventBorrow;
    })();

    nftbackedloan.EventRepay = (function () {
      /**
       * Properties of an EventRepay.
       * @memberof ununifi.nftbackedloan
       * @interface IEventRepay
       * @property {string|null} [borrower] EventRepay borrower
       * @property {string|null} [class_id] EventRepay class_id
       * @property {string|null} [token_id] EventRepay token_id
       * @property {string|null} [amount] EventRepay amount
       */

      /**
       * Constructs a new EventRepay.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventRepay.
       * @implements IEventRepay
       * @constructor
       * @param {ununifi.nftbackedloan.IEventRepay=} [properties] Properties to set
       */
      function EventRepay(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventRepay borrower.
       * @member {string} borrower
       * @memberof ununifi.nftbackedloan.EventRepay
       * @instance
       */
      EventRepay.prototype.borrower = '';

      /**
       * EventRepay class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventRepay
       * @instance
       */
      EventRepay.prototype.class_id = '';

      /**
       * EventRepay token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventRepay
       * @instance
       */
      EventRepay.prototype.token_id = '';

      /**
       * EventRepay amount.
       * @member {string} amount
       * @memberof ununifi.nftbackedloan.EventRepay
       * @instance
       */
      EventRepay.prototype.amount = '';

      /**
       * Encodes the specified EventRepay message. Does not implicitly {@link ununifi.nftbackedloan.EventRepay.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventRepay
       * @static
       * @param {ununifi.nftbackedloan.IEventRepay} message EventRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRepay.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.borrower != null && Object.hasOwnProperty.call(message, 'borrower'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.borrower);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified EventRepay message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventRepay.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventRepay
       * @static
       * @param {ununifi.nftbackedloan.IEventRepay} message EventRepay message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventRepay.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventRepay message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventRepay} EventRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRepay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventRepay();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.borrower = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventRepay message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventRepay
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventRepay} EventRepay
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventRepay.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventRepay message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventRepay
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventRepay.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.borrower != null && message.hasOwnProperty('borrower'))
          if (!$util.isString(message.borrower)) return 'borrower: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates an EventRepay message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventRepay
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventRepay} EventRepay
       */
      EventRepay.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventRepay) return object;
        let message = new $root.ununifi.nftbackedloan.EventRepay();
        if (object.borrower != null) message.borrower = String(object.borrower);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from an EventRepay message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventRepay
       * @static
       * @param {ununifi.nftbackedloan.EventRepay} message EventRepay
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventRepay.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.borrower = '';
          object.class_id = '';
          object.token_id = '';
          object.amount = '';
        }
        if (message.borrower != null && message.hasOwnProperty('borrower')) object.borrower = message.borrower;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this EventRepay to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventRepay
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventRepay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventRepay;
    })();

    nftbackedloan.EventLiquidate = (function () {
      /**
       * Properties of an EventLiquidate.
       * @memberof ununifi.nftbackedloan
       * @interface IEventLiquidate
       * @property {string|null} [liquidator] EventLiquidate liquidator
       * @property {string|null} [class_id] EventLiquidate class_id
       * @property {string|null} [token_id] EventLiquidate token_id
       */

      /**
       * Constructs a new EventLiquidate.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents an EventLiquidate.
       * @implements IEventLiquidate
       * @constructor
       * @param {ununifi.nftbackedloan.IEventLiquidate=} [properties] Properties to set
       */
      function EventLiquidate(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventLiquidate liquidator.
       * @member {string} liquidator
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @instance
       */
      EventLiquidate.prototype.liquidator = '';

      /**
       * EventLiquidate class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @instance
       */
      EventLiquidate.prototype.class_id = '';

      /**
       * EventLiquidate token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @instance
       */
      EventLiquidate.prototype.token_id = '';

      /**
       * Encodes the specified EventLiquidate message. Does not implicitly {@link ununifi.nftbackedloan.EventLiquidate.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @static
       * @param {ununifi.nftbackedloan.IEventLiquidate} message EventLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLiquidate.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.liquidator != null && Object.hasOwnProperty.call(message, 'liquidator'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.liquidator);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventLiquidate message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.EventLiquidate.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @static
       * @param {ununifi.nftbackedloan.IEventLiquidate} message EventLiquidate message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventLiquidate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventLiquidate message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.EventLiquidate} EventLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLiquidate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.EventLiquidate();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.liquidator = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventLiquidate message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.EventLiquidate} EventLiquidate
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventLiquidate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventLiquidate message.
       * @function verify
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventLiquidate.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.liquidator != null && message.hasOwnProperty('liquidator'))
          if (!$util.isString(message.liquidator)) return 'liquidator: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventLiquidate message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.EventLiquidate} EventLiquidate
       */
      EventLiquidate.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.EventLiquidate) return object;
        let message = new $root.ununifi.nftbackedloan.EventLiquidate();
        if (object.liquidator != null) message.liquidator = String(object.liquidator);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventLiquidate message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @static
       * @param {ununifi.nftbackedloan.EventLiquidate} message EventLiquidate
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventLiquidate.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.liquidator = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.liquidator != null && message.hasOwnProperty('liquidator')) object.liquidator = message.liquidator;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventLiquidate to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.EventLiquidate
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventLiquidate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventLiquidate;
    })();

    nftbackedloan.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.nftbackedloan
       * @interface IGenesisState
       * @property {ununifi.nftbackedloan.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.nftbackedloan.IListing>|null} [listings] GenesisState listings
       * @property {Array.<ununifi.nftbackedloan.IBid>|null} [bids] GenesisState bids
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.nftbackedloan.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.listings = [];
        this.bids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.nftbackedloan.IParams|null|undefined} params
       * @memberof ununifi.nftbackedloan.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState listings.
       * @member {Array.<ununifi.nftbackedloan.IListing>} listings
       * @memberof ununifi.nftbackedloan.GenesisState
       * @instance
       */
      GenesisState.prototype.listings = $util.emptyArray;

      /**
       * GenesisState bids.
       * @member {Array.<ununifi.nftbackedloan.IBid>} bids
       * @memberof ununifi.nftbackedloan.GenesisState
       * @instance
       */
      GenesisState.prototype.bids = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftbackedloan.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.GenesisState
       * @static
       * @param {ununifi.nftbackedloan.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftbackedloan.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.listings != null && message.listings.length)
          for (let i = 0; i < message.listings.length; ++i)
            $root.ununifi.nftbackedloan.Listing.encode(message.listings[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.bids != null && message.bids.length)
          for (let i = 0; i < message.bids.length; ++i)
            $root.ununifi.nftbackedloan.Bid.encode(message.bids[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.GenesisState
       * @static
       * @param {ununifi.nftbackedloan.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftbackedloan.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.listings && message.listings.length)) message.listings = [];
              message.listings.push($root.ununifi.nftbackedloan.Listing.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.bids && message.bids.length)) message.bids = [];
              message.bids.push($root.ununifi.nftbackedloan.Bid.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.nftbackedloan.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftbackedloan.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.listings != null && message.hasOwnProperty('listings')) {
          if (!Array.isArray(message.listings)) return 'listings: array expected';
          for (let i = 0; i < message.listings.length; ++i) {
            let error = $root.ununifi.nftbackedloan.Listing.verify(message.listings[i]);
            if (error) return 'listings.' + error;
          }
        }
        if (message.bids != null && message.hasOwnProperty('bids')) {
          if (!Array.isArray(message.bids)) return 'bids: array expected';
          for (let i = 0; i < message.bids.length; ++i) {
            let error = $root.ununifi.nftbackedloan.Bid.verify(message.bids[i]);
            if (error) return 'bids.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.GenesisState) return object;
        let message = new $root.ununifi.nftbackedloan.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftbackedloan.GenesisState.params: object expected');
          message.params = $root.ununifi.nftbackedloan.Params.fromObject(object.params);
        }
        if (object.listings) {
          if (!Array.isArray(object.listings)) throw TypeError('.ununifi.nftbackedloan.GenesisState.listings: array expected');
          message.listings = [];
          for (let i = 0; i < object.listings.length; ++i) {
            if (typeof object.listings[i] !== 'object') throw TypeError('.ununifi.nftbackedloan.GenesisState.listings: object expected');
            message.listings[i] = $root.ununifi.nftbackedloan.Listing.fromObject(object.listings[i]);
          }
        }
        if (object.bids) {
          if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftbackedloan.GenesisState.bids: array expected');
          message.bids = [];
          for (let i = 0; i < object.bids.length; ++i) {
            if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftbackedloan.GenesisState.bids: object expected');
            message.bids[i] = $root.ununifi.nftbackedloan.Bid.fromObject(object.bids[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.GenesisState
       * @static
       * @param {ununifi.nftbackedloan.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.listings = [];
          object.bids = [];
        }
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftbackedloan.Params.toObject(message.params, options);
        if (message.listings && message.listings.length) {
          object.listings = [];
          for (let j = 0; j < message.listings.length; ++j)
            object.listings[j] = $root.ununifi.nftbackedloan.Listing.toObject(message.listings[j], options);
        }
        if (message.bids && message.bids.length) {
          object.bids = [];
          for (let j = 0; j < message.bids.length; ++j) object.bids[j] = $root.ununifi.nftbackedloan.Bid.toObject(message.bids[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    nftbackedloan.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.nftbackedloan
       * @interface IParams
       * @property {string|null} [min_staking_for_listing] Params min_staking_for_listing
       * @property {Array.<string>|null} [bid_tokens] Params bid_tokens
       * @property {Long|null} [nft_listing_cancel_required_seconds] Params nft_listing_cancel_required_seconds
       * @property {Long|null} [bid_cancel_required_seconds] Params bid_cancel_required_seconds
       * @property {Long|null} [nft_listing_full_payment_period] Params nft_listing_full_payment_period
       * @property {Long|null} [nft_listing_nft_delivery_period] Params nft_listing_nft_delivery_period
       * @property {string|null} [nft_listing_commission_rate] Params nft_listing_commission_rate
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.nftbackedloan.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.bid_tokens = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params min_staking_for_listing.
       * @member {string} min_staking_for_listing
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       */
      Params.prototype.min_staking_for_listing = '';

      /**
       * Params bid_tokens.
       * @member {Array.<string>} bid_tokens
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       */
      Params.prototype.bid_tokens = $util.emptyArray;

      /**
       * Params nft_listing_cancel_required_seconds.
       * @member {Long} nft_listing_cancel_required_seconds
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       */
      Params.prototype.nft_listing_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params bid_cancel_required_seconds.
       * @member {Long} bid_cancel_required_seconds
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       */
      Params.prototype.bid_cancel_required_seconds = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_full_payment_period.
       * @member {Long} nft_listing_full_payment_period
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       */
      Params.prototype.nft_listing_full_payment_period = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_nft_delivery_period.
       * @member {Long} nft_listing_nft_delivery_period
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       */
      Params.prototype.nft_listing_nft_delivery_period = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Params nft_listing_commission_rate.
       * @member {string} nft_listing_commission_rate
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       */
      Params.prototype.nft_listing_commission_rate = '';

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.nftbackedloan.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.Params
       * @static
       * @param {ununifi.nftbackedloan.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.min_staking_for_listing != null && Object.hasOwnProperty.call(message, 'min_staking_for_listing'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.min_staking_for_listing);
        if (message.bid_tokens != null && message.bid_tokens.length)
          for (let i = 0; i < message.bid_tokens.length; ++i) writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.bid_tokens[i]);
        if (
          message.nft_listing_cancel_required_seconds != null &&
          Object.hasOwnProperty.call(message, 'nft_listing_cancel_required_seconds')
        )
          writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.nft_listing_cancel_required_seconds);
        if (message.bid_cancel_required_seconds != null && Object.hasOwnProperty.call(message, 'bid_cancel_required_seconds'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.bid_cancel_required_seconds);
        if (message.nft_listing_full_payment_period != null && Object.hasOwnProperty.call(message, 'nft_listing_full_payment_period'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.nft_listing_full_payment_period);
        if (message.nft_listing_nft_delivery_period != null && Object.hasOwnProperty.call(message, 'nft_listing_nft_delivery_period'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).uint64(message.nft_listing_nft_delivery_period);
        if (message.nft_listing_commission_rate != null && Object.hasOwnProperty.call(message, 'nft_listing_commission_rate'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.nft_listing_commission_rate);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.Params
       * @static
       * @param {ununifi.nftbackedloan.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.min_staking_for_listing = reader.string();
              break;
            case 2:
              if (!(message.bid_tokens && message.bid_tokens.length)) message.bid_tokens = [];
              message.bid_tokens.push(reader.string());
              break;
            case 3:
              message.nft_listing_cancel_required_seconds = reader.uint64();
              break;
            case 4:
              message.bid_cancel_required_seconds = reader.uint64();
              break;
            case 5:
              message.nft_listing_full_payment_period = reader.uint64();
              break;
            case 6:
              message.nft_listing_nft_delivery_period = reader.uint64();
              break;
            case 7:
              message.nft_listing_commission_rate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.nftbackedloan.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.min_staking_for_listing != null && message.hasOwnProperty('min_staking_for_listing'))
          if (!$util.isString(message.min_staking_for_listing)) return 'min_staking_for_listing: string expected';
        if (message.bid_tokens != null && message.hasOwnProperty('bid_tokens')) {
          if (!Array.isArray(message.bid_tokens)) return 'bid_tokens: array expected';
          for (let i = 0; i < message.bid_tokens.length; ++i)
            if (!$util.isString(message.bid_tokens[i])) return 'bid_tokens: string[] expected';
        }
        if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty('nft_listing_cancel_required_seconds'))
          if (
            !$util.isInteger(message.nft_listing_cancel_required_seconds) &&
            !(
              message.nft_listing_cancel_required_seconds &&
              $util.isInteger(message.nft_listing_cancel_required_seconds.low) &&
              $util.isInteger(message.nft_listing_cancel_required_seconds.high)
            )
          )
            return 'nft_listing_cancel_required_seconds: integer|Long expected';
        if (message.bid_cancel_required_seconds != null && message.hasOwnProperty('bid_cancel_required_seconds'))
          if (
            !$util.isInteger(message.bid_cancel_required_seconds) &&
            !(
              message.bid_cancel_required_seconds &&
              $util.isInteger(message.bid_cancel_required_seconds.low) &&
              $util.isInteger(message.bid_cancel_required_seconds.high)
            )
          )
            return 'bid_cancel_required_seconds: integer|Long expected';
        if (message.nft_listing_full_payment_period != null && message.hasOwnProperty('nft_listing_full_payment_period'))
          if (
            !$util.isInteger(message.nft_listing_full_payment_period) &&
            !(
              message.nft_listing_full_payment_period &&
              $util.isInteger(message.nft_listing_full_payment_period.low) &&
              $util.isInteger(message.nft_listing_full_payment_period.high)
            )
          )
            return 'nft_listing_full_payment_period: integer|Long expected';
        if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty('nft_listing_nft_delivery_period'))
          if (
            !$util.isInteger(message.nft_listing_nft_delivery_period) &&
            !(
              message.nft_listing_nft_delivery_period &&
              $util.isInteger(message.nft_listing_nft_delivery_period.low) &&
              $util.isInteger(message.nft_listing_nft_delivery_period.high)
            )
          )
            return 'nft_listing_nft_delivery_period: integer|Long expected';
        if (message.nft_listing_commission_rate != null && message.hasOwnProperty('nft_listing_commission_rate'))
          if (!$util.isString(message.nft_listing_commission_rate)) return 'nft_listing_commission_rate: string expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.Params) return object;
        let message = new $root.ununifi.nftbackedloan.Params();
        if (object.min_staking_for_listing != null) message.min_staking_for_listing = String(object.min_staking_for_listing);
        if (object.bid_tokens) {
          if (!Array.isArray(object.bid_tokens)) throw TypeError('.ununifi.nftbackedloan.Params.bid_tokens: array expected');
          message.bid_tokens = [];
          for (let i = 0; i < object.bid_tokens.length; ++i) message.bid_tokens[i] = String(object.bid_tokens[i]);
        }
        if (object.nft_listing_cancel_required_seconds != null)
          if ($util.Long)
            (message.nft_listing_cancel_required_seconds = $util.Long.fromValue(
              object.nft_listing_cancel_required_seconds,
            )).unsigned = true;
          else if (typeof object.nft_listing_cancel_required_seconds === 'string')
            message.nft_listing_cancel_required_seconds = parseInt(object.nft_listing_cancel_required_seconds, 10);
          else if (typeof object.nft_listing_cancel_required_seconds === 'number')
            message.nft_listing_cancel_required_seconds = object.nft_listing_cancel_required_seconds;
          else if (typeof object.nft_listing_cancel_required_seconds === 'object')
            message.nft_listing_cancel_required_seconds = new $util.LongBits(
              object.nft_listing_cancel_required_seconds.low >>> 0,
              object.nft_listing_cancel_required_seconds.high >>> 0,
            ).toNumber(true);
        if (object.bid_cancel_required_seconds != null)
          if ($util.Long) (message.bid_cancel_required_seconds = $util.Long.fromValue(object.bid_cancel_required_seconds)).unsigned = true;
          else if (typeof object.bid_cancel_required_seconds === 'string')
            message.bid_cancel_required_seconds = parseInt(object.bid_cancel_required_seconds, 10);
          else if (typeof object.bid_cancel_required_seconds === 'number')
            message.bid_cancel_required_seconds = object.bid_cancel_required_seconds;
          else if (typeof object.bid_cancel_required_seconds === 'object')
            message.bid_cancel_required_seconds = new $util.LongBits(
              object.bid_cancel_required_seconds.low >>> 0,
              object.bid_cancel_required_seconds.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_full_payment_period != null)
          if ($util.Long)
            (message.nft_listing_full_payment_period = $util.Long.fromValue(object.nft_listing_full_payment_period)).unsigned = true;
          else if (typeof object.nft_listing_full_payment_period === 'string')
            message.nft_listing_full_payment_period = parseInt(object.nft_listing_full_payment_period, 10);
          else if (typeof object.nft_listing_full_payment_period === 'number')
            message.nft_listing_full_payment_period = object.nft_listing_full_payment_period;
          else if (typeof object.nft_listing_full_payment_period === 'object')
            message.nft_listing_full_payment_period = new $util.LongBits(
              object.nft_listing_full_payment_period.low >>> 0,
              object.nft_listing_full_payment_period.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_nft_delivery_period != null)
          if ($util.Long)
            (message.nft_listing_nft_delivery_period = $util.Long.fromValue(object.nft_listing_nft_delivery_period)).unsigned = true;
          else if (typeof object.nft_listing_nft_delivery_period === 'string')
            message.nft_listing_nft_delivery_period = parseInt(object.nft_listing_nft_delivery_period, 10);
          else if (typeof object.nft_listing_nft_delivery_period === 'number')
            message.nft_listing_nft_delivery_period = object.nft_listing_nft_delivery_period;
          else if (typeof object.nft_listing_nft_delivery_period === 'object')
            message.nft_listing_nft_delivery_period = new $util.LongBits(
              object.nft_listing_nft_delivery_period.low >>> 0,
              object.nft_listing_nft_delivery_period.high >>> 0,
            ).toNumber(true);
        if (object.nft_listing_commission_rate != null) message.nft_listing_commission_rate = String(object.nft_listing_commission_rate);
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.Params
       * @static
       * @param {ununifi.nftbackedloan.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.bid_tokens = [];
        if (options.defaults) {
          object.min_staking_for_listing = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_cancel_required_seconds =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_cancel_required_seconds = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.bid_cancel_required_seconds =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.bid_cancel_required_seconds = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_full_payment_period =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_full_payment_period = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_listing_nft_delivery_period =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_listing_nft_delivery_period = options.longs === String ? '0' : 0;
          object.nft_listing_commission_rate = '';
        }
        if (message.min_staking_for_listing != null && message.hasOwnProperty('min_staking_for_listing'))
          object.min_staking_for_listing = message.min_staking_for_listing;
        if (message.bid_tokens && message.bid_tokens.length) {
          object.bid_tokens = [];
          for (let j = 0; j < message.bid_tokens.length; ++j) object.bid_tokens[j] = message.bid_tokens[j];
        }
        if (message.nft_listing_cancel_required_seconds != null && message.hasOwnProperty('nft_listing_cancel_required_seconds'))
          if (typeof message.nft_listing_cancel_required_seconds === 'number')
            object.nft_listing_cancel_required_seconds =
              options.longs === String ? String(message.nft_listing_cancel_required_seconds) : message.nft_listing_cancel_required_seconds;
          else
            object.nft_listing_cancel_required_seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_cancel_required_seconds)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_listing_cancel_required_seconds.low >>> 0,
                    message.nft_listing_cancel_required_seconds.high >>> 0,
                  ).toNumber(true)
                : message.nft_listing_cancel_required_seconds;
        if (message.bid_cancel_required_seconds != null && message.hasOwnProperty('bid_cancel_required_seconds'))
          if (typeof message.bid_cancel_required_seconds === 'number')
            object.bid_cancel_required_seconds =
              options.longs === String ? String(message.bid_cancel_required_seconds) : message.bid_cancel_required_seconds;
          else
            object.bid_cancel_required_seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.bid_cancel_required_seconds)
                : options.longs === Number
                ? new $util.LongBits(
                    message.bid_cancel_required_seconds.low >>> 0,
                    message.bid_cancel_required_seconds.high >>> 0,
                  ).toNumber(true)
                : message.bid_cancel_required_seconds;
        if (message.nft_listing_full_payment_period != null && message.hasOwnProperty('nft_listing_full_payment_period'))
          if (typeof message.nft_listing_full_payment_period === 'number')
            object.nft_listing_full_payment_period =
              options.longs === String ? String(message.nft_listing_full_payment_period) : message.nft_listing_full_payment_period;
          else
            object.nft_listing_full_payment_period =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_full_payment_period)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_listing_full_payment_period.low >>> 0,
                    message.nft_listing_full_payment_period.high >>> 0,
                  ).toNumber(true)
                : message.nft_listing_full_payment_period;
        if (message.nft_listing_nft_delivery_period != null && message.hasOwnProperty('nft_listing_nft_delivery_period'))
          if (typeof message.nft_listing_nft_delivery_period === 'number')
            object.nft_listing_nft_delivery_period =
              options.longs === String ? String(message.nft_listing_nft_delivery_period) : message.nft_listing_nft_delivery_period;
          else
            object.nft_listing_nft_delivery_period =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_listing_nft_delivery_period)
                : options.longs === Number
                ? new $util.LongBits(
                    message.nft_listing_nft_delivery_period.low >>> 0,
                    message.nft_listing_nft_delivery_period.high >>> 0,
                  ).toNumber(true)
                : message.nft_listing_nft_delivery_period;
        if (message.nft_listing_commission_rate != null && message.hasOwnProperty('nft_listing_commission_rate'))
          object.nft_listing_commission_rate = message.nft_listing_commission_rate;
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    nftbackedloan.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#params}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.nftbackedloan.QueryParamsRequest,
            $root.ununifi.nftbackedloan.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#listedNfts}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef ListedNftsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryListedNftsResponse} [response] QueryListedNftsResponse
       */

      /**
       * Calls ListedNfts.
       * @function listedNfts
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.ListedNftsCallback} callback Node-style callback called with the error, if any, and QueryListedNftsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.listedNfts = function listedNfts(request, callback) {
          return this.rpcCall(
            listedNfts,
            $root.ununifi.nftbackedloan.QueryListedNftsRequest,
            $root.ununifi.nftbackedloan.QueryListedNftsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListedNfts' },
      );

      /**
       * Calls ListedNfts.
       * @function listedNfts
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} request QueryListedNftsRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryListedNftsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#listedNft}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef ListedNftCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryListedNftResponse} [response] QueryListedNftResponse
       */

      /**
       * Calls ListedNft.
       * @function listedNft
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedNftRequest} request QueryListedNftRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.ListedNftCallback} callback Node-style callback called with the error, if any, and QueryListedNftResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.listedNft = function listedNft(request, callback) {
          return this.rpcCall(
            listedNft,
            $root.ununifi.nftbackedloan.QueryListedNftRequest,
            $root.ununifi.nftbackedloan.QueryListedNftResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListedNft' },
      );

      /**
       * Calls ListedNft.
       * @function listedNft
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedNftRequest} request QueryListedNftRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryListedNftResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#listedClasses}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef ListedClassesCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryListedClassesResponse} [response] QueryListedClassesResponse
       */

      /**
       * Calls ListedClasses.
       * @function listedClasses
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.ListedClassesCallback} callback Node-style callback called with the error, if any, and QueryListedClassesResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.listedClasses = function listedClasses(request, callback) {
          return this.rpcCall(
            listedClasses,
            $root.ununifi.nftbackedloan.QueryListedClassesRequest,
            $root.ununifi.nftbackedloan.QueryListedClassesResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListedClasses' },
      );

      /**
       * Calls ListedClasses.
       * @function listedClasses
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} request QueryListedClassesRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryListedClassesResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#listedClass}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef ListedClassCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryListedClassResponse} [response] QueryListedClassResponse
       */

      /**
       * Calls ListedClass.
       * @function listedClass
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.ListedClassCallback} callback Node-style callback called with the error, if any, and QueryListedClassResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.listedClass = function listedClass(request, callback) {
          return this.rpcCall(
            listedClass,
            $root.ununifi.nftbackedloan.QueryListedClassRequest,
            $root.ununifi.nftbackedloan.QueryListedClassResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ListedClass' },
      );

      /**
       * Calls ListedClass.
       * @function listedClass
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryListedClassRequest} request QueryListedClassRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryListedClassResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#loan}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef LoanCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryLoanResponse} [response] QueryLoanResponse
       */

      /**
       * Calls Loan.
       * @function loan
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryLoanRequest} request QueryLoanRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.LoanCallback} callback Node-style callback called with the error, if any, and QueryLoanResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.loan = function loan(request, callback) {
          return this.rpcCall(
            loan,
            $root.ununifi.nftbackedloan.QueryLoanRequest,
            $root.ununifi.nftbackedloan.QueryLoanResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Loan' },
      );

      /**
       * Calls Loan.
       * @function loan
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryLoanRequest} request QueryLoanRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryLoanResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#nftBids}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef NftBidsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryNftBidsResponse} [response] QueryNftBidsResponse
       */

      /**
       * Calls NftBids.
       * @function nftBids
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.NftBidsCallback} callback Node-style callback called with the error, if any, and QueryNftBidsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.nftBids = function nftBids(request, callback) {
          return this.rpcCall(
            nftBids,
            $root.ununifi.nftbackedloan.QueryNftBidsRequest,
            $root.ununifi.nftbackedloan.QueryNftBidsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'NftBids' },
      );

      /**
       * Calls NftBids.
       * @function nftBids
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} request QueryNftBidsRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryNftBidsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#bidderBids}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef BidderBidsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryBidderBidsResponse} [response] QueryBidderBidsResponse
       */

      /**
       * Calls BidderBids.
       * @function bidderBids
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.BidderBidsCallback} callback Node-style callback called with the error, if any, and QueryBidderBidsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.bidderBids = function bidderBids(request, callback) {
          return this.rpcCall(
            bidderBids,
            $root.ununifi.nftbackedloan.QueryBidderBidsRequest,
            $root.ununifi.nftbackedloan.QueryBidderBidsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'BidderBids' },
      );

      /**
       * Calls BidderBids.
       * @function bidderBids
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} request QueryBidderBidsRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryBidderBidsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#rewards}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef RewardsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryRewardsResponse} [response] QueryRewardsResponse
       */

      /**
       * Calls Rewards.
       * @function rewards
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.RewardsCallback} callback Node-style callback called with the error, if any, and QueryRewardsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.rewards = function rewards(request, callback) {
          return this.rpcCall(
            rewards,
            $root.ununifi.nftbackedloan.QueryRewardsRequest,
            $root.ununifi.nftbackedloan.QueryRewardsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Rewards' },
      );

      /**
       * Calls Rewards.
       * @function rewards
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryRewardsRequest} request QueryRewardsRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryRewardsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftbackedloan.Query#liquidation}.
       * @memberof ununifi.nftbackedloan.Query
       * @typedef LiquidationCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftbackedloan.QueryLiquidationResponse} [response] QueryLiquidationResponse
       */

      /**
       * Calls Liquidation.
       * @function liquidation
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} request QueryLiquidationRequest message or plain object
       * @param {ununifi.nftbackedloan.Query.LiquidationCallback} callback Node-style callback called with the error, if any, and QueryLiquidationResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.liquidation = function liquidation(request, callback) {
          return this.rpcCall(
            liquidation,
            $root.ununifi.nftbackedloan.QueryLiquidationRequest,
            $root.ununifi.nftbackedloan.QueryLiquidationResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Liquidation' },
      );

      /**
       * Calls Liquidation.
       * @function liquidation
       * @memberof ununifi.nftbackedloan.Query
       * @instance
       * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} request QueryLiquidationRequest message or plain object
       * @returns {Promise<ununifi.nftbackedloan.QueryLiquidationResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    nftbackedloan.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryParamsRequest) return object;
        return new $root.ununifi.nftbackedloan.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    nftbackedloan.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryParamsResponse
       * @property {ununifi.nftbackedloan.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.nftbackedloan.IParams|null|undefined} params
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftbackedloan.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftbackedloan.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftbackedloan.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryParamsResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftbackedloan.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.nftbackedloan.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftbackedloan.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    nftbackedloan.QueryListedNftRequest = (function () {
      /**
       * Properties of a QueryListedNftRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedNftRequest
       * @property {string|null} [class_id] QueryListedNftRequest class_id
       * @property {string|null} [token_id] QueryListedNftRequest token_id
       */

      /**
       * Constructs a new QueryListedNftRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedNftRequest.
       * @implements IQueryListedNftRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedNftRequest=} [properties] Properties to set
       */
      function QueryListedNftRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedNftRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @instance
       */
      QueryListedNftRequest.prototype.class_id = '';

      /**
       * QueryListedNftRequest token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @instance
       */
      QueryListedNftRequest.prototype.token_id = '';

      /**
       * Encodes the specified QueryListedNftRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftRequest} message QueryListedNftRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified QueryListedNftRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftRequest} message QueryListedNftRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedNftRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedNftRequest} QueryListedNftRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedNftRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedNftRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedNftRequest} QueryListedNftRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedNftRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedNftRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates a QueryListedNftRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedNftRequest} QueryListedNftRequest
       */
      QueryListedNftRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedNftRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedNftRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryListedNftRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryListedNftRequest} message QueryListedNftRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedNftRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.token_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this QueryListedNftRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedNftRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedNftRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedNftRequest;
    })();

    nftbackedloan.QueryListedNftResponse = (function () {
      /**
       * Properties of a QueryListedNftResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedNftResponse
       * @property {ununifi.nftbackedloan.IListing|null} [listing] QueryListedNftResponse listing
       */

      /**
       * Constructs a new QueryListedNftResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedNftResponse.
       * @implements IQueryListedNftResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedNftResponse=} [properties] Properties to set
       */
      function QueryListedNftResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedNftResponse listing.
       * @member {ununifi.nftbackedloan.IListing|null|undefined} listing
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @instance
       */
      QueryListedNftResponse.prototype.listing = null;

      /**
       * Encodes the specified QueryListedNftResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftResponse} message QueryListedNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.listing != null && Object.hasOwnProperty.call(message, 'listing'))
          $root.ununifi.nftbackedloan.Listing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryListedNftResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftResponse} message QueryListedNftResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedNftResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedNftResponse} QueryListedNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedNftResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.listing = $root.ununifi.nftbackedloan.Listing.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedNftResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedNftResponse} QueryListedNftResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedNftResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedNftResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.listing != null && message.hasOwnProperty('listing')) {
          let error = $root.ununifi.nftbackedloan.Listing.verify(message.listing);
          if (error) return 'listing.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryListedNftResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedNftResponse} QueryListedNftResponse
       */
      QueryListedNftResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedNftResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedNftResponse();
        if (object.listing != null) {
          if (typeof object.listing !== 'object') throw TypeError('.ununifi.nftbackedloan.QueryListedNftResponse.listing: object expected');
          message.listing = $root.ununifi.nftbackedloan.Listing.fromObject(object.listing);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryListedNftResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryListedNftResponse} message QueryListedNftResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedNftResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.listing = null;
        if (message.listing != null && message.hasOwnProperty('listing'))
          object.listing = $root.ununifi.nftbackedloan.Listing.toObject(message.listing, options);
        return object;
      };

      /**
       * Converts this QueryListedNftResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedNftResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedNftResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedNftResponse;
    })();

    nftbackedloan.QueryListedNftsRequest = (function () {
      /**
       * Properties of a QueryListedNftsRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedNftsRequest
       * @property {string|null} [owner] QueryListedNftsRequest owner
       */

      /**
       * Constructs a new QueryListedNftsRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedNftsRequest.
       * @implements IQueryListedNftsRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedNftsRequest=} [properties] Properties to set
       */
      function QueryListedNftsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedNftsRequest owner.
       * @member {string} owner
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @instance
       */
      QueryListedNftsRequest.prototype.owner = '';

      /**
       * Encodes the specified QueryListedNftsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.owner);
        return writer;
      };

      /**
       * Encodes the specified QueryListedNftsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftsRequest} message QueryListedNftsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedNftsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedNftsRequest} QueryListedNftsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedNftsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.owner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedNftsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedNftsRequest} QueryListedNftsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedNftsRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedNftsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        return null;
      };

      /**
       * Creates a QueryListedNftsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedNftsRequest} QueryListedNftsRequest
       */
      QueryListedNftsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedNftsRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedNftsRequest();
        if (object.owner != null) message.owner = String(object.owner);
        return message;
      };

      /**
       * Creates a plain object from a QueryListedNftsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryListedNftsRequest} message QueryListedNftsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedNftsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.owner = '';
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        return object;
      };

      /**
       * Converts this QueryListedNftsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedNftsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedNftsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedNftsRequest;
    })();

    nftbackedloan.QueryListedClassesRequest = (function () {
      /**
       * Properties of a QueryListedClassesRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedClassesRequest
       * @property {number|null} [nft_limit] QueryListedClassesRequest nft_limit
       */

      /**
       * Constructs a new QueryListedClassesRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedClassesRequest.
       * @implements IQueryListedClassesRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedClassesRequest=} [properties] Properties to set
       */
      function QueryListedClassesRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassesRequest nft_limit.
       * @member {number} nft_limit
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @instance
       */
      QueryListedClassesRequest.prototype.nft_limit = 0;

      /**
       * Encodes the specified QueryListedClassesRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_limit != null && Object.hasOwnProperty.call(message, 'nft_limit'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.nft_limit);
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassesRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassesRequest} message QueryListedClassesRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassesRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedClassesRequest} QueryListedClassesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedClassesRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_limit = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassesRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedClassesRequest} QueryListedClassesRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassesRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassesRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit'))
          if (!$util.isInteger(message.nft_limit)) return 'nft_limit: integer expected';
        return null;
      };

      /**
       * Creates a QueryListedClassesRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedClassesRequest} QueryListedClassesRequest
       */
      QueryListedClassesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassesRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedClassesRequest();
        if (object.nft_limit != null) message.nft_limit = object.nft_limit | 0;
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassesRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryListedClassesRequest} message QueryListedClassesRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassesRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.nft_limit = 0;
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit')) object.nft_limit = message.nft_limit;
        return object;
      };

      /**
       * Converts this QueryListedClassesRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedClassesRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassesRequest;
    })();

    nftbackedloan.QueryListedClassRequest = (function () {
      /**
       * Properties of a QueryListedClassRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedClassRequest
       * @property {string|null} [class_id] QueryListedClassRequest class_id
       * @property {number|null} [nft_limit] QueryListedClassRequest nft_limit
       */

      /**
       * Constructs a new QueryListedClassRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedClassRequest.
       * @implements IQueryListedClassRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedClassRequest=} [properties] Properties to set
       */
      function QueryListedClassRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @instance
       */
      QueryListedClassRequest.prototype.class_id = '';

      /**
       * QueryListedClassRequest nft_limit.
       * @member {number} nft_limit
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @instance
       */
      QueryListedClassRequest.prototype.nft_limit = 0;

      /**
       * Encodes the specified QueryListedClassRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.nft_limit != null && Object.hasOwnProperty.call(message, 'nft_limit'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nft_limit);
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassRequest} message QueryListedClassRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedClassRequest} QueryListedClassRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedClassRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.nft_limit = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedClassRequest} QueryListedClassRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit'))
          if (!$util.isInteger(message.nft_limit)) return 'nft_limit: integer expected';
        return null;
      };

      /**
       * Creates a QueryListedClassRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedClassRequest} QueryListedClassRequest
       */
      QueryListedClassRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedClassRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.nft_limit != null) message.nft_limit = object.nft_limit | 0;
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryListedClassRequest} message QueryListedClassRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.nft_limit = 0;
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.nft_limit != null && message.hasOwnProperty('nft_limit')) object.nft_limit = message.nft_limit;
        return object;
      };

      /**
       * Converts this QueryListedClassRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedClassRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassRequest;
    })();

    nftbackedloan.ListedNftDetail = (function () {
      /**
       * Properties of a ListedNftDetail.
       * @memberof ununifi.nftbackedloan
       * @interface IListedNftDetail
       * @property {ununifi.nftbackedloan.IListing|null} [listing] ListedNftDetail listing
       * @property {ununifi.nftbackedloan.INftInfo|null} [nft_info] ListedNftDetail nft_info
       */

      /**
       * Constructs a new ListedNftDetail.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a ListedNftDetail.
       * @implements IListedNftDetail
       * @constructor
       * @param {ununifi.nftbackedloan.IListedNftDetail=} [properties] Properties to set
       */
      function ListedNftDetail(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ListedNftDetail listing.
       * @member {ununifi.nftbackedloan.IListing|null|undefined} listing
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @instance
       */
      ListedNftDetail.prototype.listing = null;

      /**
       * ListedNftDetail nft_info.
       * @member {ununifi.nftbackedloan.INftInfo|null|undefined} nft_info
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @instance
       */
      ListedNftDetail.prototype.nft_info = null;

      /**
       * Encodes the specified ListedNftDetail message. Does not implicitly {@link ununifi.nftbackedloan.ListedNftDetail.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @static
       * @param {ununifi.nftbackedloan.IListedNftDetail} message ListedNftDetail message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedNftDetail.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.listing != null && Object.hasOwnProperty.call(message, 'listing'))
          $root.ununifi.nftbackedloan.Listing.encode(message.listing, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.nft_info != null && Object.hasOwnProperty.call(message, 'nft_info'))
          $root.ununifi.nftbackedloan.NftInfo.encode(message.nft_info, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified ListedNftDetail message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.ListedNftDetail.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @static
       * @param {ununifi.nftbackedloan.IListedNftDetail} message ListedNftDetail message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ListedNftDetail.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ListedNftDetail message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.ListedNftDetail} ListedNftDetail
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedNftDetail.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.ListedNftDetail();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.listing = $root.ununifi.nftbackedloan.Listing.decode(reader, reader.uint32());
              break;
            case 2:
              message.nft_info = $root.ununifi.nftbackedloan.NftInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ListedNftDetail message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.ListedNftDetail} ListedNftDetail
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ListedNftDetail.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ListedNftDetail message.
       * @function verify
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ListedNftDetail.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.listing != null && message.hasOwnProperty('listing')) {
          let error = $root.ununifi.nftbackedloan.Listing.verify(message.listing);
          if (error) return 'listing.' + error;
        }
        if (message.nft_info != null && message.hasOwnProperty('nft_info')) {
          let error = $root.ununifi.nftbackedloan.NftInfo.verify(message.nft_info);
          if (error) return 'nft_info.' + error;
        }
        return null;
      };

      /**
       * Creates a ListedNftDetail message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.ListedNftDetail} ListedNftDetail
       */
      ListedNftDetail.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.ListedNftDetail) return object;
        let message = new $root.ununifi.nftbackedloan.ListedNftDetail();
        if (object.listing != null) {
          if (typeof object.listing !== 'object') throw TypeError('.ununifi.nftbackedloan.ListedNftDetail.listing: object expected');
          message.listing = $root.ununifi.nftbackedloan.Listing.fromObject(object.listing);
        }
        if (object.nft_info != null) {
          if (typeof object.nft_info !== 'object') throw TypeError('.ununifi.nftbackedloan.ListedNftDetail.nft_info: object expected');
          message.nft_info = $root.ununifi.nftbackedloan.NftInfo.fromObject(object.nft_info);
        }
        return message;
      };

      /**
       * Creates a plain object from a ListedNftDetail message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @static
       * @param {ununifi.nftbackedloan.ListedNftDetail} message ListedNftDetail
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ListedNftDetail.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.listing = null;
          object.nft_info = null;
        }
        if (message.listing != null && message.hasOwnProperty('listing'))
          object.listing = $root.ununifi.nftbackedloan.Listing.toObject(message.listing, options);
        if (message.nft_info != null && message.hasOwnProperty('nft_info'))
          object.nft_info = $root.ununifi.nftbackedloan.NftInfo.toObject(message.nft_info, options);
        return object;
      };

      /**
       * Converts this ListedNftDetail to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.ListedNftDetail
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ListedNftDetail.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ListedNftDetail;
    })();

    nftbackedloan.QueryListedNftsResponse = (function () {
      /**
       * Properties of a QueryListedNftsResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedNftsResponse
       * @property {Array.<ununifi.nftbackedloan.IListedNftDetail>|null} [listings] QueryListedNftsResponse listings
       */

      /**
       * Constructs a new QueryListedNftsResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedNftsResponse.
       * @implements IQueryListedNftsResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedNftsResponse=} [properties] Properties to set
       */
      function QueryListedNftsResponse(properties) {
        this.listings = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedNftsResponse listings.
       * @member {Array.<ununifi.nftbackedloan.IListedNftDetail>} listings
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @instance
       */
      QueryListedNftsResponse.prototype.listings = $util.emptyArray;

      /**
       * Encodes the specified QueryListedNftsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.listings != null && message.listings.length)
          for (let i = 0; i < message.listings.length; ++i)
            $root.ununifi.nftbackedloan.ListedNftDetail.encode(
              message.listings[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryListedNftsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedNftsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedNftsResponse} message QueryListedNftsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedNftsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedNftsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedNftsResponse} QueryListedNftsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedNftsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.listings && message.listings.length)) message.listings = [];
              message.listings.push($root.ununifi.nftbackedloan.ListedNftDetail.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedNftsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedNftsResponse} QueryListedNftsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedNftsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedNftsResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedNftsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.listings != null && message.hasOwnProperty('listings')) {
          if (!Array.isArray(message.listings)) return 'listings: array expected';
          for (let i = 0; i < message.listings.length; ++i) {
            let error = $root.ununifi.nftbackedloan.ListedNftDetail.verify(message.listings[i]);
            if (error) return 'listings.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryListedNftsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedNftsResponse} QueryListedNftsResponse
       */
      QueryListedNftsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedNftsResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedNftsResponse();
        if (object.listings) {
          if (!Array.isArray(object.listings)) throw TypeError('.ununifi.nftbackedloan.QueryListedNftsResponse.listings: array expected');
          message.listings = [];
          for (let i = 0; i < object.listings.length; ++i) {
            if (typeof object.listings[i] !== 'object')
              throw TypeError('.ununifi.nftbackedloan.QueryListedNftsResponse.listings: object expected');
            message.listings[i] = $root.ununifi.nftbackedloan.ListedNftDetail.fromObject(object.listings[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryListedNftsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryListedNftsResponse} message QueryListedNftsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedNftsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.listings = [];
        if (message.listings && message.listings.length) {
          object.listings = [];
          for (let j = 0; j < message.listings.length; ++j)
            object.listings[j] = $root.ununifi.nftbackedloan.ListedNftDetail.toObject(message.listings[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryListedNftsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedNftsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedNftsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedNftsResponse;
    })();

    nftbackedloan.QueryListedClassesResponse = (function () {
      /**
       * Properties of a QueryListedClassesResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedClassesResponse
       * @property {Array.<ununifi.nftbackedloan.IQueryListedClassResponse>|null} [classes] QueryListedClassesResponse classes
       */

      /**
       * Constructs a new QueryListedClassesResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedClassesResponse.
       * @implements IQueryListedClassesResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedClassesResponse=} [properties] Properties to set
       */
      function QueryListedClassesResponse(properties) {
        this.classes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassesResponse classes.
       * @member {Array.<ununifi.nftbackedloan.IQueryListedClassResponse>} classes
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @instance
       */
      QueryListedClassesResponse.prototype.classes = $util.emptyArray;

      /**
       * Encodes the specified QueryListedClassesResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.classes != null && message.classes.length)
          for (let i = 0; i < message.classes.length; ++i)
            $root.ununifi.nftbackedloan.QueryListedClassResponse.encode(
              message.classes[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassesResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassesResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassesResponse} message QueryListedClassesResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassesResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedClassesResponse} QueryListedClassesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedClassesResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.classes && message.classes.length)) message.classes = [];
              message.classes.push($root.ununifi.nftbackedloan.QueryListedClassResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassesResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedClassesResponse} QueryListedClassesResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassesResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassesResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.classes != null && message.hasOwnProperty('classes')) {
          if (!Array.isArray(message.classes)) return 'classes: array expected';
          for (let i = 0; i < message.classes.length; ++i) {
            let error = $root.ununifi.nftbackedloan.QueryListedClassResponse.verify(message.classes[i]);
            if (error) return 'classes.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryListedClassesResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedClassesResponse} QueryListedClassesResponse
       */
      QueryListedClassesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassesResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedClassesResponse();
        if (object.classes) {
          if (!Array.isArray(object.classes)) throw TypeError('.ununifi.nftbackedloan.QueryListedClassesResponse.classes: array expected');
          message.classes = [];
          for (let i = 0; i < object.classes.length; ++i) {
            if (typeof object.classes[i] !== 'object')
              throw TypeError('.ununifi.nftbackedloan.QueryListedClassesResponse.classes: object expected');
            message.classes[i] = $root.ununifi.nftbackedloan.QueryListedClassResponse.fromObject(object.classes[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassesResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryListedClassesResponse} message QueryListedClassesResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassesResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.classes = [];
        if (message.classes && message.classes.length) {
          object.classes = [];
          for (let j = 0; j < message.classes.length; ++j)
            object.classes[j] = $root.ununifi.nftbackedloan.QueryListedClassResponse.toObject(message.classes[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryListedClassesResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedClassesResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassesResponse;
    })();

    nftbackedloan.QueryListedClassResponse = (function () {
      /**
       * Properties of a QueryListedClassResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryListedClassResponse
       * @property {string|null} [class_id] QueryListedClassResponse class_id
       * @property {string|null} [name] QueryListedClassResponse name
       * @property {string|null} [description] QueryListedClassResponse description
       * @property {string|null} [symbol] QueryListedClassResponse symbol
       * @property {string|null} [uri] QueryListedClassResponse uri
       * @property {string|null} [urihash] QueryListedClassResponse urihash
       * @property {Array.<ununifi.nftbackedloan.INftInfo>|null} [nfts] QueryListedClassResponse nfts
       * @property {Long|null} [nft_count] QueryListedClassResponse nft_count
       */

      /**
       * Constructs a new QueryListedClassResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryListedClassResponse.
       * @implements IQueryListedClassResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryListedClassResponse=} [properties] Properties to set
       */
      function QueryListedClassResponse(properties) {
        this.nfts = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryListedClassResponse class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.class_id = '';

      /**
       * QueryListedClassResponse name.
       * @member {string} name
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.name = '';

      /**
       * QueryListedClassResponse description.
       * @member {string} description
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.description = '';

      /**
       * QueryListedClassResponse symbol.
       * @member {string} symbol
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.symbol = '';

      /**
       * QueryListedClassResponse uri.
       * @member {string} uri
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.uri = '';

      /**
       * QueryListedClassResponse urihash.
       * @member {string} urihash
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.urihash = '';

      /**
       * QueryListedClassResponse nfts.
       * @member {Array.<ununifi.nftbackedloan.INftInfo>} nfts
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.nfts = $util.emptyArray;

      /**
       * QueryListedClassResponse nft_count.
       * @member {Long} nft_count
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       */
      QueryListedClassResponse.prototype.nft_count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryListedClassResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.description);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.symbol);
        if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.uri);
        if (message.urihash != null && Object.hasOwnProperty.call(message, 'urihash'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.urihash);
        if (message.nfts != null && message.nfts.length)
          for (let i = 0; i < message.nfts.length; ++i)
            $root.ununifi.nftbackedloan.NftInfo.encode(message.nfts[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.nft_count != null && Object.hasOwnProperty.call(message, 'nft_count'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).uint64(message.nft_count);
        return writer;
      };

      /**
       * Encodes the specified QueryListedClassResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryListedClassResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryListedClassResponse} message QueryListedClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryListedClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryListedClassResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryListedClassResponse} QueryListedClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryListedClassResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.description = reader.string();
              break;
            case 4:
              message.symbol = reader.string();
              break;
            case 5:
              message.uri = reader.string();
              break;
            case 6:
              message.urihash = reader.string();
              break;
            case 7:
              if (!(message.nfts && message.nfts.length)) message.nfts = [];
              message.nfts.push($root.ununifi.nftbackedloan.NftInfo.decode(reader, reader.uint32()));
              break;
            case 8:
              message.nft_count = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryListedClassResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryListedClassResponse} QueryListedClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryListedClassResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryListedClassResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryListedClassResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
        if (message.urihash != null && message.hasOwnProperty('urihash'))
          if (!$util.isString(message.urihash)) return 'urihash: string expected';
        if (message.nfts != null && message.hasOwnProperty('nfts')) {
          if (!Array.isArray(message.nfts)) return 'nfts: array expected';
          for (let i = 0; i < message.nfts.length; ++i) {
            let error = $root.ununifi.nftbackedloan.NftInfo.verify(message.nfts[i]);
            if (error) return 'nfts.' + error;
          }
        }
        if (message.nft_count != null && message.hasOwnProperty('nft_count'))
          if (
            !$util.isInteger(message.nft_count) &&
            !(message.nft_count && $util.isInteger(message.nft_count.low) && $util.isInteger(message.nft_count.high))
          )
            return 'nft_count: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryListedClassResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryListedClassResponse} QueryListedClassResponse
       */
      QueryListedClassResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryListedClassResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryListedClassResponse();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.uri != null) message.uri = String(object.uri);
        if (object.urihash != null) message.urihash = String(object.urihash);
        if (object.nfts) {
          if (!Array.isArray(object.nfts)) throw TypeError('.ununifi.nftbackedloan.QueryListedClassResponse.nfts: array expected');
          message.nfts = [];
          for (let i = 0; i < object.nfts.length; ++i) {
            if (typeof object.nfts[i] !== 'object')
              throw TypeError('.ununifi.nftbackedloan.QueryListedClassResponse.nfts: object expected');
            message.nfts[i] = $root.ununifi.nftbackedloan.NftInfo.fromObject(object.nfts[i]);
          }
        }
        if (object.nft_count != null)
          if ($util.Long) (message.nft_count = $util.Long.fromValue(object.nft_count)).unsigned = true;
          else if (typeof object.nft_count === 'string') message.nft_count = parseInt(object.nft_count, 10);
          else if (typeof object.nft_count === 'number') message.nft_count = object.nft_count;
          else if (typeof object.nft_count === 'object')
            message.nft_count = new $util.LongBits(object.nft_count.low >>> 0, object.nft_count.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryListedClassResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryListedClassResponse} message QueryListedClassResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryListedClassResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.nfts = [];
        if (options.defaults) {
          object.class_id = '';
          object.name = '';
          object.description = '';
          object.symbol = '';
          object.uri = '';
          object.urihash = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.nft_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.nft_count = options.longs === String ? '0' : 0;
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
        if (message.urihash != null && message.hasOwnProperty('urihash')) object.urihash = message.urihash;
        if (message.nfts && message.nfts.length) {
          object.nfts = [];
          for (let j = 0; j < message.nfts.length; ++j)
            object.nfts[j] = $root.ununifi.nftbackedloan.NftInfo.toObject(message.nfts[j], options);
        }
        if (message.nft_count != null && message.hasOwnProperty('nft_count'))
          if (typeof message.nft_count === 'number')
            object.nft_count = options.longs === String ? String(message.nft_count) : message.nft_count;
          else
            object.nft_count =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.nft_count)
                : options.longs === Number
                ? new $util.LongBits(message.nft_count.low >>> 0, message.nft_count.high >>> 0).toNumber(true)
                : message.nft_count;
        return object;
      };

      /**
       * Converts this QueryListedClassResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryListedClassResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryListedClassResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryListedClassResponse;
    })();

    nftbackedloan.QueryLoanRequest = (function () {
      /**
       * Properties of a QueryLoanRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryLoanRequest
       * @property {string|null} [class_id] QueryLoanRequest class_id
       * @property {string|null} [token_id] QueryLoanRequest token_id
       */

      /**
       * Constructs a new QueryLoanRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryLoanRequest.
       * @implements IQueryLoanRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryLoanRequest=} [properties] Properties to set
       */
      function QueryLoanRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLoanRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @instance
       */
      QueryLoanRequest.prototype.class_id = '';

      /**
       * QueryLoanRequest token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @instance
       */
      QueryLoanRequest.prototype.token_id = '';

      /**
       * Encodes the specified QueryLoanRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified QueryLoanRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryLoanRequest} message QueryLoanRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLoanRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryLoanRequest} QueryLoanRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryLoanRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLoanRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryLoanRequest} QueryLoanRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLoanRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLoanRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates a QueryLoanRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryLoanRequest} QueryLoanRequest
       */
      QueryLoanRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryLoanRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryLoanRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryLoanRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryLoanRequest} message QueryLoanRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLoanRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.token_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this QueryLoanRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryLoanRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLoanRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLoanRequest;
    })();

    nftbackedloan.QueryLoanResponse = (function () {
      /**
       * Properties of a QueryLoanResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryLoanResponse
       * @property {ununifi.nftbackedloan.INftId|null} [nft_id] QueryLoanResponse nft_id
       * @property {cosmos.base.v1beta1.ICoin|null} [borrowing_amount] QueryLoanResponse borrowing_amount
       * @property {cosmos.base.v1beta1.ICoin|null} [borrowing_limit] QueryLoanResponse borrowing_limit
       * @property {cosmos.base.v1beta1.ICoin|null} [total_deposit] QueryLoanResponse total_deposit
       */

      /**
       * Constructs a new QueryLoanResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryLoanResponse.
       * @implements IQueryLoanResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryLoanResponse=} [properties] Properties to set
       */
      function QueryLoanResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLoanResponse nft_id.
       * @member {ununifi.nftbackedloan.INftId|null|undefined} nft_id
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @instance
       */
      QueryLoanResponse.prototype.nft_id = null;

      /**
       * QueryLoanResponse borrowing_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} borrowing_amount
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @instance
       */
      QueryLoanResponse.prototype.borrowing_amount = null;

      /**
       * QueryLoanResponse borrowing_limit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} borrowing_limit
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @instance
       */
      QueryLoanResponse.prototype.borrowing_limit = null;

      /**
       * QueryLoanResponse total_deposit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} total_deposit
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @instance
       */
      QueryLoanResponse.prototype.total_deposit = null;

      /**
       * Encodes the specified QueryLoanResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.nft_id != null && Object.hasOwnProperty.call(message, 'nft_id'))
          $root.ununifi.nftbackedloan.NftId.encode(message.nft_id, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.borrowing_amount != null && Object.hasOwnProperty.call(message, 'borrowing_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.borrowing_amount, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.borrowing_limit != null && Object.hasOwnProperty.call(message, 'borrowing_limit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.borrowing_limit, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.total_deposit != null && Object.hasOwnProperty.call(message, 'total_deposit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.total_deposit, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLoanResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLoanResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryLoanResponse} message QueryLoanResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLoanResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLoanResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryLoanResponse} QueryLoanResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryLoanResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nft_id = $root.ununifi.nftbackedloan.NftId.decode(reader, reader.uint32());
              break;
            case 2:
              message.borrowing_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.borrowing_limit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.total_deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLoanResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryLoanResponse} QueryLoanResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLoanResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLoanResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLoanResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.nft_id != null && message.hasOwnProperty('nft_id')) {
          let error = $root.ununifi.nftbackedloan.NftId.verify(message.nft_id);
          if (error) return 'nft_id.' + error;
        }
        if (message.borrowing_amount != null && message.hasOwnProperty('borrowing_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.borrowing_amount);
          if (error) return 'borrowing_amount.' + error;
        }
        if (message.borrowing_limit != null && message.hasOwnProperty('borrowing_limit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.borrowing_limit);
          if (error) return 'borrowing_limit.' + error;
        }
        if (message.total_deposit != null && message.hasOwnProperty('total_deposit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.total_deposit);
          if (error) return 'total_deposit.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryLoanResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryLoanResponse} QueryLoanResponse
       */
      QueryLoanResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryLoanResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryLoanResponse();
        if (object.nft_id != null) {
          if (typeof object.nft_id !== 'object') throw TypeError('.ununifi.nftbackedloan.QueryLoanResponse.nft_id: object expected');
          message.nft_id = $root.ununifi.nftbackedloan.NftId.fromObject(object.nft_id);
        }
        if (object.borrowing_amount != null) {
          if (typeof object.borrowing_amount !== 'object')
            throw TypeError('.ununifi.nftbackedloan.QueryLoanResponse.borrowing_amount: object expected');
          message.borrowing_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.borrowing_amount);
        }
        if (object.borrowing_limit != null) {
          if (typeof object.borrowing_limit !== 'object')
            throw TypeError('.ununifi.nftbackedloan.QueryLoanResponse.borrowing_limit: object expected');
          message.borrowing_limit = $root.cosmos.base.v1beta1.Coin.fromObject(object.borrowing_limit);
        }
        if (object.total_deposit != null) {
          if (typeof object.total_deposit !== 'object')
            throw TypeError('.ununifi.nftbackedloan.QueryLoanResponse.total_deposit: object expected');
          message.total_deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.total_deposit);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLoanResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryLoanResponse} message QueryLoanResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLoanResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.nft_id = null;
          object.borrowing_amount = null;
          object.borrowing_limit = null;
          object.total_deposit = null;
        }
        if (message.nft_id != null && message.hasOwnProperty('nft_id'))
          object.nft_id = $root.ununifi.nftbackedloan.NftId.toObject(message.nft_id, options);
        if (message.borrowing_amount != null && message.hasOwnProperty('borrowing_amount'))
          object.borrowing_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.borrowing_amount, options);
        if (message.borrowing_limit != null && message.hasOwnProperty('borrowing_limit'))
          object.borrowing_limit = $root.cosmos.base.v1beta1.Coin.toObject(message.borrowing_limit, options);
        if (message.total_deposit != null && message.hasOwnProperty('total_deposit'))
          object.total_deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.total_deposit, options);
        return object;
      };

      /**
       * Converts this QueryLoanResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryLoanResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLoanResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLoanResponse;
    })();

    nftbackedloan.QueryNftBidsRequest = (function () {
      /**
       * Properties of a QueryNftBidsRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryNftBidsRequest
       * @property {string|null} [class_id] QueryNftBidsRequest class_id
       * @property {string|null} [token_id] QueryNftBidsRequest token_id
       */

      /**
       * Constructs a new QueryNftBidsRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryNftBidsRequest.
       * @implements IQueryNftBidsRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryNftBidsRequest=} [properties] Properties to set
       */
      function QueryNftBidsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNftBidsRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @instance
       */
      QueryNftBidsRequest.prototype.class_id = '';

      /**
       * QueryNftBidsRequest token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @instance
       */
      QueryNftBidsRequest.prototype.token_id = '';

      /**
       * Encodes the specified QueryNftBidsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified QueryNftBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryNftBidsRequest} message QueryNftBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNftBidsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryNftBidsRequest} QueryNftBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryNftBidsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNftBidsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryNftBidsRequest} QueryNftBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNftBidsRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNftBidsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates a QueryNftBidsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryNftBidsRequest} QueryNftBidsRequest
       */
      QueryNftBidsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryNftBidsRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryNftBidsRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryNftBidsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryNftBidsRequest} message QueryNftBidsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNftBidsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.token_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this QueryNftBidsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryNftBidsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNftBidsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNftBidsRequest;
    })();

    nftbackedloan.QueryNftBidsResponse = (function () {
      /**
       * Properties of a QueryNftBidsResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryNftBidsResponse
       * @property {Array.<ununifi.nftbackedloan.IBid>|null} [bids] QueryNftBidsResponse bids
       */

      /**
       * Constructs a new QueryNftBidsResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryNftBidsResponse.
       * @implements IQueryNftBidsResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryNftBidsResponse=} [properties] Properties to set
       */
      function QueryNftBidsResponse(properties) {
        this.bids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryNftBidsResponse bids.
       * @member {Array.<ununifi.nftbackedloan.IBid>} bids
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @instance
       */
      QueryNftBidsResponse.prototype.bids = $util.emptyArray;

      /**
       * Encodes the specified QueryNftBidsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bids != null && message.bids.length)
          for (let i = 0; i < message.bids.length; ++i)
            $root.ununifi.nftbackedloan.Bid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryNftBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryNftBidsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryNftBidsResponse} message QueryNftBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryNftBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryNftBidsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryNftBidsResponse} QueryNftBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryNftBidsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.bids && message.bids.length)) message.bids = [];
              message.bids.push($root.ununifi.nftbackedloan.Bid.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryNftBidsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryNftBidsResponse} QueryNftBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryNftBidsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryNftBidsResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryNftBidsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bids != null && message.hasOwnProperty('bids')) {
          if (!Array.isArray(message.bids)) return 'bids: array expected';
          for (let i = 0; i < message.bids.length; ++i) {
            let error = $root.ununifi.nftbackedloan.Bid.verify(message.bids[i]);
            if (error) return 'bids.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryNftBidsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryNftBidsResponse} QueryNftBidsResponse
       */
      QueryNftBidsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryNftBidsResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryNftBidsResponse();
        if (object.bids) {
          if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftbackedloan.QueryNftBidsResponse.bids: array expected');
          message.bids = [];
          for (let i = 0; i < object.bids.length; ++i) {
            if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftbackedloan.QueryNftBidsResponse.bids: object expected');
            message.bids[i] = $root.ununifi.nftbackedloan.Bid.fromObject(object.bids[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryNftBidsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryNftBidsResponse} message QueryNftBidsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryNftBidsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.bids = [];
        if (message.bids && message.bids.length) {
          object.bids = [];
          for (let j = 0; j < message.bids.length; ++j) object.bids[j] = $root.ununifi.nftbackedloan.Bid.toObject(message.bids[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryNftBidsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryNftBidsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryNftBidsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryNftBidsResponse;
    })();

    nftbackedloan.QueryBidderBidsRequest = (function () {
      /**
       * Properties of a QueryBidderBidsRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryBidderBidsRequest
       * @property {string|null} [bidder] QueryBidderBidsRequest bidder
       */

      /**
       * Constructs a new QueryBidderBidsRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryBidderBidsRequest.
       * @implements IQueryBidderBidsRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest=} [properties] Properties to set
       */
      function QueryBidderBidsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBidderBidsRequest bidder.
       * @member {string} bidder
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @instance
       */
      QueryBidderBidsRequest.prototype.bidder = '';

      /**
       * Encodes the specified QueryBidderBidsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bidder != null && Object.hasOwnProperty.call(message, 'bidder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.bidder);
        return writer;
      };

      /**
       * Encodes the specified QueryBidderBidsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryBidderBidsRequest} message QueryBidderBidsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBidderBidsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryBidderBidsRequest} QueryBidderBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryBidderBidsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bidder = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBidderBidsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryBidderBidsRequest} QueryBidderBidsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBidderBidsRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBidderBidsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bidder != null && message.hasOwnProperty('bidder'))
          if (!$util.isString(message.bidder)) return 'bidder: string expected';
        return null;
      };

      /**
       * Creates a QueryBidderBidsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryBidderBidsRequest} QueryBidderBidsRequest
       */
      QueryBidderBidsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryBidderBidsRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryBidderBidsRequest();
        if (object.bidder != null) message.bidder = String(object.bidder);
        return message;
      };

      /**
       * Creates a plain object from a QueryBidderBidsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryBidderBidsRequest} message QueryBidderBidsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBidderBidsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.bidder = '';
        if (message.bidder != null && message.hasOwnProperty('bidder')) object.bidder = message.bidder;
        return object;
      };

      /**
       * Converts this QueryBidderBidsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryBidderBidsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBidderBidsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBidderBidsRequest;
    })();

    nftbackedloan.QueryBidderBidsResponse = (function () {
      /**
       * Properties of a QueryBidderBidsResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryBidderBidsResponse
       * @property {Array.<ununifi.nftbackedloan.IBid>|null} [bids] QueryBidderBidsResponse bids
       */

      /**
       * Constructs a new QueryBidderBidsResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryBidderBidsResponse.
       * @implements IQueryBidderBidsResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryBidderBidsResponse=} [properties] Properties to set
       */
      function QueryBidderBidsResponse(properties) {
        this.bids = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryBidderBidsResponse bids.
       * @member {Array.<ununifi.nftbackedloan.IBid>} bids
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @instance
       */
      QueryBidderBidsResponse.prototype.bids = $util.emptyArray;

      /**
       * Encodes the specified QueryBidderBidsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.bids != null && message.bids.length)
          for (let i = 0; i < message.bids.length; ++i)
            $root.ununifi.nftbackedloan.Bid.encode(message.bids[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryBidderBidsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryBidderBidsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryBidderBidsResponse} message QueryBidderBidsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryBidderBidsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryBidderBidsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryBidderBidsResponse} QueryBidderBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryBidderBidsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.bids && message.bids.length)) message.bids = [];
              message.bids.push($root.ununifi.nftbackedloan.Bid.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryBidderBidsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryBidderBidsResponse} QueryBidderBidsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryBidderBidsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryBidderBidsResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryBidderBidsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.bids != null && message.hasOwnProperty('bids')) {
          if (!Array.isArray(message.bids)) return 'bids: array expected';
          for (let i = 0; i < message.bids.length; ++i) {
            let error = $root.ununifi.nftbackedloan.Bid.verify(message.bids[i]);
            if (error) return 'bids.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryBidderBidsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryBidderBidsResponse} QueryBidderBidsResponse
       */
      QueryBidderBidsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryBidderBidsResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryBidderBidsResponse();
        if (object.bids) {
          if (!Array.isArray(object.bids)) throw TypeError('.ununifi.nftbackedloan.QueryBidderBidsResponse.bids: array expected');
          message.bids = [];
          for (let i = 0; i < object.bids.length; ++i) {
            if (typeof object.bids[i] !== 'object') throw TypeError('.ununifi.nftbackedloan.QueryBidderBidsResponse.bids: object expected');
            message.bids[i] = $root.ununifi.nftbackedloan.Bid.fromObject(object.bids[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryBidderBidsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryBidderBidsResponse} message QueryBidderBidsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryBidderBidsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.bids = [];
        if (message.bids && message.bids.length) {
          object.bids = [];
          for (let j = 0; j < message.bids.length; ++j) object.bids[j] = $root.ununifi.nftbackedloan.Bid.toObject(message.bids[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryBidderBidsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryBidderBidsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryBidderBidsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryBidderBidsResponse;
    })();

    nftbackedloan.QueryRewardsRequest = (function () {
      /**
       * Properties of a QueryRewardsRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryRewardsRequest
       * @property {Long|null} [address] QueryRewardsRequest address
       */

      /**
       * Constructs a new QueryRewardsRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryRewardsRequest.
       * @implements IQueryRewardsRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryRewardsRequest=} [properties] Properties to set
       */
      function QueryRewardsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRewardsRequest address.
       * @member {Long} address
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @instance
       */
      QueryRewardsRequest.prototype.address = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryRewardsRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.address);
        return writer;
      };

      /**
       * Encodes the specified QueryRewardsRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryRewardsRequest} message QueryRewardsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRewardsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryRewardsRequest} QueryRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryRewardsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRewardsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryRewardsRequest} QueryRewardsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRewardsRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRewardsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (
            !$util.isInteger(message.address) &&
            !(message.address && $util.isInteger(message.address.low) && $util.isInteger(message.address.high))
          )
            return 'address: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryRewardsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryRewardsRequest} QueryRewardsRequest
       */
      QueryRewardsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryRewardsRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryRewardsRequest();
        if (object.address != null)
          if ($util.Long) (message.address = $util.Long.fromValue(object.address)).unsigned = true;
          else if (typeof object.address === 'string') message.address = parseInt(object.address, 10);
          else if (typeof object.address === 'number') message.address = object.address;
          else if (typeof object.address === 'object')
            message.address = new $util.LongBits(object.address.low >>> 0, object.address.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryRewardsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryRewardsRequest} message QueryRewardsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRewardsRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.address = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.address = options.longs === String ? '0' : 0;
        if (message.address != null && message.hasOwnProperty('address'))
          if (typeof message.address === 'number') object.address = options.longs === String ? String(message.address) : message.address;
          else
            object.address =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.address)
                : options.longs === Number
                ? new $util.LongBits(message.address.low >>> 0, message.address.high >>> 0).toNumber(true)
                : message.address;
        return object;
      };

      /**
       * Converts this QueryRewardsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryRewardsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRewardsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRewardsRequest;
    })();

    nftbackedloan.QueryRewardsResponse = (function () {
      /**
       * Properties of a QueryRewardsResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryRewardsResponse
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [rewards] QueryRewardsResponse rewards
       */

      /**
       * Constructs a new QueryRewardsResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryRewardsResponse.
       * @implements IQueryRewardsResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryRewardsResponse=} [properties] Properties to set
       */
      function QueryRewardsResponse(properties) {
        this.rewards = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryRewardsResponse rewards.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} rewards
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @instance
       */
      QueryRewardsResponse.prototype.rewards = $util.emptyArray;

      /**
       * Encodes the specified QueryRewardsResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.rewards != null && message.rewards.length)
          for (let i = 0; i < message.rewards.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryRewardsResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryRewardsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryRewardsResponse} message QueryRewardsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryRewardsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryRewardsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryRewardsResponse} QueryRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryRewardsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.rewards && message.rewards.length)) message.rewards = [];
              message.rewards.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryRewardsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryRewardsResponse} QueryRewardsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryRewardsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryRewardsResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryRewardsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.rewards != null && message.hasOwnProperty('rewards')) {
          if (!Array.isArray(message.rewards)) return 'rewards: array expected';
          for (let i = 0; i < message.rewards.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.rewards[i]);
            if (error) return 'rewards.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryRewardsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryRewardsResponse} QueryRewardsResponse
       */
      QueryRewardsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryRewardsResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryRewardsResponse();
        if (object.rewards) {
          if (!Array.isArray(object.rewards)) throw TypeError('.ununifi.nftbackedloan.QueryRewardsResponse.rewards: array expected');
          message.rewards = [];
          for (let i = 0; i < object.rewards.length; ++i) {
            if (typeof object.rewards[i] !== 'object')
              throw TypeError('.ununifi.nftbackedloan.QueryRewardsResponse.rewards: object expected');
            message.rewards[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.rewards[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryRewardsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryRewardsResponse} message QueryRewardsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryRewardsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rewards = [];
        if (message.rewards && message.rewards.length) {
          object.rewards = [];
          for (let j = 0; j < message.rewards.length; ++j)
            object.rewards[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.rewards[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryRewardsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryRewardsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryRewardsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryRewardsResponse;
    })();

    nftbackedloan.QueryLiquidationRequest = (function () {
      /**
       * Properties of a QueryLiquidationRequest.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryLiquidationRequest
       * @property {string|null} [class_id] QueryLiquidationRequest class_id
       * @property {string|null} [token_id] QueryLiquidationRequest token_id
       */

      /**
       * Constructs a new QueryLiquidationRequest.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryLiquidationRequest.
       * @implements IQueryLiquidationRequest
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryLiquidationRequest=} [properties] Properties to set
       */
      function QueryLiquidationRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLiquidationRequest class_id.
       * @member {string} class_id
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @instance
       */
      QueryLiquidationRequest.prototype.class_id = '';

      /**
       * QueryLiquidationRequest token_id.
       * @member {string} token_id
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @instance
       */
      QueryLiquidationRequest.prototype.token_id = '';

      /**
       * Encodes the specified QueryLiquidationRequest message. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} message QueryLiquidationRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidationRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified QueryLiquidationRequest message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @static
       * @param {ununifi.nftbackedloan.IQueryLiquidationRequest} message QueryLiquidationRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLiquidationRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryLiquidationRequest} QueryLiquidationRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryLiquidationRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLiquidationRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryLiquidationRequest} QueryLiquidationRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLiquidationRequest message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLiquidationRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates a QueryLiquidationRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryLiquidationRequest} QueryLiquidationRequest
       */
      QueryLiquidationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryLiquidationRequest) return object;
        let message = new $root.ununifi.nftbackedloan.QueryLiquidationRequest();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryLiquidationRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @static
       * @param {ununifi.nftbackedloan.QueryLiquidationRequest} message QueryLiquidationRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLiquidationRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.token_id = '';
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this QueryLiquidationRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryLiquidationRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLiquidationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLiquidationRequest;
    })();

    nftbackedloan.QueryLiquidationResponse = (function () {
      /**
       * Properties of a QueryLiquidationResponse.
       * @memberof ununifi.nftbackedloan
       * @interface IQueryLiquidationResponse
       * @property {ununifi.nftbackedloan.ILiquidations|null} [liquidations] QueryLiquidationResponse liquidations
       */

      /**
       * Constructs a new QueryLiquidationResponse.
       * @memberof ununifi.nftbackedloan
       * @classdesc Represents a QueryLiquidationResponse.
       * @implements IQueryLiquidationResponse
       * @constructor
       * @param {ununifi.nftbackedloan.IQueryLiquidationResponse=} [properties] Properties to set
       */
      function QueryLiquidationResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryLiquidationResponse liquidations.
       * @member {ununifi.nftbackedloan.ILiquidations|null|undefined} liquidations
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @instance
       */
      QueryLiquidationResponse.prototype.liquidations = null;

      /**
       * Encodes the specified QueryLiquidationResponse message. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryLiquidationResponse} message QueryLiquidationResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidationResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.liquidations != null && Object.hasOwnProperty.call(message, 'liquidations'))
          $root.ununifi.nftbackedloan.Liquidations.encode(message.liquidations, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryLiquidationResponse message, length delimited. Does not implicitly {@link ununifi.nftbackedloan.QueryLiquidationResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @static
       * @param {ununifi.nftbackedloan.IQueryLiquidationResponse} message QueryLiquidationResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryLiquidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryLiquidationResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftbackedloan.QueryLiquidationResponse} QueryLiquidationResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftbackedloan.QueryLiquidationResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.liquidations = $root.ununifi.nftbackedloan.Liquidations.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryLiquidationResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftbackedloan.QueryLiquidationResponse} QueryLiquidationResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryLiquidationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryLiquidationResponse message.
       * @function verify
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryLiquidationResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.liquidations != null && message.hasOwnProperty('liquidations')) {
          let error = $root.ununifi.nftbackedloan.Liquidations.verify(message.liquidations);
          if (error) return 'liquidations.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryLiquidationResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftbackedloan.QueryLiquidationResponse} QueryLiquidationResponse
       */
      QueryLiquidationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftbackedloan.QueryLiquidationResponse) return object;
        let message = new $root.ununifi.nftbackedloan.QueryLiquidationResponse();
        if (object.liquidations != null) {
          if (typeof object.liquidations !== 'object')
            throw TypeError('.ununifi.nftbackedloan.QueryLiquidationResponse.liquidations: object expected');
          message.liquidations = $root.ununifi.nftbackedloan.Liquidations.fromObject(object.liquidations);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryLiquidationResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @static
       * @param {ununifi.nftbackedloan.QueryLiquidationResponse} message QueryLiquidationResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryLiquidationResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.liquidations = null;
        if (message.liquidations != null && message.hasOwnProperty('liquidations'))
          object.liquidations = $root.ununifi.nftbackedloan.Liquidations.toObject(message.liquidations, options);
        return object;
      };

      /**
       * Converts this QueryLiquidationResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftbackedloan.QueryLiquidationResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryLiquidationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryLiquidationResponse;
    })();

    return nftbackedloan;
  })();

  ununifi.nftfactory = (function () {
    /**
     * Namespace nftfactory.
     * @memberof ununifi
     * @namespace
     */
    const nftfactory = {};

    nftfactory.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.nftfactory.Msg#createClass}.
       * @memberof ununifi.nftfactory.Msg
       * @typedef CreateClassCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.MsgCreateClassResponse} [response] MsgCreateClassResponse
       */

      /**
       * Calls CreateClass.
       * @function createClass
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgCreateClass} request MsgCreateClass message or plain object
       * @param {ununifi.nftfactory.Msg.CreateClassCallback} callback Node-style callback called with the error, if any, and MsgCreateClassResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.createClass = function createClass(request, callback) {
          return this.rpcCall(
            createClass,
            $root.ununifi.nftfactory.MsgCreateClass,
            $root.ununifi.nftfactory.MsgCreateClassResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CreateClass' },
      );

      /**
       * Calls CreateClass.
       * @function createClass
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgCreateClass} request MsgCreateClass message or plain object
       * @returns {Promise<ununifi.nftfactory.MsgCreateClassResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftfactory.Msg#updateClass}.
       * @memberof ununifi.nftfactory.Msg
       * @typedef UpdateClassCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.MsgUpdateClassResponse} [response] MsgUpdateClassResponse
       */

      /**
       * Calls UpdateClass.
       * @function updateClass
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgUpdateClass} request MsgUpdateClass message or plain object
       * @param {ununifi.nftfactory.Msg.UpdateClassCallback} callback Node-style callback called with the error, if any, and MsgUpdateClassResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateClass = function updateClass(request, callback) {
          return this.rpcCall(
            updateClass,
            $root.ununifi.nftfactory.MsgUpdateClass,
            $root.ununifi.nftfactory.MsgUpdateClassResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateClass' },
      );

      /**
       * Calls UpdateClass.
       * @function updateClass
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgUpdateClass} request MsgUpdateClass message or plain object
       * @returns {Promise<ununifi.nftfactory.MsgUpdateClassResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftfactory.Msg#mintNFT}.
       * @memberof ununifi.nftfactory.Msg
       * @typedef MintNFTCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.MsgMintNFTResponse} [response] MsgMintNFTResponse
       */

      /**
       * Calls MintNFT.
       * @function mintNFT
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgMintNFT} request MsgMintNFT message or plain object
       * @param {ununifi.nftfactory.Msg.MintNFTCallback} callback Node-style callback called with the error, if any, and MsgMintNFTResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.mintNFT = function mintNFT(request, callback) {
          return this.rpcCall(mintNFT, $root.ununifi.nftfactory.MsgMintNFT, $root.ununifi.nftfactory.MsgMintNFTResponse, request, callback);
        }),
        'name',
        { value: 'MintNFT' },
      );

      /**
       * Calls MintNFT.
       * @function mintNFT
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgMintNFT} request MsgMintNFT message or plain object
       * @returns {Promise<ununifi.nftfactory.MsgMintNFTResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftfactory.Msg#burnNFT}.
       * @memberof ununifi.nftfactory.Msg
       * @typedef BurnNFTCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.MsgBurnNFTResponse} [response] MsgBurnNFTResponse
       */

      /**
       * Calls BurnNFT.
       * @function burnNFT
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgBurnNFT} request MsgBurnNFT message or plain object
       * @param {ununifi.nftfactory.Msg.BurnNFTCallback} callback Node-style callback called with the error, if any, and MsgBurnNFTResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.burnNFT = function burnNFT(request, callback) {
          return this.rpcCall(burnNFT, $root.ununifi.nftfactory.MsgBurnNFT, $root.ununifi.nftfactory.MsgBurnNFTResponse, request, callback);
        }),
        'name',
        { value: 'BurnNFT' },
      );

      /**
       * Calls BurnNFT.
       * @function burnNFT
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgBurnNFT} request MsgBurnNFT message or plain object
       * @returns {Promise<ununifi.nftfactory.MsgBurnNFTResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftfactory.Msg#changeAdmin}.
       * @memberof ununifi.nftfactory.Msg
       * @typedef ChangeAdminCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.MsgChangeAdminResponse} [response] MsgChangeAdminResponse
       */

      /**
       * Calls ChangeAdmin.
       * @function changeAdmin
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgChangeAdmin} request MsgChangeAdmin message or plain object
       * @param {ununifi.nftfactory.Msg.ChangeAdminCallback} callback Node-style callback called with the error, if any, and MsgChangeAdminResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.changeAdmin = function changeAdmin(request, callback) {
          return this.rpcCall(
            changeAdmin,
            $root.ununifi.nftfactory.MsgChangeAdmin,
            $root.ununifi.nftfactory.MsgChangeAdminResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ChangeAdmin' },
      );

      /**
       * Calls ChangeAdmin.
       * @function changeAdmin
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgChangeAdmin} request MsgChangeAdmin message or plain object
       * @returns {Promise<ununifi.nftfactory.MsgChangeAdminResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftfactory.Msg#updateParams}.
       * @memberof ununifi.nftfactory.Msg
       * @typedef UpdateParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.MsgUpdateParamsResponse} [response] MsgUpdateParamsResponse
       */

      /**
       * Calls UpdateParams.
       * @function updateParams
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgUpdateParams} request MsgUpdateParams message or plain object
       * @param {ununifi.nftfactory.Msg.UpdateParamsCallback} callback Node-style callback called with the error, if any, and MsgUpdateParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateParams = function updateParams(request, callback) {
          return this.rpcCall(
            updateParams,
            $root.ununifi.nftfactory.MsgUpdateParams,
            $root.ununifi.nftfactory.MsgUpdateParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateParams' },
      );

      /**
       * Calls UpdateParams.
       * @function updateParams
       * @memberof ununifi.nftfactory.Msg
       * @instance
       * @param {ununifi.nftfactory.IMsgUpdateParams} request MsgUpdateParams message or plain object
       * @returns {Promise<ununifi.nftfactory.MsgUpdateParamsResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    nftfactory.MsgCreateClass = (function () {
      /**
       * Properties of a MsgCreateClass.
       * @memberof ununifi.nftfactory
       * @interface IMsgCreateClass
       * @property {string|null} [sender] MsgCreateClass sender
       * @property {string|null} [subclass] MsgCreateClass subclass
       * @property {string|null} [name] MsgCreateClass name
       * @property {string|null} [symbol] MsgCreateClass symbol
       * @property {string|null} [description] MsgCreateClass description
       * @property {string|null} [uri] MsgCreateClass uri
       * @property {string|null} [uri_hash] MsgCreateClass uri_hash
       */

      /**
       * Constructs a new MsgCreateClass.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgCreateClass.
       * @implements IMsgCreateClass
       * @constructor
       * @param {ununifi.nftfactory.IMsgCreateClass=} [properties] Properties to set
       */
      function MsgCreateClass(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCreateClass sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.sender = '';

      /**
       * MsgCreateClass subclass.
       * @member {string} subclass
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.subclass = '';

      /**
       * MsgCreateClass name.
       * @member {string} name
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.name = '';

      /**
       * MsgCreateClass symbol.
       * @member {string} symbol
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.symbol = '';

      /**
       * MsgCreateClass description.
       * @member {string} description
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.description = '';

      /**
       * MsgCreateClass uri.
       * @member {string} uri
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.uri = '';

      /**
       * MsgCreateClass uri_hash.
       * @member {string} uri_hash
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       */
      MsgCreateClass.prototype.uri_hash = '';

      /**
       * Encodes the specified MsgCreateClass message. Does not implicitly {@link ununifi.nftfactory.MsgCreateClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @static
       * @param {ununifi.nftfactory.IMsgCreateClass} message MsgCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.subclass != null && Object.hasOwnProperty.call(message, 'subclass'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.subclass);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.symbol);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.description);
        if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.uri);
        if (message.uri_hash != null && Object.hasOwnProperty.call(message, 'uri_hash'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.uri_hash);
        return writer;
      };

      /**
       * Encodes the specified MsgCreateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgCreateClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @static
       * @param {ununifi.nftfactory.IMsgCreateClass} message MsgCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgCreateClass} MsgCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgCreateClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.subclass = reader.string();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.symbol = reader.string();
              break;
            case 5:
              message.description = reader.string();
              break;
            case 6:
              message.uri = reader.string();
              break;
            case 7:
              message.uri_hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgCreateClass} MsgCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateClass message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.subclass != null && message.hasOwnProperty('subclass'))
          if (!$util.isString(message.subclass)) return 'subclass: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash'))
          if (!$util.isString(message.uri_hash)) return 'uri_hash: string expected';
        return null;
      };

      /**
       * Creates a MsgCreateClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgCreateClass} MsgCreateClass
       */
      MsgCreateClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgCreateClass) return object;
        let message = new $root.ununifi.nftfactory.MsgCreateClass();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.subclass != null) message.subclass = String(object.subclass);
        if (object.name != null) message.name = String(object.name);
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.description != null) message.description = String(object.description);
        if (object.uri != null) message.uri = String(object.uri);
        if (object.uri_hash != null) message.uri_hash = String(object.uri_hash);
        return message;
      };

      /**
       * Creates a plain object from a MsgCreateClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @static
       * @param {ununifi.nftfactory.MsgCreateClass} message MsgCreateClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.subclass = '';
          object.name = '';
          object.symbol = '';
          object.description = '';
          object.uri = '';
          object.uri_hash = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.subclass != null && message.hasOwnProperty('subclass')) object.subclass = message.subclass;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash')) object.uri_hash = message.uri_hash;
        return object;
      };

      /**
       * Converts this MsgCreateClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgCreateClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateClass;
    })();

    nftfactory.MsgCreateClassResponse = (function () {
      /**
       * Properties of a MsgCreateClassResponse.
       * @memberof ununifi.nftfactory
       * @interface IMsgCreateClassResponse
       */

      /**
       * Constructs a new MsgCreateClassResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgCreateClassResponse.
       * @implements IMsgCreateClassResponse
       * @constructor
       * @param {ununifi.nftfactory.IMsgCreateClassResponse=} [properties] Properties to set
       */
      function MsgCreateClassResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgCreateClassResponse message. Does not implicitly {@link ununifi.nftfactory.MsgCreateClassResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @static
       * @param {ununifi.nftfactory.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClassResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgCreateClassResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgCreateClassResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @static
       * @param {ununifi.nftfactory.IMsgCreateClassResponse} message MsgCreateClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateClassResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgCreateClassResponse} MsgCreateClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClassResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgCreateClassResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateClassResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgCreateClassResponse} MsgCreateClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateClassResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateClassResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateClassResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgCreateClassResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgCreateClassResponse} MsgCreateClassResponse
       */
      MsgCreateClassResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgCreateClassResponse) return object;
        return new $root.ununifi.nftfactory.MsgCreateClassResponse();
      };

      /**
       * Creates a plain object from a MsgCreateClassResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @static
       * @param {ununifi.nftfactory.MsgCreateClassResponse} message MsgCreateClassResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateClassResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgCreateClassResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgCreateClassResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateClassResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateClassResponse;
    })();

    nftfactory.MsgUpdateClass = (function () {
      /**
       * Properties of a MsgUpdateClass.
       * @memberof ununifi.nftfactory
       * @interface IMsgUpdateClass
       * @property {string|null} [sender] MsgUpdateClass sender
       * @property {string|null} [class_id] MsgUpdateClass class_id
       * @property {string|null} [name] MsgUpdateClass name
       * @property {string|null} [symbol] MsgUpdateClass symbol
       * @property {string|null} [description] MsgUpdateClass description
       * @property {string|null} [uri] MsgUpdateClass uri
       * @property {string|null} [uri_hash] MsgUpdateClass uri_hash
       */

      /**
       * Constructs a new MsgUpdateClass.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgUpdateClass.
       * @implements IMsgUpdateClass
       * @constructor
       * @param {ununifi.nftfactory.IMsgUpdateClass=} [properties] Properties to set
       */
      function MsgUpdateClass(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateClass sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       */
      MsgUpdateClass.prototype.sender = '';

      /**
       * MsgUpdateClass class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       */
      MsgUpdateClass.prototype.class_id = '';

      /**
       * MsgUpdateClass name.
       * @member {string} name
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       */
      MsgUpdateClass.prototype.name = '';

      /**
       * MsgUpdateClass symbol.
       * @member {string} symbol
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       */
      MsgUpdateClass.prototype.symbol = '';

      /**
       * MsgUpdateClass description.
       * @member {string} description
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       */
      MsgUpdateClass.prototype.description = '';

      /**
       * MsgUpdateClass uri.
       * @member {string} uri
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       */
      MsgUpdateClass.prototype.uri = '';

      /**
       * MsgUpdateClass uri_hash.
       * @member {string} uri_hash
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       */
      MsgUpdateClass.prototype.uri_hash = '';

      /**
       * Encodes the specified MsgUpdateClass message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateClass} message MsgUpdateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.symbol);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.description);
        if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.uri);
        if (message.uri_hash != null && Object.hasOwnProperty.call(message, 'uri_hash'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.uri_hash);
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateClass} message MsgUpdateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgUpdateClass} MsgUpdateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgUpdateClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.symbol = reader.string();
              break;
            case 5:
              message.description = reader.string();
              break;
            case 6:
              message.uri = reader.string();
              break;
            case 7:
              message.uri_hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgUpdateClass} MsgUpdateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateClass message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash'))
          if (!$util.isString(message.uri_hash)) return 'uri_hash: string expected';
        return null;
      };

      /**
       * Creates a MsgUpdateClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgUpdateClass} MsgUpdateClass
       */
      MsgUpdateClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgUpdateClass) return object;
        let message = new $root.ununifi.nftfactory.MsgUpdateClass();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.name != null) message.name = String(object.name);
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.description != null) message.description = String(object.description);
        if (object.uri != null) message.uri = String(object.uri);
        if (object.uri_hash != null) message.uri_hash = String(object.uri_hash);
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @static
       * @param {ununifi.nftfactory.MsgUpdateClass} message MsgUpdateClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.name = '';
          object.symbol = '';
          object.description = '';
          object.uri = '';
          object.uri_hash = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash')) object.uri_hash = message.uri_hash;
        return object;
      };

      /**
       * Converts this MsgUpdateClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgUpdateClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateClass;
    })();

    nftfactory.MsgUpdateClassResponse = (function () {
      /**
       * Properties of a MsgUpdateClassResponse.
       * @memberof ununifi.nftfactory
       * @interface IMsgUpdateClassResponse
       */

      /**
       * Constructs a new MsgUpdateClassResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgUpdateClassResponse.
       * @implements IMsgUpdateClassResponse
       * @constructor
       * @param {ununifi.nftfactory.IMsgUpdateClassResponse=} [properties] Properties to set
       */
      function MsgUpdateClassResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateClassResponse message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClassResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateClassResponse} message MsgUpdateClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateClassResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateClassResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateClassResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateClassResponse} message MsgUpdateClassResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateClassResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateClassResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgUpdateClassResponse} MsgUpdateClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateClassResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgUpdateClassResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateClassResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgUpdateClassResponse} MsgUpdateClassResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateClassResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateClassResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateClassResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateClassResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgUpdateClassResponse} MsgUpdateClassResponse
       */
      MsgUpdateClassResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgUpdateClassResponse) return object;
        return new $root.ununifi.nftfactory.MsgUpdateClassResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateClassResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @static
       * @param {ununifi.nftfactory.MsgUpdateClassResponse} message MsgUpdateClassResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateClassResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateClassResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgUpdateClassResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateClassResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateClassResponse;
    })();

    nftfactory.MsgMintNFT = (function () {
      /**
       * Properties of a MsgMintNFT.
       * @memberof ununifi.nftfactory
       * @interface IMsgMintNFT
       * @property {string|null} [sender] MsgMintNFT sender
       * @property {string|null} [class_id] MsgMintNFT class_id
       * @property {string|null} [token_id] MsgMintNFT token_id
       * @property {string|null} [uri] MsgMintNFT uri
       * @property {string|null} [uri_hash] MsgMintNFT uri_hash
       * @property {string|null} [recipient] MsgMintNFT recipient
       */

      /**
       * Constructs a new MsgMintNFT.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgMintNFT.
       * @implements IMsgMintNFT
       * @constructor
       * @param {ununifi.nftfactory.IMsgMintNFT=} [properties] Properties to set
       */
      function MsgMintNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgMintNFT sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.sender = '';

      /**
       * MsgMintNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.class_id = '';

      /**
       * MsgMintNFT token_id.
       * @member {string} token_id
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.token_id = '';

      /**
       * MsgMintNFT uri.
       * @member {string} uri
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.uri = '';

      /**
       * MsgMintNFT uri_hash.
       * @member {string} uri_hash
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.uri_hash = '';

      /**
       * MsgMintNFT recipient.
       * @member {string} recipient
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @instance
       */
      MsgMintNFT.prototype.recipient = '';

      /**
       * Encodes the specified MsgMintNFT message. Does not implicitly {@link ununifi.nftfactory.MsgMintNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @static
       * @param {ununifi.nftfactory.IMsgMintNFT} message MsgMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        if (message.uri != null && Object.hasOwnProperty.call(message, 'uri'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.uri);
        if (message.uri_hash != null && Object.hasOwnProperty.call(message, 'uri_hash'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.uri_hash);
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.recipient);
        return writer;
      };

      /**
       * Encodes the specified MsgMintNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgMintNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @static
       * @param {ununifi.nftfactory.IMsgMintNFT} message MsgMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgMintNFT} MsgMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgMintNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            case 4:
              message.uri = reader.string();
              break;
            case 5:
              message.uri_hash = reader.string();
              break;
            case 6:
              message.recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgMintNFT} MsgMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintNFT message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        if (message.uri != null && message.hasOwnProperty('uri')) if (!$util.isString(message.uri)) return 'uri: string expected';
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash'))
          if (!$util.isString(message.uri_hash)) return 'uri_hash: string expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        return null;
      };

      /**
       * Creates a MsgMintNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgMintNFT} MsgMintNFT
       */
      MsgMintNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgMintNFT) return object;
        let message = new $root.ununifi.nftfactory.MsgMintNFT();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        if (object.uri != null) message.uri = String(object.uri);
        if (object.uri_hash != null) message.uri_hash = String(object.uri_hash);
        if (object.recipient != null) message.recipient = String(object.recipient);
        return message;
      };

      /**
       * Creates a plain object from a MsgMintNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @static
       * @param {ununifi.nftfactory.MsgMintNFT} message MsgMintNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.token_id = '';
          object.uri = '';
          object.uri_hash = '';
          object.recipient = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        if (message.uri != null && message.hasOwnProperty('uri')) object.uri = message.uri;
        if (message.uri_hash != null && message.hasOwnProperty('uri_hash')) object.uri_hash = message.uri_hash;
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        return object;
      };

      /**
       * Converts this MsgMintNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgMintNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintNFT;
    })();

    nftfactory.MsgMintNFTResponse = (function () {
      /**
       * Properties of a MsgMintNFTResponse.
       * @memberof ununifi.nftfactory
       * @interface IMsgMintNFTResponse
       */

      /**
       * Constructs a new MsgMintNFTResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgMintNFTResponse.
       * @implements IMsgMintNFTResponse
       * @constructor
       * @param {ununifi.nftfactory.IMsgMintNFTResponse=} [properties] Properties to set
       */
      function MsgMintNFTResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgMintNFTResponse message. Does not implicitly {@link ununifi.nftfactory.MsgMintNFTResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @static
       * @param {ununifi.nftfactory.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFTResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgMintNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgMintNFTResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @static
       * @param {ununifi.nftfactory.IMsgMintNFTResponse} message MsgMintNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgMintNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgMintNFTResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgMintNFTResponse} MsgMintNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFTResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgMintNFTResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgMintNFTResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgMintNFTResponse} MsgMintNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgMintNFTResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgMintNFTResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgMintNFTResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgMintNFTResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgMintNFTResponse} MsgMintNFTResponse
       */
      MsgMintNFTResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgMintNFTResponse) return object;
        return new $root.ununifi.nftfactory.MsgMintNFTResponse();
      };

      /**
       * Creates a plain object from a MsgMintNFTResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @static
       * @param {ununifi.nftfactory.MsgMintNFTResponse} message MsgMintNFTResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgMintNFTResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgMintNFTResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgMintNFTResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgMintNFTResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgMintNFTResponse;
    })();

    nftfactory.MsgBurnNFT = (function () {
      /**
       * Properties of a MsgBurnNFT.
       * @memberof ununifi.nftfactory
       * @interface IMsgBurnNFT
       * @property {string|null} [sender] MsgBurnNFT sender
       * @property {string|null} [class_id] MsgBurnNFT class_id
       * @property {string|null} [token_id] MsgBurnNFT token_id
       */

      /**
       * Constructs a new MsgBurnNFT.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgBurnNFT.
       * @implements IMsgBurnNFT
       * @constructor
       * @param {ununifi.nftfactory.IMsgBurnNFT=} [properties] Properties to set
       */
      function MsgBurnNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgBurnNFT sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @instance
       */
      MsgBurnNFT.prototype.sender = '';

      /**
       * MsgBurnNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @instance
       */
      MsgBurnNFT.prototype.class_id = '';

      /**
       * MsgBurnNFT token_id.
       * @member {string} token_id
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @instance
       */
      MsgBurnNFT.prototype.token_id = '';

      /**
       * Encodes the specified MsgBurnNFT message. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @static
       * @param {ununifi.nftfactory.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified MsgBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @static
       * @param {ununifi.nftfactory.IMsgBurnNFT} message MsgBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBurnNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgBurnNFT} MsgBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgBurnNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBurnNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgBurnNFT} MsgBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBurnNFT message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBurnNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates a MsgBurnNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgBurnNFT} MsgBurnNFT
       */
      MsgBurnNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgBurnNFT) return object;
        let message = new $root.ununifi.nftfactory.MsgBurnNFT();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from a MsgBurnNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @static
       * @param {ununifi.nftfactory.MsgBurnNFT} message MsgBurnNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBurnNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this MsgBurnNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgBurnNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBurnNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBurnNFT;
    })();

    nftfactory.MsgBurnNFTResponse = (function () {
      /**
       * Properties of a MsgBurnNFTResponse.
       * @memberof ununifi.nftfactory
       * @interface IMsgBurnNFTResponse
       */

      /**
       * Constructs a new MsgBurnNFTResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgBurnNFTResponse.
       * @implements IMsgBurnNFTResponse
       * @constructor
       * @param {ununifi.nftfactory.IMsgBurnNFTResponse=} [properties] Properties to set
       */
      function MsgBurnNFTResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgBurnNFTResponse message. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFTResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @static
       * @param {ununifi.nftfactory.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFTResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgBurnNFTResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgBurnNFTResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @static
       * @param {ununifi.nftfactory.IMsgBurnNFTResponse} message MsgBurnNFTResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgBurnNFTResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgBurnNFTResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgBurnNFTResponse} MsgBurnNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFTResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgBurnNFTResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgBurnNFTResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgBurnNFTResponse} MsgBurnNFTResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgBurnNFTResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgBurnNFTResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgBurnNFTResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgBurnNFTResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgBurnNFTResponse} MsgBurnNFTResponse
       */
      MsgBurnNFTResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgBurnNFTResponse) return object;
        return new $root.ununifi.nftfactory.MsgBurnNFTResponse();
      };

      /**
       * Creates a plain object from a MsgBurnNFTResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @static
       * @param {ununifi.nftfactory.MsgBurnNFTResponse} message MsgBurnNFTResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgBurnNFTResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgBurnNFTResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgBurnNFTResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgBurnNFTResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgBurnNFTResponse;
    })();

    nftfactory.MsgChangeAdmin = (function () {
      /**
       * Properties of a MsgChangeAdmin.
       * @memberof ununifi.nftfactory
       * @interface IMsgChangeAdmin
       * @property {string|null} [sender] MsgChangeAdmin sender
       * @property {string|null} [class_id] MsgChangeAdmin class_id
       * @property {string|null} [new_admin] MsgChangeAdmin new_admin
       */

      /**
       * Constructs a new MsgChangeAdmin.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgChangeAdmin.
       * @implements IMsgChangeAdmin
       * @constructor
       * @param {ununifi.nftfactory.IMsgChangeAdmin=} [properties] Properties to set
       */
      function MsgChangeAdmin(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgChangeAdmin sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @instance
       */
      MsgChangeAdmin.prototype.sender = '';

      /**
       * MsgChangeAdmin class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @instance
       */
      MsgChangeAdmin.prototype.class_id = '';

      /**
       * MsgChangeAdmin new_admin.
       * @member {string} new_admin
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @instance
       */
      MsgChangeAdmin.prototype.new_admin = '';

      /**
       * Encodes the specified MsgChangeAdmin message. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdmin.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @static
       * @param {ununifi.nftfactory.IMsgChangeAdmin} message MsgChangeAdmin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgChangeAdmin.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.new_admin != null && Object.hasOwnProperty.call(message, 'new_admin'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.new_admin);
        return writer;
      };

      /**
       * Encodes the specified MsgChangeAdmin message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdmin.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @static
       * @param {ununifi.nftfactory.IMsgChangeAdmin} message MsgChangeAdmin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgChangeAdmin.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgChangeAdmin message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgChangeAdmin} MsgChangeAdmin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgChangeAdmin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgChangeAdmin();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.new_admin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgChangeAdmin message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgChangeAdmin} MsgChangeAdmin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgChangeAdmin.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgChangeAdmin message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgChangeAdmin.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.new_admin != null && message.hasOwnProperty('new_admin'))
          if (!$util.isString(message.new_admin)) return 'new_admin: string expected';
        return null;
      };

      /**
       * Creates a MsgChangeAdmin message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgChangeAdmin} MsgChangeAdmin
       */
      MsgChangeAdmin.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgChangeAdmin) return object;
        let message = new $root.ununifi.nftfactory.MsgChangeAdmin();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.new_admin != null) message.new_admin = String(object.new_admin);
        return message;
      };

      /**
       * Creates a plain object from a MsgChangeAdmin message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @static
       * @param {ununifi.nftfactory.MsgChangeAdmin} message MsgChangeAdmin
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgChangeAdmin.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.new_admin = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.new_admin != null && message.hasOwnProperty('new_admin')) object.new_admin = message.new_admin;
        return object;
      };

      /**
       * Converts this MsgChangeAdmin to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgChangeAdmin
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgChangeAdmin.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgChangeAdmin;
    })();

    nftfactory.MsgChangeAdminResponse = (function () {
      /**
       * Properties of a MsgChangeAdminResponse.
       * @memberof ununifi.nftfactory
       * @interface IMsgChangeAdminResponse
       */

      /**
       * Constructs a new MsgChangeAdminResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgChangeAdminResponse.
       * @implements IMsgChangeAdminResponse
       * @constructor
       * @param {ununifi.nftfactory.IMsgChangeAdminResponse=} [properties] Properties to set
       */
      function MsgChangeAdminResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgChangeAdminResponse message. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdminResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @static
       * @param {ununifi.nftfactory.IMsgChangeAdminResponse} message MsgChangeAdminResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgChangeAdminResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgChangeAdminResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgChangeAdminResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @static
       * @param {ununifi.nftfactory.IMsgChangeAdminResponse} message MsgChangeAdminResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgChangeAdminResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgChangeAdminResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgChangeAdminResponse} MsgChangeAdminResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgChangeAdminResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgChangeAdminResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgChangeAdminResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgChangeAdminResponse} MsgChangeAdminResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgChangeAdminResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgChangeAdminResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgChangeAdminResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgChangeAdminResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgChangeAdminResponse} MsgChangeAdminResponse
       */
      MsgChangeAdminResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgChangeAdminResponse) return object;
        return new $root.ununifi.nftfactory.MsgChangeAdminResponse();
      };

      /**
       * Creates a plain object from a MsgChangeAdminResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @static
       * @param {ununifi.nftfactory.MsgChangeAdminResponse} message MsgChangeAdminResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgChangeAdminResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgChangeAdminResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgChangeAdminResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgChangeAdminResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgChangeAdminResponse;
    })();

    nftfactory.MsgUpdateParams = (function () {
      /**
       * Properties of a MsgUpdateParams.
       * @memberof ununifi.nftfactory
       * @interface IMsgUpdateParams
       * @property {string|null} [sender] MsgUpdateParams sender
       * @property {ununifi.nftfactory.IParams|null} [params] MsgUpdateParams params
       */

      /**
       * Constructs a new MsgUpdateParams.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgUpdateParams.
       * @implements IMsgUpdateParams
       * @constructor
       * @param {ununifi.nftfactory.IMsgUpdateParams=} [properties] Properties to set
       */
      function MsgUpdateParams(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateParams sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @instance
       */
      MsgUpdateParams.prototype.sender = '';

      /**
       * MsgUpdateParams params.
       * @member {ununifi.nftfactory.IParams|null|undefined} params
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @instance
       */
      MsgUpdateParams.prototype.params = null;

      /**
       * Encodes the specified MsgUpdateParams message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftfactory.Params.encode(message.params, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateParams message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgUpdateParams} MsgUpdateParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgUpdateParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.params = $root.ununifi.nftfactory.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgUpdateParams} MsgUpdateParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateParams message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftfactory.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgUpdateParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgUpdateParams} MsgUpdateParams
       */
      MsgUpdateParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgUpdateParams) return object;
        let message = new $root.ununifi.nftfactory.MsgUpdateParams();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftfactory.MsgUpdateParams.params: object expected');
          message.params = $root.ununifi.nftfactory.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @static
       * @param {ununifi.nftfactory.MsgUpdateParams} message MsgUpdateParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.params = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftfactory.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this MsgUpdateParams to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgUpdateParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateParams;
    })();

    nftfactory.MsgUpdateParamsResponse = (function () {
      /**
       * Properties of a MsgUpdateParamsResponse.
       * @memberof ununifi.nftfactory
       * @interface IMsgUpdateParamsResponse
       */

      /**
       * Constructs a new MsgUpdateParamsResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a MsgUpdateParamsResponse.
       * @implements IMsgUpdateParamsResponse
       * @constructor
       * @param {ununifi.nftfactory.IMsgUpdateParamsResponse=} [properties] Properties to set
       */
      function MsgUpdateParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateParamsResponse message. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.MsgUpdateParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.nftfactory.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.MsgUpdateParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateParamsResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       */
      MsgUpdateParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.MsgUpdateParamsResponse) return object;
        return new $root.ununifi.nftfactory.MsgUpdateParamsResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.nftfactory.MsgUpdateParamsResponse} message MsgUpdateParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateParamsResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.MsgUpdateParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateParamsResponse;
    })();

    nftfactory.ClassAuthorityMetadata = (function () {
      /**
       * Properties of a ClassAuthorityMetadata.
       * @memberof ununifi.nftfactory
       * @interface IClassAuthorityMetadata
       * @property {string|null} [Admin] ClassAuthorityMetadata Admin
       */

      /**
       * Constructs a new ClassAuthorityMetadata.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a ClassAuthorityMetadata.
       * @implements IClassAuthorityMetadata
       * @constructor
       * @param {ununifi.nftfactory.IClassAuthorityMetadata=} [properties] Properties to set
       */
      function ClassAuthorityMetadata(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ClassAuthorityMetadata Admin.
       * @member {string} Admin
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @instance
       */
      ClassAuthorityMetadata.prototype.Admin = '';

      /**
       * Encodes the specified ClassAuthorityMetadata message. Does not implicitly {@link ununifi.nftfactory.ClassAuthorityMetadata.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @static
       * @param {ununifi.nftfactory.IClassAuthorityMetadata} message ClassAuthorityMetadata message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassAuthorityMetadata.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.Admin != null && Object.hasOwnProperty.call(message, 'Admin'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.Admin);
        return writer;
      };

      /**
       * Encodes the specified ClassAuthorityMetadata message, length delimited. Does not implicitly {@link ununifi.nftfactory.ClassAuthorityMetadata.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @static
       * @param {ununifi.nftfactory.IClassAuthorityMetadata} message ClassAuthorityMetadata message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ClassAuthorityMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ClassAuthorityMetadata message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.ClassAuthorityMetadata} ClassAuthorityMetadata
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassAuthorityMetadata.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.ClassAuthorityMetadata();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.Admin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ClassAuthorityMetadata message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.ClassAuthorityMetadata} ClassAuthorityMetadata
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ClassAuthorityMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ClassAuthorityMetadata message.
       * @function verify
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ClassAuthorityMetadata.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.Admin != null && message.hasOwnProperty('Admin')) if (!$util.isString(message.Admin)) return 'Admin: string expected';
        return null;
      };

      /**
       * Creates a ClassAuthorityMetadata message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.ClassAuthorityMetadata} ClassAuthorityMetadata
       */
      ClassAuthorityMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.ClassAuthorityMetadata) return object;
        let message = new $root.ununifi.nftfactory.ClassAuthorityMetadata();
        if (object.Admin != null) message.Admin = String(object.Admin);
        return message;
      };

      /**
       * Creates a plain object from a ClassAuthorityMetadata message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @static
       * @param {ununifi.nftfactory.ClassAuthorityMetadata} message ClassAuthorityMetadata
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ClassAuthorityMetadata.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.Admin = '';
        if (message.Admin != null && message.hasOwnProperty('Admin')) object.Admin = message.Admin;
        return object;
      };

      /**
       * Converts this ClassAuthorityMetadata to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.ClassAuthorityMetadata
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ClassAuthorityMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ClassAuthorityMetadata;
    })();

    nftfactory.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.nftfactory
       * @interface IParams
       * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [class_creation_fee] Params class_creation_fee
       * @property {string|null} [fee_collector_address] Params fee_collector_address
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.nftfactory.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.class_creation_fee = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params class_creation_fee.
       * @member {Array.<cosmos.base.v1beta1.ICoin>} class_creation_fee
       * @memberof ununifi.nftfactory.Params
       * @instance
       */
      Params.prototype.class_creation_fee = $util.emptyArray;

      /**
       * Params fee_collector_address.
       * @member {string} fee_collector_address
       * @memberof ununifi.nftfactory.Params
       * @instance
       */
      Params.prototype.fee_collector_address = '';

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.nftfactory.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.Params
       * @static
       * @param {ununifi.nftfactory.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_creation_fee != null && message.class_creation_fee.length)
          for (let i = 0; i < message.class_creation_fee.length; ++i)
            $root.cosmos.base.v1beta1.Coin.encode(message.class_creation_fee[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, 'fee_collector_address'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.fee_collector_address);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.nftfactory.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.Params
       * @static
       * @param {ununifi.nftfactory.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.class_creation_fee && message.class_creation_fee.length)) message.class_creation_fee = [];
              message.class_creation_fee.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee_collector_address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.nftfactory.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_creation_fee != null && message.hasOwnProperty('class_creation_fee')) {
          if (!Array.isArray(message.class_creation_fee)) return 'class_creation_fee: array expected';
          for (let i = 0; i < message.class_creation_fee.length; ++i) {
            let error = $root.cosmos.base.v1beta1.Coin.verify(message.class_creation_fee[i]);
            if (error) return 'class_creation_fee.' + error;
          }
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          if (!$util.isString(message.fee_collector_address)) return 'fee_collector_address: string expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.Params) return object;
        let message = new $root.ununifi.nftfactory.Params();
        if (object.class_creation_fee) {
          if (!Array.isArray(object.class_creation_fee)) throw TypeError('.ununifi.nftfactory.Params.class_creation_fee: array expected');
          message.class_creation_fee = [];
          for (let i = 0; i < object.class_creation_fee.length; ++i) {
            if (typeof object.class_creation_fee[i] !== 'object')
              throw TypeError('.ununifi.nftfactory.Params.class_creation_fee: object expected');
            message.class_creation_fee[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.class_creation_fee[i]);
          }
        }
        if (object.fee_collector_address != null) message.fee_collector_address = String(object.fee_collector_address);
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.Params
       * @static
       * @param {ununifi.nftfactory.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.class_creation_fee = [];
        if (options.defaults) object.fee_collector_address = '';
        if (message.class_creation_fee && message.class_creation_fee.length) {
          object.class_creation_fee = [];
          for (let j = 0; j < message.class_creation_fee.length; ++j)
            object.class_creation_fee[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.class_creation_fee[j], options);
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          object.fee_collector_address = message.fee_collector_address;
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    nftfactory.EventCreateClass = (function () {
      /**
       * Properties of an EventCreateClass.
       * @memberof ununifi.nftfactory
       * @interface IEventCreateClass
       * @property {string|null} [sender] EventCreateClass sender
       * @property {string|null} [class_id] EventCreateClass class_id
       */

      /**
       * Constructs a new EventCreateClass.
       * @memberof ununifi.nftfactory
       * @classdesc Represents an EventCreateClass.
       * @implements IEventCreateClass
       * @constructor
       * @param {ununifi.nftfactory.IEventCreateClass=} [properties] Properties to set
       */
      function EventCreateClass(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventCreateClass sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.EventCreateClass
       * @instance
       */
      EventCreateClass.prototype.sender = '';

      /**
       * EventCreateClass class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.EventCreateClass
       * @instance
       */
      EventCreateClass.prototype.class_id = '';

      /**
       * Encodes the specified EventCreateClass message. Does not implicitly {@link ununifi.nftfactory.EventCreateClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.EventCreateClass
       * @static
       * @param {ununifi.nftfactory.IEventCreateClass} message EventCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCreateClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        return writer;
      };

      /**
       * Encodes the specified EventCreateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventCreateClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.EventCreateClass
       * @static
       * @param {ununifi.nftfactory.IEventCreateClass} message EventCreateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventCreateClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventCreateClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.EventCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.EventCreateClass} EventCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCreateClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.EventCreateClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventCreateClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.EventCreateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.EventCreateClass} EventCreateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventCreateClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventCreateClass message.
       * @function verify
       * @memberof ununifi.nftfactory.EventCreateClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventCreateClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        return null;
      };

      /**
       * Creates an EventCreateClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.EventCreateClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.EventCreateClass} EventCreateClass
       */
      EventCreateClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.EventCreateClass) return object;
        let message = new $root.ununifi.nftfactory.EventCreateClass();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        return message;
      };

      /**
       * Creates a plain object from an EventCreateClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.EventCreateClass
       * @static
       * @param {ununifi.nftfactory.EventCreateClass} message EventCreateClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventCreateClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        return object;
      };

      /**
       * Converts this EventCreateClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.EventCreateClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventCreateClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventCreateClass;
    })();

    nftfactory.EventUpdateClass = (function () {
      /**
       * Properties of an EventUpdateClass.
       * @memberof ununifi.nftfactory
       * @interface IEventUpdateClass
       * @property {string|null} [sender] EventUpdateClass sender
       * @property {string|null} [class_id] EventUpdateClass class_id
       */

      /**
       * Constructs a new EventUpdateClass.
       * @memberof ununifi.nftfactory
       * @classdesc Represents an EventUpdateClass.
       * @implements IEventUpdateClass
       * @constructor
       * @param {ununifi.nftfactory.IEventUpdateClass=} [properties] Properties to set
       */
      function EventUpdateClass(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventUpdateClass sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @instance
       */
      EventUpdateClass.prototype.sender = '';

      /**
       * EventUpdateClass class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @instance
       */
      EventUpdateClass.prototype.class_id = '';

      /**
       * Encodes the specified EventUpdateClass message. Does not implicitly {@link ununifi.nftfactory.EventUpdateClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @static
       * @param {ununifi.nftfactory.IEventUpdateClass} message EventUpdateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdateClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        return writer;
      };

      /**
       * Encodes the specified EventUpdateClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventUpdateClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @static
       * @param {ununifi.nftfactory.IEventUpdateClass} message EventUpdateClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventUpdateClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventUpdateClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.EventUpdateClass} EventUpdateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdateClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.EventUpdateClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventUpdateClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.EventUpdateClass} EventUpdateClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventUpdateClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventUpdateClass message.
       * @function verify
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventUpdateClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        return null;
      };

      /**
       * Creates an EventUpdateClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.EventUpdateClass} EventUpdateClass
       */
      EventUpdateClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.EventUpdateClass) return object;
        let message = new $root.ununifi.nftfactory.EventUpdateClass();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        return message;
      };

      /**
       * Creates a plain object from an EventUpdateClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @static
       * @param {ununifi.nftfactory.EventUpdateClass} message EventUpdateClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventUpdateClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        return object;
      };

      /**
       * Converts this EventUpdateClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.EventUpdateClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventUpdateClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventUpdateClass;
    })();

    nftfactory.EventMintNFT = (function () {
      /**
       * Properties of an EventMintNFT.
       * @memberof ununifi.nftfactory
       * @interface IEventMintNFT
       * @property {string|null} [sender] EventMintNFT sender
       * @property {string|null} [class_id] EventMintNFT class_id
       * @property {string|null} [token_id] EventMintNFT token_id
       * @property {string|null} [recipient] EventMintNFT recipient
       */

      /**
       * Constructs a new EventMintNFT.
       * @memberof ununifi.nftfactory
       * @classdesc Represents an EventMintNFT.
       * @implements IEventMintNFT
       * @constructor
       * @param {ununifi.nftfactory.IEventMintNFT=} [properties] Properties to set
       */
      function EventMintNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventMintNFT sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.sender = '';

      /**
       * EventMintNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.class_id = '';

      /**
       * EventMintNFT token_id.
       * @member {string} token_id
       * @memberof ununifi.nftfactory.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.token_id = '';

      /**
       * EventMintNFT recipient.
       * @member {string} recipient
       * @memberof ununifi.nftfactory.EventMintNFT
       * @instance
       */
      EventMintNFT.prototype.recipient = '';

      /**
       * Encodes the specified EventMintNFT message. Does not implicitly {@link ununifi.nftfactory.EventMintNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.EventMintNFT
       * @static
       * @param {ununifi.nftfactory.IEventMintNFT} message EventMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventMintNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.recipient);
        return writer;
      };

      /**
       * Encodes the specified EventMintNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventMintNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.EventMintNFT
       * @static
       * @param {ununifi.nftfactory.IEventMintNFT} message EventMintNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventMintNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventMintNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.EventMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.EventMintNFT} EventMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventMintNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.EventMintNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            case 4:
              message.recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventMintNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.EventMintNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.EventMintNFT} EventMintNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventMintNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventMintNFT message.
       * @function verify
       * @memberof ununifi.nftfactory.EventMintNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventMintNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        return null;
      };

      /**
       * Creates an EventMintNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.EventMintNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.EventMintNFT} EventMintNFT
       */
      EventMintNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.EventMintNFT) return object;
        let message = new $root.ununifi.nftfactory.EventMintNFT();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        if (object.recipient != null) message.recipient = String(object.recipient);
        return message;
      };

      /**
       * Creates a plain object from an EventMintNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.EventMintNFT
       * @static
       * @param {ununifi.nftfactory.EventMintNFT} message EventMintNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventMintNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.token_id = '';
          object.recipient = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        return object;
      };

      /**
       * Converts this EventMintNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.EventMintNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventMintNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventMintNFT;
    })();

    nftfactory.EventBurnNFT = (function () {
      /**
       * Properties of an EventBurnNFT.
       * @memberof ununifi.nftfactory
       * @interface IEventBurnNFT
       * @property {string|null} [sender] EventBurnNFT sender
       * @property {string|null} [class_id] EventBurnNFT class_id
       * @property {string|null} [token_id] EventBurnNFT token_id
       */

      /**
       * Constructs a new EventBurnNFT.
       * @memberof ununifi.nftfactory
       * @classdesc Represents an EventBurnNFT.
       * @implements IEventBurnNFT
       * @constructor
       * @param {ununifi.nftfactory.IEventBurnNFT=} [properties] Properties to set
       */
      function EventBurnNFT(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventBurnNFT sender.
       * @member {string} sender
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @instance
       */
      EventBurnNFT.prototype.sender = '';

      /**
       * EventBurnNFT class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @instance
       */
      EventBurnNFT.prototype.class_id = '';

      /**
       * EventBurnNFT token_id.
       * @member {string} token_id
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @instance
       */
      EventBurnNFT.prototype.token_id = '';

      /**
       * Encodes the specified EventBurnNFT message. Does not implicitly {@link ununifi.nftfactory.EventBurnNFT.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @static
       * @param {ununifi.nftfactory.IEventBurnNFT} message EventBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBurnNFT.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.class_id);
        if (message.token_id != null && Object.hasOwnProperty.call(message, 'token_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.token_id);
        return writer;
      };

      /**
       * Encodes the specified EventBurnNFT message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventBurnNFT.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @static
       * @param {ununifi.nftfactory.IEventBurnNFT} message EventBurnNFT message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventBurnNFT.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventBurnNFT message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.EventBurnNFT} EventBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBurnNFT.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.EventBurnNFT();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.class_id = reader.string();
              break;
            case 3:
              message.token_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventBurnNFT message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.EventBurnNFT} EventBurnNFT
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventBurnNFT.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventBurnNFT message.
       * @function verify
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventBurnNFT.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.token_id != null && message.hasOwnProperty('token_id'))
          if (!$util.isString(message.token_id)) return 'token_id: string expected';
        return null;
      };

      /**
       * Creates an EventBurnNFT message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.EventBurnNFT} EventBurnNFT
       */
      EventBurnNFT.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.EventBurnNFT) return object;
        let message = new $root.ununifi.nftfactory.EventBurnNFT();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.token_id != null) message.token_id = String(object.token_id);
        return message;
      };

      /**
       * Creates a plain object from an EventBurnNFT message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @static
       * @param {ununifi.nftfactory.EventBurnNFT} message EventBurnNFT
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventBurnNFT.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.class_id = '';
          object.token_id = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.token_id != null && message.hasOwnProperty('token_id')) object.token_id = message.token_id;
        return object;
      };

      /**
       * Converts this EventBurnNFT to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.EventBurnNFT
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventBurnNFT.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventBurnNFT;
    })();

    nftfactory.EventChangeAdmin = (function () {
      /**
       * Properties of an EventChangeAdmin.
       * @memberof ununifi.nftfactory
       * @interface IEventChangeAdmin
       * @property {string|null} [admin] EventChangeAdmin admin
       * @property {string|null} [class_id] EventChangeAdmin class_id
       * @property {string|null} [new_admin] EventChangeAdmin new_admin
       */

      /**
       * Constructs a new EventChangeAdmin.
       * @memberof ununifi.nftfactory
       * @classdesc Represents an EventChangeAdmin.
       * @implements IEventChangeAdmin
       * @constructor
       * @param {ununifi.nftfactory.IEventChangeAdmin=} [properties] Properties to set
       */
      function EventChangeAdmin(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EventChangeAdmin admin.
       * @member {string} admin
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @instance
       */
      EventChangeAdmin.prototype.admin = '';

      /**
       * EventChangeAdmin class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @instance
       */
      EventChangeAdmin.prototype.class_id = '';

      /**
       * EventChangeAdmin new_admin.
       * @member {string} new_admin
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @instance
       */
      EventChangeAdmin.prototype.new_admin = '';

      /**
       * Encodes the specified EventChangeAdmin message. Does not implicitly {@link ununifi.nftfactory.EventChangeAdmin.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @static
       * @param {ununifi.nftfactory.IEventChangeAdmin} message EventChangeAdmin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventChangeAdmin.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.admin != null && Object.hasOwnProperty.call(message, 'admin'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.admin);
        if (message.new_admin != null && Object.hasOwnProperty.call(message, 'new_admin'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.new_admin);
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.class_id);
        return writer;
      };

      /**
       * Encodes the specified EventChangeAdmin message, length delimited. Does not implicitly {@link ununifi.nftfactory.EventChangeAdmin.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @static
       * @param {ununifi.nftfactory.IEventChangeAdmin} message EventChangeAdmin message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EventChangeAdmin.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EventChangeAdmin message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.EventChangeAdmin} EventChangeAdmin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventChangeAdmin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.EventChangeAdmin();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 3:
              message.class_id = reader.string();
              break;
            case 2:
              message.new_admin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EventChangeAdmin message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.EventChangeAdmin} EventChangeAdmin
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EventChangeAdmin.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EventChangeAdmin message.
       * @function verify
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EventChangeAdmin.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.admin != null && message.hasOwnProperty('admin')) if (!$util.isString(message.admin)) return 'admin: string expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.new_admin != null && message.hasOwnProperty('new_admin'))
          if (!$util.isString(message.new_admin)) return 'new_admin: string expected';
        return null;
      };

      /**
       * Creates an EventChangeAdmin message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.EventChangeAdmin} EventChangeAdmin
       */
      EventChangeAdmin.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.EventChangeAdmin) return object;
        let message = new $root.ununifi.nftfactory.EventChangeAdmin();
        if (object.admin != null) message.admin = String(object.admin);
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.new_admin != null) message.new_admin = String(object.new_admin);
        return message;
      };

      /**
       * Creates a plain object from an EventChangeAdmin message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @static
       * @param {ununifi.nftfactory.EventChangeAdmin} message EventChangeAdmin
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EventChangeAdmin.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.admin = '';
          object.new_admin = '';
          object.class_id = '';
        }
        if (message.admin != null && message.hasOwnProperty('admin')) object.admin = message.admin;
        if (message.new_admin != null && message.hasOwnProperty('new_admin')) object.new_admin = message.new_admin;
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        return object;
      };

      /**
       * Converts this EventChangeAdmin to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.EventChangeAdmin
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EventChangeAdmin.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EventChangeAdmin;
    })();

    nftfactory.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.nftfactory
       * @interface IGenesisState
       * @property {ununifi.nftfactory.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.nftfactory.IGenesisClass>|null} [classes] GenesisState classes
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.nftfactory.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.classes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.nftfactory.IParams|null|undefined} params
       * @memberof ununifi.nftfactory.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState classes.
       * @member {Array.<ununifi.nftfactory.IGenesisClass>} classes
       * @memberof ununifi.nftfactory.GenesisState
       * @instance
       */
      GenesisState.prototype.classes = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.nftfactory.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.GenesisState
       * @static
       * @param {ununifi.nftfactory.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftfactory.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.classes != null && message.classes.length)
          for (let i = 0; i < message.classes.length; ++i)
            $root.ununifi.nftfactory.GenesisClass.encode(message.classes[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.nftfactory.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.GenesisState
       * @static
       * @param {ununifi.nftfactory.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftfactory.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.classes && message.classes.length)) message.classes = [];
              message.classes.push($root.ununifi.nftfactory.GenesisClass.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.nftfactory.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftfactory.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.classes != null && message.hasOwnProperty('classes')) {
          if (!Array.isArray(message.classes)) return 'classes: array expected';
          for (let i = 0; i < message.classes.length; ++i) {
            let error = $root.ununifi.nftfactory.GenesisClass.verify(message.classes[i]);
            if (error) return 'classes.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.GenesisState) return object;
        let message = new $root.ununifi.nftfactory.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftfactory.GenesisState.params: object expected');
          message.params = $root.ununifi.nftfactory.Params.fromObject(object.params);
        }
        if (object.classes) {
          if (!Array.isArray(object.classes)) throw TypeError('.ununifi.nftfactory.GenesisState.classes: array expected');
          message.classes = [];
          for (let i = 0; i < object.classes.length; ++i) {
            if (typeof object.classes[i] !== 'object') throw TypeError('.ununifi.nftfactory.GenesisState.classes: object expected');
            message.classes[i] = $root.ununifi.nftfactory.GenesisClass.fromObject(object.classes[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.GenesisState
       * @static
       * @param {ununifi.nftfactory.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.classes = [];
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftfactory.Params.toObject(message.params, options);
        if (message.classes && message.classes.length) {
          object.classes = [];
          for (let j = 0; j < message.classes.length; ++j)
            object.classes[j] = $root.ununifi.nftfactory.GenesisClass.toObject(message.classes[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    nftfactory.GenesisClass = (function () {
      /**
       * Properties of a GenesisClass.
       * @memberof ununifi.nftfactory
       * @interface IGenesisClass
       * @property {string|null} [class_id] GenesisClass class_id
       * @property {ununifi.nftfactory.IClassAuthorityMetadata|null} [authority_metadata] GenesisClass authority_metadata
       */

      /**
       * Constructs a new GenesisClass.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a GenesisClass.
       * @implements IGenesisClass
       * @constructor
       * @param {ununifi.nftfactory.IGenesisClass=} [properties] Properties to set
       */
      function GenesisClass(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisClass class_id.
       * @member {string} class_id
       * @memberof ununifi.nftfactory.GenesisClass
       * @instance
       */
      GenesisClass.prototype.class_id = '';

      /**
       * GenesisClass authority_metadata.
       * @member {ununifi.nftfactory.IClassAuthorityMetadata|null|undefined} authority_metadata
       * @memberof ununifi.nftfactory.GenesisClass
       * @instance
       */
      GenesisClass.prototype.authority_metadata = null;

      /**
       * Encodes the specified GenesisClass message. Does not implicitly {@link ununifi.nftfactory.GenesisClass.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.GenesisClass
       * @static
       * @param {ununifi.nftfactory.IGenesisClass} message GenesisClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisClass.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.class_id != null && Object.hasOwnProperty.call(message, 'class_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.class_id);
        if (message.authority_metadata != null && Object.hasOwnProperty.call(message, 'authority_metadata'))
          $root.ununifi.nftfactory.ClassAuthorityMetadata.encode(
            message.authority_metadata,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisClass message, length delimited. Does not implicitly {@link ununifi.nftfactory.GenesisClass.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.GenesisClass
       * @static
       * @param {ununifi.nftfactory.IGenesisClass} message GenesisClass message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisClass.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisClass message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.GenesisClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.GenesisClass} GenesisClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisClass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.GenesisClass();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.class_id = reader.string();
              break;
            case 2:
              message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisClass message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.GenesisClass
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.GenesisClass} GenesisClass
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisClass.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisClass message.
       * @function verify
       * @memberof ununifi.nftfactory.GenesisClass
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisClass.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.class_id != null && message.hasOwnProperty('class_id'))
          if (!$util.isString(message.class_id)) return 'class_id: string expected';
        if (message.authority_metadata != null && message.hasOwnProperty('authority_metadata')) {
          let error = $root.ununifi.nftfactory.ClassAuthorityMetadata.verify(message.authority_metadata);
          if (error) return 'authority_metadata.' + error;
        }
        return null;
      };

      /**
       * Creates a GenesisClass message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.GenesisClass
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.GenesisClass} GenesisClass
       */
      GenesisClass.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.GenesisClass) return object;
        let message = new $root.ununifi.nftfactory.GenesisClass();
        if (object.class_id != null) message.class_id = String(object.class_id);
        if (object.authority_metadata != null) {
          if (typeof object.authority_metadata !== 'object')
            throw TypeError('.ununifi.nftfactory.GenesisClass.authority_metadata: object expected');
          message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.fromObject(object.authority_metadata);
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisClass message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.GenesisClass
       * @static
       * @param {ununifi.nftfactory.GenesisClass} message GenesisClass
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisClass.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.class_id = '';
          object.authority_metadata = null;
        }
        if (message.class_id != null && message.hasOwnProperty('class_id')) object.class_id = message.class_id;
        if (message.authority_metadata != null && message.hasOwnProperty('authority_metadata'))
          object.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.toObject(message.authority_metadata, options);
        return object;
      };

      /**
       * Converts this GenesisClass to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.GenesisClass
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisClass.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisClass;
    })();

    nftfactory.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.nftfactory.Query#params}.
       * @memberof ununifi.nftfactory.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftfactory.Query
       * @instance
       * @param {ununifi.nftfactory.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.nftfactory.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.nftfactory.QueryParamsRequest,
            $root.ununifi.nftfactory.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.nftfactory.Query
       * @instance
       * @param {ununifi.nftfactory.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.nftfactory.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftfactory.Query#classAuthorityMetadata}.
       * @memberof ununifi.nftfactory.Query
       * @typedef ClassAuthorityMetadataCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} [response] QueryClassAuthorityMetadataResponse
       */

      /**
       * Calls ClassAuthorityMetadata.
       * @function classAuthorityMetadata
       * @memberof ununifi.nftfactory.Query
       * @instance
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} request QueryClassAuthorityMetadataRequest message or plain object
       * @param {ununifi.nftfactory.Query.ClassAuthorityMetadataCallback} callback Node-style callback called with the error, if any, and QueryClassAuthorityMetadataResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.classAuthorityMetadata = function classAuthorityMetadata(request, callback) {
          return this.rpcCall(
            classAuthorityMetadata,
            $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest,
            $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ClassAuthorityMetadata' },
      );

      /**
       * Calls ClassAuthorityMetadata.
       * @function classAuthorityMetadata
       * @memberof ununifi.nftfactory.Query
       * @instance
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} request QueryClassAuthorityMetadataRequest message or plain object
       * @returns {Promise<ununifi.nftfactory.QueryClassAuthorityMetadataResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.nftfactory.Query#classesFromCreator}.
       * @memberof ununifi.nftfactory.Query
       * @typedef ClassesFromCreatorCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.nftfactory.QueryClassesFromCreatorResponse} [response] QueryClassesFromCreatorResponse
       */

      /**
       * Calls ClassesFromCreator.
       * @function classesFromCreator
       * @memberof ununifi.nftfactory.Query
       * @instance
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} request QueryClassesFromCreatorRequest message or plain object
       * @param {ununifi.nftfactory.Query.ClassesFromCreatorCallback} callback Node-style callback called with the error, if any, and QueryClassesFromCreatorResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.classesFromCreator = function classesFromCreator(request, callback) {
          return this.rpcCall(
            classesFromCreator,
            $root.ununifi.nftfactory.QueryClassesFromCreatorRequest,
            $root.ununifi.nftfactory.QueryClassesFromCreatorResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ClassesFromCreator' },
      );

      /**
       * Calls ClassesFromCreator.
       * @function classesFromCreator
       * @memberof ununifi.nftfactory.Query
       * @instance
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} request QueryClassesFromCreatorRequest message or plain object
       * @returns {Promise<ununifi.nftfactory.QueryClassesFromCreatorResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    nftfactory.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.nftfactory
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.nftfactory.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.nftfactory.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @static
       * @param {ununifi.nftfactory.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @static
       * @param {ununifi.nftfactory.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.QueryParamsRequest) return object;
        return new $root.ununifi.nftfactory.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @static
       * @param {ununifi.nftfactory.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    nftfactory.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.nftfactory
       * @interface IQueryParamsResponse
       * @property {ununifi.nftfactory.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.nftfactory.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.nftfactory.IParams|null|undefined} params
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.nftfactory.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @static
       * @param {ununifi.nftfactory.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.nftfactory.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @static
       * @param {ununifi.nftfactory.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.nftfactory.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.nftfactory.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.QueryParamsResponse) return object;
        let message = new $root.ununifi.nftfactory.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.nftfactory.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.nftfactory.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @static
       * @param {ununifi.nftfactory.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.nftfactory.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    nftfactory.QueryClassAuthorityMetadataRequest = (function () {
      /**
       * Properties of a QueryClassAuthorityMetadataRequest.
       * @memberof ununifi.nftfactory
       * @interface IQueryClassAuthorityMetadataRequest
       * @property {string|null} [creator] QueryClassAuthorityMetadataRequest creator
       * @property {string|null} [subclass] QueryClassAuthorityMetadataRequest subclass
       */

      /**
       * Constructs a new QueryClassAuthorityMetadataRequest.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a QueryClassAuthorityMetadataRequest.
       * @implements IQueryClassAuthorityMetadataRequest
       * @constructor
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest=} [properties] Properties to set
       */
      function QueryClassAuthorityMetadataRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassAuthorityMetadataRequest creator.
       * @member {string} creator
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @instance
       */
      QueryClassAuthorityMetadataRequest.prototype.creator = '';

      /**
       * QueryClassAuthorityMetadataRequest subclass.
       * @member {string} subclass
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @instance
       */
      QueryClassAuthorityMetadataRequest.prototype.subclass = '';

      /**
       * Encodes the specified QueryClassAuthorityMetadataRequest message. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @static
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} message QueryClassAuthorityMetadataRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAuthorityMetadataRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.creator != null && Object.hasOwnProperty.call(message, 'creator'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.creator);
        if (message.subclass != null && Object.hasOwnProperty.call(message, 'subclass'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.subclass);
        return writer;
      };

      /**
       * Encodes the specified QueryClassAuthorityMetadataRequest message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @static
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataRequest} message QueryClassAuthorityMetadataRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAuthorityMetadataRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassAuthorityMetadataRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} QueryClassAuthorityMetadataRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAuthorityMetadataRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            case 2:
              message.subclass = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassAuthorityMetadataRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} QueryClassAuthorityMetadataRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAuthorityMetadataRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassAuthorityMetadataRequest message.
       * @function verify
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassAuthorityMetadataRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.creator != null && message.hasOwnProperty('creator'))
          if (!$util.isString(message.creator)) return 'creator: string expected';
        if (message.subclass != null && message.hasOwnProperty('subclass'))
          if (!$util.isString(message.subclass)) return 'subclass: string expected';
        return null;
      };

      /**
       * Creates a QueryClassAuthorityMetadataRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} QueryClassAuthorityMetadataRequest
       */
      QueryClassAuthorityMetadataRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest) return object;
        let message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataRequest();
        if (object.creator != null) message.creator = String(object.creator);
        if (object.subclass != null) message.subclass = String(object.subclass);
        return message;
      };

      /**
       * Creates a plain object from a QueryClassAuthorityMetadataRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @static
       * @param {ununifi.nftfactory.QueryClassAuthorityMetadataRequest} message QueryClassAuthorityMetadataRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassAuthorityMetadataRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.creator = '';
          object.subclass = '';
        }
        if (message.creator != null && message.hasOwnProperty('creator')) object.creator = message.creator;
        if (message.subclass != null && message.hasOwnProperty('subclass')) object.subclass = message.subclass;
        return object;
      };

      /**
       * Converts this QueryClassAuthorityMetadataRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassAuthorityMetadataRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassAuthorityMetadataRequest;
    })();

    nftfactory.QueryClassAuthorityMetadataResponse = (function () {
      /**
       * Properties of a QueryClassAuthorityMetadataResponse.
       * @memberof ununifi.nftfactory
       * @interface IQueryClassAuthorityMetadataResponse
       * @property {ununifi.nftfactory.IClassAuthorityMetadata|null} [authority_metadata] QueryClassAuthorityMetadataResponse authority_metadata
       */

      /**
       * Constructs a new QueryClassAuthorityMetadataResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a QueryClassAuthorityMetadataResponse.
       * @implements IQueryClassAuthorityMetadataResponse
       * @constructor
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataResponse=} [properties] Properties to set
       */
      function QueryClassAuthorityMetadataResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassAuthorityMetadataResponse authority_metadata.
       * @member {ununifi.nftfactory.IClassAuthorityMetadata|null|undefined} authority_metadata
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @instance
       */
      QueryClassAuthorityMetadataResponse.prototype.authority_metadata = null;

      /**
       * Encodes the specified QueryClassAuthorityMetadataResponse message. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @static
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataResponse} message QueryClassAuthorityMetadataResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAuthorityMetadataResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.authority_metadata != null && Object.hasOwnProperty.call(message, 'authority_metadata'))
          $root.ununifi.nftfactory.ClassAuthorityMetadata.encode(
            message.authority_metadata,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryClassAuthorityMetadataResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassAuthorityMetadataResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @static
       * @param {ununifi.nftfactory.IQueryClassAuthorityMetadataResponse} message QueryClassAuthorityMetadataResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassAuthorityMetadataResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassAuthorityMetadataResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} QueryClassAuthorityMetadataResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAuthorityMetadataResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassAuthorityMetadataResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} QueryClassAuthorityMetadataResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassAuthorityMetadataResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassAuthorityMetadataResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassAuthorityMetadataResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.authority_metadata != null && message.hasOwnProperty('authority_metadata')) {
          let error = $root.ununifi.nftfactory.ClassAuthorityMetadata.verify(message.authority_metadata);
          if (error) return 'authority_metadata.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryClassAuthorityMetadataResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} QueryClassAuthorityMetadataResponse
       */
      QueryClassAuthorityMetadataResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse) return object;
        let message = new $root.ununifi.nftfactory.QueryClassAuthorityMetadataResponse();
        if (object.authority_metadata != null) {
          if (typeof object.authority_metadata !== 'object')
            throw TypeError('.ununifi.nftfactory.QueryClassAuthorityMetadataResponse.authority_metadata: object expected');
          message.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.fromObject(object.authority_metadata);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryClassAuthorityMetadataResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @static
       * @param {ununifi.nftfactory.QueryClassAuthorityMetadataResponse} message QueryClassAuthorityMetadataResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassAuthorityMetadataResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.authority_metadata = null;
        if (message.authority_metadata != null && message.hasOwnProperty('authority_metadata'))
          object.authority_metadata = $root.ununifi.nftfactory.ClassAuthorityMetadata.toObject(message.authority_metadata, options);
        return object;
      };

      /**
       * Converts this QueryClassAuthorityMetadataResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.QueryClassAuthorityMetadataResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassAuthorityMetadataResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassAuthorityMetadataResponse;
    })();

    nftfactory.QueryClassesFromCreatorRequest = (function () {
      /**
       * Properties of a QueryClassesFromCreatorRequest.
       * @memberof ununifi.nftfactory
       * @interface IQueryClassesFromCreatorRequest
       * @property {string|null} [creator] QueryClassesFromCreatorRequest creator
       */

      /**
       * Constructs a new QueryClassesFromCreatorRequest.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a QueryClassesFromCreatorRequest.
       * @implements IQueryClassesFromCreatorRequest
       * @constructor
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest=} [properties] Properties to set
       */
      function QueryClassesFromCreatorRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassesFromCreatorRequest creator.
       * @member {string} creator
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @instance
       */
      QueryClassesFromCreatorRequest.prototype.creator = '';

      /**
       * Encodes the specified QueryClassesFromCreatorRequest message. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @static
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} message QueryClassesFromCreatorRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassesFromCreatorRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.creator != null && Object.hasOwnProperty.call(message, 'creator'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.creator);
        return writer;
      };

      /**
       * Encodes the specified QueryClassesFromCreatorRequest message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @static
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorRequest} message QueryClassesFromCreatorRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassesFromCreatorRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassesFromCreatorRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.QueryClassesFromCreatorRequest} QueryClassesFromCreatorRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassesFromCreatorRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.QueryClassesFromCreatorRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creator = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassesFromCreatorRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.QueryClassesFromCreatorRequest} QueryClassesFromCreatorRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassesFromCreatorRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassesFromCreatorRequest message.
       * @function verify
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassesFromCreatorRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.creator != null && message.hasOwnProperty('creator'))
          if (!$util.isString(message.creator)) return 'creator: string expected';
        return null;
      };

      /**
       * Creates a QueryClassesFromCreatorRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.QueryClassesFromCreatorRequest} QueryClassesFromCreatorRequest
       */
      QueryClassesFromCreatorRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.QueryClassesFromCreatorRequest) return object;
        let message = new $root.ununifi.nftfactory.QueryClassesFromCreatorRequest();
        if (object.creator != null) message.creator = String(object.creator);
        return message;
      };

      /**
       * Creates a plain object from a QueryClassesFromCreatorRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @static
       * @param {ununifi.nftfactory.QueryClassesFromCreatorRequest} message QueryClassesFromCreatorRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassesFromCreatorRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.creator = '';
        if (message.creator != null && message.hasOwnProperty('creator')) object.creator = message.creator;
        return object;
      };

      /**
       * Converts this QueryClassesFromCreatorRequest to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassesFromCreatorRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassesFromCreatorRequest;
    })();

    nftfactory.QueryClassesFromCreatorResponse = (function () {
      /**
       * Properties of a QueryClassesFromCreatorResponse.
       * @memberof ununifi.nftfactory
       * @interface IQueryClassesFromCreatorResponse
       * @property {Array.<string>|null} [classes] QueryClassesFromCreatorResponse classes
       */

      /**
       * Constructs a new QueryClassesFromCreatorResponse.
       * @memberof ununifi.nftfactory
       * @classdesc Represents a QueryClassesFromCreatorResponse.
       * @implements IQueryClassesFromCreatorResponse
       * @constructor
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorResponse=} [properties] Properties to set
       */
      function QueryClassesFromCreatorResponse(properties) {
        this.classes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryClassesFromCreatorResponse classes.
       * @member {Array.<string>} classes
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @instance
       */
      QueryClassesFromCreatorResponse.prototype.classes = $util.emptyArray;

      /**
       * Encodes the specified QueryClassesFromCreatorResponse message. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @static
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorResponse} message QueryClassesFromCreatorResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassesFromCreatorResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.classes != null && message.classes.length)
          for (let i = 0; i < message.classes.length; ++i) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.classes[i]);
        return writer;
      };

      /**
       * Encodes the specified QueryClassesFromCreatorResponse message, length delimited. Does not implicitly {@link ununifi.nftfactory.QueryClassesFromCreatorResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @static
       * @param {ununifi.nftfactory.IQueryClassesFromCreatorResponse} message QueryClassesFromCreatorResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryClassesFromCreatorResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryClassesFromCreatorResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.nftfactory.QueryClassesFromCreatorResponse} QueryClassesFromCreatorResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassesFromCreatorResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.nftfactory.QueryClassesFromCreatorResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.classes && message.classes.length)) message.classes = [];
              message.classes.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryClassesFromCreatorResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.nftfactory.QueryClassesFromCreatorResponse} QueryClassesFromCreatorResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryClassesFromCreatorResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryClassesFromCreatorResponse message.
       * @function verify
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryClassesFromCreatorResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.classes != null && message.hasOwnProperty('classes')) {
          if (!Array.isArray(message.classes)) return 'classes: array expected';
          for (let i = 0; i < message.classes.length; ++i) if (!$util.isString(message.classes[i])) return 'classes: string[] expected';
        }
        return null;
      };

      /**
       * Creates a QueryClassesFromCreatorResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.nftfactory.QueryClassesFromCreatorResponse} QueryClassesFromCreatorResponse
       */
      QueryClassesFromCreatorResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.nftfactory.QueryClassesFromCreatorResponse) return object;
        let message = new $root.ununifi.nftfactory.QueryClassesFromCreatorResponse();
        if (object.classes) {
          if (!Array.isArray(object.classes))
            throw TypeError('.ununifi.nftfactory.QueryClassesFromCreatorResponse.classes: array expected');
          message.classes = [];
          for (let i = 0; i < object.classes.length; ++i) message.classes[i] = String(object.classes[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryClassesFromCreatorResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @static
       * @param {ununifi.nftfactory.QueryClassesFromCreatorResponse} message QueryClassesFromCreatorResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryClassesFromCreatorResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.classes = [];
        if (message.classes && message.classes.length) {
          object.classes = [];
          for (let j = 0; j < message.classes.length; ++j) object.classes[j] = message.classes[j];
        }
        return object;
      };

      /**
       * Converts this QueryClassesFromCreatorResponse to JSON.
       * @function toJSON
       * @memberof ununifi.nftfactory.QueryClassesFromCreatorResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryClassesFromCreatorResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryClassesFromCreatorResponse;
    })();

    return nftfactory;
  })();

  ununifi.pricefeed = (function () {
    /**
     * Namespace pricefeed.
     * @memberof ununifi
     * @namespace
     */
    const pricefeed = {};

    pricefeed.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.pricefeed.Msg#postPrice}.
       * @memberof ununifi.pricefeed.Msg
       * @typedef PostPriceCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.MsgPostPriceResponse} [response] MsgPostPriceResponse
       */

      /**
       * Calls PostPrice.
       * @function postPrice
       * @memberof ununifi.pricefeed.Msg
       * @instance
       * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
       * @param {ununifi.pricefeed.Msg.PostPriceCallback} callback Node-style callback called with the error, if any, and MsgPostPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.postPrice = function postPrice(request, callback) {
          return this.rpcCall(
            postPrice,
            $root.ununifi.pricefeed.MsgPostPrice,
            $root.ununifi.pricefeed.MsgPostPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PostPrice' },
      );

      /**
       * Calls PostPrice.
       * @function postPrice
       * @memberof ununifi.pricefeed.Msg
       * @instance
       * @param {ununifi.pricefeed.IMsgPostPrice} request MsgPostPrice message or plain object
       * @returns {Promise<ununifi.pricefeed.MsgPostPriceResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    pricefeed.MsgPostPrice = (function () {
      /**
       * Properties of a MsgPostPrice.
       * @memberof ununifi.pricefeed
       * @interface IMsgPostPrice
       * @property {string|null} [from] MsgPostPrice from
       * @property {string|null} [market_id] MsgPostPrice market_id
       * @property {string|null} [price] MsgPostPrice price
       * @property {google.protobuf.ITimestamp|null} [expiry] MsgPostPrice expiry
       */

      /**
       * Constructs a new MsgPostPrice.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a MsgPostPrice.
       * @implements IMsgPostPrice
       * @constructor
       * @param {ununifi.pricefeed.IMsgPostPrice=} [properties] Properties to set
       */
      function MsgPostPrice(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgPostPrice from.
       * @member {string} from
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.from = '';

      /**
       * MsgPostPrice market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.market_id = '';

      /**
       * MsgPostPrice price.
       * @member {string} price
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.price = '';

      /**
       * MsgPostPrice expiry.
       * @member {google.protobuf.ITimestamp|null|undefined} expiry
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       */
      MsgPostPrice.prototype.expiry = null;

      /**
       * Encodes the specified MsgPostPrice message. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPrice.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.from != null && Object.hasOwnProperty.call(message, 'from'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.from);
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.market_id);
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
        if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
          $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgPostPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPrice.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {ununifi.pricefeed.IMsgPostPrice} message MsgPostPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPrice.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPostPrice message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPrice.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.MsgPostPrice();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.from = reader.string();
              break;
            case 2:
              message.market_id = reader.string();
              break;
            case 3:
              message.price = reader.string();
              break;
            case 4:
              message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPostPrice message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPrice.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPostPrice message.
       * @function verify
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPostPrice.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.from != null && message.hasOwnProperty('from')) if (!$util.isString(message.from)) return 'from: string expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
        if (message.expiry != null && message.hasOwnProperty('expiry')) {
          let error = $root.google.protobuf.Timestamp.verify(message.expiry);
          if (error) return 'expiry.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgPostPrice message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.MsgPostPrice} MsgPostPrice
       */
      MsgPostPrice.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.MsgPostPrice) return object;
        let message = new $root.ununifi.pricefeed.MsgPostPrice();
        if (object.from != null) message.from = String(object.from);
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.price != null) message.price = String(object.price);
        if (object.expiry != null) {
          if (typeof object.expiry !== 'object') throw TypeError('.ununifi.pricefeed.MsgPostPrice.expiry: object expected');
          message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgPostPrice message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @static
       * @param {ununifi.pricefeed.MsgPostPrice} message MsgPostPrice
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPostPrice.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.from = '';
          object.market_id = '';
          object.price = '';
          object.expiry = null;
        }
        if (message.from != null && message.hasOwnProperty('from')) object.from = message.from;
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
        if (message.expiry != null && message.hasOwnProperty('expiry'))
          object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
        return object;
      };

      /**
       * Converts this MsgPostPrice to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.MsgPostPrice
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPostPrice.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPostPrice;
    })();

    pricefeed.MsgPostPriceResponse = (function () {
      /**
       * Properties of a MsgPostPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IMsgPostPriceResponse
       */

      /**
       * Constructs a new MsgPostPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a MsgPostPriceResponse.
       * @implements IMsgPostPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IMsgPostPriceResponse=} [properties] Properties to set
       */
      function MsgPostPriceResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgPostPriceResponse message. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgPostPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.MsgPostPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {ununifi.pricefeed.IMsgPostPriceResponse} message MsgPostPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgPostPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgPostPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.MsgPostPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgPostPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgPostPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgPostPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgPostPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgPostPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.MsgPostPriceResponse} MsgPostPriceResponse
       */
      MsgPostPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.MsgPostPriceResponse) return object;
        return new $root.ununifi.pricefeed.MsgPostPriceResponse();
      };

      /**
       * Creates a plain object from a MsgPostPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @static
       * @param {ununifi.pricefeed.MsgPostPriceResponse} message MsgPostPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgPostPriceResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgPostPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.MsgPostPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgPostPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgPostPriceResponse;
    })();

    pricefeed.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.pricefeed
       * @interface IGenesisState
       * @property {ununifi.pricefeed.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [posted_prices] GenesisState posted_prices
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.pricefeed.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.posted_prices = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.pricefeed.IParams|null|undefined} params
       * @memberof ununifi.pricefeed.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState posted_prices.
       * @member {Array.<ununifi.pricefeed.IPostedPrice>} posted_prices
       * @memberof ununifi.pricefeed.GenesisState
       * @instance
       */
      GenesisState.prototype.posted_prices = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.posted_prices != null && message.posted_prices.length)
          for (let i = 0; i < message.posted_prices.length; ++i)
            $root.ununifi.pricefeed.PostedPrice.encode(message.posted_prices[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.pricefeed.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {ununifi.pricefeed.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.posted_prices && message.posted_prices.length)) message.posted_prices = [];
              message.posted_prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.pricefeed.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.posted_prices != null && message.hasOwnProperty('posted_prices')) {
          if (!Array.isArray(message.posted_prices)) return 'posted_prices: array expected';
          for (let i = 0; i < message.posted_prices.length; ++i) {
            let error = $root.ununifi.pricefeed.PostedPrice.verify(message.posted_prices[i]);
            if (error) return 'posted_prices.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.GenesisState) return object;
        let message = new $root.ununifi.pricefeed.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.pricefeed.GenesisState.params: object expected');
          message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
        }
        if (object.posted_prices) {
          if (!Array.isArray(object.posted_prices)) throw TypeError('.ununifi.pricefeed.GenesisState.posted_prices: array expected');
          message.posted_prices = [];
          for (let i = 0; i < object.posted_prices.length; ++i) {
            if (typeof object.posted_prices[i] !== 'object')
              throw TypeError('.ununifi.pricefeed.GenesisState.posted_prices: object expected');
            message.posted_prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.posted_prices[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.GenesisState
       * @static
       * @param {ununifi.pricefeed.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.posted_prices = [];
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
        if (message.posted_prices && message.posted_prices.length) {
          object.posted_prices = [];
          for (let j = 0; j < message.posted_prices.length; ++j)
            object.posted_prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.posted_prices[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    pricefeed.Market = (function () {
      /**
       * Properties of a Market.
       * @memberof ununifi.pricefeed
       * @interface IMarket
       * @property {string|null} [market_id] Market market_id
       * @property {string|null} [base_asset] Market base_asset
       * @property {string|null} [quote_asset] Market quote_asset
       * @property {Array.<string>|null} [oracles] Market oracles
       * @property {boolean|null} [active] Market active
       */

      /**
       * Constructs a new Market.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Market.
       * @implements IMarket
       * @constructor
       * @param {ununifi.pricefeed.IMarket=} [properties] Properties to set
       */
      function Market(properties) {
        this.oracles = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Market market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.market_id = '';

      /**
       * Market base_asset.
       * @member {string} base_asset
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.base_asset = '';

      /**
       * Market quote_asset.
       * @member {string} quote_asset
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.quote_asset = '';

      /**
       * Market oracles.
       * @member {Array.<string>} oracles
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.oracles = $util.emptyArray;

      /**
       * Market active.
       * @member {boolean} active
       * @memberof ununifi.pricefeed.Market
       * @instance
       */
      Market.prototype.active = false;

      /**
       * Encodes the specified Market message. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Market.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.base_asset != null && Object.hasOwnProperty.call(message, 'base_asset'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.base_asset);
        if (message.quote_asset != null && Object.hasOwnProperty.call(message, 'quote_asset'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.quote_asset);
        if (message.oracles != null && message.oracles.length)
          for (let i = 0; i < message.oracles.length; ++i) writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.oracles[i]);
        if (message.active != null && Object.hasOwnProperty.call(message, 'active'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.active);
        return writer;
      };

      /**
       * Encodes the specified Market message, length delimited. Does not implicitly {@link ununifi.pricefeed.Market.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {ununifi.pricefeed.IMarket} message Market message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Market.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Market message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.Market} Market
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Market.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.Market();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.base_asset = reader.string();
              break;
            case 3:
              message.quote_asset = reader.string();
              break;
            case 4:
              if (!(message.oracles && message.oracles.length)) message.oracles = [];
              message.oracles.push(reader.string());
              break;
            case 5:
              message.active = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Market message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.Market} Market
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Market.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Market message.
       * @function verify
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Market.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.base_asset != null && message.hasOwnProperty('base_asset'))
          if (!$util.isString(message.base_asset)) return 'base_asset: string expected';
        if (message.quote_asset != null && message.hasOwnProperty('quote_asset'))
          if (!$util.isString(message.quote_asset)) return 'quote_asset: string expected';
        if (message.oracles != null && message.hasOwnProperty('oracles')) {
          if (!Array.isArray(message.oracles)) return 'oracles: array expected';
          for (let i = 0; i < message.oracles.length; ++i) if (!$util.isString(message.oracles[i])) return 'oracles: string[] expected';
        }
        if (message.active != null && message.hasOwnProperty('active'))
          if (typeof message.active !== 'boolean') return 'active: boolean expected';
        return null;
      };

      /**
       * Creates a Market message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.Market} Market
       */
      Market.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.Market) return object;
        let message = new $root.ununifi.pricefeed.Market();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.base_asset != null) message.base_asset = String(object.base_asset);
        if (object.quote_asset != null) message.quote_asset = String(object.quote_asset);
        if (object.oracles) {
          if (!Array.isArray(object.oracles)) throw TypeError('.ununifi.pricefeed.Market.oracles: array expected');
          message.oracles = [];
          for (let i = 0; i < object.oracles.length; ++i) message.oracles[i] = String(object.oracles[i]);
        }
        if (object.active != null) message.active = Boolean(object.active);
        return message;
      };

      /**
       * Creates a plain object from a Market message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.Market
       * @static
       * @param {ununifi.pricefeed.Market} message Market
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Market.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.oracles = [];
        if (options.defaults) {
          object.market_id = '';
          object.base_asset = '';
          object.quote_asset = '';
          object.active = false;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.base_asset != null && message.hasOwnProperty('base_asset')) object.base_asset = message.base_asset;
        if (message.quote_asset != null && message.hasOwnProperty('quote_asset')) object.quote_asset = message.quote_asset;
        if (message.oracles && message.oracles.length) {
          object.oracles = [];
          for (let j = 0; j < message.oracles.length; ++j) object.oracles[j] = message.oracles[j];
        }
        if (message.active != null && message.hasOwnProperty('active')) object.active = message.active;
        return object;
      };

      /**
       * Converts this Market to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.Market
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Market.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Market;
    })();

    pricefeed.CurrentPrice = (function () {
      /**
       * Properties of a CurrentPrice.
       * @memberof ununifi.pricefeed
       * @interface ICurrentPrice
       * @property {string|null} [market_id] CurrentPrice market_id
       * @property {string|null} [price] CurrentPrice price
       */

      /**
       * Constructs a new CurrentPrice.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a CurrentPrice.
       * @implements ICurrentPrice
       * @constructor
       * @param {ununifi.pricefeed.ICurrentPrice=} [properties] Properties to set
       */
      function CurrentPrice(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * CurrentPrice market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.CurrentPrice
       * @instance
       */
      CurrentPrice.prototype.market_id = '';

      /**
       * CurrentPrice price.
       * @member {string} price
       * @memberof ununifi.pricefeed.CurrentPrice
       * @instance
       */
      CurrentPrice.prototype.price = '';

      /**
       * Encodes the specified CurrentPrice message. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CurrentPrice.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.price);
        return writer;
      };

      /**
       * Encodes the specified CurrentPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.CurrentPrice.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {ununifi.pricefeed.ICurrentPrice} message CurrentPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CurrentPrice.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CurrentPrice message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CurrentPrice.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.CurrentPrice();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.price = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CurrentPrice message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CurrentPrice.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CurrentPrice message.
       * @function verify
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CurrentPrice.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
        return null;
      };

      /**
       * Creates a CurrentPrice message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.CurrentPrice} CurrentPrice
       */
      CurrentPrice.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.CurrentPrice) return object;
        let message = new $root.ununifi.pricefeed.CurrentPrice();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.price != null) message.price = String(object.price);
        return message;
      };

      /**
       * Creates a plain object from a CurrentPrice message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.CurrentPrice
       * @static
       * @param {ununifi.pricefeed.CurrentPrice} message CurrentPrice
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CurrentPrice.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.price = '';
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
        return object;
      };

      /**
       * Converts this CurrentPrice to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.CurrentPrice
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CurrentPrice.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CurrentPrice;
    })();

    pricefeed.PostedPrice = (function () {
      /**
       * Properties of a PostedPrice.
       * @memberof ununifi.pricefeed
       * @interface IPostedPrice
       * @property {string|null} [market_id] PostedPrice market_id
       * @property {string|null} [oracle_address] PostedPrice oracle_address
       * @property {string|null} [price] PostedPrice price
       * @property {google.protobuf.ITimestamp|null} [expiry] PostedPrice expiry
       */

      /**
       * Constructs a new PostedPrice.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a PostedPrice.
       * @implements IPostedPrice
       * @constructor
       * @param {ununifi.pricefeed.IPostedPrice=} [properties] Properties to set
       */
      function PostedPrice(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PostedPrice market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.market_id = '';

      /**
       * PostedPrice oracle_address.
       * @member {string} oracle_address
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.oracle_address = '';

      /**
       * PostedPrice price.
       * @member {string} price
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.price = '';

      /**
       * PostedPrice expiry.
       * @member {google.protobuf.ITimestamp|null|undefined} expiry
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       */
      PostedPrice.prototype.expiry = null;

      /**
       * Encodes the specified PostedPrice message. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PostedPrice.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.oracle_address != null && Object.hasOwnProperty.call(message, 'oracle_address'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.oracle_address);
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.price);
        if (message.expiry != null && Object.hasOwnProperty.call(message, 'expiry'))
          $root.google.protobuf.Timestamp.encode(message.expiry, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified PostedPrice message, length delimited. Does not implicitly {@link ununifi.pricefeed.PostedPrice.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {ununifi.pricefeed.IPostedPrice} message PostedPrice message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PostedPrice.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PostedPrice message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PostedPrice.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.PostedPrice();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.oracle_address = reader.string();
              break;
            case 3:
              message.price = reader.string();
              break;
            case 4:
              message.expiry = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PostedPrice message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PostedPrice.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PostedPrice message.
       * @function verify
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PostedPrice.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.oracle_address != null && message.hasOwnProperty('oracle_address'))
          if (!$util.isString(message.oracle_address)) return 'oracle_address: string expected';
        if (message.price != null && message.hasOwnProperty('price')) if (!$util.isString(message.price)) return 'price: string expected';
        if (message.expiry != null && message.hasOwnProperty('expiry')) {
          let error = $root.google.protobuf.Timestamp.verify(message.expiry);
          if (error) return 'expiry.' + error;
        }
        return null;
      };

      /**
       * Creates a PostedPrice message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.PostedPrice} PostedPrice
       */
      PostedPrice.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.PostedPrice) return object;
        let message = new $root.ununifi.pricefeed.PostedPrice();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.oracle_address != null) message.oracle_address = String(object.oracle_address);
        if (object.price != null) message.price = String(object.price);
        if (object.expiry != null) {
          if (typeof object.expiry !== 'object') throw TypeError('.ununifi.pricefeed.PostedPrice.expiry: object expected');
          message.expiry = $root.google.protobuf.Timestamp.fromObject(object.expiry);
        }
        return message;
      };

      /**
       * Creates a plain object from a PostedPrice message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.PostedPrice
       * @static
       * @param {ununifi.pricefeed.PostedPrice} message PostedPrice
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PostedPrice.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.oracle_address = '';
          object.price = '';
          object.expiry = null;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.oracle_address != null && message.hasOwnProperty('oracle_address')) object.oracle_address = message.oracle_address;
        if (message.price != null && message.hasOwnProperty('price')) object.price = message.price;
        if (message.expiry != null && message.hasOwnProperty('expiry'))
          object.expiry = $root.google.protobuf.Timestamp.toObject(message.expiry, options);
        return object;
      };

      /**
       * Converts this PostedPrice to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.PostedPrice
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PostedPrice.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PostedPrice;
    })();

    pricefeed.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.pricefeed
       * @interface IParams
       * @property {cosmos.base.v1beta1.ICoin|null} [deposit_for_posting] Params deposit_for_posting
       * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] Params markets
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.pricefeed.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        this.markets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params deposit_for_posting.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit_for_posting
       * @memberof ununifi.pricefeed.Params
       * @instance
       */
      Params.prototype.deposit_for_posting = null;

      /**
       * Params markets.
       * @member {Array.<ununifi.pricefeed.IMarket>} markets
       * @memberof ununifi.pricefeed.Params
       * @instance
       */
      Params.prototype.markets = $util.emptyArray;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deposit_for_posting != null && Object.hasOwnProperty.call(message, 'deposit_for_posting'))
          $root.cosmos.base.v1beta1.Coin.encode(message.deposit_for_posting, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.markets != null && message.markets.length)
          for (let i = 0; i < message.markets.length; ++i)
            $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.pricefeed.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {ununifi.pricefeed.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit_for_posting = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.markets && message.markets.length)) message.markets = [];
              message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deposit_for_posting != null && message.hasOwnProperty('deposit_for_posting')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit_for_posting);
          if (error) return 'deposit_for_posting.' + error;
        }
        if (message.markets != null && message.hasOwnProperty('markets')) {
          if (!Array.isArray(message.markets)) return 'markets: array expected';
          for (let i = 0; i < message.markets.length; ++i) {
            let error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
            if (error) return 'markets.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.Params) return object;
        let message = new $root.ununifi.pricefeed.Params();
        if (object.deposit_for_posting != null) {
          if (typeof object.deposit_for_posting !== 'object')
            throw TypeError('.ununifi.pricefeed.Params.deposit_for_posting: object expected');
          message.deposit_for_posting = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit_for_posting);
        }
        if (object.markets) {
          if (!Array.isArray(object.markets)) throw TypeError('.ununifi.pricefeed.Params.markets: array expected');
          message.markets = [];
          for (let i = 0; i < object.markets.length; ++i) {
            if (typeof object.markets[i] !== 'object') throw TypeError('.ununifi.pricefeed.Params.markets: object expected');
            message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.Params
       * @static
       * @param {ununifi.pricefeed.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.markets = [];
        if (options.defaults) object.deposit_for_posting = null;
        if (message.deposit_for_posting != null && message.hasOwnProperty('deposit_for_posting'))
          object.deposit_for_posting = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit_for_posting, options);
        if (message.markets && message.markets.length) {
          object.markets = [];
          for (let j = 0; j < message.markets.length; ++j)
            object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
        }
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    pricefeed.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#params}.
       * @memberof ununifi.pricefeed.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.pricefeed.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.pricefeed.QueryParamsRequest,
            $root.ununifi.pricefeed.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#marketAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef MarketAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllMarketResponse} [response] QueryAllMarketResponse
       */

      /**
       * Calls MarketAll.
       * @function marketAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
       * @param {ununifi.pricefeed.Query.MarketAllCallback} callback Node-style callback called with the error, if any, and QueryAllMarketResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.marketAll = function marketAll(request, callback) {
          return this.rpcCall(
            marketAll,
            $root.ununifi.pricefeed.QueryAllMarketRequest,
            $root.ununifi.pricefeed.QueryAllMarketResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'MarketAll' },
      );

      /**
       * Calls MarketAll.
       * @function marketAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} request QueryAllMarketRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllMarketResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#oracleAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef OracleAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllOracleResponse} [response] QueryAllOracleResponse
       */

      /**
       * Calls OracleAll.
       * @function oracleAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
       * @param {ununifi.pricefeed.Query.OracleAllCallback} callback Node-style callback called with the error, if any, and QueryAllOracleResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.oracleAll = function oracleAll(request, callback) {
          return this.rpcCall(
            oracleAll,
            $root.ununifi.pricefeed.QueryAllOracleRequest,
            $root.ununifi.pricefeed.QueryAllOracleResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'OracleAll' },
      );

      /**
       * Calls OracleAll.
       * @function oracleAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} request QueryAllOracleRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllOracleResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#price}.
       * @memberof ununifi.pricefeed.Query
       * @typedef PriceCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryGetPriceResponse} [response] QueryGetPriceResponse
       */

      /**
       * Calls Price.
       * @function price
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
       * @param {ununifi.pricefeed.Query.PriceCallback} callback Node-style callback called with the error, if any, and QueryGetPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.price = function price(request, callback) {
          return this.rpcCall(
            price,
            $root.ununifi.pricefeed.QueryGetPriceRequest,
            $root.ununifi.pricefeed.QueryGetPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Price' },
      );

      /**
       * Calls Price.
       * @function price
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} request QueryGetPriceRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryGetPriceResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#priceAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef PriceAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllPriceResponse} [response] QueryAllPriceResponse
       */

      /**
       * Calls PriceAll.
       * @function priceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
       * @param {ununifi.pricefeed.Query.PriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.priceAll = function priceAll(request, callback) {
          return this.rpcCall(
            priceAll,
            $root.ununifi.pricefeed.QueryAllPriceRequest,
            $root.ununifi.pricefeed.QueryAllPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PriceAll' },
      );

      /**
       * Calls PriceAll.
       * @function priceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} request QueryAllPriceRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllPriceResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.pricefeed.Query#rawPriceAll}.
       * @memberof ununifi.pricefeed.Query
       * @typedef RawPriceAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.pricefeed.QueryAllRawPriceResponse} [response] QueryAllRawPriceResponse
       */

      /**
       * Calls RawPriceAll.
       * @function rawPriceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
       * @param {ununifi.pricefeed.Query.RawPriceAllCallback} callback Node-style callback called with the error, if any, and QueryAllRawPriceResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.rawPriceAll = function rawPriceAll(request, callback) {
          return this.rpcCall(
            rawPriceAll,
            $root.ununifi.pricefeed.QueryAllRawPriceRequest,
            $root.ununifi.pricefeed.QueryAllRawPriceResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RawPriceAll' },
      );

      /**
       * Calls RawPriceAll.
       * @function rawPriceAll
       * @memberof ununifi.pricefeed.Query
       * @instance
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} request QueryAllRawPriceRequest message or plain object
       * @returns {Promise<ununifi.pricefeed.QueryAllRawPriceResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    pricefeed.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {ununifi.pricefeed.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryParamsRequest) return object;
        return new $root.ununifi.pricefeed.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @static
       * @param {ununifi.pricefeed.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    pricefeed.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryParamsResponse
       * @property {ununifi.pricefeed.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.pricefeed.IParams|null|undefined} params
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.pricefeed.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {ununifi.pricefeed.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.pricefeed.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.pricefeed.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryParamsResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.pricefeed.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.pricefeed.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @static
       * @param {ununifi.pricefeed.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.pricefeed.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    pricefeed.QueryAllMarketRequest = (function () {
      /**
       * Properties of a QueryAllMarketRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllMarketRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllMarketRequest pagination
       */

      /**
       * Constructs a new QueryAllMarketRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllMarketRequest.
       * @implements IQueryAllMarketRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllMarketRequest=} [properties] Properties to set
       */
      function QueryAllMarketRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllMarketRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @instance
       */
      QueryAllMarketRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllMarketRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllMarketRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketRequest} message QueryAllMarketRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllMarketRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllMarketRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllMarketRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllMarketRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllMarketRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllMarketRequest} QueryAllMarketRequest
       */
      QueryAllMarketRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllMarketRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllMarketRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllMarketRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllMarketRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllMarketRequest} message QueryAllMarketRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllMarketRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllMarketRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllMarketRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllMarketRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllMarketRequest;
    })();

    pricefeed.QueryAllMarketResponse = (function () {
      /**
       * Properties of a QueryAllMarketResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllMarketResponse
       * @property {Array.<ununifi.pricefeed.IMarket>|null} [markets] QueryAllMarketResponse markets
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllMarketResponse pagination
       */

      /**
       * Constructs a new QueryAllMarketResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllMarketResponse.
       * @implements IQueryAllMarketResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllMarketResponse=} [properties] Properties to set
       */
      function QueryAllMarketResponse(properties) {
        this.markets = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllMarketResponse markets.
       * @member {Array.<ununifi.pricefeed.IMarket>} markets
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @instance
       */
      QueryAllMarketResponse.prototype.markets = $util.emptyArray;

      /**
       * QueryAllMarketResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @instance
       */
      QueryAllMarketResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllMarketResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.markets != null && message.markets.length)
          for (let i = 0; i < message.markets.length; ++i)
            $root.ununifi.pricefeed.Market.encode(message.markets[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllMarketResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllMarketResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllMarketResponse} message QueryAllMarketResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllMarketResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllMarketResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.markets && message.markets.length)) message.markets = [];
              message.markets.push($root.ununifi.pricefeed.Market.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllMarketResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllMarketResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllMarketResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllMarketResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.markets != null && message.hasOwnProperty('markets')) {
          if (!Array.isArray(message.markets)) return 'markets: array expected';
          for (let i = 0; i < message.markets.length; ++i) {
            let error = $root.ununifi.pricefeed.Market.verify(message.markets[i]);
            if (error) return 'markets.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllMarketResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllMarketResponse} QueryAllMarketResponse
       */
      QueryAllMarketResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllMarketResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllMarketResponse();
        if (object.markets) {
          if (!Array.isArray(object.markets)) throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.markets: array expected');
          message.markets = [];
          for (let i = 0; i < object.markets.length; ++i) {
            if (typeof object.markets[i] !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.markets: object expected');
            message.markets[i] = $root.ununifi.pricefeed.Market.fromObject(object.markets[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllMarketResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllMarketResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllMarketResponse} message QueryAllMarketResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllMarketResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.markets = [];
        if (options.defaults) object.pagination = null;
        if (message.markets && message.markets.length) {
          object.markets = [];
          for (let j = 0; j < message.markets.length; ++j)
            object.markets[j] = $root.ununifi.pricefeed.Market.toObject(message.markets[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllMarketResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllMarketResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllMarketResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllMarketResponse;
    })();

    pricefeed.QueryAllOracleRequest = (function () {
      /**
       * Properties of a QueryAllOracleRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllOracleRequest
       * @property {string|null} [market_id] QueryAllOracleRequest market_id
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllOracleRequest pagination
       */

      /**
       * Constructs a new QueryAllOracleRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllOracleRequest.
       * @implements IQueryAllOracleRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllOracleRequest=} [properties] Properties to set
       */
      function QueryAllOracleRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllOracleRequest market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @instance
       */
      QueryAllOracleRequest.prototype.market_id = '';

      /**
       * QueryAllOracleRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @instance
       */
      QueryAllOracleRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllOracleRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllOracleRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleRequest} message QueryAllOracleRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllOracleRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllOracleRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllOracleRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllOracleRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllOracleRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllOracleRequest} QueryAllOracleRequest
       */
      QueryAllOracleRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllOracleRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllOracleRequest();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllOracleRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllOracleRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllOracleRequest} message QueryAllOracleRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllOracleRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.pagination = null;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllOracleRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllOracleRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllOracleRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllOracleRequest;
    })();

    pricefeed.QueryAllOracleResponse = (function () {
      /**
       * Properties of a QueryAllOracleResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllOracleResponse
       * @property {Array.<string>|null} [oracles] QueryAllOracleResponse oracles
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllOracleResponse pagination
       */

      /**
       * Constructs a new QueryAllOracleResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllOracleResponse.
       * @implements IQueryAllOracleResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllOracleResponse=} [properties] Properties to set
       */
      function QueryAllOracleResponse(properties) {
        this.oracles = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllOracleResponse oracles.
       * @member {Array.<string>} oracles
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @instance
       */
      QueryAllOracleResponse.prototype.oracles = $util.emptyArray;

      /**
       * QueryAllOracleResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @instance
       */
      QueryAllOracleResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllOracleResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.oracles != null && message.oracles.length)
          for (let i = 0; i < message.oracles.length; ++i) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.oracles[i]);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllOracleResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllOracleResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllOracleResponse} message QueryAllOracleResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllOracleResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllOracleResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.oracles && message.oracles.length)) message.oracles = [];
              message.oracles.push(reader.string());
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllOracleResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllOracleResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllOracleResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllOracleResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.oracles != null && message.hasOwnProperty('oracles')) {
          if (!Array.isArray(message.oracles)) return 'oracles: array expected';
          for (let i = 0; i < message.oracles.length; ++i) if (!$util.isString(message.oracles[i])) return 'oracles: string[] expected';
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllOracleResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllOracleResponse} QueryAllOracleResponse
       */
      QueryAllOracleResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllOracleResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllOracleResponse();
        if (object.oracles) {
          if (!Array.isArray(object.oracles)) throw TypeError('.ununifi.pricefeed.QueryAllOracleResponse.oracles: array expected');
          message.oracles = [];
          for (let i = 0; i < object.oracles.length; ++i) message.oracles[i] = String(object.oracles[i]);
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllOracleResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllOracleResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllOracleResponse} message QueryAllOracleResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllOracleResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.oracles = [];
        if (options.defaults) object.pagination = null;
        if (message.oracles && message.oracles.length) {
          object.oracles = [];
          for (let j = 0; j < message.oracles.length; ++j) object.oracles[j] = message.oracles[j];
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllOracleResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllOracleResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllOracleResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllOracleResponse;
    })();

    pricefeed.QueryGetPriceRequest = (function () {
      /**
       * Properties of a QueryGetPriceRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryGetPriceRequest
       * @property {string|null} [market_id] QueryGetPriceRequest market_id
       */

      /**
       * Constructs a new QueryGetPriceRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryGetPriceRequest.
       * @implements IQueryGetPriceRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryGetPriceRequest=} [properties] Properties to set
       */
      function QueryGetPriceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetPriceRequest market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @instance
       */
      QueryGetPriceRequest.prototype.market_id = '';

      /**
       * Encodes the specified QueryGetPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceRequest} message QueryGetPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetPriceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetPriceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetPriceRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetPriceRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        return null;
      };

      /**
       * Creates a QueryGetPriceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryGetPriceRequest} QueryGetPriceRequest
       */
      QueryGetPriceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryGetPriceRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryGetPriceRequest();
        if (object.market_id != null) message.market_id = String(object.market_id);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetPriceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @static
       * @param {ununifi.pricefeed.QueryGetPriceRequest} message QueryGetPriceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetPriceRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.market_id = '';
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        return object;
      };

      /**
       * Converts this QueryGetPriceRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryGetPriceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetPriceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetPriceRequest;
    })();

    pricefeed.QueryGetPriceResponse = (function () {
      /**
       * Properties of a QueryGetPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryGetPriceResponse
       * @property {ununifi.pricefeed.ICurrentPrice|null} [price] QueryGetPriceResponse price
       */

      /**
       * Constructs a new QueryGetPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryGetPriceResponse.
       * @implements IQueryGetPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryGetPriceResponse=} [properties] Properties to set
       */
      function QueryGetPriceResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetPriceResponse price.
       * @member {ununifi.pricefeed.ICurrentPrice|null|undefined} price
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @instance
       */
      QueryGetPriceResponse.prototype.price = null;

      /**
       * Encodes the specified QueryGetPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.price != null && Object.hasOwnProperty.call(message, 'price'))
          $root.ununifi.pricefeed.CurrentPrice.encode(message.price, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryGetPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryGetPriceResponse} message QueryGetPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.price = $root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.price != null && message.hasOwnProperty('price')) {
          let error = $root.ununifi.pricefeed.CurrentPrice.verify(message.price);
          if (error) return 'price.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryGetPriceResponse} QueryGetPriceResponse
       */
      QueryGetPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryGetPriceResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryGetPriceResponse();
        if (object.price != null) {
          if (typeof object.price !== 'object') throw TypeError('.ununifi.pricefeed.QueryGetPriceResponse.price: object expected');
          message.price = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.price);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @static
       * @param {ununifi.pricefeed.QueryGetPriceResponse} message QueryGetPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetPriceResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.price = null;
        if (message.price != null && message.hasOwnProperty('price'))
          object.price = $root.ununifi.pricefeed.CurrentPrice.toObject(message.price, options);
        return object;
      };

      /**
       * Converts this QueryGetPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryGetPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetPriceResponse;
    })();

    pricefeed.QueryAllPriceRequest = (function () {
      /**
       * Properties of a QueryAllPriceRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllPriceRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllPriceRequest pagination
       */

      /**
       * Constructs a new QueryAllPriceRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllPriceRequest.
       * @implements IQueryAllPriceRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllPriceRequest=} [properties] Properties to set
       */
      function QueryAllPriceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllPriceRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @instance
       */
      QueryAllPriceRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceRequest} message QueryAllPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPriceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPriceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPriceRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPriceRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllPriceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllPriceRequest} QueryAllPriceRequest
       */
      QueryAllPriceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllPriceRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllPriceRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.ununifi.pricefeed.QueryAllPriceRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllPriceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllPriceRequest} message QueryAllPriceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPriceRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllPriceRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllPriceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPriceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPriceRequest;
    })();

    pricefeed.QueryAllPriceResponse = (function () {
      /**
       * Properties of a QueryAllPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllPriceResponse
       * @property {Array.<ununifi.pricefeed.ICurrentPrice>|null} [prices] QueryAllPriceResponse prices
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllPriceResponse pagination
       */

      /**
       * Constructs a new QueryAllPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllPriceResponse.
       * @implements IQueryAllPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllPriceResponse=} [properties] Properties to set
       */
      function QueryAllPriceResponse(properties) {
        this.prices = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllPriceResponse prices.
       * @member {Array.<ununifi.pricefeed.ICurrentPrice>} prices
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @instance
       */
      QueryAllPriceResponse.prototype.prices = $util.emptyArray;

      /**
       * QueryAllPriceResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @instance
       */
      QueryAllPriceResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.prices != null && message.prices.length)
          for (let i = 0; i < message.prices.length; ++i)
            $root.ununifi.pricefeed.CurrentPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllPriceResponse} message QueryAllPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.prices && message.prices.length)) message.prices = [];
              message.prices.push($root.ununifi.pricefeed.CurrentPrice.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.prices != null && message.hasOwnProperty('prices')) {
          if (!Array.isArray(message.prices)) return 'prices: array expected';
          for (let i = 0; i < message.prices.length; ++i) {
            let error = $root.ununifi.pricefeed.CurrentPrice.verify(message.prices[i]);
            if (error) return 'prices.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllPriceResponse} QueryAllPriceResponse
       */
      QueryAllPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllPriceResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllPriceResponse();
        if (object.prices) {
          if (!Array.isArray(object.prices)) throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.prices: array expected');
          message.prices = [];
          for (let i = 0; i < object.prices.length; ++i) {
            if (typeof object.prices[i] !== 'object') throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.prices: object expected');
            message.prices[i] = $root.ununifi.pricefeed.CurrentPrice.fromObject(object.prices[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllPriceResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllPriceResponse} message QueryAllPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPriceResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.prices = [];
        if (options.defaults) object.pagination = null;
        if (message.prices && message.prices.length) {
          object.prices = [];
          for (let j = 0; j < message.prices.length; ++j)
            object.prices[j] = $root.ununifi.pricefeed.CurrentPrice.toObject(message.prices[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPriceResponse;
    })();

    pricefeed.QueryAllRawPriceRequest = (function () {
      /**
       * Properties of a QueryAllRawPriceRequest.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllRawPriceRequest
       * @property {string|null} [market_id] QueryAllRawPriceRequest market_id
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllRawPriceRequest pagination
       */

      /**
       * Constructs a new QueryAllRawPriceRequest.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllRawPriceRequest.
       * @implements IQueryAllRawPriceRequest
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest=} [properties] Properties to set
       */
      function QueryAllRawPriceRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllRawPriceRequest market_id.
       * @member {string} market_id
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @instance
       */
      QueryAllRawPriceRequest.prototype.market_id = '';

      /**
       * QueryAllRawPriceRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @instance
       */
      QueryAllRawPriceRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllRawPriceRequest message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.market_id != null && Object.hasOwnProperty.call(message, 'market_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.market_id);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllRawPriceRequest message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceRequest} message QueryAllRawPriceRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.market_id = reader.string();
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllRawPriceRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllRawPriceRequest message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllRawPriceRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.market_id != null && message.hasOwnProperty('market_id'))
          if (!$util.isString(message.market_id)) return 'market_id: string expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllRawPriceRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllRawPriceRequest} QueryAllRawPriceRequest
       */
      QueryAllRawPriceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceRequest) return object;
        let message = new $root.ununifi.pricefeed.QueryAllRawPriceRequest();
        if (object.market_id != null) message.market_id = String(object.market_id);
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllRawPriceRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllRawPriceRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @static
       * @param {ununifi.pricefeed.QueryAllRawPriceRequest} message QueryAllRawPriceRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllRawPriceRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.market_id = '';
          object.pagination = null;
        }
        if (message.market_id != null && message.hasOwnProperty('market_id')) object.market_id = message.market_id;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllRawPriceRequest to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllRawPriceRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllRawPriceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllRawPriceRequest;
    })();

    pricefeed.QueryAllRawPriceResponse = (function () {
      /**
       * Properties of a QueryAllRawPriceResponse.
       * @memberof ununifi.pricefeed
       * @interface IQueryAllRawPriceResponse
       * @property {Array.<ununifi.pricefeed.IPostedPrice>|null} [prices] QueryAllRawPriceResponse prices
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllRawPriceResponse pagination
       */

      /**
       * Constructs a new QueryAllRawPriceResponse.
       * @memberof ununifi.pricefeed
       * @classdesc Represents a QueryAllRawPriceResponse.
       * @implements IQueryAllRawPriceResponse
       * @constructor
       * @param {ununifi.pricefeed.IQueryAllRawPriceResponse=} [properties] Properties to set
       */
      function QueryAllRawPriceResponse(properties) {
        this.prices = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllRawPriceResponse prices.
       * @member {Array.<ununifi.pricefeed.IPostedPrice>} prices
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @instance
       */
      QueryAllRawPriceResponse.prototype.prices = $util.emptyArray;

      /**
       * QueryAllRawPriceResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @instance
       */
      QueryAllRawPriceResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllRawPriceResponse message. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.prices != null && message.prices.length)
          for (let i = 0; i < message.prices.length; ++i)
            $root.ununifi.pricefeed.PostedPrice.encode(message.prices[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllRawPriceResponse message, length delimited. Does not implicitly {@link ununifi.pricefeed.QueryAllRawPriceResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {ununifi.pricefeed.IQueryAllRawPriceResponse} message QueryAllRawPriceResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllRawPriceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.prices && message.prices.length)) message.prices = [];
              message.prices.push($root.ununifi.pricefeed.PostedPrice.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllRawPriceResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllRawPriceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllRawPriceResponse message.
       * @function verify
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllRawPriceResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.prices != null && message.hasOwnProperty('prices')) {
          if (!Array.isArray(message.prices)) return 'prices: array expected';
          for (let i = 0; i < message.prices.length; ++i) {
            let error = $root.ununifi.pricefeed.PostedPrice.verify(message.prices[i]);
            if (error) return 'prices.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllRawPriceResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.pricefeed.QueryAllRawPriceResponse} QueryAllRawPriceResponse
       */
      QueryAllRawPriceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.pricefeed.QueryAllRawPriceResponse) return object;
        let message = new $root.ununifi.pricefeed.QueryAllRawPriceResponse();
        if (object.prices) {
          if (!Array.isArray(object.prices)) throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.prices: array expected');
          message.prices = [];
          for (let i = 0; i < object.prices.length; ++i) {
            if (typeof object.prices[i] !== 'object')
              throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.prices: object expected');
            message.prices[i] = $root.ununifi.pricefeed.PostedPrice.fromObject(object.prices[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.pricefeed.QueryAllRawPriceResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllRawPriceResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @static
       * @param {ununifi.pricefeed.QueryAllRawPriceResponse} message QueryAllRawPriceResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllRawPriceResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.prices = [];
        if (options.defaults) object.pagination = null;
        if (message.prices && message.prices.length) {
          object.prices = [];
          for (let j = 0; j < message.prices.length; ++j)
            object.prices[j] = $root.ununifi.pricefeed.PostedPrice.toObject(message.prices[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllRawPriceResponse to JSON.
       * @function toJSON
       * @memberof ununifi.pricefeed.QueryAllRawPriceResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllRawPriceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllRawPriceResponse;
    })();

    return pricefeed;
  })();

  ununifi.records = (function () {
    /**
     * Namespace records.
     * @memberof ununifi
     * @namespace
     */
    const records = {};

    records.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.records
       * @interface IGenesisState
       * @property {ununifi.records.IParams|null} [params] GenesisState params
       * @property {string|null} [port_id] GenesisState port_id
       * @property {Array.<ununifi.records.IUserRedemptionRecord>|null} [user_redemption_record_list] GenesisState user_redemption_record_list
       * @property {Long|null} [user_redemption_record_count] GenesisState user_redemption_record_count
       * @property {Array.<ununifi.records.IEpochUnbondingRecord>|null} [epoch_unbonding_record_list] GenesisState epoch_unbonding_record_list
       * @property {Array.<ununifi.records.IDepositRecord>|null} [deposit_record_list] GenesisState deposit_record_list
       * @property {Long|null} [deposit_record_count] GenesisState deposit_record_count
       * @property {Array.<ununifi.records.IPendingDeposit>|null} [pending_deposits] GenesisState pending_deposits
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.records
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.records.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.user_redemption_record_list = [];
        this.epoch_unbonding_record_list = [];
        this.deposit_record_list = [];
        this.pending_deposits = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.records.IParams|null|undefined} params
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState port_id.
       * @member {string} port_id
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.port_id = '';

      /**
       * GenesisState user_redemption_record_list.
       * @member {Array.<ununifi.records.IUserRedemptionRecord>} user_redemption_record_list
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.user_redemption_record_list = $util.emptyArray;

      /**
       * GenesisState user_redemption_record_count.
       * @member {Long} user_redemption_record_count
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.user_redemption_record_count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * GenesisState epoch_unbonding_record_list.
       * @member {Array.<ununifi.records.IEpochUnbondingRecord>} epoch_unbonding_record_list
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.epoch_unbonding_record_list = $util.emptyArray;

      /**
       * GenesisState deposit_record_list.
       * @member {Array.<ununifi.records.IDepositRecord>} deposit_record_list
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.deposit_record_list = $util.emptyArray;

      /**
       * GenesisState deposit_record_count.
       * @member {Long} deposit_record_count
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.deposit_record_count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * GenesisState pending_deposits.
       * @member {Array.<ununifi.records.IPendingDeposit>} pending_deposits
       * @memberof ununifi.records.GenesisState
       * @instance
       */
      GenesisState.prototype.pending_deposits = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.records.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.GenesisState
       * @static
       * @param {ununifi.records.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.records.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.port_id != null && Object.hasOwnProperty.call(message, 'port_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.port_id);
        if (message.user_redemption_record_list != null && message.user_redemption_record_list.length)
          for (let i = 0; i < message.user_redemption_record_list.length; ++i)
            $root.ununifi.records.UserRedemptionRecord.encode(
              message.user_redemption_record_list[i],
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
        if (message.user_redemption_record_count != null && Object.hasOwnProperty.call(message, 'user_redemption_record_count'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.user_redemption_record_count);
        if (message.epoch_unbonding_record_list != null && message.epoch_unbonding_record_list.length)
          for (let i = 0; i < message.epoch_unbonding_record_list.length; ++i)
            $root.ununifi.records.EpochUnbondingRecord.encode(
              message.epoch_unbonding_record_list[i],
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
        if (message.deposit_record_list != null && message.deposit_record_list.length)
          for (let i = 0; i < message.deposit_record_list.length; ++i)
            $root.ununifi.records.DepositRecord.encode(
              message.deposit_record_list[i],
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
        if (message.deposit_record_count != null && Object.hasOwnProperty.call(message, 'deposit_record_count'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).uint64(message.deposit_record_count);
        if (message.pending_deposits != null && message.pending_deposits.length)
          for (let i = 0; i < message.pending_deposits.length; ++i)
            $root.ununifi.records.PendingDeposit.encode(
              message.pending_deposits[i],
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.records.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.GenesisState
       * @static
       * @param {ununifi.records.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.records.Params.decode(reader, reader.uint32());
              break;
            case 2:
              message.port_id = reader.string();
              break;
            case 3:
              if (!(message.user_redemption_record_list && message.user_redemption_record_list.length))
                message.user_redemption_record_list = [];
              message.user_redemption_record_list.push($root.ununifi.records.UserRedemptionRecord.decode(reader, reader.uint32()));
              break;
            case 4:
              message.user_redemption_record_count = reader.uint64();
              break;
            case 5:
              if (!(message.epoch_unbonding_record_list && message.epoch_unbonding_record_list.length))
                message.epoch_unbonding_record_list = [];
              message.epoch_unbonding_record_list.push($root.ununifi.records.EpochUnbondingRecord.decode(reader, reader.uint32()));
              break;
            case 7:
              if (!(message.deposit_record_list && message.deposit_record_list.length)) message.deposit_record_list = [];
              message.deposit_record_list.push($root.ununifi.records.DepositRecord.decode(reader, reader.uint32()));
              break;
            case 8:
              message.deposit_record_count = reader.uint64();
              break;
            case 9:
              if (!(message.pending_deposits && message.pending_deposits.length)) message.pending_deposits = [];
              message.pending_deposits.push($root.ununifi.records.PendingDeposit.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.records.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.records.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.port_id != null && message.hasOwnProperty('port_id'))
          if (!$util.isString(message.port_id)) return 'port_id: string expected';
        if (message.user_redemption_record_list != null && message.hasOwnProperty('user_redemption_record_list')) {
          if (!Array.isArray(message.user_redemption_record_list)) return 'user_redemption_record_list: array expected';
          for (let i = 0; i < message.user_redemption_record_list.length; ++i) {
            let error = $root.ununifi.records.UserRedemptionRecord.verify(message.user_redemption_record_list[i]);
            if (error) return 'user_redemption_record_list.' + error;
          }
        }
        if (message.user_redemption_record_count != null && message.hasOwnProperty('user_redemption_record_count'))
          if (
            !$util.isInteger(message.user_redemption_record_count) &&
            !(
              message.user_redemption_record_count &&
              $util.isInteger(message.user_redemption_record_count.low) &&
              $util.isInteger(message.user_redemption_record_count.high)
            )
          )
            return 'user_redemption_record_count: integer|Long expected';
        if (message.epoch_unbonding_record_list != null && message.hasOwnProperty('epoch_unbonding_record_list')) {
          if (!Array.isArray(message.epoch_unbonding_record_list)) return 'epoch_unbonding_record_list: array expected';
          for (let i = 0; i < message.epoch_unbonding_record_list.length; ++i) {
            let error = $root.ununifi.records.EpochUnbondingRecord.verify(message.epoch_unbonding_record_list[i]);
            if (error) return 'epoch_unbonding_record_list.' + error;
          }
        }
        if (message.deposit_record_list != null && message.hasOwnProperty('deposit_record_list')) {
          if (!Array.isArray(message.deposit_record_list)) return 'deposit_record_list: array expected';
          for (let i = 0; i < message.deposit_record_list.length; ++i) {
            let error = $root.ununifi.records.DepositRecord.verify(message.deposit_record_list[i]);
            if (error) return 'deposit_record_list.' + error;
          }
        }
        if (message.deposit_record_count != null && message.hasOwnProperty('deposit_record_count'))
          if (
            !$util.isInteger(message.deposit_record_count) &&
            !(
              message.deposit_record_count &&
              $util.isInteger(message.deposit_record_count.low) &&
              $util.isInteger(message.deposit_record_count.high)
            )
          )
            return 'deposit_record_count: integer|Long expected';
        if (message.pending_deposits != null && message.hasOwnProperty('pending_deposits')) {
          if (!Array.isArray(message.pending_deposits)) return 'pending_deposits: array expected';
          for (let i = 0; i < message.pending_deposits.length; ++i) {
            let error = $root.ununifi.records.PendingDeposit.verify(message.pending_deposits[i]);
            if (error) return 'pending_deposits.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.GenesisState) return object;
        let message = new $root.ununifi.records.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.records.GenesisState.params: object expected');
          message.params = $root.ununifi.records.Params.fromObject(object.params);
        }
        if (object.port_id != null) message.port_id = String(object.port_id);
        if (object.user_redemption_record_list) {
          if (!Array.isArray(object.user_redemption_record_list))
            throw TypeError('.ununifi.records.GenesisState.user_redemption_record_list: array expected');
          message.user_redemption_record_list = [];
          for (let i = 0; i < object.user_redemption_record_list.length; ++i) {
            if (typeof object.user_redemption_record_list[i] !== 'object')
              throw TypeError('.ununifi.records.GenesisState.user_redemption_record_list: object expected');
            message.user_redemption_record_list[i] = $root.ununifi.records.UserRedemptionRecord.fromObject(
              object.user_redemption_record_list[i],
            );
          }
        }
        if (object.user_redemption_record_count != null)
          if ($util.Long)
            (message.user_redemption_record_count = $util.Long.fromValue(object.user_redemption_record_count)).unsigned = true;
          else if (typeof object.user_redemption_record_count === 'string')
            message.user_redemption_record_count = parseInt(object.user_redemption_record_count, 10);
          else if (typeof object.user_redemption_record_count === 'number')
            message.user_redemption_record_count = object.user_redemption_record_count;
          else if (typeof object.user_redemption_record_count === 'object')
            message.user_redemption_record_count = new $util.LongBits(
              object.user_redemption_record_count.low >>> 0,
              object.user_redemption_record_count.high >>> 0,
            ).toNumber(true);
        if (object.epoch_unbonding_record_list) {
          if (!Array.isArray(object.epoch_unbonding_record_list))
            throw TypeError('.ununifi.records.GenesisState.epoch_unbonding_record_list: array expected');
          message.epoch_unbonding_record_list = [];
          for (let i = 0; i < object.epoch_unbonding_record_list.length; ++i) {
            if (typeof object.epoch_unbonding_record_list[i] !== 'object')
              throw TypeError('.ununifi.records.GenesisState.epoch_unbonding_record_list: object expected');
            message.epoch_unbonding_record_list[i] = $root.ununifi.records.EpochUnbondingRecord.fromObject(
              object.epoch_unbonding_record_list[i],
            );
          }
        }
        if (object.deposit_record_list) {
          if (!Array.isArray(object.deposit_record_list))
            throw TypeError('.ununifi.records.GenesisState.deposit_record_list: array expected');
          message.deposit_record_list = [];
          for (let i = 0; i < object.deposit_record_list.length; ++i) {
            if (typeof object.deposit_record_list[i] !== 'object')
              throw TypeError('.ununifi.records.GenesisState.deposit_record_list: object expected');
            message.deposit_record_list[i] = $root.ununifi.records.DepositRecord.fromObject(object.deposit_record_list[i]);
          }
        }
        if (object.deposit_record_count != null)
          if ($util.Long) (message.deposit_record_count = $util.Long.fromValue(object.deposit_record_count)).unsigned = true;
          else if (typeof object.deposit_record_count === 'string')
            message.deposit_record_count = parseInt(object.deposit_record_count, 10);
          else if (typeof object.deposit_record_count === 'number') message.deposit_record_count = object.deposit_record_count;
          else if (typeof object.deposit_record_count === 'object')
            message.deposit_record_count = new $util.LongBits(
              object.deposit_record_count.low >>> 0,
              object.deposit_record_count.high >>> 0,
            ).toNumber(true);
        if (object.pending_deposits) {
          if (!Array.isArray(object.pending_deposits)) throw TypeError('.ununifi.records.GenesisState.pending_deposits: array expected');
          message.pending_deposits = [];
          for (let i = 0; i < object.pending_deposits.length; ++i) {
            if (typeof object.pending_deposits[i] !== 'object')
              throw TypeError('.ununifi.records.GenesisState.pending_deposits: object expected');
            message.pending_deposits[i] = $root.ununifi.records.PendingDeposit.fromObject(object.pending_deposits[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.GenesisState
       * @static
       * @param {ununifi.records.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.user_redemption_record_list = [];
          object.epoch_unbonding_record_list = [];
          object.deposit_record_list = [];
          object.pending_deposits = [];
        }
        if (options.defaults) {
          object.params = null;
          object.port_id = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.user_redemption_record_count =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.user_redemption_record_count = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.deposit_record_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.deposit_record_count = options.longs === String ? '0' : 0;
        }
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.records.Params.toObject(message.params, options);
        if (message.port_id != null && message.hasOwnProperty('port_id')) object.port_id = message.port_id;
        if (message.user_redemption_record_list && message.user_redemption_record_list.length) {
          object.user_redemption_record_list = [];
          for (let j = 0; j < message.user_redemption_record_list.length; ++j)
            object.user_redemption_record_list[j] = $root.ununifi.records.UserRedemptionRecord.toObject(
              message.user_redemption_record_list[j],
              options,
            );
        }
        if (message.user_redemption_record_count != null && message.hasOwnProperty('user_redemption_record_count'))
          if (typeof message.user_redemption_record_count === 'number')
            object.user_redemption_record_count =
              options.longs === String ? String(message.user_redemption_record_count) : message.user_redemption_record_count;
          else
            object.user_redemption_record_count =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.user_redemption_record_count)
                : options.longs === Number
                ? new $util.LongBits(
                    message.user_redemption_record_count.low >>> 0,
                    message.user_redemption_record_count.high >>> 0,
                  ).toNumber(true)
                : message.user_redemption_record_count;
        if (message.epoch_unbonding_record_list && message.epoch_unbonding_record_list.length) {
          object.epoch_unbonding_record_list = [];
          for (let j = 0; j < message.epoch_unbonding_record_list.length; ++j)
            object.epoch_unbonding_record_list[j] = $root.ununifi.records.EpochUnbondingRecord.toObject(
              message.epoch_unbonding_record_list[j],
              options,
            );
        }
        if (message.deposit_record_list && message.deposit_record_list.length) {
          object.deposit_record_list = [];
          for (let j = 0; j < message.deposit_record_list.length; ++j)
            object.deposit_record_list[j] = $root.ununifi.records.DepositRecord.toObject(message.deposit_record_list[j], options);
        }
        if (message.deposit_record_count != null && message.hasOwnProperty('deposit_record_count'))
          if (typeof message.deposit_record_count === 'number')
            object.deposit_record_count = options.longs === String ? String(message.deposit_record_count) : message.deposit_record_count;
          else
            object.deposit_record_count =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.deposit_record_count)
                : options.longs === Number
                ? new $util.LongBits(message.deposit_record_count.low >>> 0, message.deposit_record_count.high >>> 0).toNumber(true)
                : message.deposit_record_count;
        if (message.pending_deposits && message.pending_deposits.length) {
          object.pending_deposits = [];
          for (let j = 0; j < message.pending_deposits.length; ++j)
            object.pending_deposits[j] = $root.ununifi.records.PendingDeposit.toObject(message.pending_deposits[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.records.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    records.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.records
       * @interface IParams
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.records
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.records.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.records.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.Params
       * @static
       * @param {ununifi.records.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.records.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.Params
       * @static
       * @param {ununifi.records.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.records.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.Params) return object;
        return new $root.ununifi.records.Params();
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.Params
       * @static
       * @param {ununifi.records.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.records.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    records.UserRedemptionRecord = (function () {
      /**
       * Properties of a UserRedemptionRecord.
       * @memberof ununifi.records
       * @interface IUserRedemptionRecord
       * @property {string|null} [id] UserRedemptionRecord id
       * @property {string|null} [sender] UserRedemptionRecord sender
       * @property {string|null} [receiver] UserRedemptionRecord receiver
       * @property {string|null} [amount] UserRedemptionRecord amount
       * @property {string|null} [denom] UserRedemptionRecord denom
       * @property {string|null} [host_zone_id] UserRedemptionRecord host_zone_id
       * @property {Long|null} [epoch_number] UserRedemptionRecord epoch_number
       * @property {boolean|null} [claim_is_pending] UserRedemptionRecord claim_is_pending
       */

      /**
       * Constructs a new UserRedemptionRecord.
       * @memberof ununifi.records
       * @classdesc Represents a UserRedemptionRecord.
       * @implements IUserRedemptionRecord
       * @constructor
       * @param {ununifi.records.IUserRedemptionRecord=} [properties] Properties to set
       */
      function UserRedemptionRecord(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * UserRedemptionRecord id.
       * @member {string} id
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.id = '';

      /**
       * UserRedemptionRecord sender.
       * @member {string} sender
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.sender = '';

      /**
       * UserRedemptionRecord receiver.
       * @member {string} receiver
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.receiver = '';

      /**
       * UserRedemptionRecord amount.
       * @member {string} amount
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.amount = '';

      /**
       * UserRedemptionRecord denom.
       * @member {string} denom
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.denom = '';

      /**
       * UserRedemptionRecord host_zone_id.
       * @member {string} host_zone_id
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.host_zone_id = '';

      /**
       * UserRedemptionRecord epoch_number.
       * @member {Long} epoch_number
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.epoch_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * UserRedemptionRecord claim_is_pending.
       * @member {boolean} claim_is_pending
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       */
      UserRedemptionRecord.prototype.claim_is_pending = false;

      /**
       * Encodes the specified UserRedemptionRecord message. Does not implicitly {@link ununifi.records.UserRedemptionRecord.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.UserRedemptionRecord
       * @static
       * @param {ununifi.records.IUserRedemptionRecord} message UserRedemptionRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UserRedemptionRecord.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.sender);
        if (message.receiver != null && Object.hasOwnProperty.call(message, 'receiver'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.receiver);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.amount);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.denom);
        if (message.host_zone_id != null && Object.hasOwnProperty.call(message, 'host_zone_id'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.host_zone_id);
        if (message.epoch_number != null && Object.hasOwnProperty.call(message, 'epoch_number'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.epoch_number);
        if (message.claim_is_pending != null && Object.hasOwnProperty.call(message, 'claim_is_pending'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).bool(message.claim_is_pending);
        return writer;
      };

      /**
       * Encodes the specified UserRedemptionRecord message, length delimited. Does not implicitly {@link ununifi.records.UserRedemptionRecord.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.UserRedemptionRecord
       * @static
       * @param {ununifi.records.IUserRedemptionRecord} message UserRedemptionRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UserRedemptionRecord.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a UserRedemptionRecord message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.UserRedemptionRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.UserRedemptionRecord} UserRedemptionRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UserRedemptionRecord.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.UserRedemptionRecord();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.sender = reader.string();
              break;
            case 3:
              message.receiver = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.denom = reader.string();
              break;
            case 6:
              message.host_zone_id = reader.string();
              break;
            case 7:
              message.epoch_number = reader.uint64();
              break;
            case 8:
              message.claim_is_pending = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a UserRedemptionRecord message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.UserRedemptionRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.UserRedemptionRecord} UserRedemptionRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UserRedemptionRecord.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a UserRedemptionRecord message.
       * @function verify
       * @memberof ununifi.records.UserRedemptionRecord
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      UserRedemptionRecord.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.receiver != null && message.hasOwnProperty('receiver'))
          if (!$util.isString(message.receiver)) return 'receiver: string expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.host_zone_id != null && message.hasOwnProperty('host_zone_id'))
          if (!$util.isString(message.host_zone_id)) return 'host_zone_id: string expected';
        if (message.epoch_number != null && message.hasOwnProperty('epoch_number'))
          if (
            !$util.isInteger(message.epoch_number) &&
            !(message.epoch_number && $util.isInteger(message.epoch_number.low) && $util.isInteger(message.epoch_number.high))
          )
            return 'epoch_number: integer|Long expected';
        if (message.claim_is_pending != null && message.hasOwnProperty('claim_is_pending'))
          if (typeof message.claim_is_pending !== 'boolean') return 'claim_is_pending: boolean expected';
        return null;
      };

      /**
       * Creates a UserRedemptionRecord message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.UserRedemptionRecord
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.UserRedemptionRecord} UserRedemptionRecord
       */
      UserRedemptionRecord.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.UserRedemptionRecord) return object;
        let message = new $root.ununifi.records.UserRedemptionRecord();
        if (object.id != null) message.id = String(object.id);
        if (object.sender != null) message.sender = String(object.sender);
        if (object.receiver != null) message.receiver = String(object.receiver);
        if (object.amount != null) message.amount = String(object.amount);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.host_zone_id != null) message.host_zone_id = String(object.host_zone_id);
        if (object.epoch_number != null)
          if ($util.Long) (message.epoch_number = $util.Long.fromValue(object.epoch_number)).unsigned = true;
          else if (typeof object.epoch_number === 'string') message.epoch_number = parseInt(object.epoch_number, 10);
          else if (typeof object.epoch_number === 'number') message.epoch_number = object.epoch_number;
          else if (typeof object.epoch_number === 'object')
            message.epoch_number = new $util.LongBits(object.epoch_number.low >>> 0, object.epoch_number.high >>> 0).toNumber(true);
        if (object.claim_is_pending != null) message.claim_is_pending = Boolean(object.claim_is_pending);
        return message;
      };

      /**
       * Creates a plain object from a UserRedemptionRecord message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.UserRedemptionRecord
       * @static
       * @param {ununifi.records.UserRedemptionRecord} message UserRedemptionRecord
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      UserRedemptionRecord.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.id = '';
          object.sender = '';
          object.receiver = '';
          object.amount = '';
          object.denom = '';
          object.host_zone_id = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.epoch_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.epoch_number = options.longs === String ? '0' : 0;
          object.claim_is_pending = false;
        }
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.receiver != null && message.hasOwnProperty('receiver')) object.receiver = message.receiver;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.host_zone_id != null && message.hasOwnProperty('host_zone_id')) object.host_zone_id = message.host_zone_id;
        if (message.epoch_number != null && message.hasOwnProperty('epoch_number'))
          if (typeof message.epoch_number === 'number')
            object.epoch_number = options.longs === String ? String(message.epoch_number) : message.epoch_number;
          else
            object.epoch_number =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.epoch_number)
                : options.longs === Number
                ? new $util.LongBits(message.epoch_number.low >>> 0, message.epoch_number.high >>> 0).toNumber(true)
                : message.epoch_number;
        if (message.claim_is_pending != null && message.hasOwnProperty('claim_is_pending'))
          object.claim_is_pending = message.claim_is_pending;
        return object;
      };

      /**
       * Converts this UserRedemptionRecord to JSON.
       * @function toJSON
       * @memberof ununifi.records.UserRedemptionRecord
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      UserRedemptionRecord.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return UserRedemptionRecord;
    })();

    records.DepositRecord = (function () {
      /**
       * Properties of a DepositRecord.
       * @memberof ununifi.records
       * @interface IDepositRecord
       * @property {Long|null} [id] DepositRecord id
       * @property {string|null} [amount] DepositRecord amount
       * @property {string|null} [denom] DepositRecord denom
       * @property {string|null} [host_zone_id] DepositRecord host_zone_id
       * @property {ununifi.records.DepositRecord.Status|null} [status] DepositRecord status
       * @property {Long|null} [deposit_epoch_number] DepositRecord deposit_epoch_number
       * @property {ununifi.records.DepositRecord.Source|null} [source] DepositRecord source
       */

      /**
       * Constructs a new DepositRecord.
       * @memberof ununifi.records
       * @classdesc Represents a DepositRecord.
       * @implements IDepositRecord
       * @constructor
       * @param {ununifi.records.IDepositRecord=} [properties] Properties to set
       */
      function DepositRecord(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * DepositRecord id.
       * @member {Long} id
       * @memberof ununifi.records.DepositRecord
       * @instance
       */
      DepositRecord.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * DepositRecord amount.
       * @member {string} amount
       * @memberof ununifi.records.DepositRecord
       * @instance
       */
      DepositRecord.prototype.amount = '';

      /**
       * DepositRecord denom.
       * @member {string} denom
       * @memberof ununifi.records.DepositRecord
       * @instance
       */
      DepositRecord.prototype.denom = '';

      /**
       * DepositRecord host_zone_id.
       * @member {string} host_zone_id
       * @memberof ununifi.records.DepositRecord
       * @instance
       */
      DepositRecord.prototype.host_zone_id = '';

      /**
       * DepositRecord status.
       * @member {ununifi.records.DepositRecord.Status} status
       * @memberof ununifi.records.DepositRecord
       * @instance
       */
      DepositRecord.prototype.status = 0;

      /**
       * DepositRecord deposit_epoch_number.
       * @member {Long} deposit_epoch_number
       * @memberof ununifi.records.DepositRecord
       * @instance
       */
      DepositRecord.prototype.deposit_epoch_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * DepositRecord source.
       * @member {ununifi.records.DepositRecord.Source} source
       * @memberof ununifi.records.DepositRecord
       * @instance
       */
      DepositRecord.prototype.source = 0;

      /**
       * Encodes the specified DepositRecord message. Does not implicitly {@link ununifi.records.DepositRecord.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.DepositRecord
       * @static
       * @param {ununifi.records.IDepositRecord} message DepositRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DepositRecord.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.denom);
        if (message.host_zone_id != null && Object.hasOwnProperty.call(message, 'host_zone_id'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.host_zone_id);
        if (message.status != null && Object.hasOwnProperty.call(message, 'status'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.status);
        if (message.deposit_epoch_number != null && Object.hasOwnProperty.call(message, 'deposit_epoch_number'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).uint64(message.deposit_epoch_number);
        if (message.source != null && Object.hasOwnProperty.call(message, 'source'))
          writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.source);
        return writer;
      };

      /**
       * Encodes the specified DepositRecord message, length delimited. Does not implicitly {@link ununifi.records.DepositRecord.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.DepositRecord
       * @static
       * @param {ununifi.records.IDepositRecord} message DepositRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DepositRecord.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DepositRecord message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.DepositRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.DepositRecord} DepositRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DepositRecord.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.DepositRecord();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.amount = reader.string();
              break;
            case 3:
              message.denom = reader.string();
              break;
            case 4:
              message.host_zone_id = reader.string();
              break;
            case 6:
              message.status = reader.int32();
              break;
            case 7:
              message.deposit_epoch_number = reader.uint64();
              break;
            case 8:
              message.source = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a DepositRecord message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.DepositRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.DepositRecord} DepositRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DepositRecord.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DepositRecord message.
       * @function verify
       * @memberof ununifi.records.DepositRecord
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DepositRecord.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.host_zone_id != null && message.hasOwnProperty('host_zone_id'))
          if (!$util.isString(message.host_zone_id)) return 'host_zone_id: string expected';
        if (message.status != null && message.hasOwnProperty('status'))
          switch (message.status) {
            default:
              return 'status: enum value expected';
            case 0:
            case 2:
            case 1:
            case 3:
              break;
          }
        if (message.deposit_epoch_number != null && message.hasOwnProperty('deposit_epoch_number'))
          if (
            !$util.isInteger(message.deposit_epoch_number) &&
            !(
              message.deposit_epoch_number &&
              $util.isInteger(message.deposit_epoch_number.low) &&
              $util.isInteger(message.deposit_epoch_number.high)
            )
          )
            return 'deposit_epoch_number: integer|Long expected';
        if (message.source != null && message.hasOwnProperty('source'))
          switch (message.source) {
            default:
              return 'source: enum value expected';
            case 0:
            case 1:
              break;
          }
        return null;
      };

      /**
       * Creates a DepositRecord message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.DepositRecord
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.DepositRecord} DepositRecord
       */
      DepositRecord.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.DepositRecord) return object;
        let message = new $root.ununifi.records.DepositRecord();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.amount != null) message.amount = String(object.amount);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.host_zone_id != null) message.host_zone_id = String(object.host_zone_id);
        switch (object.status) {
          case 'TRANSFER_QUEUE':
          case 0:
            message.status = 0;
            break;
          case 'TRANSFER_IN_PROGRESS':
          case 2:
            message.status = 2;
            break;
          case 'DELEGATION_QUEUE':
          case 1:
            message.status = 1;
            break;
          case 'DELEGATION_IN_PROGRESS':
          case 3:
            message.status = 3;
            break;
        }
        if (object.deposit_epoch_number != null)
          if ($util.Long) (message.deposit_epoch_number = $util.Long.fromValue(object.deposit_epoch_number)).unsigned = true;
          else if (typeof object.deposit_epoch_number === 'string')
            message.deposit_epoch_number = parseInt(object.deposit_epoch_number, 10);
          else if (typeof object.deposit_epoch_number === 'number') message.deposit_epoch_number = object.deposit_epoch_number;
          else if (typeof object.deposit_epoch_number === 'object')
            message.deposit_epoch_number = new $util.LongBits(
              object.deposit_epoch_number.low >>> 0,
              object.deposit_epoch_number.high >>> 0,
            ).toNumber(true);
        switch (object.source) {
          case 'UNUNIFI':
          case 0:
            message.source = 0;
            break;
          case 'WITHDRAWAL_ICA':
          case 1:
            message.source = 1;
            break;
        }
        return message;
      };

      /**
       * Creates a plain object from a DepositRecord message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.DepositRecord
       * @static
       * @param {ununifi.records.DepositRecord} message DepositRecord
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DepositRecord.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.amount = '';
          object.denom = '';
          object.host_zone_id = '';
          object.status = options.enums === String ? 'TRANSFER_QUEUE' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.deposit_epoch_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.deposit_epoch_number = options.longs === String ? '0' : 0;
          object.source = options.enums === String ? 'UNUNIFI' : 0;
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.host_zone_id != null && message.hasOwnProperty('host_zone_id')) object.host_zone_id = message.host_zone_id;
        if (message.status != null && message.hasOwnProperty('status'))
          object.status = options.enums === String ? $root.ununifi.records.DepositRecord.Status[message.status] : message.status;
        if (message.deposit_epoch_number != null && message.hasOwnProperty('deposit_epoch_number'))
          if (typeof message.deposit_epoch_number === 'number')
            object.deposit_epoch_number = options.longs === String ? String(message.deposit_epoch_number) : message.deposit_epoch_number;
          else
            object.deposit_epoch_number =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.deposit_epoch_number)
                : options.longs === Number
                ? new $util.LongBits(message.deposit_epoch_number.low >>> 0, message.deposit_epoch_number.high >>> 0).toNumber(true)
                : message.deposit_epoch_number;
        if (message.source != null && message.hasOwnProperty('source'))
          object.source = options.enums === String ? $root.ununifi.records.DepositRecord.Source[message.source] : message.source;
        return object;
      };

      /**
       * Converts this DepositRecord to JSON.
       * @function toJSON
       * @memberof ununifi.records.DepositRecord
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DepositRecord.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * Status enum.
       * @name ununifi.records.DepositRecord.Status
       * @enum {number}
       * @property {number} TRANSFER_QUEUE=0 TRANSFER_QUEUE value
       * @property {number} TRANSFER_IN_PROGRESS=2 TRANSFER_IN_PROGRESS value
       * @property {number} DELEGATION_QUEUE=1 DELEGATION_QUEUE value
       * @property {number} DELEGATION_IN_PROGRESS=3 DELEGATION_IN_PROGRESS value
       */
      DepositRecord.Status = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'TRANSFER_QUEUE')] = 0;
        values[(valuesById[2] = 'TRANSFER_IN_PROGRESS')] = 2;
        values[(valuesById[1] = 'DELEGATION_QUEUE')] = 1;
        values[(valuesById[3] = 'DELEGATION_IN_PROGRESS')] = 3;
        return values;
      })();

      /**
       * Source enum.
       * @name ununifi.records.DepositRecord.Source
       * @enum {number}
       * @property {number} UNUNIFI=0 UNUNIFI value
       * @property {number} WITHDRAWAL_ICA=1 WITHDRAWAL_ICA value
       */
      DepositRecord.Source = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'UNUNIFI')] = 0;
        values[(valuesById[1] = 'WITHDRAWAL_ICA')] = 1;
        return values;
      })();

      return DepositRecord;
    })();

    records.HostZoneUnbonding = (function () {
      /**
       * Properties of a HostZoneUnbonding.
       * @memberof ununifi.records
       * @interface IHostZoneUnbonding
       * @property {string|null} [st_token_amount] HostZoneUnbonding st_token_amount
       * @property {string|null} [native_token_amount] HostZoneUnbonding native_token_amount
       * @property {string|null} [denom] HostZoneUnbonding denom
       * @property {string|null} [host_zone_id] HostZoneUnbonding host_zone_id
       * @property {Long|null} [unbonding_time] HostZoneUnbonding unbonding_time
       * @property {ununifi.records.HostZoneUnbonding.Status|null} [status] HostZoneUnbonding status
       * @property {Array.<string>|null} [user_redemption_records] HostZoneUnbonding user_redemption_records
       */

      /**
       * Constructs a new HostZoneUnbonding.
       * @memberof ununifi.records
       * @classdesc Represents a HostZoneUnbonding.
       * @implements IHostZoneUnbonding
       * @constructor
       * @param {ununifi.records.IHostZoneUnbonding=} [properties] Properties to set
       */
      function HostZoneUnbonding(properties) {
        this.user_redemption_records = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * HostZoneUnbonding st_token_amount.
       * @member {string} st_token_amount
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       */
      HostZoneUnbonding.prototype.st_token_amount = '';

      /**
       * HostZoneUnbonding native_token_amount.
       * @member {string} native_token_amount
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       */
      HostZoneUnbonding.prototype.native_token_amount = '';

      /**
       * HostZoneUnbonding denom.
       * @member {string} denom
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       */
      HostZoneUnbonding.prototype.denom = '';

      /**
       * HostZoneUnbonding host_zone_id.
       * @member {string} host_zone_id
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       */
      HostZoneUnbonding.prototype.host_zone_id = '';

      /**
       * HostZoneUnbonding unbonding_time.
       * @member {Long} unbonding_time
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       */
      HostZoneUnbonding.prototype.unbonding_time = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * HostZoneUnbonding status.
       * @member {ununifi.records.HostZoneUnbonding.Status} status
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       */
      HostZoneUnbonding.prototype.status = 0;

      /**
       * HostZoneUnbonding user_redemption_records.
       * @member {Array.<string>} user_redemption_records
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       */
      HostZoneUnbonding.prototype.user_redemption_records = $util.emptyArray;

      /**
       * Encodes the specified HostZoneUnbonding message. Does not implicitly {@link ununifi.records.HostZoneUnbonding.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.HostZoneUnbonding
       * @static
       * @param {ununifi.records.IHostZoneUnbonding} message HostZoneUnbonding message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HostZoneUnbonding.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.st_token_amount != null && Object.hasOwnProperty.call(message, 'st_token_amount'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.st_token_amount);
        if (message.native_token_amount != null && Object.hasOwnProperty.call(message, 'native_token_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.native_token_amount);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.denom);
        if (message.host_zone_id != null && Object.hasOwnProperty.call(message, 'host_zone_id'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.host_zone_id);
        if (message.unbonding_time != null && Object.hasOwnProperty.call(message, 'unbonding_time'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.unbonding_time);
        if (message.status != null && Object.hasOwnProperty.call(message, 'status'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.status);
        if (message.user_redemption_records != null && message.user_redemption_records.length)
          for (let i = 0; i < message.user_redemption_records.length; ++i)
            writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.user_redemption_records[i]);
        return writer;
      };

      /**
       * Encodes the specified HostZoneUnbonding message, length delimited. Does not implicitly {@link ununifi.records.HostZoneUnbonding.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.HostZoneUnbonding
       * @static
       * @param {ununifi.records.IHostZoneUnbonding} message HostZoneUnbonding message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HostZoneUnbonding.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a HostZoneUnbonding message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.HostZoneUnbonding
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.HostZoneUnbonding} HostZoneUnbonding
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HostZoneUnbonding.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.HostZoneUnbonding();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.st_token_amount = reader.string();
              break;
            case 2:
              message.native_token_amount = reader.string();
              break;
            case 3:
              message.denom = reader.string();
              break;
            case 4:
              message.host_zone_id = reader.string();
              break;
            case 5:
              message.unbonding_time = reader.uint64();
              break;
            case 6:
              message.status = reader.int32();
              break;
            case 7:
              if (!(message.user_redemption_records && message.user_redemption_records.length)) message.user_redemption_records = [];
              message.user_redemption_records.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a HostZoneUnbonding message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.HostZoneUnbonding
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.HostZoneUnbonding} HostZoneUnbonding
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HostZoneUnbonding.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a HostZoneUnbonding message.
       * @function verify
       * @memberof ununifi.records.HostZoneUnbonding
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      HostZoneUnbonding.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.st_token_amount != null && message.hasOwnProperty('st_token_amount'))
          if (!$util.isString(message.st_token_amount)) return 'st_token_amount: string expected';
        if (message.native_token_amount != null && message.hasOwnProperty('native_token_amount'))
          if (!$util.isString(message.native_token_amount)) return 'native_token_amount: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.host_zone_id != null && message.hasOwnProperty('host_zone_id'))
          if (!$util.isString(message.host_zone_id)) return 'host_zone_id: string expected';
        if (message.unbonding_time != null && message.hasOwnProperty('unbonding_time'))
          if (
            !$util.isInteger(message.unbonding_time) &&
            !(message.unbonding_time && $util.isInteger(message.unbonding_time.low) && $util.isInteger(message.unbonding_time.high))
          )
            return 'unbonding_time: integer|Long expected';
        if (message.status != null && message.hasOwnProperty('status'))
          switch (message.status) {
            default:
              return 'status: enum value expected';
            case 0:
            case 3:
            case 1:
            case 4:
            case 2:
              break;
          }
        if (message.user_redemption_records != null && message.hasOwnProperty('user_redemption_records')) {
          if (!Array.isArray(message.user_redemption_records)) return 'user_redemption_records: array expected';
          for (let i = 0; i < message.user_redemption_records.length; ++i)
            if (!$util.isString(message.user_redemption_records[i])) return 'user_redemption_records: string[] expected';
        }
        return null;
      };

      /**
       * Creates a HostZoneUnbonding message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.HostZoneUnbonding
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.HostZoneUnbonding} HostZoneUnbonding
       */
      HostZoneUnbonding.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.HostZoneUnbonding) return object;
        let message = new $root.ununifi.records.HostZoneUnbonding();
        if (object.st_token_amount != null) message.st_token_amount = String(object.st_token_amount);
        if (object.native_token_amount != null) message.native_token_amount = String(object.native_token_amount);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.host_zone_id != null) message.host_zone_id = String(object.host_zone_id);
        if (object.unbonding_time != null)
          if ($util.Long) (message.unbonding_time = $util.Long.fromValue(object.unbonding_time)).unsigned = true;
          else if (typeof object.unbonding_time === 'string') message.unbonding_time = parseInt(object.unbonding_time, 10);
          else if (typeof object.unbonding_time === 'number') message.unbonding_time = object.unbonding_time;
          else if (typeof object.unbonding_time === 'object')
            message.unbonding_time = new $util.LongBits(object.unbonding_time.low >>> 0, object.unbonding_time.high >>> 0).toNumber(true);
        switch (object.status) {
          case 'UNBONDING_QUEUE':
          case 0:
            message.status = 0;
            break;
          case 'UNBONDING_IN_PROGRESS':
          case 3:
            message.status = 3;
            break;
          case 'EXIT_TRANSFER_QUEUE':
          case 1:
            message.status = 1;
            break;
          case 'EXIT_TRANSFER_IN_PROGRESS':
          case 4:
            message.status = 4;
            break;
          case 'CLAIMABLE':
          case 2:
            message.status = 2;
            break;
        }
        if (object.user_redemption_records) {
          if (!Array.isArray(object.user_redemption_records))
            throw TypeError('.ununifi.records.HostZoneUnbonding.user_redemption_records: array expected');
          message.user_redemption_records = [];
          for (let i = 0; i < object.user_redemption_records.length; ++i)
            message.user_redemption_records[i] = String(object.user_redemption_records[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a HostZoneUnbonding message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.HostZoneUnbonding
       * @static
       * @param {ununifi.records.HostZoneUnbonding} message HostZoneUnbonding
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      HostZoneUnbonding.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.user_redemption_records = [];
        if (options.defaults) {
          object.st_token_amount = '';
          object.native_token_amount = '';
          object.denom = '';
          object.host_zone_id = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.unbonding_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.unbonding_time = options.longs === String ? '0' : 0;
          object.status = options.enums === String ? 'UNBONDING_QUEUE' : 0;
        }
        if (message.st_token_amount != null && message.hasOwnProperty('st_token_amount')) object.st_token_amount = message.st_token_amount;
        if (message.native_token_amount != null && message.hasOwnProperty('native_token_amount'))
          object.native_token_amount = message.native_token_amount;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.host_zone_id != null && message.hasOwnProperty('host_zone_id')) object.host_zone_id = message.host_zone_id;
        if (message.unbonding_time != null && message.hasOwnProperty('unbonding_time'))
          if (typeof message.unbonding_time === 'number')
            object.unbonding_time = options.longs === String ? String(message.unbonding_time) : message.unbonding_time;
          else
            object.unbonding_time =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.unbonding_time)
                : options.longs === Number
                ? new $util.LongBits(message.unbonding_time.low >>> 0, message.unbonding_time.high >>> 0).toNumber(true)
                : message.unbonding_time;
        if (message.status != null && message.hasOwnProperty('status'))
          object.status = options.enums === String ? $root.ununifi.records.HostZoneUnbonding.Status[message.status] : message.status;
        if (message.user_redemption_records && message.user_redemption_records.length) {
          object.user_redemption_records = [];
          for (let j = 0; j < message.user_redemption_records.length; ++j)
            object.user_redemption_records[j] = message.user_redemption_records[j];
        }
        return object;
      };

      /**
       * Converts this HostZoneUnbonding to JSON.
       * @function toJSON
       * @memberof ununifi.records.HostZoneUnbonding
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      HostZoneUnbonding.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * Status enum.
       * @name ununifi.records.HostZoneUnbonding.Status
       * @enum {number}
       * @property {number} UNBONDING_QUEUE=0 UNBONDING_QUEUE value
       * @property {number} UNBONDING_IN_PROGRESS=3 UNBONDING_IN_PROGRESS value
       * @property {number} EXIT_TRANSFER_QUEUE=1 EXIT_TRANSFER_QUEUE value
       * @property {number} EXIT_TRANSFER_IN_PROGRESS=4 EXIT_TRANSFER_IN_PROGRESS value
       * @property {number} CLAIMABLE=2 CLAIMABLE value
       */
      HostZoneUnbonding.Status = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'UNBONDING_QUEUE')] = 0;
        values[(valuesById[3] = 'UNBONDING_IN_PROGRESS')] = 3;
        values[(valuesById[1] = 'EXIT_TRANSFER_QUEUE')] = 1;
        values[(valuesById[4] = 'EXIT_TRANSFER_IN_PROGRESS')] = 4;
        values[(valuesById[2] = 'CLAIMABLE')] = 2;
        return values;
      })();

      return HostZoneUnbonding;
    })();

    records.EpochUnbondingRecord = (function () {
      /**
       * Properties of an EpochUnbondingRecord.
       * @memberof ununifi.records
       * @interface IEpochUnbondingRecord
       * @property {Long|null} [epoch_number] EpochUnbondingRecord epoch_number
       * @property {Array.<ununifi.records.IHostZoneUnbonding>|null} [host_zone_unbondings] EpochUnbondingRecord host_zone_unbondings
       */

      /**
       * Constructs a new EpochUnbondingRecord.
       * @memberof ununifi.records
       * @classdesc Represents an EpochUnbondingRecord.
       * @implements IEpochUnbondingRecord
       * @constructor
       * @param {ununifi.records.IEpochUnbondingRecord=} [properties] Properties to set
       */
      function EpochUnbondingRecord(properties) {
        this.host_zone_unbondings = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EpochUnbondingRecord epoch_number.
       * @member {Long} epoch_number
       * @memberof ununifi.records.EpochUnbondingRecord
       * @instance
       */
      EpochUnbondingRecord.prototype.epoch_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * EpochUnbondingRecord host_zone_unbondings.
       * @member {Array.<ununifi.records.IHostZoneUnbonding>} host_zone_unbondings
       * @memberof ununifi.records.EpochUnbondingRecord
       * @instance
       */
      EpochUnbondingRecord.prototype.host_zone_unbondings = $util.emptyArray;

      /**
       * Encodes the specified EpochUnbondingRecord message. Does not implicitly {@link ununifi.records.EpochUnbondingRecord.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.EpochUnbondingRecord
       * @static
       * @param {ununifi.records.IEpochUnbondingRecord} message EpochUnbondingRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EpochUnbondingRecord.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.epoch_number != null && Object.hasOwnProperty.call(message, 'epoch_number'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.epoch_number);
        if (message.host_zone_unbondings != null && message.host_zone_unbondings.length)
          for (let i = 0; i < message.host_zone_unbondings.length; ++i)
            $root.ununifi.records.HostZoneUnbonding.encode(
              message.host_zone_unbondings[i],
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EpochUnbondingRecord message, length delimited. Does not implicitly {@link ununifi.records.EpochUnbondingRecord.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.EpochUnbondingRecord
       * @static
       * @param {ununifi.records.IEpochUnbondingRecord} message EpochUnbondingRecord message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EpochUnbondingRecord.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EpochUnbondingRecord message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.EpochUnbondingRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.EpochUnbondingRecord} EpochUnbondingRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EpochUnbondingRecord.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.EpochUnbondingRecord();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.epoch_number = reader.uint64();
              break;
            case 3:
              if (!(message.host_zone_unbondings && message.host_zone_unbondings.length)) message.host_zone_unbondings = [];
              message.host_zone_unbondings.push($root.ununifi.records.HostZoneUnbonding.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EpochUnbondingRecord message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.EpochUnbondingRecord
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.EpochUnbondingRecord} EpochUnbondingRecord
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EpochUnbondingRecord.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EpochUnbondingRecord message.
       * @function verify
       * @memberof ununifi.records.EpochUnbondingRecord
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EpochUnbondingRecord.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.epoch_number != null && message.hasOwnProperty('epoch_number'))
          if (
            !$util.isInteger(message.epoch_number) &&
            !(message.epoch_number && $util.isInteger(message.epoch_number.low) && $util.isInteger(message.epoch_number.high))
          )
            return 'epoch_number: integer|Long expected';
        if (message.host_zone_unbondings != null && message.hasOwnProperty('host_zone_unbondings')) {
          if (!Array.isArray(message.host_zone_unbondings)) return 'host_zone_unbondings: array expected';
          for (let i = 0; i < message.host_zone_unbondings.length; ++i) {
            let error = $root.ununifi.records.HostZoneUnbonding.verify(message.host_zone_unbondings[i]);
            if (error) return 'host_zone_unbondings.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an EpochUnbondingRecord message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.EpochUnbondingRecord
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.EpochUnbondingRecord} EpochUnbondingRecord
       */
      EpochUnbondingRecord.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.EpochUnbondingRecord) return object;
        let message = new $root.ununifi.records.EpochUnbondingRecord();
        if (object.epoch_number != null)
          if ($util.Long) (message.epoch_number = $util.Long.fromValue(object.epoch_number)).unsigned = true;
          else if (typeof object.epoch_number === 'string') message.epoch_number = parseInt(object.epoch_number, 10);
          else if (typeof object.epoch_number === 'number') message.epoch_number = object.epoch_number;
          else if (typeof object.epoch_number === 'object')
            message.epoch_number = new $util.LongBits(object.epoch_number.low >>> 0, object.epoch_number.high >>> 0).toNumber(true);
        if (object.host_zone_unbondings) {
          if (!Array.isArray(object.host_zone_unbondings))
            throw TypeError('.ununifi.records.EpochUnbondingRecord.host_zone_unbondings: array expected');
          message.host_zone_unbondings = [];
          for (let i = 0; i < object.host_zone_unbondings.length; ++i) {
            if (typeof object.host_zone_unbondings[i] !== 'object')
              throw TypeError('.ununifi.records.EpochUnbondingRecord.host_zone_unbondings: object expected');
            message.host_zone_unbondings[i] = $root.ununifi.records.HostZoneUnbonding.fromObject(object.host_zone_unbondings[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EpochUnbondingRecord message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.EpochUnbondingRecord
       * @static
       * @param {ununifi.records.EpochUnbondingRecord} message EpochUnbondingRecord
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EpochUnbondingRecord.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.host_zone_unbondings = [];
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.epoch_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.epoch_number = options.longs === String ? '0' : 0;
        if (message.epoch_number != null && message.hasOwnProperty('epoch_number'))
          if (typeof message.epoch_number === 'number')
            object.epoch_number = options.longs === String ? String(message.epoch_number) : message.epoch_number;
          else
            object.epoch_number =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.epoch_number)
                : options.longs === Number
                ? new $util.LongBits(message.epoch_number.low >>> 0, message.epoch_number.high >>> 0).toNumber(true)
                : message.epoch_number;
        if (message.host_zone_unbondings && message.host_zone_unbondings.length) {
          object.host_zone_unbondings = [];
          for (let j = 0; j < message.host_zone_unbondings.length; ++j)
            object.host_zone_unbondings[j] = $root.ununifi.records.HostZoneUnbonding.toObject(message.host_zone_unbondings[j], options);
        }
        return object;
      };

      /**
       * Converts this EpochUnbondingRecord to JSON.
       * @function toJSON
       * @memberof ununifi.records.EpochUnbondingRecord
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EpochUnbondingRecord.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EpochUnbondingRecord;
    })();

    records.PendingDeposit = (function () {
      /**
       * Properties of a PendingDeposit.
       * @memberof ununifi.records
       * @interface IPendingDeposit
       * @property {Long|null} [vault_id] PendingDeposit vault_id
       * @property {string|null} [amount] PendingDeposit amount
       */

      /**
       * Constructs a new PendingDeposit.
       * @memberof ununifi.records
       * @classdesc Represents a PendingDeposit.
       * @implements IPendingDeposit
       * @constructor
       * @param {ununifi.records.IPendingDeposit=} [properties] Properties to set
       */
      function PendingDeposit(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * PendingDeposit vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.records.PendingDeposit
       * @instance
       */
      PendingDeposit.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * PendingDeposit amount.
       * @member {string} amount
       * @memberof ununifi.records.PendingDeposit
       * @instance
       */
      PendingDeposit.prototype.amount = '';

      /**
       * Encodes the specified PendingDeposit message. Does not implicitly {@link ununifi.records.PendingDeposit.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.PendingDeposit
       * @static
       * @param {ununifi.records.IPendingDeposit} message PendingDeposit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PendingDeposit.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.vault_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
        return writer;
      };

      /**
       * Encodes the specified PendingDeposit message, length delimited. Does not implicitly {@link ununifi.records.PendingDeposit.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.PendingDeposit
       * @static
       * @param {ununifi.records.IPendingDeposit} message PendingDeposit message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      PendingDeposit.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a PendingDeposit message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.PendingDeposit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.PendingDeposit} PendingDeposit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PendingDeposit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.PendingDeposit();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vault_id = reader.uint64();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a PendingDeposit message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.PendingDeposit
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.PendingDeposit} PendingDeposit
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      PendingDeposit.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a PendingDeposit message.
       * @function verify
       * @memberof ununifi.records.PendingDeposit
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      PendingDeposit.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        if (message.amount != null && message.hasOwnProperty('amount'))
          if (!$util.isString(message.amount)) return 'amount: string expected';
        return null;
      };

      /**
       * Creates a PendingDeposit message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.PendingDeposit
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.PendingDeposit} PendingDeposit
       */
      PendingDeposit.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.PendingDeposit) return object;
        let message = new $root.ununifi.records.PendingDeposit();
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        if (object.amount != null) message.amount = String(object.amount);
        return message;
      };

      /**
       * Creates a plain object from a PendingDeposit message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.PendingDeposit
       * @static
       * @param {ununifi.records.PendingDeposit} message PendingDeposit
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      PendingDeposit.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
          object.amount = '';
        }
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
        return object;
      };

      /**
       * Converts this PendingDeposit to JSON.
       * @function toJSON
       * @memberof ununifi.records.PendingDeposit
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      PendingDeposit.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return PendingDeposit;
    })();

    records.TransferCallback = (function () {
      /**
       * Properties of a TransferCallback.
       * @memberof ununifi.records
       * @interface ITransferCallback
       * @property {Long|null} [deposit_record_id] TransferCallback deposit_record_id
       */

      /**
       * Constructs a new TransferCallback.
       * @memberof ununifi.records
       * @classdesc Represents a TransferCallback.
       * @implements ITransferCallback
       * @constructor
       * @param {ununifi.records.ITransferCallback=} [properties] Properties to set
       */
      function TransferCallback(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * TransferCallback deposit_record_id.
       * @member {Long} deposit_record_id
       * @memberof ununifi.records.TransferCallback
       * @instance
       */
      TransferCallback.prototype.deposit_record_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified TransferCallback message. Does not implicitly {@link ununifi.records.TransferCallback.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.TransferCallback
       * @static
       * @param {ununifi.records.ITransferCallback} message TransferCallback message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TransferCallback.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deposit_record_id != null && Object.hasOwnProperty.call(message, 'deposit_record_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.deposit_record_id);
        return writer;
      };

      /**
       * Encodes the specified TransferCallback message, length delimited. Does not implicitly {@link ununifi.records.TransferCallback.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.TransferCallback
       * @static
       * @param {ununifi.records.ITransferCallback} message TransferCallback message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TransferCallback.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a TransferCallback message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.TransferCallback
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.TransferCallback} TransferCallback
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TransferCallback.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.TransferCallback();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit_record_id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a TransferCallback message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.TransferCallback
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.TransferCallback} TransferCallback
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TransferCallback.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a TransferCallback message.
       * @function verify
       * @memberof ununifi.records.TransferCallback
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      TransferCallback.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deposit_record_id != null && message.hasOwnProperty('deposit_record_id'))
          if (
            !$util.isInteger(message.deposit_record_id) &&
            !(
              message.deposit_record_id &&
              $util.isInteger(message.deposit_record_id.low) &&
              $util.isInteger(message.deposit_record_id.high)
            )
          )
            return 'deposit_record_id: integer|Long expected';
        return null;
      };

      /**
       * Creates a TransferCallback message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.TransferCallback
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.TransferCallback} TransferCallback
       */
      TransferCallback.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.TransferCallback) return object;
        let message = new $root.ununifi.records.TransferCallback();
        if (object.deposit_record_id != null)
          if ($util.Long) (message.deposit_record_id = $util.Long.fromValue(object.deposit_record_id)).unsigned = true;
          else if (typeof object.deposit_record_id === 'string') message.deposit_record_id = parseInt(object.deposit_record_id, 10);
          else if (typeof object.deposit_record_id === 'number') message.deposit_record_id = object.deposit_record_id;
          else if (typeof object.deposit_record_id === 'object')
            message.deposit_record_id = new $util.LongBits(
              object.deposit_record_id.low >>> 0,
              object.deposit_record_id.high >>> 0,
            ).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a TransferCallback message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.TransferCallback
       * @static
       * @param {ununifi.records.TransferCallback} message TransferCallback
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      TransferCallback.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.deposit_record_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.deposit_record_id = options.longs === String ? '0' : 0;
        if (message.deposit_record_id != null && message.hasOwnProperty('deposit_record_id'))
          if (typeof message.deposit_record_id === 'number')
            object.deposit_record_id = options.longs === String ? String(message.deposit_record_id) : message.deposit_record_id;
          else
            object.deposit_record_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.deposit_record_id)
                : options.longs === Number
                ? new $util.LongBits(message.deposit_record_id.low >>> 0, message.deposit_record_id.high >>> 0).toNumber(true)
                : message.deposit_record_id;
        return object;
      };

      /**
       * Converts this TransferCallback to JSON.
       * @function toJSON
       * @memberof ununifi.records.TransferCallback
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      TransferCallback.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return TransferCallback;
    })();

    records.VaultTransferCallback = (function () {
      /**
       * Properties of a VaultTransferCallback.
       * @memberof ununifi.records
       * @interface IVaultTransferCallback
       * @property {Long|null} [vault_id] VaultTransferCallback vault_id
       * @property {string|null} [strategy_contract] VaultTransferCallback strategy_contract
       */

      /**
       * Constructs a new VaultTransferCallback.
       * @memberof ununifi.records
       * @classdesc Represents a VaultTransferCallback.
       * @implements IVaultTransferCallback
       * @constructor
       * @param {ununifi.records.IVaultTransferCallback=} [properties] Properties to set
       */
      function VaultTransferCallback(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * VaultTransferCallback vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.records.VaultTransferCallback
       * @instance
       */
      VaultTransferCallback.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * VaultTransferCallback strategy_contract.
       * @member {string} strategy_contract
       * @memberof ununifi.records.VaultTransferCallback
       * @instance
       */
      VaultTransferCallback.prototype.strategy_contract = '';

      /**
       * Encodes the specified VaultTransferCallback message. Does not implicitly {@link ununifi.records.VaultTransferCallback.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.VaultTransferCallback
       * @static
       * @param {ununifi.records.IVaultTransferCallback} message VaultTransferCallback message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      VaultTransferCallback.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.vault_id);
        if (message.strategy_contract != null && Object.hasOwnProperty.call(message, 'strategy_contract'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.strategy_contract);
        return writer;
      };

      /**
       * Encodes the specified VaultTransferCallback message, length delimited. Does not implicitly {@link ununifi.records.VaultTransferCallback.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.VaultTransferCallback
       * @static
       * @param {ununifi.records.IVaultTransferCallback} message VaultTransferCallback message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      VaultTransferCallback.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a VaultTransferCallback message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.VaultTransferCallback
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.VaultTransferCallback} VaultTransferCallback
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      VaultTransferCallback.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.VaultTransferCallback();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vault_id = reader.uint64();
              break;
            case 2:
              message.strategy_contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a VaultTransferCallback message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.VaultTransferCallback
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.VaultTransferCallback} VaultTransferCallback
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      VaultTransferCallback.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a VaultTransferCallback message.
       * @function verify
       * @memberof ununifi.records.VaultTransferCallback
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      VaultTransferCallback.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          if (!$util.isString(message.strategy_contract)) return 'strategy_contract: string expected';
        return null;
      };

      /**
       * Creates a VaultTransferCallback message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.VaultTransferCallback
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.VaultTransferCallback} VaultTransferCallback
       */
      VaultTransferCallback.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.VaultTransferCallback) return object;
        let message = new $root.ununifi.records.VaultTransferCallback();
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        if (object.strategy_contract != null) message.strategy_contract = String(object.strategy_contract);
        return message;
      };

      /**
       * Creates a plain object from a VaultTransferCallback message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.VaultTransferCallback
       * @static
       * @param {ununifi.records.VaultTransferCallback} message VaultTransferCallback
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      VaultTransferCallback.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
          object.strategy_contract = '';
        }
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        if (message.strategy_contract != null && message.hasOwnProperty('strategy_contract'))
          object.strategy_contract = message.strategy_contract;
        return object;
      };

      /**
       * Converts this VaultTransferCallback to JSON.
       * @function toJSON
       * @memberof ununifi.records.VaultTransferCallback
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      VaultTransferCallback.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return VaultTransferCallback;
    })();

    records.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.records
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.records.Query#params}.
       * @memberof ununifi.records.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.records.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.records.QueryParamsRequest,
            $root.ununifi.records.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.records.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#userRedemptionRecord}.
       * @memberof ununifi.records.Query
       * @typedef UserRedemptionRecordCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryGetUserRedemptionRecordResponse} [response] QueryGetUserRedemptionRecordResponse
       */

      /**
       * Calls UserRedemptionRecord.
       * @function userRedemptionRecord
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryGetUserRedemptionRecordRequest} request QueryGetUserRedemptionRecordRequest message or plain object
       * @param {ununifi.records.Query.UserRedemptionRecordCallback} callback Node-style callback called with the error, if any, and QueryGetUserRedemptionRecordResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.userRedemptionRecord = function userRedemptionRecord(request, callback) {
          return this.rpcCall(
            userRedemptionRecord,
            $root.ununifi.records.QueryGetUserRedemptionRecordRequest,
            $root.ununifi.records.QueryGetUserRedemptionRecordResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UserRedemptionRecord' },
      );

      /**
       * Calls UserRedemptionRecord.
       * @function userRedemptionRecord
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryGetUserRedemptionRecordRequest} request QueryGetUserRedemptionRecordRequest message or plain object
       * @returns {Promise<ununifi.records.QueryGetUserRedemptionRecordResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#userRedemptionRecordAll}.
       * @memberof ununifi.records.Query
       * @typedef UserRedemptionRecordAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryAllUserRedemptionRecordResponse} [response] QueryAllUserRedemptionRecordResponse
       */

      /**
       * Calls UserRedemptionRecordAll.
       * @function userRedemptionRecordAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllUserRedemptionRecordRequest} request QueryAllUserRedemptionRecordRequest message or plain object
       * @param {ununifi.records.Query.UserRedemptionRecordAllCallback} callback Node-style callback called with the error, if any, and QueryAllUserRedemptionRecordResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.userRedemptionRecordAll = function userRedemptionRecordAll(request, callback) {
          return this.rpcCall(
            userRedemptionRecordAll,
            $root.ununifi.records.QueryAllUserRedemptionRecordRequest,
            $root.ununifi.records.QueryAllUserRedemptionRecordResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UserRedemptionRecordAll' },
      );

      /**
       * Calls UserRedemptionRecordAll.
       * @function userRedemptionRecordAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllUserRedemptionRecordRequest} request QueryAllUserRedemptionRecordRequest message or plain object
       * @returns {Promise<ununifi.records.QueryAllUserRedemptionRecordResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#userRedemptionRecordForUser}.
       * @memberof ununifi.records.Query
       * @typedef UserRedemptionRecordForUserCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryAllUserRedemptionRecordForUserResponse} [response] QueryAllUserRedemptionRecordForUserResponse
       */

      /**
       * Calls UserRedemptionRecordForUser.
       * @function userRedemptionRecordForUser
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserRequest} request QueryAllUserRedemptionRecordForUserRequest message or plain object
       * @param {ununifi.records.Query.UserRedemptionRecordForUserCallback} callback Node-style callback called with the error, if any, and QueryAllUserRedemptionRecordForUserResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.userRedemptionRecordForUser = function userRedemptionRecordForUser(request, callback) {
          return this.rpcCall(
            userRedemptionRecordForUser,
            $root.ununifi.records.QueryAllUserRedemptionRecordForUserRequest,
            $root.ununifi.records.QueryAllUserRedemptionRecordForUserResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UserRedemptionRecordForUser' },
      );

      /**
       * Calls UserRedemptionRecordForUser.
       * @function userRedemptionRecordForUser
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserRequest} request QueryAllUserRedemptionRecordForUserRequest message or plain object
       * @returns {Promise<ununifi.records.QueryAllUserRedemptionRecordForUserResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#epochUnbondingRecord}.
       * @memberof ununifi.records.Query
       * @typedef EpochUnbondingRecordCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryGetEpochUnbondingRecordResponse} [response] QueryGetEpochUnbondingRecordResponse
       */

      /**
       * Calls EpochUnbondingRecord.
       * @function epochUnbondingRecord
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordRequest} request QueryGetEpochUnbondingRecordRequest message or plain object
       * @param {ununifi.records.Query.EpochUnbondingRecordCallback} callback Node-style callback called with the error, if any, and QueryGetEpochUnbondingRecordResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.epochUnbondingRecord = function epochUnbondingRecord(request, callback) {
          return this.rpcCall(
            epochUnbondingRecord,
            $root.ununifi.records.QueryGetEpochUnbondingRecordRequest,
            $root.ununifi.records.QueryGetEpochUnbondingRecordResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EpochUnbondingRecord' },
      );

      /**
       * Calls EpochUnbondingRecord.
       * @function epochUnbondingRecord
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordRequest} request QueryGetEpochUnbondingRecordRequest message or plain object
       * @returns {Promise<ununifi.records.QueryGetEpochUnbondingRecordResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#epochUnbondingRecordAll}.
       * @memberof ununifi.records.Query
       * @typedef EpochUnbondingRecordAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryAllEpochUnbondingRecordResponse} [response] QueryAllEpochUnbondingRecordResponse
       */

      /**
       * Calls EpochUnbondingRecordAll.
       * @function epochUnbondingRecordAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordRequest} request QueryAllEpochUnbondingRecordRequest message or plain object
       * @param {ununifi.records.Query.EpochUnbondingRecordAllCallback} callback Node-style callback called with the error, if any, and QueryAllEpochUnbondingRecordResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.epochUnbondingRecordAll = function epochUnbondingRecordAll(request, callback) {
          return this.rpcCall(
            epochUnbondingRecordAll,
            $root.ununifi.records.QueryAllEpochUnbondingRecordRequest,
            $root.ununifi.records.QueryAllEpochUnbondingRecordResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EpochUnbondingRecordAll' },
      );

      /**
       * Calls EpochUnbondingRecordAll.
       * @function epochUnbondingRecordAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordRequest} request QueryAllEpochUnbondingRecordRequest message or plain object
       * @returns {Promise<ununifi.records.QueryAllEpochUnbondingRecordResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#depositRecord}.
       * @memberof ununifi.records.Query
       * @typedef DepositRecordCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryGetDepositRecordResponse} [response] QueryGetDepositRecordResponse
       */

      /**
       * Calls DepositRecord.
       * @function depositRecord
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryGetDepositRecordRequest} request QueryGetDepositRecordRequest message or plain object
       * @param {ununifi.records.Query.DepositRecordCallback} callback Node-style callback called with the error, if any, and QueryGetDepositRecordResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.depositRecord = function depositRecord(request, callback) {
          return this.rpcCall(
            depositRecord,
            $root.ununifi.records.QueryGetDepositRecordRequest,
            $root.ununifi.records.QueryGetDepositRecordResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DepositRecord' },
      );

      /**
       * Calls DepositRecord.
       * @function depositRecord
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryGetDepositRecordRequest} request QueryGetDepositRecordRequest message or plain object
       * @returns {Promise<ununifi.records.QueryGetDepositRecordResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#depositRecordAll}.
       * @memberof ununifi.records.Query
       * @typedef DepositRecordAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryAllDepositRecordResponse} [response] QueryAllDepositRecordResponse
       */

      /**
       * Calls DepositRecordAll.
       * @function depositRecordAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllDepositRecordRequest} request QueryAllDepositRecordRequest message or plain object
       * @param {ununifi.records.Query.DepositRecordAllCallback} callback Node-style callback called with the error, if any, and QueryAllDepositRecordResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.depositRecordAll = function depositRecordAll(request, callback) {
          return this.rpcCall(
            depositRecordAll,
            $root.ununifi.records.QueryAllDepositRecordRequest,
            $root.ununifi.records.QueryAllDepositRecordResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DepositRecordAll' },
      );

      /**
       * Calls DepositRecordAll.
       * @function depositRecordAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllDepositRecordRequest} request QueryAllDepositRecordRequest message or plain object
       * @returns {Promise<ununifi.records.QueryAllDepositRecordResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.records.Query#pendingVaultDepositAll}.
       * @memberof ununifi.records.Query
       * @typedef PendingVaultDepositAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.records.QueryPendingVaultDepositResponse} [response] QueryPendingVaultDepositResponse
       */

      /**
       * Calls PendingVaultDepositAll.
       * @function pendingVaultDepositAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllPendingVaultDepositRequest} request QueryAllPendingVaultDepositRequest message or plain object
       * @param {ununifi.records.Query.PendingVaultDepositAllCallback} callback Node-style callback called with the error, if any, and QueryPendingVaultDepositResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.pendingVaultDepositAll = function pendingVaultDepositAll(request, callback) {
          return this.rpcCall(
            pendingVaultDepositAll,
            $root.ununifi.records.QueryAllPendingVaultDepositRequest,
            $root.ununifi.records.QueryPendingVaultDepositResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'PendingVaultDepositAll' },
      );

      /**
       * Calls PendingVaultDepositAll.
       * @function pendingVaultDepositAll
       * @memberof ununifi.records.Query
       * @instance
       * @param {ununifi.records.IQueryAllPendingVaultDepositRequest} request QueryAllPendingVaultDepositRequest message or plain object
       * @returns {Promise<ununifi.records.QueryPendingVaultDepositResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    records.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.records
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.records.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.records.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryParamsRequest
       * @static
       * @param {ununifi.records.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryParamsRequest
       * @static
       * @param {ununifi.records.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.records.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryParamsRequest) return object;
        return new $root.ununifi.records.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryParamsRequest
       * @static
       * @param {ununifi.records.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    records.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.records
       * @interface IQueryParamsResponse
       * @property {ununifi.records.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.records.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.records.IParams|null|undefined} params
       * @memberof ununifi.records.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.records.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryParamsResponse
       * @static
       * @param {ununifi.records.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.records.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryParamsResponse
       * @static
       * @param {ununifi.records.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.records.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.records.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.records.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryParamsResponse) return object;
        let message = new $root.ununifi.records.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.records.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.records.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryParamsResponse
       * @static
       * @param {ununifi.records.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.records.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    records.QueryGetDepositRecordRequest = (function () {
      /**
       * Properties of a QueryGetDepositRecordRequest.
       * @memberof ununifi.records
       * @interface IQueryGetDepositRecordRequest
       * @property {Long|null} [id] QueryGetDepositRecordRequest id
       */

      /**
       * Constructs a new QueryGetDepositRecordRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryGetDepositRecordRequest.
       * @implements IQueryGetDepositRecordRequest
       * @constructor
       * @param {ununifi.records.IQueryGetDepositRecordRequest=} [properties] Properties to set
       */
      function QueryGetDepositRecordRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetDepositRecordRequest id.
       * @member {Long} id
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @instance
       */
      QueryGetDepositRecordRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryGetDepositRecordRequest message. Does not implicitly {@link ununifi.records.QueryGetDepositRecordRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @static
       * @param {ununifi.records.IQueryGetDepositRecordRequest} message QueryGetDepositRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetDepositRecordRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetDepositRecordRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryGetDepositRecordRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @static
       * @param {ununifi.records.IQueryGetDepositRecordRequest} message QueryGetDepositRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetDepositRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetDepositRecordRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryGetDepositRecordRequest} QueryGetDepositRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetDepositRecordRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryGetDepositRecordRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetDepositRecordRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryGetDepositRecordRequest} QueryGetDepositRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetDepositRecordRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetDepositRecordRequest message.
       * @function verify
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetDepositRecordRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryGetDepositRecordRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryGetDepositRecordRequest} QueryGetDepositRecordRequest
       */
      QueryGetDepositRecordRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryGetDepositRecordRequest) return object;
        let message = new $root.ununifi.records.QueryGetDepositRecordRequest();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetDepositRecordRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @static
       * @param {ununifi.records.QueryGetDepositRecordRequest} message QueryGetDepositRecordRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetDepositRecordRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this QueryGetDepositRecordRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryGetDepositRecordRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetDepositRecordRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetDepositRecordRequest;
    })();

    records.QueryGetDepositRecordResponse = (function () {
      /**
       * Properties of a QueryGetDepositRecordResponse.
       * @memberof ununifi.records
       * @interface IQueryGetDepositRecordResponse
       * @property {ununifi.records.IDepositRecord|null} [deposit_record] QueryGetDepositRecordResponse deposit_record
       */

      /**
       * Constructs a new QueryGetDepositRecordResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryGetDepositRecordResponse.
       * @implements IQueryGetDepositRecordResponse
       * @constructor
       * @param {ununifi.records.IQueryGetDepositRecordResponse=} [properties] Properties to set
       */
      function QueryGetDepositRecordResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetDepositRecordResponse deposit_record.
       * @member {ununifi.records.IDepositRecord|null|undefined} deposit_record
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @instance
       */
      QueryGetDepositRecordResponse.prototype.deposit_record = null;

      /**
       * Encodes the specified QueryGetDepositRecordResponse message. Does not implicitly {@link ununifi.records.QueryGetDepositRecordResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @static
       * @param {ununifi.records.IQueryGetDepositRecordResponse} message QueryGetDepositRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetDepositRecordResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deposit_record != null && Object.hasOwnProperty.call(message, 'deposit_record'))
          $root.ununifi.records.DepositRecord.encode(message.deposit_record, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetDepositRecordResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryGetDepositRecordResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @static
       * @param {ununifi.records.IQueryGetDepositRecordResponse} message QueryGetDepositRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetDepositRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetDepositRecordResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryGetDepositRecordResponse} QueryGetDepositRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetDepositRecordResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryGetDepositRecordResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit_record = $root.ununifi.records.DepositRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetDepositRecordResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryGetDepositRecordResponse} QueryGetDepositRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetDepositRecordResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetDepositRecordResponse message.
       * @function verify
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetDepositRecordResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deposit_record != null && message.hasOwnProperty('deposit_record')) {
          let error = $root.ununifi.records.DepositRecord.verify(message.deposit_record);
          if (error) return 'deposit_record.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetDepositRecordResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryGetDepositRecordResponse} QueryGetDepositRecordResponse
       */
      QueryGetDepositRecordResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryGetDepositRecordResponse) return object;
        let message = new $root.ununifi.records.QueryGetDepositRecordResponse();
        if (object.deposit_record != null) {
          if (typeof object.deposit_record !== 'object')
            throw TypeError('.ununifi.records.QueryGetDepositRecordResponse.deposit_record: object expected');
          message.deposit_record = $root.ununifi.records.DepositRecord.fromObject(object.deposit_record);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetDepositRecordResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @static
       * @param {ununifi.records.QueryGetDepositRecordResponse} message QueryGetDepositRecordResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetDepositRecordResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.deposit_record = null;
        if (message.deposit_record != null && message.hasOwnProperty('deposit_record'))
          object.deposit_record = $root.ununifi.records.DepositRecord.toObject(message.deposit_record, options);
        return object;
      };

      /**
       * Converts this QueryGetDepositRecordResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryGetDepositRecordResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetDepositRecordResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetDepositRecordResponse;
    })();

    records.QueryAllDepositRecordRequest = (function () {
      /**
       * Properties of a QueryAllDepositRecordRequest.
       * @memberof ununifi.records
       * @interface IQueryAllDepositRecordRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllDepositRecordRequest pagination
       */

      /**
       * Constructs a new QueryAllDepositRecordRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllDepositRecordRequest.
       * @implements IQueryAllDepositRecordRequest
       * @constructor
       * @param {ununifi.records.IQueryAllDepositRecordRequest=} [properties] Properties to set
       */
      function QueryAllDepositRecordRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllDepositRecordRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @instance
       */
      QueryAllDepositRecordRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllDepositRecordRequest message. Does not implicitly {@link ununifi.records.QueryAllDepositRecordRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @static
       * @param {ununifi.records.IQueryAllDepositRecordRequest} message QueryAllDepositRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositRecordRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllDepositRecordRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryAllDepositRecordRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @static
       * @param {ununifi.records.IQueryAllDepositRecordRequest} message QueryAllDepositRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllDepositRecordRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllDepositRecordRequest} QueryAllDepositRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositRecordRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllDepositRecordRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllDepositRecordRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllDepositRecordRequest} QueryAllDepositRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositRecordRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllDepositRecordRequest message.
       * @function verify
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllDepositRecordRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllDepositRecordRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllDepositRecordRequest} QueryAllDepositRecordRequest
       */
      QueryAllDepositRecordRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllDepositRecordRequest) return object;
        let message = new $root.ununifi.records.QueryAllDepositRecordRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllDepositRecordRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllDepositRecordRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @static
       * @param {ununifi.records.QueryAllDepositRecordRequest} message QueryAllDepositRecordRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllDepositRecordRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllDepositRecordRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllDepositRecordRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllDepositRecordRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllDepositRecordRequest;
    })();

    records.QueryAllDepositRecordResponse = (function () {
      /**
       * Properties of a QueryAllDepositRecordResponse.
       * @memberof ununifi.records
       * @interface IQueryAllDepositRecordResponse
       * @property {Array.<ununifi.records.IDepositRecord>|null} [deposit_record] QueryAllDepositRecordResponse deposit_record
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllDepositRecordResponse pagination
       */

      /**
       * Constructs a new QueryAllDepositRecordResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllDepositRecordResponse.
       * @implements IQueryAllDepositRecordResponse
       * @constructor
       * @param {ununifi.records.IQueryAllDepositRecordResponse=} [properties] Properties to set
       */
      function QueryAllDepositRecordResponse(properties) {
        this.deposit_record = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllDepositRecordResponse deposit_record.
       * @member {Array.<ununifi.records.IDepositRecord>} deposit_record
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @instance
       */
      QueryAllDepositRecordResponse.prototype.deposit_record = $util.emptyArray;

      /**
       * QueryAllDepositRecordResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @instance
       */
      QueryAllDepositRecordResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllDepositRecordResponse message. Does not implicitly {@link ununifi.records.QueryAllDepositRecordResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @static
       * @param {ununifi.records.IQueryAllDepositRecordResponse} message QueryAllDepositRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositRecordResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deposit_record != null && message.deposit_record.length)
          for (let i = 0; i < message.deposit_record.length; ++i)
            $root.ununifi.records.DepositRecord.encode(
              message.deposit_record[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllDepositRecordResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryAllDepositRecordResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @static
       * @param {ununifi.records.IQueryAllDepositRecordResponse} message QueryAllDepositRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllDepositRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllDepositRecordResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllDepositRecordResponse} QueryAllDepositRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositRecordResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllDepositRecordResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.deposit_record && message.deposit_record.length)) message.deposit_record = [];
              message.deposit_record.push($root.ununifi.records.DepositRecord.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllDepositRecordResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllDepositRecordResponse} QueryAllDepositRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllDepositRecordResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllDepositRecordResponse message.
       * @function verify
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllDepositRecordResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deposit_record != null && message.hasOwnProperty('deposit_record')) {
          if (!Array.isArray(message.deposit_record)) return 'deposit_record: array expected';
          for (let i = 0; i < message.deposit_record.length; ++i) {
            let error = $root.ununifi.records.DepositRecord.verify(message.deposit_record[i]);
            if (error) return 'deposit_record.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllDepositRecordResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllDepositRecordResponse} QueryAllDepositRecordResponse
       */
      QueryAllDepositRecordResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllDepositRecordResponse) return object;
        let message = new $root.ununifi.records.QueryAllDepositRecordResponse();
        if (object.deposit_record) {
          if (!Array.isArray(object.deposit_record))
            throw TypeError('.ununifi.records.QueryAllDepositRecordResponse.deposit_record: array expected');
          message.deposit_record = [];
          for (let i = 0; i < object.deposit_record.length; ++i) {
            if (typeof object.deposit_record[i] !== 'object')
              throw TypeError('.ununifi.records.QueryAllDepositRecordResponse.deposit_record: object expected');
            message.deposit_record[i] = $root.ununifi.records.DepositRecord.fromObject(object.deposit_record[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllDepositRecordResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllDepositRecordResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @static
       * @param {ununifi.records.QueryAllDepositRecordResponse} message QueryAllDepositRecordResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllDepositRecordResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.deposit_record = [];
        if (options.defaults) object.pagination = null;
        if (message.deposit_record && message.deposit_record.length) {
          object.deposit_record = [];
          for (let j = 0; j < message.deposit_record.length; ++j)
            object.deposit_record[j] = $root.ununifi.records.DepositRecord.toObject(message.deposit_record[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllDepositRecordResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllDepositRecordResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllDepositRecordResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllDepositRecordResponse;
    })();

    records.QueryGetUserRedemptionRecordRequest = (function () {
      /**
       * Properties of a QueryGetUserRedemptionRecordRequest.
       * @memberof ununifi.records
       * @interface IQueryGetUserRedemptionRecordRequest
       * @property {string|null} [id] QueryGetUserRedemptionRecordRequest id
       */

      /**
       * Constructs a new QueryGetUserRedemptionRecordRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryGetUserRedemptionRecordRequest.
       * @implements IQueryGetUserRedemptionRecordRequest
       * @constructor
       * @param {ununifi.records.IQueryGetUserRedemptionRecordRequest=} [properties] Properties to set
       */
      function QueryGetUserRedemptionRecordRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetUserRedemptionRecordRequest id.
       * @member {string} id
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @instance
       */
      QueryGetUserRedemptionRecordRequest.prototype.id = '';

      /**
       * Encodes the specified QueryGetUserRedemptionRecordRequest message. Does not implicitly {@link ununifi.records.QueryGetUserRedemptionRecordRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @static
       * @param {ununifi.records.IQueryGetUserRedemptionRecordRequest} message QueryGetUserRedemptionRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetUserRedemptionRecordRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetUserRedemptionRecordRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryGetUserRedemptionRecordRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @static
       * @param {ununifi.records.IQueryGetUserRedemptionRecordRequest} message QueryGetUserRedemptionRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetUserRedemptionRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetUserRedemptionRecordRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryGetUserRedemptionRecordRequest} QueryGetUserRedemptionRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetUserRedemptionRecordRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryGetUserRedemptionRecordRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetUserRedemptionRecordRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryGetUserRedemptionRecordRequest} QueryGetUserRedemptionRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetUserRedemptionRecordRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetUserRedemptionRecordRequest message.
       * @function verify
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetUserRedemptionRecordRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';
        return null;
      };

      /**
       * Creates a QueryGetUserRedemptionRecordRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryGetUserRedemptionRecordRequest} QueryGetUserRedemptionRecordRequest
       */
      QueryGetUserRedemptionRecordRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryGetUserRedemptionRecordRequest) return object;
        let message = new $root.ununifi.records.QueryGetUserRedemptionRecordRequest();
        if (object.id != null) message.id = String(object.id);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetUserRedemptionRecordRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @static
       * @param {ununifi.records.QueryGetUserRedemptionRecordRequest} message QueryGetUserRedemptionRecordRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetUserRedemptionRecordRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.id = '';
        if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;
        return object;
      };

      /**
       * Converts this QueryGetUserRedemptionRecordRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryGetUserRedemptionRecordRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetUserRedemptionRecordRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetUserRedemptionRecordRequest;
    })();

    records.QueryGetUserRedemptionRecordResponse = (function () {
      /**
       * Properties of a QueryGetUserRedemptionRecordResponse.
       * @memberof ununifi.records
       * @interface IQueryGetUserRedemptionRecordResponse
       * @property {ununifi.records.IUserRedemptionRecord|null} [user_redemption_record] QueryGetUserRedemptionRecordResponse user_redemption_record
       */

      /**
       * Constructs a new QueryGetUserRedemptionRecordResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryGetUserRedemptionRecordResponse.
       * @implements IQueryGetUserRedemptionRecordResponse
       * @constructor
       * @param {ununifi.records.IQueryGetUserRedemptionRecordResponse=} [properties] Properties to set
       */
      function QueryGetUserRedemptionRecordResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetUserRedemptionRecordResponse user_redemption_record.
       * @member {ununifi.records.IUserRedemptionRecord|null|undefined} user_redemption_record
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @instance
       */
      QueryGetUserRedemptionRecordResponse.prototype.user_redemption_record = null;

      /**
       * Encodes the specified QueryGetUserRedemptionRecordResponse message. Does not implicitly {@link ununifi.records.QueryGetUserRedemptionRecordResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @static
       * @param {ununifi.records.IQueryGetUserRedemptionRecordResponse} message QueryGetUserRedemptionRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetUserRedemptionRecordResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.user_redemption_record != null && Object.hasOwnProperty.call(message, 'user_redemption_record'))
          $root.ununifi.records.UserRedemptionRecord.encode(
            message.user_redemption_record,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetUserRedemptionRecordResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryGetUserRedemptionRecordResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @static
       * @param {ununifi.records.IQueryGetUserRedemptionRecordResponse} message QueryGetUserRedemptionRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetUserRedemptionRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetUserRedemptionRecordResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryGetUserRedemptionRecordResponse} QueryGetUserRedemptionRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetUserRedemptionRecordResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryGetUserRedemptionRecordResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.user_redemption_record = $root.ununifi.records.UserRedemptionRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetUserRedemptionRecordResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryGetUserRedemptionRecordResponse} QueryGetUserRedemptionRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetUserRedemptionRecordResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetUserRedemptionRecordResponse message.
       * @function verify
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetUserRedemptionRecordResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.user_redemption_record != null && message.hasOwnProperty('user_redemption_record')) {
          let error = $root.ununifi.records.UserRedemptionRecord.verify(message.user_redemption_record);
          if (error) return 'user_redemption_record.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetUserRedemptionRecordResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryGetUserRedemptionRecordResponse} QueryGetUserRedemptionRecordResponse
       */
      QueryGetUserRedemptionRecordResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryGetUserRedemptionRecordResponse) return object;
        let message = new $root.ununifi.records.QueryGetUserRedemptionRecordResponse();
        if (object.user_redemption_record != null) {
          if (typeof object.user_redemption_record !== 'object')
            throw TypeError('.ununifi.records.QueryGetUserRedemptionRecordResponse.user_redemption_record: object expected');
          message.user_redemption_record = $root.ununifi.records.UserRedemptionRecord.fromObject(object.user_redemption_record);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetUserRedemptionRecordResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @static
       * @param {ununifi.records.QueryGetUserRedemptionRecordResponse} message QueryGetUserRedemptionRecordResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetUserRedemptionRecordResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.user_redemption_record = null;
        if (message.user_redemption_record != null && message.hasOwnProperty('user_redemption_record'))
          object.user_redemption_record = $root.ununifi.records.UserRedemptionRecord.toObject(message.user_redemption_record, options);
        return object;
      };

      /**
       * Converts this QueryGetUserRedemptionRecordResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryGetUserRedemptionRecordResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetUserRedemptionRecordResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetUserRedemptionRecordResponse;
    })();

    records.QueryAllUserRedemptionRecordRequest = (function () {
      /**
       * Properties of a QueryAllUserRedemptionRecordRequest.
       * @memberof ununifi.records
       * @interface IQueryAllUserRedemptionRecordRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllUserRedemptionRecordRequest pagination
       */

      /**
       * Constructs a new QueryAllUserRedemptionRecordRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllUserRedemptionRecordRequest.
       * @implements IQueryAllUserRedemptionRecordRequest
       * @constructor
       * @param {ununifi.records.IQueryAllUserRedemptionRecordRequest=} [properties] Properties to set
       */
      function QueryAllUserRedemptionRecordRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllUserRedemptionRecordRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @instance
       */
      QueryAllUserRedemptionRecordRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllUserRedemptionRecordRequest message. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordRequest} message QueryAllUserRedemptionRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllUserRedemptionRecordRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordRequest} message QueryAllUserRedemptionRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllUserRedemptionRecordRequest} QueryAllUserRedemptionRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllUserRedemptionRecordRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllUserRedemptionRecordRequest} QueryAllUserRedemptionRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllUserRedemptionRecordRequest message.
       * @function verify
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllUserRedemptionRecordRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllUserRedemptionRecordRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllUserRedemptionRecordRequest} QueryAllUserRedemptionRecordRequest
       */
      QueryAllUserRedemptionRecordRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllUserRedemptionRecordRequest) return object;
        let message = new $root.ununifi.records.QueryAllUserRedemptionRecordRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllUserRedemptionRecordRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @static
       * @param {ununifi.records.QueryAllUserRedemptionRecordRequest} message QueryAllUserRedemptionRecordRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllUserRedemptionRecordRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllUserRedemptionRecordRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllUserRedemptionRecordRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllUserRedemptionRecordRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllUserRedemptionRecordRequest;
    })();

    records.QueryAllUserRedemptionRecordResponse = (function () {
      /**
       * Properties of a QueryAllUserRedemptionRecordResponse.
       * @memberof ununifi.records
       * @interface IQueryAllUserRedemptionRecordResponse
       * @property {Array.<ununifi.records.IUserRedemptionRecord>|null} [user_redemption_record] QueryAllUserRedemptionRecordResponse user_redemption_record
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllUserRedemptionRecordResponse pagination
       */

      /**
       * Constructs a new QueryAllUserRedemptionRecordResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllUserRedemptionRecordResponse.
       * @implements IQueryAllUserRedemptionRecordResponse
       * @constructor
       * @param {ununifi.records.IQueryAllUserRedemptionRecordResponse=} [properties] Properties to set
       */
      function QueryAllUserRedemptionRecordResponse(properties) {
        this.user_redemption_record = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllUserRedemptionRecordResponse user_redemption_record.
       * @member {Array.<ununifi.records.IUserRedemptionRecord>} user_redemption_record
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @instance
       */
      QueryAllUserRedemptionRecordResponse.prototype.user_redemption_record = $util.emptyArray;

      /**
       * QueryAllUserRedemptionRecordResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @instance
       */
      QueryAllUserRedemptionRecordResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllUserRedemptionRecordResponse message. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordResponse} message QueryAllUserRedemptionRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.user_redemption_record != null && message.user_redemption_record.length)
          for (let i = 0; i < message.user_redemption_record.length; ++i)
            $root.ununifi.records.UserRedemptionRecord.encode(
              message.user_redemption_record[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllUserRedemptionRecordResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordResponse} message QueryAllUserRedemptionRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllUserRedemptionRecordResponse} QueryAllUserRedemptionRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllUserRedemptionRecordResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.user_redemption_record && message.user_redemption_record.length)) message.user_redemption_record = [];
              message.user_redemption_record.push($root.ununifi.records.UserRedemptionRecord.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllUserRedemptionRecordResponse} QueryAllUserRedemptionRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllUserRedemptionRecordResponse message.
       * @function verify
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllUserRedemptionRecordResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.user_redemption_record != null && message.hasOwnProperty('user_redemption_record')) {
          if (!Array.isArray(message.user_redemption_record)) return 'user_redemption_record: array expected';
          for (let i = 0; i < message.user_redemption_record.length; ++i) {
            let error = $root.ununifi.records.UserRedemptionRecord.verify(message.user_redemption_record[i]);
            if (error) return 'user_redemption_record.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllUserRedemptionRecordResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllUserRedemptionRecordResponse} QueryAllUserRedemptionRecordResponse
       */
      QueryAllUserRedemptionRecordResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllUserRedemptionRecordResponse) return object;
        let message = new $root.ununifi.records.QueryAllUserRedemptionRecordResponse();
        if (object.user_redemption_record) {
          if (!Array.isArray(object.user_redemption_record))
            throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordResponse.user_redemption_record: array expected');
          message.user_redemption_record = [];
          for (let i = 0; i < object.user_redemption_record.length; ++i) {
            if (typeof object.user_redemption_record[i] !== 'object')
              throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordResponse.user_redemption_record: object expected');
            message.user_redemption_record[i] = $root.ununifi.records.UserRedemptionRecord.fromObject(object.user_redemption_record[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllUserRedemptionRecordResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @static
       * @param {ununifi.records.QueryAllUserRedemptionRecordResponse} message QueryAllUserRedemptionRecordResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllUserRedemptionRecordResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.user_redemption_record = [];
        if (options.defaults) object.pagination = null;
        if (message.user_redemption_record && message.user_redemption_record.length) {
          object.user_redemption_record = [];
          for (let j = 0; j < message.user_redemption_record.length; ++j)
            object.user_redemption_record[j] = $root.ununifi.records.UserRedemptionRecord.toObject(
              message.user_redemption_record[j],
              options,
            );
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllUserRedemptionRecordResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllUserRedemptionRecordResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllUserRedemptionRecordResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllUserRedemptionRecordResponse;
    })();

    records.QueryAllUserRedemptionRecordForUserRequest = (function () {
      /**
       * Properties of a QueryAllUserRedemptionRecordForUserRequest.
       * @memberof ununifi.records
       * @interface IQueryAllUserRedemptionRecordForUserRequest
       * @property {string|null} [chain_id] QueryAllUserRedemptionRecordForUserRequest chain_id
       * @property {Long|null} [day] QueryAllUserRedemptionRecordForUserRequest day
       * @property {string|null} [address] QueryAllUserRedemptionRecordForUserRequest address
       * @property {Long|null} [limit] QueryAllUserRedemptionRecordForUserRequest limit
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllUserRedemptionRecordForUserRequest pagination
       */

      /**
       * Constructs a new QueryAllUserRedemptionRecordForUserRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllUserRedemptionRecordForUserRequest.
       * @implements IQueryAllUserRedemptionRecordForUserRequest
       * @constructor
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserRequest=} [properties] Properties to set
       */
      function QueryAllUserRedemptionRecordForUserRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllUserRedemptionRecordForUserRequest chain_id.
       * @member {string} chain_id
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @instance
       */
      QueryAllUserRedemptionRecordForUserRequest.prototype.chain_id = '';

      /**
       * QueryAllUserRedemptionRecordForUserRequest day.
       * @member {Long} day
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @instance
       */
      QueryAllUserRedemptionRecordForUserRequest.prototype.day = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryAllUserRedemptionRecordForUserRequest address.
       * @member {string} address
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @instance
       */
      QueryAllUserRedemptionRecordForUserRequest.prototype.address = '';

      /**
       * QueryAllUserRedemptionRecordForUserRequest limit.
       * @member {Long} limit
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @instance
       */
      QueryAllUserRedemptionRecordForUserRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryAllUserRedemptionRecordForUserRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @instance
       */
      QueryAllUserRedemptionRecordForUserRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllUserRedemptionRecordForUserRequest message. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordForUserRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserRequest} message QueryAllUserRedemptionRecordForUserRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordForUserRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.chain_id);
        if (message.day != null && Object.hasOwnProperty.call(message, 'day'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.day);
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.address);
        if (message.limit != null && Object.hasOwnProperty.call(message, 'limit'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.limit);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllUserRedemptionRecordForUserRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordForUserRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserRequest} message QueryAllUserRedemptionRecordForUserRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordForUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordForUserRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllUserRedemptionRecordForUserRequest} QueryAllUserRedemptionRecordForUserRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordForUserRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllUserRedemptionRecordForUserRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chain_id = reader.string();
              break;
            case 2:
              message.day = reader.uint64();
              break;
            case 3:
              message.address = reader.string();
              break;
            case 4:
              message.limit = reader.uint64();
              break;
            case 5:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordForUserRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllUserRedemptionRecordForUserRequest} QueryAllUserRedemptionRecordForUserRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordForUserRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllUserRedemptionRecordForUserRequest message.
       * @function verify
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllUserRedemptionRecordForUserRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.chain_id != null && message.hasOwnProperty('chain_id'))
          if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
        if (message.day != null && message.hasOwnProperty('day'))
          if (!$util.isInteger(message.day) && !(message.day && $util.isInteger(message.day.low) && $util.isInteger(message.day.high)))
            return 'day: integer|Long expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        if (message.limit != null && message.hasOwnProperty('limit'))
          if (
            !$util.isInteger(message.limit) &&
            !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high))
          )
            return 'limit: integer|Long expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllUserRedemptionRecordForUserRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllUserRedemptionRecordForUserRequest} QueryAllUserRedemptionRecordForUserRequest
       */
      QueryAllUserRedemptionRecordForUserRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllUserRedemptionRecordForUserRequest) return object;
        let message = new $root.ununifi.records.QueryAllUserRedemptionRecordForUserRequest();
        if (object.chain_id != null) message.chain_id = String(object.chain_id);
        if (object.day != null)
          if ($util.Long) (message.day = $util.Long.fromValue(object.day)).unsigned = true;
          else if (typeof object.day === 'string') message.day = parseInt(object.day, 10);
          else if (typeof object.day === 'number') message.day = object.day;
          else if (typeof object.day === 'object')
            message.day = new $util.LongBits(object.day.low >>> 0, object.day.high >>> 0).toNumber(true);
        if (object.address != null) message.address = String(object.address);
        if (object.limit != null)
          if ($util.Long) (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
          else if (typeof object.limit === 'string') message.limit = parseInt(object.limit, 10);
          else if (typeof object.limit === 'number') message.limit = object.limit;
          else if (typeof object.limit === 'object')
            message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordForUserRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllUserRedemptionRecordForUserRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @static
       * @param {ununifi.records.QueryAllUserRedemptionRecordForUserRequest} message QueryAllUserRedemptionRecordForUserRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllUserRedemptionRecordForUserRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.chain_id = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.day = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.day = options.longs === String ? '0' : 0;
          object.address = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.limit = options.longs === String ? '0' : 0;
          object.pagination = null;
        }
        if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
        if (message.day != null && message.hasOwnProperty('day'))
          if (typeof message.day === 'number') object.day = options.longs === String ? String(message.day) : message.day;
          else
            object.day =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.day)
                : options.longs === Number
                ? new $util.LongBits(message.day.low >>> 0, message.day.high >>> 0).toNumber(true)
                : message.day;
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        if (message.limit != null && message.hasOwnProperty('limit'))
          if (typeof message.limit === 'number') object.limit = options.longs === String ? String(message.limit) : message.limit;
          else
            object.limit =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.limit)
                : options.longs === Number
                ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true)
                : message.limit;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllUserRedemptionRecordForUserRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllUserRedemptionRecordForUserRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllUserRedemptionRecordForUserRequest;
    })();

    records.QueryAllUserRedemptionRecordForUserResponse = (function () {
      /**
       * Properties of a QueryAllUserRedemptionRecordForUserResponse.
       * @memberof ununifi.records
       * @interface IQueryAllUserRedemptionRecordForUserResponse
       * @property {Array.<ununifi.records.IUserRedemptionRecord>|null} [user_redemption_record] QueryAllUserRedemptionRecordForUserResponse user_redemption_record
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllUserRedemptionRecordForUserResponse pagination
       */

      /**
       * Constructs a new QueryAllUserRedemptionRecordForUserResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllUserRedemptionRecordForUserResponse.
       * @implements IQueryAllUserRedemptionRecordForUserResponse
       * @constructor
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserResponse=} [properties] Properties to set
       */
      function QueryAllUserRedemptionRecordForUserResponse(properties) {
        this.user_redemption_record = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllUserRedemptionRecordForUserResponse user_redemption_record.
       * @member {Array.<ununifi.records.IUserRedemptionRecord>} user_redemption_record
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @instance
       */
      QueryAllUserRedemptionRecordForUserResponse.prototype.user_redemption_record = $util.emptyArray;

      /**
       * QueryAllUserRedemptionRecordForUserResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @instance
       */
      QueryAllUserRedemptionRecordForUserResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllUserRedemptionRecordForUserResponse message. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordForUserResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserResponse} message QueryAllUserRedemptionRecordForUserResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordForUserResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.user_redemption_record != null && message.user_redemption_record.length)
          for (let i = 0; i < message.user_redemption_record.length; ++i)
            $root.ununifi.records.UserRedemptionRecord.encode(
              message.user_redemption_record[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllUserRedemptionRecordForUserResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryAllUserRedemptionRecordForUserResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @static
       * @param {ununifi.records.IQueryAllUserRedemptionRecordForUserResponse} message QueryAllUserRedemptionRecordForUserResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllUserRedemptionRecordForUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordForUserResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllUserRedemptionRecordForUserResponse} QueryAllUserRedemptionRecordForUserResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordForUserResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllUserRedemptionRecordForUserResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.user_redemption_record && message.user_redemption_record.length)) message.user_redemption_record = [];
              message.user_redemption_record.push($root.ununifi.records.UserRedemptionRecord.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllUserRedemptionRecordForUserResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllUserRedemptionRecordForUserResponse} QueryAllUserRedemptionRecordForUserResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllUserRedemptionRecordForUserResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllUserRedemptionRecordForUserResponse message.
       * @function verify
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllUserRedemptionRecordForUserResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.user_redemption_record != null && message.hasOwnProperty('user_redemption_record')) {
          if (!Array.isArray(message.user_redemption_record)) return 'user_redemption_record: array expected';
          for (let i = 0; i < message.user_redemption_record.length; ++i) {
            let error = $root.ununifi.records.UserRedemptionRecord.verify(message.user_redemption_record[i]);
            if (error) return 'user_redemption_record.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllUserRedemptionRecordForUserResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllUserRedemptionRecordForUserResponse} QueryAllUserRedemptionRecordForUserResponse
       */
      QueryAllUserRedemptionRecordForUserResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllUserRedemptionRecordForUserResponse) return object;
        let message = new $root.ununifi.records.QueryAllUserRedemptionRecordForUserResponse();
        if (object.user_redemption_record) {
          if (!Array.isArray(object.user_redemption_record))
            throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordForUserResponse.user_redemption_record: array expected');
          message.user_redemption_record = [];
          for (let i = 0; i < object.user_redemption_record.length; ++i) {
            if (typeof object.user_redemption_record[i] !== 'object')
              throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordForUserResponse.user_redemption_record: object expected');
            message.user_redemption_record[i] = $root.ununifi.records.UserRedemptionRecord.fromObject(object.user_redemption_record[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllUserRedemptionRecordForUserResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllUserRedemptionRecordForUserResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @static
       * @param {ununifi.records.QueryAllUserRedemptionRecordForUserResponse} message QueryAllUserRedemptionRecordForUserResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllUserRedemptionRecordForUserResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.user_redemption_record = [];
        if (options.defaults) object.pagination = null;
        if (message.user_redemption_record && message.user_redemption_record.length) {
          object.user_redemption_record = [];
          for (let j = 0; j < message.user_redemption_record.length; ++j)
            object.user_redemption_record[j] = $root.ununifi.records.UserRedemptionRecord.toObject(
              message.user_redemption_record[j],
              options,
            );
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllUserRedemptionRecordForUserResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllUserRedemptionRecordForUserResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllUserRedemptionRecordForUserResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllUserRedemptionRecordForUserResponse;
    })();

    records.QueryGetEpochUnbondingRecordRequest = (function () {
      /**
       * Properties of a QueryGetEpochUnbondingRecordRequest.
       * @memberof ununifi.records
       * @interface IQueryGetEpochUnbondingRecordRequest
       * @property {Long|null} [epoch_number] QueryGetEpochUnbondingRecordRequest epoch_number
       */

      /**
       * Constructs a new QueryGetEpochUnbondingRecordRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryGetEpochUnbondingRecordRequest.
       * @implements IQueryGetEpochUnbondingRecordRequest
       * @constructor
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordRequest=} [properties] Properties to set
       */
      function QueryGetEpochUnbondingRecordRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetEpochUnbondingRecordRequest epoch_number.
       * @member {Long} epoch_number
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @instance
       */
      QueryGetEpochUnbondingRecordRequest.prototype.epoch_number = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryGetEpochUnbondingRecordRequest message. Does not implicitly {@link ununifi.records.QueryGetEpochUnbondingRecordRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @static
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordRequest} message QueryGetEpochUnbondingRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetEpochUnbondingRecordRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.epoch_number != null && Object.hasOwnProperty.call(message, 'epoch_number'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.epoch_number);
        return writer;
      };

      /**
       * Encodes the specified QueryGetEpochUnbondingRecordRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryGetEpochUnbondingRecordRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @static
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordRequest} message QueryGetEpochUnbondingRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetEpochUnbondingRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetEpochUnbondingRecordRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryGetEpochUnbondingRecordRequest} QueryGetEpochUnbondingRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetEpochUnbondingRecordRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryGetEpochUnbondingRecordRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.epoch_number = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetEpochUnbondingRecordRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryGetEpochUnbondingRecordRequest} QueryGetEpochUnbondingRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetEpochUnbondingRecordRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetEpochUnbondingRecordRequest message.
       * @function verify
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetEpochUnbondingRecordRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.epoch_number != null && message.hasOwnProperty('epoch_number'))
          if (
            !$util.isInteger(message.epoch_number) &&
            !(message.epoch_number && $util.isInteger(message.epoch_number.low) && $util.isInteger(message.epoch_number.high))
          )
            return 'epoch_number: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryGetEpochUnbondingRecordRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryGetEpochUnbondingRecordRequest} QueryGetEpochUnbondingRecordRequest
       */
      QueryGetEpochUnbondingRecordRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryGetEpochUnbondingRecordRequest) return object;
        let message = new $root.ununifi.records.QueryGetEpochUnbondingRecordRequest();
        if (object.epoch_number != null)
          if ($util.Long) (message.epoch_number = $util.Long.fromValue(object.epoch_number)).unsigned = true;
          else if (typeof object.epoch_number === 'string') message.epoch_number = parseInt(object.epoch_number, 10);
          else if (typeof object.epoch_number === 'number') message.epoch_number = object.epoch_number;
          else if (typeof object.epoch_number === 'object')
            message.epoch_number = new $util.LongBits(object.epoch_number.low >>> 0, object.epoch_number.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetEpochUnbondingRecordRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @static
       * @param {ununifi.records.QueryGetEpochUnbondingRecordRequest} message QueryGetEpochUnbondingRecordRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetEpochUnbondingRecordRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.epoch_number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.epoch_number = options.longs === String ? '0' : 0;
        if (message.epoch_number != null && message.hasOwnProperty('epoch_number'))
          if (typeof message.epoch_number === 'number')
            object.epoch_number = options.longs === String ? String(message.epoch_number) : message.epoch_number;
          else
            object.epoch_number =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.epoch_number)
                : options.longs === Number
                ? new $util.LongBits(message.epoch_number.low >>> 0, message.epoch_number.high >>> 0).toNumber(true)
                : message.epoch_number;
        return object;
      };

      /**
       * Converts this QueryGetEpochUnbondingRecordRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetEpochUnbondingRecordRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetEpochUnbondingRecordRequest;
    })();

    records.QueryGetEpochUnbondingRecordResponse = (function () {
      /**
       * Properties of a QueryGetEpochUnbondingRecordResponse.
       * @memberof ununifi.records
       * @interface IQueryGetEpochUnbondingRecordResponse
       * @property {ununifi.records.IEpochUnbondingRecord|null} [epoch_unbonding_record] QueryGetEpochUnbondingRecordResponse epoch_unbonding_record
       */

      /**
       * Constructs a new QueryGetEpochUnbondingRecordResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryGetEpochUnbondingRecordResponse.
       * @implements IQueryGetEpochUnbondingRecordResponse
       * @constructor
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordResponse=} [properties] Properties to set
       */
      function QueryGetEpochUnbondingRecordResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetEpochUnbondingRecordResponse epoch_unbonding_record.
       * @member {ununifi.records.IEpochUnbondingRecord|null|undefined} epoch_unbonding_record
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @instance
       */
      QueryGetEpochUnbondingRecordResponse.prototype.epoch_unbonding_record = null;

      /**
       * Encodes the specified QueryGetEpochUnbondingRecordResponse message. Does not implicitly {@link ununifi.records.QueryGetEpochUnbondingRecordResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @static
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordResponse} message QueryGetEpochUnbondingRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetEpochUnbondingRecordResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.epoch_unbonding_record != null && Object.hasOwnProperty.call(message, 'epoch_unbonding_record'))
          $root.ununifi.records.EpochUnbondingRecord.encode(
            message.epoch_unbonding_record,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetEpochUnbondingRecordResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryGetEpochUnbondingRecordResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @static
       * @param {ununifi.records.IQueryGetEpochUnbondingRecordResponse} message QueryGetEpochUnbondingRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetEpochUnbondingRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetEpochUnbondingRecordResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryGetEpochUnbondingRecordResponse} QueryGetEpochUnbondingRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetEpochUnbondingRecordResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryGetEpochUnbondingRecordResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.epoch_unbonding_record = $root.ununifi.records.EpochUnbondingRecord.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetEpochUnbondingRecordResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryGetEpochUnbondingRecordResponse} QueryGetEpochUnbondingRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetEpochUnbondingRecordResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetEpochUnbondingRecordResponse message.
       * @function verify
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetEpochUnbondingRecordResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.epoch_unbonding_record != null && message.hasOwnProperty('epoch_unbonding_record')) {
          let error = $root.ununifi.records.EpochUnbondingRecord.verify(message.epoch_unbonding_record);
          if (error) return 'epoch_unbonding_record.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetEpochUnbondingRecordResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryGetEpochUnbondingRecordResponse} QueryGetEpochUnbondingRecordResponse
       */
      QueryGetEpochUnbondingRecordResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryGetEpochUnbondingRecordResponse) return object;
        let message = new $root.ununifi.records.QueryGetEpochUnbondingRecordResponse();
        if (object.epoch_unbonding_record != null) {
          if (typeof object.epoch_unbonding_record !== 'object')
            throw TypeError('.ununifi.records.QueryGetEpochUnbondingRecordResponse.epoch_unbonding_record: object expected');
          message.epoch_unbonding_record = $root.ununifi.records.EpochUnbondingRecord.fromObject(object.epoch_unbonding_record);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetEpochUnbondingRecordResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @static
       * @param {ununifi.records.QueryGetEpochUnbondingRecordResponse} message QueryGetEpochUnbondingRecordResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetEpochUnbondingRecordResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.epoch_unbonding_record = null;
        if (message.epoch_unbonding_record != null && message.hasOwnProperty('epoch_unbonding_record'))
          object.epoch_unbonding_record = $root.ununifi.records.EpochUnbondingRecord.toObject(message.epoch_unbonding_record, options);
        return object;
      };

      /**
       * Converts this QueryGetEpochUnbondingRecordResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryGetEpochUnbondingRecordResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetEpochUnbondingRecordResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetEpochUnbondingRecordResponse;
    })();

    records.QueryAllEpochUnbondingRecordRequest = (function () {
      /**
       * Properties of a QueryAllEpochUnbondingRecordRequest.
       * @memberof ununifi.records
       * @interface IQueryAllEpochUnbondingRecordRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllEpochUnbondingRecordRequest pagination
       */

      /**
       * Constructs a new QueryAllEpochUnbondingRecordRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllEpochUnbondingRecordRequest.
       * @implements IQueryAllEpochUnbondingRecordRequest
       * @constructor
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordRequest=} [properties] Properties to set
       */
      function QueryAllEpochUnbondingRecordRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllEpochUnbondingRecordRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @instance
       */
      QueryAllEpochUnbondingRecordRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllEpochUnbondingRecordRequest message. Does not implicitly {@link ununifi.records.QueryAllEpochUnbondingRecordRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @static
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordRequest} message QueryAllEpochUnbondingRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllEpochUnbondingRecordRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllEpochUnbondingRecordRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryAllEpochUnbondingRecordRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @static
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordRequest} message QueryAllEpochUnbondingRecordRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllEpochUnbondingRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllEpochUnbondingRecordRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllEpochUnbondingRecordRequest} QueryAllEpochUnbondingRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllEpochUnbondingRecordRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllEpochUnbondingRecordRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllEpochUnbondingRecordRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllEpochUnbondingRecordRequest} QueryAllEpochUnbondingRecordRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllEpochUnbondingRecordRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllEpochUnbondingRecordRequest message.
       * @function verify
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllEpochUnbondingRecordRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllEpochUnbondingRecordRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllEpochUnbondingRecordRequest} QueryAllEpochUnbondingRecordRequest
       */
      QueryAllEpochUnbondingRecordRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllEpochUnbondingRecordRequest) return object;
        let message = new $root.ununifi.records.QueryAllEpochUnbondingRecordRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllEpochUnbondingRecordRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllEpochUnbondingRecordRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @static
       * @param {ununifi.records.QueryAllEpochUnbondingRecordRequest} message QueryAllEpochUnbondingRecordRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllEpochUnbondingRecordRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllEpochUnbondingRecordRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllEpochUnbondingRecordRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllEpochUnbondingRecordRequest;
    })();

    records.QueryAllEpochUnbondingRecordResponse = (function () {
      /**
       * Properties of a QueryAllEpochUnbondingRecordResponse.
       * @memberof ununifi.records
       * @interface IQueryAllEpochUnbondingRecordResponse
       * @property {Array.<ununifi.records.IEpochUnbondingRecord>|null} [epoch_unbonding_record] QueryAllEpochUnbondingRecordResponse epoch_unbonding_record
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllEpochUnbondingRecordResponse pagination
       */

      /**
       * Constructs a new QueryAllEpochUnbondingRecordResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllEpochUnbondingRecordResponse.
       * @implements IQueryAllEpochUnbondingRecordResponse
       * @constructor
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordResponse=} [properties] Properties to set
       */
      function QueryAllEpochUnbondingRecordResponse(properties) {
        this.epoch_unbonding_record = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllEpochUnbondingRecordResponse epoch_unbonding_record.
       * @member {Array.<ununifi.records.IEpochUnbondingRecord>} epoch_unbonding_record
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @instance
       */
      QueryAllEpochUnbondingRecordResponse.prototype.epoch_unbonding_record = $util.emptyArray;

      /**
       * QueryAllEpochUnbondingRecordResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @instance
       */
      QueryAllEpochUnbondingRecordResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllEpochUnbondingRecordResponse message. Does not implicitly {@link ununifi.records.QueryAllEpochUnbondingRecordResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @static
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordResponse} message QueryAllEpochUnbondingRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllEpochUnbondingRecordResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.epoch_unbonding_record != null && message.epoch_unbonding_record.length)
          for (let i = 0; i < message.epoch_unbonding_record.length; ++i)
            $root.ununifi.records.EpochUnbondingRecord.encode(
              message.epoch_unbonding_record[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllEpochUnbondingRecordResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryAllEpochUnbondingRecordResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @static
       * @param {ununifi.records.IQueryAllEpochUnbondingRecordResponse} message QueryAllEpochUnbondingRecordResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllEpochUnbondingRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllEpochUnbondingRecordResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllEpochUnbondingRecordResponse} QueryAllEpochUnbondingRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllEpochUnbondingRecordResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllEpochUnbondingRecordResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.epoch_unbonding_record && message.epoch_unbonding_record.length)) message.epoch_unbonding_record = [];
              message.epoch_unbonding_record.push($root.ununifi.records.EpochUnbondingRecord.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllEpochUnbondingRecordResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllEpochUnbondingRecordResponse} QueryAllEpochUnbondingRecordResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllEpochUnbondingRecordResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllEpochUnbondingRecordResponse message.
       * @function verify
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllEpochUnbondingRecordResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.epoch_unbonding_record != null && message.hasOwnProperty('epoch_unbonding_record')) {
          if (!Array.isArray(message.epoch_unbonding_record)) return 'epoch_unbonding_record: array expected';
          for (let i = 0; i < message.epoch_unbonding_record.length; ++i) {
            let error = $root.ununifi.records.EpochUnbondingRecord.verify(message.epoch_unbonding_record[i]);
            if (error) return 'epoch_unbonding_record.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllEpochUnbondingRecordResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllEpochUnbondingRecordResponse} QueryAllEpochUnbondingRecordResponse
       */
      QueryAllEpochUnbondingRecordResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllEpochUnbondingRecordResponse) return object;
        let message = new $root.ununifi.records.QueryAllEpochUnbondingRecordResponse();
        if (object.epoch_unbonding_record) {
          if (!Array.isArray(object.epoch_unbonding_record))
            throw TypeError('.ununifi.records.QueryAllEpochUnbondingRecordResponse.epoch_unbonding_record: array expected');
          message.epoch_unbonding_record = [];
          for (let i = 0; i < object.epoch_unbonding_record.length; ++i) {
            if (typeof object.epoch_unbonding_record[i] !== 'object')
              throw TypeError('.ununifi.records.QueryAllEpochUnbondingRecordResponse.epoch_unbonding_record: object expected');
            message.epoch_unbonding_record[i] = $root.ununifi.records.EpochUnbondingRecord.fromObject(object.epoch_unbonding_record[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.records.QueryAllEpochUnbondingRecordResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllEpochUnbondingRecordResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @static
       * @param {ununifi.records.QueryAllEpochUnbondingRecordResponse} message QueryAllEpochUnbondingRecordResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllEpochUnbondingRecordResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.epoch_unbonding_record = [];
        if (options.defaults) object.pagination = null;
        if (message.epoch_unbonding_record && message.epoch_unbonding_record.length) {
          object.epoch_unbonding_record = [];
          for (let j = 0; j < message.epoch_unbonding_record.length; ++j)
            object.epoch_unbonding_record[j] = $root.ununifi.records.EpochUnbondingRecord.toObject(
              message.epoch_unbonding_record[j],
              options,
            );
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllEpochUnbondingRecordResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllEpochUnbondingRecordResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllEpochUnbondingRecordResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllEpochUnbondingRecordResponse;
    })();

    records.QueryAllPendingVaultDepositRequest = (function () {
      /**
       * Properties of a QueryAllPendingVaultDepositRequest.
       * @memberof ununifi.records
       * @interface IQueryAllPendingVaultDepositRequest
       */

      /**
       * Constructs a new QueryAllPendingVaultDepositRequest.
       * @memberof ununifi.records
       * @classdesc Represents a QueryAllPendingVaultDepositRequest.
       * @implements IQueryAllPendingVaultDepositRequest
       * @constructor
       * @param {ununifi.records.IQueryAllPendingVaultDepositRequest=} [properties] Properties to set
       */
      function QueryAllPendingVaultDepositRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryAllPendingVaultDepositRequest message. Does not implicitly {@link ununifi.records.QueryAllPendingVaultDepositRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @static
       * @param {ununifi.records.IQueryAllPendingVaultDepositRequest} message QueryAllPendingVaultDepositRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPendingVaultDepositRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryAllPendingVaultDepositRequest message, length delimited. Does not implicitly {@link ununifi.records.QueryAllPendingVaultDepositRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @static
       * @param {ununifi.records.IQueryAllPendingVaultDepositRequest} message QueryAllPendingVaultDepositRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllPendingVaultDepositRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllPendingVaultDepositRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryAllPendingVaultDepositRequest} QueryAllPendingVaultDepositRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPendingVaultDepositRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryAllPendingVaultDepositRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllPendingVaultDepositRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryAllPendingVaultDepositRequest} QueryAllPendingVaultDepositRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllPendingVaultDepositRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllPendingVaultDepositRequest message.
       * @function verify
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllPendingVaultDepositRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryAllPendingVaultDepositRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryAllPendingVaultDepositRequest} QueryAllPendingVaultDepositRequest
       */
      QueryAllPendingVaultDepositRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryAllPendingVaultDepositRequest) return object;
        return new $root.ununifi.records.QueryAllPendingVaultDepositRequest();
      };

      /**
       * Creates a plain object from a QueryAllPendingVaultDepositRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @static
       * @param {ununifi.records.QueryAllPendingVaultDepositRequest} message QueryAllPendingVaultDepositRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllPendingVaultDepositRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryAllPendingVaultDepositRequest to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryAllPendingVaultDepositRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllPendingVaultDepositRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllPendingVaultDepositRequest;
    })();

    records.QueryPendingVaultDepositResponse = (function () {
      /**
       * Properties of a QueryPendingVaultDepositResponse.
       * @memberof ununifi.records
       * @interface IQueryPendingVaultDepositResponse
       * @property {Array.<ununifi.records.IPendingDeposit>|null} [pending_deposits] QueryPendingVaultDepositResponse pending_deposits
       */

      /**
       * Constructs a new QueryPendingVaultDepositResponse.
       * @memberof ununifi.records
       * @classdesc Represents a QueryPendingVaultDepositResponse.
       * @implements IQueryPendingVaultDepositResponse
       * @constructor
       * @param {ununifi.records.IQueryPendingVaultDepositResponse=} [properties] Properties to set
       */
      function QueryPendingVaultDepositResponse(properties) {
        this.pending_deposits = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryPendingVaultDepositResponse pending_deposits.
       * @member {Array.<ununifi.records.IPendingDeposit>} pending_deposits
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @instance
       */
      QueryPendingVaultDepositResponse.prototype.pending_deposits = $util.emptyArray;

      /**
       * Encodes the specified QueryPendingVaultDepositResponse message. Does not implicitly {@link ununifi.records.QueryPendingVaultDepositResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @static
       * @param {ununifi.records.IQueryPendingVaultDepositResponse} message QueryPendingVaultDepositResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingVaultDepositResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pending_deposits != null && message.pending_deposits.length)
          for (let i = 0; i < message.pending_deposits.length; ++i)
            $root.ununifi.records.PendingDeposit.encode(
              message.pending_deposits[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryPendingVaultDepositResponse message, length delimited. Does not implicitly {@link ununifi.records.QueryPendingVaultDepositResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @static
       * @param {ununifi.records.IQueryPendingVaultDepositResponse} message QueryPendingVaultDepositResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryPendingVaultDepositResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryPendingVaultDepositResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.records.QueryPendingVaultDepositResponse} QueryPendingVaultDepositResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingVaultDepositResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.records.QueryPendingVaultDepositResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.pending_deposits && message.pending_deposits.length)) message.pending_deposits = [];
              message.pending_deposits.push($root.ununifi.records.PendingDeposit.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryPendingVaultDepositResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.records.QueryPendingVaultDepositResponse} QueryPendingVaultDepositResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryPendingVaultDepositResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryPendingVaultDepositResponse message.
       * @function verify
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryPendingVaultDepositResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pending_deposits != null && message.hasOwnProperty('pending_deposits')) {
          if (!Array.isArray(message.pending_deposits)) return 'pending_deposits: array expected';
          for (let i = 0; i < message.pending_deposits.length; ++i) {
            let error = $root.ununifi.records.PendingDeposit.verify(message.pending_deposits[i]);
            if (error) return 'pending_deposits.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryPendingVaultDepositResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.records.QueryPendingVaultDepositResponse} QueryPendingVaultDepositResponse
       */
      QueryPendingVaultDepositResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.records.QueryPendingVaultDepositResponse) return object;
        let message = new $root.ununifi.records.QueryPendingVaultDepositResponse();
        if (object.pending_deposits) {
          if (!Array.isArray(object.pending_deposits))
            throw TypeError('.ununifi.records.QueryPendingVaultDepositResponse.pending_deposits: array expected');
          message.pending_deposits = [];
          for (let i = 0; i < object.pending_deposits.length; ++i) {
            if (typeof object.pending_deposits[i] !== 'object')
              throw TypeError('.ununifi.records.QueryPendingVaultDepositResponse.pending_deposits: object expected');
            message.pending_deposits[i] = $root.ununifi.records.PendingDeposit.fromObject(object.pending_deposits[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryPendingVaultDepositResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @static
       * @param {ununifi.records.QueryPendingVaultDepositResponse} message QueryPendingVaultDepositResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryPendingVaultDepositResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.pending_deposits = [];
        if (message.pending_deposits && message.pending_deposits.length) {
          object.pending_deposits = [];
          for (let j = 0; j < message.pending_deposits.length; ++j)
            object.pending_deposits[j] = $root.ununifi.records.PendingDeposit.toObject(message.pending_deposits[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryPendingVaultDepositResponse to JSON.
       * @function toJSON
       * @memberof ununifi.records.QueryPendingVaultDepositResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryPendingVaultDepositResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryPendingVaultDepositResponse;
    })();

    return records;
  })();

  ununifi.yieldaggregator = (function () {
    /**
     * Namespace yieldaggregator.
     * @memberof ununifi
     * @namespace
     */
    const yieldaggregator = {};

    yieldaggregator.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#depositToVault}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef DepositToVaultCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgDepositToVaultResponse} [response] MsgDepositToVaultResponse
       */

      /**
       * Calls DepositToVault.
       * @function depositToVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgDepositToVault} request MsgDepositToVault message or plain object
       * @param {ununifi.yieldaggregator.Msg.DepositToVaultCallback} callback Node-style callback called with the error, if any, and MsgDepositToVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.depositToVault = function depositToVault(request, callback) {
          return this.rpcCall(
            depositToVault,
            $root.ununifi.yieldaggregator.MsgDepositToVault,
            $root.ununifi.yieldaggregator.MsgDepositToVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DepositToVault' },
      );

      /**
       * Calls DepositToVault.
       * @function depositToVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgDepositToVault} request MsgDepositToVault message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgDepositToVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#withdrawFromVault}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef WithdrawFromVaultCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} [response] MsgWithdrawFromVaultResponse
       */

      /**
       * Calls WithdrawFromVault.
       * @function withdrawFromVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} request MsgWithdrawFromVault message or plain object
       * @param {ununifi.yieldaggregator.Msg.WithdrawFromVaultCallback} callback Node-style callback called with the error, if any, and MsgWithdrawFromVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawFromVault = function withdrawFromVault(request, callback) {
          return this.rpcCall(
            withdrawFromVault,
            $root.ununifi.yieldaggregator.MsgWithdrawFromVault,
            $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawFromVault' },
      );

      /**
       * Calls WithdrawFromVault.
       * @function withdrawFromVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} request MsgWithdrawFromVault message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgWithdrawFromVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#withdrawFromVaultWithUnbondingTime}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef WithdrawFromVaultWithUnbondingTimeCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse} [response] MsgWithdrawFromVaultWithUnbondingTimeResponse
       */

      /**
       * Calls WithdrawFromVaultWithUnbondingTime.
       * @function withdrawFromVaultWithUnbondingTime
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTime} request MsgWithdrawFromVaultWithUnbondingTime message or plain object
       * @param {ununifi.yieldaggregator.Msg.WithdrawFromVaultWithUnbondingTimeCallback} callback Node-style callback called with the error, if any, and MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.withdrawFromVaultWithUnbondingTime = function withdrawFromVaultWithUnbondingTime(request, callback) {
          return this.rpcCall(
            withdrawFromVaultWithUnbondingTime,
            $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime,
            $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'WithdrawFromVaultWithUnbondingTime' },
      );

      /**
       * Calls WithdrawFromVaultWithUnbondingTime.
       * @function withdrawFromVaultWithUnbondingTime
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTime} request MsgWithdrawFromVaultWithUnbondingTime message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#createVault}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef CreateVaultCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgCreateVaultResponse} [response] MsgCreateVaultResponse
       */

      /**
       * Calls CreateVault.
       * @function createVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgCreateVault} request MsgCreateVault message or plain object
       * @param {ununifi.yieldaggregator.Msg.CreateVaultCallback} callback Node-style callback called with the error, if any, and MsgCreateVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.createVault = function createVault(request, callback) {
          return this.rpcCall(
            createVault,
            $root.ununifi.yieldaggregator.MsgCreateVault,
            $root.ununifi.yieldaggregator.MsgCreateVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'CreateVault' },
      );

      /**
       * Calls CreateVault.
       * @function createVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgCreateVault} request MsgCreateVault message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgCreateVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#transferVaultOwnership}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef TransferVaultOwnershipCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} [response] MsgTransferVaultOwnershipResponse
       */

      /**
       * Calls TransferVaultOwnership.
       * @function transferVaultOwnership
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} request MsgTransferVaultOwnership message or plain object
       * @param {ununifi.yieldaggregator.Msg.TransferVaultOwnershipCallback} callback Node-style callback called with the error, if any, and MsgTransferVaultOwnershipResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.transferVaultOwnership = function transferVaultOwnership(request, callback) {
          return this.rpcCall(
            transferVaultOwnership,
            $root.ununifi.yieldaggregator.MsgTransferVaultOwnership,
            $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'TransferVaultOwnership' },
      );

      /**
       * Calls TransferVaultOwnership.
       * @function transferVaultOwnership
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} request MsgTransferVaultOwnership message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#updateParams}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef UpdateParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgUpdateParamsResponse} [response] MsgUpdateParamsResponse
       */

      /**
       * Calls UpdateParams.
       * @function updateParams
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgUpdateParams} request MsgUpdateParams message or plain object
       * @param {ununifi.yieldaggregator.Msg.UpdateParamsCallback} callback Node-style callback called with the error, if any, and MsgUpdateParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateParams = function updateParams(request, callback) {
          return this.rpcCall(
            updateParams,
            $root.ununifi.yieldaggregator.MsgUpdateParams,
            $root.ununifi.yieldaggregator.MsgUpdateParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateParams' },
      );

      /**
       * Calls UpdateParams.
       * @function updateParams
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgUpdateParams} request MsgUpdateParams message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgUpdateParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#registerStrategy}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef RegisterStrategyCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgRegisterStrategyResponse} [response] MsgRegisterStrategyResponse
       */

      /**
       * Calls RegisterStrategy.
       * @function registerStrategy
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} request MsgRegisterStrategy message or plain object
       * @param {ununifi.yieldaggregator.Msg.RegisterStrategyCallback} callback Node-style callback called with the error, if any, and MsgRegisterStrategyResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.registerStrategy = function registerStrategy(request, callback) {
          return this.rpcCall(
            registerStrategy,
            $root.ununifi.yieldaggregator.MsgRegisterStrategy,
            $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RegisterStrategy' },
      );

      /**
       * Calls RegisterStrategy.
       * @function registerStrategy
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} request MsgRegisterStrategy message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgRegisterStrategyResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#deleteVault}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef DeleteVaultCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgDeleteVaultResponse} [response] MsgDeleteVaultResponse
       */

      /**
       * Calls DeleteVault.
       * @function deleteVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgDeleteVault} request MsgDeleteVault message or plain object
       * @param {ununifi.yieldaggregator.Msg.DeleteVaultCallback} callback Node-style callback called with the error, if any, and MsgDeleteVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.deleteVault = function deleteVault(request, callback) {
          return this.rpcCall(
            deleteVault,
            $root.ununifi.yieldaggregator.MsgDeleteVault,
            $root.ununifi.yieldaggregator.MsgDeleteVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DeleteVault' },
      );

      /**
       * Calls DeleteVault.
       * @function deleteVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgDeleteVault} request MsgDeleteVault message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgDeleteVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#updateVault}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef UpdateVaultCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgUpdateVaultResponse} [response] MsgUpdateVaultResponse
       */

      /**
       * Calls UpdateVault.
       * @function updateVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgUpdateVault} request MsgUpdateVault message or plain object
       * @param {ununifi.yieldaggregator.Msg.UpdateVaultCallback} callback Node-style callback called with the error, if any, and MsgUpdateVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateVault = function updateVault(request, callback) {
          return this.rpcCall(
            updateVault,
            $root.ununifi.yieldaggregator.MsgUpdateVault,
            $root.ununifi.yieldaggregator.MsgUpdateVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateVault' },
      );

      /**
       * Calls UpdateVault.
       * @function updateVault
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgUpdateVault} request MsgUpdateVault message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgUpdateVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#updateStrategy}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef UpdateStrategyCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgUpdateStrategyResponse} [response] MsgUpdateStrategyResponse
       */

      /**
       * Calls UpdateStrategy.
       * @function updateStrategy
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategy} request MsgUpdateStrategy message or plain object
       * @param {ununifi.yieldaggregator.Msg.UpdateStrategyCallback} callback Node-style callback called with the error, if any, and MsgUpdateStrategyResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.updateStrategy = function updateStrategy(request, callback) {
          return this.rpcCall(
            updateStrategy,
            $root.ununifi.yieldaggregator.MsgUpdateStrategy,
            $root.ununifi.yieldaggregator.MsgUpdateStrategyResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UpdateStrategy' },
      );

      /**
       * Calls UpdateStrategy.
       * @function updateStrategy
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategy} request MsgUpdateStrategy message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgUpdateStrategyResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#registerDenomInfos}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef RegisterDenomInfosCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgRegisterDenomInfosResponse} [response] MsgRegisterDenomInfosResponse
       */

      /**
       * Calls RegisterDenomInfos.
       * @function registerDenomInfos
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfos} request MsgRegisterDenomInfos message or plain object
       * @param {ununifi.yieldaggregator.Msg.RegisterDenomInfosCallback} callback Node-style callback called with the error, if any, and MsgRegisterDenomInfosResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.registerDenomInfos = function registerDenomInfos(request, callback) {
          return this.rpcCall(
            registerDenomInfos,
            $root.ununifi.yieldaggregator.MsgRegisterDenomInfos,
            $root.ununifi.yieldaggregator.MsgRegisterDenomInfosResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RegisterDenomInfos' },
      );

      /**
       * Calls RegisterDenomInfos.
       * @function registerDenomInfos
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfos} request MsgRegisterDenomInfos message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgRegisterDenomInfosResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#registerSymbolInfos}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef RegisterSymbolInfosCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse} [response] MsgRegisterSymbolInfosResponse
       */

      /**
       * Calls RegisterSymbolInfos.
       * @function registerSymbolInfos
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfos} request MsgRegisterSymbolInfos message or plain object
       * @param {ununifi.yieldaggregator.Msg.RegisterSymbolInfosCallback} callback Node-style callback called with the error, if any, and MsgRegisterSymbolInfosResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.registerSymbolInfos = function registerSymbolInfos(request, callback) {
          return this.rpcCall(
            registerSymbolInfos,
            $root.ununifi.yieldaggregator.MsgRegisterSymbolInfos,
            $root.ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RegisterSymbolInfos' },
      );

      /**
       * Calls RegisterSymbolInfos.
       * @function registerSymbolInfos
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfos} request MsgRegisterSymbolInfos message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#setIntermediaryAccountInfo}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef SetIntermediaryAccountInfoCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse} [response] MsgSetIntermediaryAccountInfoResponse
       */

      /**
       * Calls SetIntermediaryAccountInfo.
       * @function setIntermediaryAccountInfo
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfo} request MsgSetIntermediaryAccountInfo message or plain object
       * @param {ununifi.yieldaggregator.Msg.SetIntermediaryAccountInfoCallback} callback Node-style callback called with the error, if any, and MsgSetIntermediaryAccountInfoResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.setIntermediaryAccountInfo = function setIntermediaryAccountInfo(request, callback) {
          return this.rpcCall(
            setIntermediaryAccountInfo,
            $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo,
            $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'SetIntermediaryAccountInfo' },
      );

      /**
       * Calls SetIntermediaryAccountInfo.
       * @function setIntermediaryAccountInfo
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfo} request MsgSetIntermediaryAccountInfo message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Msg#reinitVaultTransfer}.
       * @memberof ununifi.yieldaggregator.Msg
       * @typedef ReinitVaultTransferCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.MsgReinitVaultTransferResponse} [response] MsgReinitVaultTransferResponse
       */

      /**
       * Calls ReinitVaultTransfer.
       * @function reinitVaultTransfer
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransfer} request MsgReinitVaultTransfer message or plain object
       * @param {ununifi.yieldaggregator.Msg.ReinitVaultTransferCallback} callback Node-style callback called with the error, if any, and MsgReinitVaultTransferResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.reinitVaultTransfer = function reinitVaultTransfer(request, callback) {
          return this.rpcCall(
            reinitVaultTransfer,
            $root.ununifi.yieldaggregator.MsgReinitVaultTransfer,
            $root.ununifi.yieldaggregator.MsgReinitVaultTransferResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'ReinitVaultTransfer' },
      );

      /**
       * Calls ReinitVaultTransfer.
       * @function reinitVaultTransfer
       * @memberof ununifi.yieldaggregator.Msg
       * @instance
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransfer} request MsgReinitVaultTransfer message or plain object
       * @returns {Promise<ununifi.yieldaggregator.MsgReinitVaultTransferResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    yieldaggregator.MsgDepositToVault = (function () {
      /**
       * Properties of a MsgDepositToVault.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgDepositToVault
       * @property {string|null} [sender] MsgDepositToVault sender
       * @property {Long|null} [vault_id] MsgDepositToVault vault_id
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgDepositToVault amount
       */

      /**
       * Constructs a new MsgDepositToVault.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgDepositToVault.
       * @implements IMsgDepositToVault
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgDepositToVault=} [properties] Properties to set
       */
      function MsgDepositToVault(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgDepositToVault sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @instance
       */
      MsgDepositToVault.prototype.sender = '';

      /**
       * MsgDepositToVault vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @instance
       */
      MsgDepositToVault.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgDepositToVault amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @instance
       */
      MsgDepositToVault.prototype.amount = null;

      /**
       * Encodes the specified MsgDepositToVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgDepositToVault} message MsgDepositToVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.vault_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositToVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgDepositToVault} message MsgDepositToVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositToVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgDepositToVault} MsgDepositToVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgDepositToVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.vault_id = reader.uint64();
              break;
            case 3:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositToVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgDepositToVault} MsgDepositToVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositToVault message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositToVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgDepositToVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgDepositToVault} MsgDepositToVault
       */
      MsgDepositToVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgDepositToVault) return object;
        let message = new $root.ununifi.yieldaggregator.MsgDepositToVault();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.yieldaggregator.MsgDepositToVault.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgDepositToVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @static
       * @param {ununifi.yieldaggregator.MsgDepositToVault} message MsgDepositToVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositToVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
          object.amount = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this MsgDepositToVault to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgDepositToVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositToVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositToVault;
    })();

    yieldaggregator.MsgDepositToVaultResponse = (function () {
      /**
       * Properties of a MsgDepositToVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgDepositToVaultResponse
       */

      /**
       * Constructs a new MsgDepositToVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgDepositToVaultResponse.
       * @implements IMsgDepositToVaultResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgDepositToVaultResponse=} [properties] Properties to set
       */
      function MsgDepositToVaultResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgDepositToVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgDepositToVaultResponse} message MsgDepositToVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgDepositToVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDepositToVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgDepositToVaultResponse} message MsgDepositToVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDepositToVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDepositToVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgDepositToVaultResponse} MsgDepositToVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgDepositToVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDepositToVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgDepositToVaultResponse} MsgDepositToVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDepositToVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDepositToVaultResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDepositToVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgDepositToVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgDepositToVaultResponse} MsgDepositToVaultResponse
       */
      MsgDepositToVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgDepositToVaultResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgDepositToVaultResponse();
      };

      /**
       * Creates a plain object from a MsgDepositToVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgDepositToVaultResponse} message MsgDepositToVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDepositToVaultResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgDepositToVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgDepositToVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDepositToVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDepositToVaultResponse;
    })();

    yieldaggregator.MsgWithdrawFromVault = (function () {
      /**
       * Properties of a MsgWithdrawFromVault.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgWithdrawFromVault
       * @property {string|null} [sender] MsgWithdrawFromVault sender
       * @property {Long|null} [vault_id] MsgWithdrawFromVault vault_id
       * @property {string|null} [lp_token_amount] MsgWithdrawFromVault lp_token_amount
       */

      /**
       * Constructs a new MsgWithdrawFromVault.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgWithdrawFromVault.
       * @implements IMsgWithdrawFromVault
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault=} [properties] Properties to set
       */
      function MsgWithdrawFromVault(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawFromVault sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @instance
       */
      MsgWithdrawFromVault.prototype.sender = '';

      /**
       * MsgWithdrawFromVault vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @instance
       */
      MsgWithdrawFromVault.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgWithdrawFromVault lp_token_amount.
       * @member {string} lp_token_amount
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @instance
       */
      MsgWithdrawFromVault.prototype.lp_token_amount = '';

      /**
       * Encodes the specified MsgWithdrawFromVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} message MsgWithdrawFromVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.vault_id);
        if (message.lp_token_amount != null && Object.hasOwnProperty.call(message, 'lp_token_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.lp_token_amount);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVault} message MsgWithdrawFromVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVault} MsgWithdrawFromVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.vault_id = reader.uint64();
              break;
            case 3:
              message.lp_token_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVault} MsgWithdrawFromVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromVault message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        if (message.lp_token_amount != null && message.hasOwnProperty('lp_token_amount'))
          if (!$util.isString(message.lp_token_amount)) return 'lp_token_amount: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVault} MsgWithdrawFromVault
       */
      MsgWithdrawFromVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgWithdrawFromVault) return object;
        let message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVault();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        if (object.lp_token_amount != null) message.lp_token_amount = String(object.lp_token_amount);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawFromVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @static
       * @param {ununifi.yieldaggregator.MsgWithdrawFromVault} message MsgWithdrawFromVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
          object.lp_token_amount = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        if (message.lp_token_amount != null && message.hasOwnProperty('lp_token_amount')) object.lp_token_amount = message.lp_token_amount;
        return object;
      };

      /**
       * Converts this MsgWithdrawFromVault to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromVault;
    })();

    yieldaggregator.MsgWithdrawFromVaultResponse = (function () {
      /**
       * Properties of a MsgWithdrawFromVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgWithdrawFromVaultResponse
       */

      /**
       * Constructs a new MsgWithdrawFromVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgWithdrawFromVaultResponse.
       * @implements IMsgWithdrawFromVaultResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultResponse=} [properties] Properties to set
       */
      function MsgWithdrawFromVaultResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawFromVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultResponse} message MsgWithdrawFromVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultResponse} message MsgWithdrawFromVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} MsgWithdrawFromVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} MsgWithdrawFromVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromVaultResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} MsgWithdrawFromVaultResponse
       */
      MsgWithdrawFromVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawFromVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgWithdrawFromVaultResponse} message MsgWithdrawFromVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromVaultResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawFromVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromVaultResponse;
    })();

    yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime = (function () {
      /**
       * Properties of a MsgWithdrawFromVaultWithUnbondingTime.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgWithdrawFromVaultWithUnbondingTime
       * @property {string|null} [sender] MsgWithdrawFromVaultWithUnbondingTime sender
       * @property {Long|null} [vault_id] MsgWithdrawFromVaultWithUnbondingTime vault_id
       * @property {string|null} [lp_token_amount] MsgWithdrawFromVaultWithUnbondingTime lp_token_amount
       */

      /**
       * Constructs a new MsgWithdrawFromVaultWithUnbondingTime.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgWithdrawFromVaultWithUnbondingTime.
       * @implements IMsgWithdrawFromVaultWithUnbondingTime
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTime=} [properties] Properties to set
       */
      function MsgWithdrawFromVaultWithUnbondingTime(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgWithdrawFromVaultWithUnbondingTime sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @instance
       */
      MsgWithdrawFromVaultWithUnbondingTime.prototype.sender = '';

      /**
       * MsgWithdrawFromVaultWithUnbondingTime vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @instance
       */
      MsgWithdrawFromVaultWithUnbondingTime.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgWithdrawFromVaultWithUnbondingTime lp_token_amount.
       * @member {string} lp_token_amount
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @instance
       */
      MsgWithdrawFromVaultWithUnbondingTime.prototype.lp_token_amount = '';

      /**
       * Encodes the specified MsgWithdrawFromVaultWithUnbondingTime message. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTime} message MsgWithdrawFromVaultWithUnbondingTime message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVaultWithUnbondingTime.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.vault_id);
        if (message.lp_token_amount != null && Object.hasOwnProperty.call(message, 'lp_token_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.lp_token_amount);
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromVaultWithUnbondingTime message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTime} message MsgWithdrawFromVaultWithUnbondingTime message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVaultWithUnbondingTime.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromVaultWithUnbondingTime message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime} MsgWithdrawFromVaultWithUnbondingTime
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVaultWithUnbondingTime.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.vault_id = reader.uint64();
              break;
            case 3:
              message.lp_token_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromVaultWithUnbondingTime message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime} MsgWithdrawFromVaultWithUnbondingTime
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVaultWithUnbondingTime.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromVaultWithUnbondingTime message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromVaultWithUnbondingTime.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        if (message.lp_token_amount != null && message.hasOwnProperty('lp_token_amount'))
          if (!$util.isString(message.lp_token_amount)) return 'lp_token_amount: string expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromVaultWithUnbondingTime message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime} MsgWithdrawFromVaultWithUnbondingTime
       */
      MsgWithdrawFromVaultWithUnbondingTime.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime) return object;
        let message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        if (object.lp_token_amount != null) message.lp_token_amount = String(object.lp_token_amount);
        return message;
      };

      /**
       * Creates a plain object from a MsgWithdrawFromVaultWithUnbondingTime message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @static
       * @param {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime} message MsgWithdrawFromVaultWithUnbondingTime
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromVaultWithUnbondingTime.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
          object.lp_token_amount = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        if (message.lp_token_amount != null && message.hasOwnProperty('lp_token_amount')) object.lp_token_amount = message.lp_token_amount;
        return object;
      };

      /**
       * Converts this MsgWithdrawFromVaultWithUnbondingTime to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTime
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromVaultWithUnbondingTime.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromVaultWithUnbondingTime;
    })();

    yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse = (function () {
      /**
       * Properties of a MsgWithdrawFromVaultWithUnbondingTimeResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgWithdrawFromVaultWithUnbondingTimeResponse
       */

      /**
       * Constructs a new MsgWithdrawFromVaultWithUnbondingTimeResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgWithdrawFromVaultWithUnbondingTimeResponse.
       * @implements IMsgWithdrawFromVaultWithUnbondingTimeResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTimeResponse=} [properties] Properties to set
       */
      function MsgWithdrawFromVaultWithUnbondingTimeResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgWithdrawFromVaultWithUnbondingTimeResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTimeResponse} message MsgWithdrawFromVaultWithUnbondingTimeResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgWithdrawFromVaultWithUnbondingTimeResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgWithdrawFromVaultWithUnbondingTimeResponse} message MsgWithdrawFromVaultWithUnbondingTimeResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgWithdrawFromVaultWithUnbondingTimeResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse} MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgWithdrawFromVaultWithUnbondingTimeResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse} MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgWithdrawFromVaultWithUnbondingTimeResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgWithdrawFromVaultWithUnbondingTimeResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse} MsgWithdrawFromVaultWithUnbondingTimeResponse
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse();
      };

      /**
       * Creates a plain object from a MsgWithdrawFromVaultWithUnbondingTimeResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse} message MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgWithdrawFromVaultWithUnbondingTimeResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgWithdrawFromVaultWithUnbondingTimeResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgWithdrawFromVaultWithUnbondingTimeResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgWithdrawFromVaultWithUnbondingTimeResponse;
    })();

    yieldaggregator.MsgCreateVault = (function () {
      /**
       * Properties of a MsgCreateVault.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgCreateVault
       * @property {string|null} [sender] MsgCreateVault sender
       * @property {string|null} [symbol] MsgCreateVault symbol
       * @property {string|null} [name] MsgCreateVault name
       * @property {string|null} [description] MsgCreateVault description
       * @property {string|null} [commission_rate] MsgCreateVault commission_rate
       * @property {string|null} [withdraw_reserve_rate] MsgCreateVault withdraw_reserve_rate
       * @property {Array.<ununifi.yieldaggregator.IStrategyWeight>|null} [strategy_weights] MsgCreateVault strategy_weights
       * @property {cosmos.base.v1beta1.ICoin|null} [fee] MsgCreateVault fee
       * @property {cosmos.base.v1beta1.ICoin|null} [deposit] MsgCreateVault deposit
       * @property {string|null} [fee_collector_address] MsgCreateVault fee_collector_address
       */

      /**
       * Constructs a new MsgCreateVault.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgCreateVault.
       * @implements IMsgCreateVault
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgCreateVault=} [properties] Properties to set
       */
      function MsgCreateVault(properties) {
        this.strategy_weights = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCreateVault sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.sender = '';

      /**
       * MsgCreateVault symbol.
       * @member {string} symbol
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.symbol = '';

      /**
       * MsgCreateVault name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.name = '';

      /**
       * MsgCreateVault description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.description = '';

      /**
       * MsgCreateVault commission_rate.
       * @member {string} commission_rate
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.commission_rate = '';

      /**
       * MsgCreateVault withdraw_reserve_rate.
       * @member {string} withdraw_reserve_rate
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.withdraw_reserve_rate = '';

      /**
       * MsgCreateVault strategy_weights.
       * @member {Array.<ununifi.yieldaggregator.IStrategyWeight>} strategy_weights
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.strategy_weights = $util.emptyArray;

      /**
       * MsgCreateVault fee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} fee
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.fee = null;

      /**
       * MsgCreateVault deposit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} deposit
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.deposit = null;

      /**
       * MsgCreateVault fee_collector_address.
       * @member {string} fee_collector_address
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       */
      MsgCreateVault.prototype.fee_collector_address = '';

      /**
       * Encodes the specified MsgCreateVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgCreateVault} message MsgCreateVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.symbol);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.description);
        if (message.commission_rate != null && Object.hasOwnProperty.call(message, 'commission_rate'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.commission_rate);
        if (message.withdraw_reserve_rate != null && Object.hasOwnProperty.call(message, 'withdraw_reserve_rate'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.withdraw_reserve_rate);
        if (message.strategy_weights != null && message.strategy_weights.length)
          for (let i = 0; i < message.strategy_weights.length; ++i)
            $root.ununifi.yieldaggregator.StrategyWeight.encode(
              message.strategy_weights[i],
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
        if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
          $root.cosmos.base.v1beta1.Coin.encode(message.fee, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.deposit != null && Object.hasOwnProperty.call(message, 'deposit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.deposit, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, 'fee_collector_address'))
          writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.fee_collector_address);
        return writer;
      };

      /**
       * Encodes the specified MsgCreateVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgCreateVault} message MsgCreateVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgCreateVault} MsgCreateVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgCreateVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.symbol = reader.string();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.description = reader.string();
              break;
            case 5:
              message.commission_rate = reader.string();
              break;
            case 6:
              message.withdraw_reserve_rate = reader.string();
              break;
            case 7:
              if (!(message.strategy_weights && message.strategy_weights.length)) message.strategy_weights = [];
              message.strategy_weights.push($root.ununifi.yieldaggregator.StrategyWeight.decode(reader, reader.uint32()));
              break;
            case 8:
              message.fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 9:
              message.deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 10:
              message.fee_collector_address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgCreateVault} MsgCreateVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateVault message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.commission_rate != null && message.hasOwnProperty('commission_rate'))
          if (!$util.isString(message.commission_rate)) return 'commission_rate: string expected';
        if (message.withdraw_reserve_rate != null && message.hasOwnProperty('withdraw_reserve_rate'))
          if (!$util.isString(message.withdraw_reserve_rate)) return 'withdraw_reserve_rate: string expected';
        if (message.strategy_weights != null && message.hasOwnProperty('strategy_weights')) {
          if (!Array.isArray(message.strategy_weights)) return 'strategy_weights: array expected';
          for (let i = 0; i < message.strategy_weights.length; ++i) {
            let error = $root.ununifi.yieldaggregator.StrategyWeight.verify(message.strategy_weights[i]);
            if (error) return 'strategy_weights.' + error;
          }
        }
        if (message.fee != null && message.hasOwnProperty('fee')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.fee);
          if (error) return 'fee.' + error;
        }
        if (message.deposit != null && message.hasOwnProperty('deposit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.deposit);
          if (error) return 'deposit.' + error;
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          if (!$util.isString(message.fee_collector_address)) return 'fee_collector_address: string expected';
        return null;
      };

      /**
       * Creates a MsgCreateVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgCreateVault} MsgCreateVault
       */
      MsgCreateVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgCreateVault) return object;
        let message = new $root.ununifi.yieldaggregator.MsgCreateVault();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.commission_rate != null) message.commission_rate = String(object.commission_rate);
        if (object.withdraw_reserve_rate != null) message.withdraw_reserve_rate = String(object.withdraw_reserve_rate);
        if (object.strategy_weights) {
          if (!Array.isArray(object.strategy_weights))
            throw TypeError('.ununifi.yieldaggregator.MsgCreateVault.strategy_weights: array expected');
          message.strategy_weights = [];
          for (let i = 0; i < object.strategy_weights.length; ++i) {
            if (typeof object.strategy_weights[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.MsgCreateVault.strategy_weights: object expected');
            message.strategy_weights[i] = $root.ununifi.yieldaggregator.StrategyWeight.fromObject(object.strategy_weights[i]);
          }
        }
        if (object.fee != null) {
          if (typeof object.fee !== 'object') throw TypeError('.ununifi.yieldaggregator.MsgCreateVault.fee: object expected');
          message.fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.fee);
        }
        if (object.deposit != null) {
          if (typeof object.deposit !== 'object') throw TypeError('.ununifi.yieldaggregator.MsgCreateVault.deposit: object expected');
          message.deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.deposit);
        }
        if (object.fee_collector_address != null) message.fee_collector_address = String(object.fee_collector_address);
        return message;
      };

      /**
       * Creates a plain object from a MsgCreateVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @static
       * @param {ununifi.yieldaggregator.MsgCreateVault} message MsgCreateVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.strategy_weights = [];
        if (options.defaults) {
          object.sender = '';
          object.symbol = '';
          object.name = '';
          object.description = '';
          object.commission_rate = '';
          object.withdraw_reserve_rate = '';
          object.fee = null;
          object.deposit = null;
          object.fee_collector_address = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.commission_rate != null && message.hasOwnProperty('commission_rate')) object.commission_rate = message.commission_rate;
        if (message.withdraw_reserve_rate != null && message.hasOwnProperty('withdraw_reserve_rate'))
          object.withdraw_reserve_rate = message.withdraw_reserve_rate;
        if (message.strategy_weights && message.strategy_weights.length) {
          object.strategy_weights = [];
          for (let j = 0; j < message.strategy_weights.length; ++j)
            object.strategy_weights[j] = $root.ununifi.yieldaggregator.StrategyWeight.toObject(message.strategy_weights[j], options);
        }
        if (message.fee != null && message.hasOwnProperty('fee'))
          object.fee = $root.cosmos.base.v1beta1.Coin.toObject(message.fee, options);
        if (message.deposit != null && message.hasOwnProperty('deposit'))
          object.deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.deposit, options);
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          object.fee_collector_address = message.fee_collector_address;
        return object;
      };

      /**
       * Converts this MsgCreateVault to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgCreateVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateVault;
    })();

    yieldaggregator.MsgCreateVaultResponse = (function () {
      /**
       * Properties of a MsgCreateVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgCreateVaultResponse
       * @property {Long|null} [id] MsgCreateVaultResponse id
       */

      /**
       * Constructs a new MsgCreateVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgCreateVaultResponse.
       * @implements IMsgCreateVaultResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgCreateVaultResponse=} [properties] Properties to set
       */
      function MsgCreateVaultResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgCreateVaultResponse id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @instance
       */
      MsgCreateVaultResponse.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified MsgCreateVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgCreateVaultResponse} message MsgCreateVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified MsgCreateVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgCreateVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgCreateVaultResponse} message MsgCreateVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgCreateVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgCreateVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgCreateVaultResponse} MsgCreateVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgCreateVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgCreateVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgCreateVaultResponse} MsgCreateVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgCreateVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgCreateVaultResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgCreateVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a MsgCreateVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgCreateVaultResponse} MsgCreateVaultResponse
       */
      MsgCreateVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgCreateVaultResponse) return object;
        let message = new $root.ununifi.yieldaggregator.MsgCreateVaultResponse();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a MsgCreateVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgCreateVaultResponse} message MsgCreateVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgCreateVaultResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this MsgCreateVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgCreateVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgCreateVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgCreateVaultResponse;
    })();

    yieldaggregator.MsgUpdateVault = (function () {
      /**
       * Properties of a MsgUpdateVault.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgUpdateVault
       * @property {string|null} [sender] MsgUpdateVault sender
       * @property {Long|null} [id] MsgUpdateVault id
       * @property {string|null} [name] MsgUpdateVault name
       * @property {string|null} [description] MsgUpdateVault description
       * @property {string|null} [fee_collector_address] MsgUpdateVault fee_collector_address
       */

      /**
       * Constructs a new MsgUpdateVault.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgUpdateVault.
       * @implements IMsgUpdateVault
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgUpdateVault=} [properties] Properties to set
       */
      function MsgUpdateVault(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateVault sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @instance
       */
      MsgUpdateVault.prototype.sender = '';

      /**
       * MsgUpdateVault id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @instance
       */
      MsgUpdateVault.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgUpdateVault name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @instance
       */
      MsgUpdateVault.prototype.name = '';

      /**
       * MsgUpdateVault description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @instance
       */
      MsgUpdateVault.prototype.description = '';

      /**
       * MsgUpdateVault fee_collector_address.
       * @member {string} fee_collector_address
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @instance
       */
      MsgUpdateVault.prototype.fee_collector_address = '';

      /**
       * Encodes the specified MsgUpdateVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateVault} message MsgUpdateVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.description);
        if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, 'fee_collector_address'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fee_collector_address);
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateVault} message MsgUpdateVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgUpdateVault} MsgUpdateVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgUpdateVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.id = reader.uint64();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.description = reader.string();
              break;
            case 5:
              message.fee_collector_address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgUpdateVault} MsgUpdateVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateVault message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          if (!$util.isString(message.fee_collector_address)) return 'fee_collector_address: string expected';
        return null;
      };

      /**
       * Creates a MsgUpdateVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgUpdateVault} MsgUpdateVault
       */
      MsgUpdateVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateVault) return object;
        let message = new $root.ununifi.yieldaggregator.MsgUpdateVault();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.fee_collector_address != null) message.fee_collector_address = String(object.fee_collector_address);
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @static
       * @param {ununifi.yieldaggregator.MsgUpdateVault} message MsgUpdateVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.name = '';
          object.description = '';
          object.fee_collector_address = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          object.fee_collector_address = message.fee_collector_address;
        return object;
      };

      /**
       * Converts this MsgUpdateVault to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgUpdateVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateVault;
    })();

    yieldaggregator.MsgUpdateVaultResponse = (function () {
      /**
       * Properties of a MsgUpdateVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgUpdateVaultResponse
       */

      /**
       * Constructs a new MsgUpdateVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgUpdateVaultResponse.
       * @implements IMsgUpdateVaultResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgUpdateVaultResponse=} [properties] Properties to set
       */
      function MsgUpdateVaultResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateVaultResponse} message MsgUpdateVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateVaultResponse} message MsgUpdateVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgUpdateVaultResponse} MsgUpdateVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgUpdateVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgUpdateVaultResponse} MsgUpdateVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateVaultResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgUpdateVaultResponse} MsgUpdateVaultResponse
       */
      MsgUpdateVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateVaultResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgUpdateVaultResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgUpdateVaultResponse} message MsgUpdateVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateVaultResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgUpdateVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateVaultResponse;
    })();

    yieldaggregator.MsgTransferVaultOwnership = (function () {
      /**
       * Properties of a MsgTransferVaultOwnership.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgTransferVaultOwnership
       * @property {string|null} [sender] MsgTransferVaultOwnership sender
       * @property {Long|null} [vault_id] MsgTransferVaultOwnership vault_id
       * @property {string|null} [recipient] MsgTransferVaultOwnership recipient
       */

      /**
       * Constructs a new MsgTransferVaultOwnership.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgTransferVaultOwnership.
       * @implements IMsgTransferVaultOwnership
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership=} [properties] Properties to set
       */
      function MsgTransferVaultOwnership(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgTransferVaultOwnership sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @instance
       */
      MsgTransferVaultOwnership.prototype.sender = '';

      /**
       * MsgTransferVaultOwnership vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @instance
       */
      MsgTransferVaultOwnership.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgTransferVaultOwnership recipient.
       * @member {string} recipient
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @instance
       */
      MsgTransferVaultOwnership.prototype.recipient = '';

      /**
       * Encodes the specified MsgTransferVaultOwnership message. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnership.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @static
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} message MsgTransferVaultOwnership message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgTransferVaultOwnership.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.vault_id);
        if (message.recipient != null && Object.hasOwnProperty.call(message, 'recipient'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.recipient);
        return writer;
      };

      /**
       * Encodes the specified MsgTransferVaultOwnership message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnership.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @static
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnership} message MsgTransferVaultOwnership message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgTransferVaultOwnership.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgTransferVaultOwnership message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnership} MsgTransferVaultOwnership
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgTransferVaultOwnership.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgTransferVaultOwnership();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.vault_id = reader.uint64();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgTransferVaultOwnership message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnership} MsgTransferVaultOwnership
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgTransferVaultOwnership.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgTransferVaultOwnership message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgTransferVaultOwnership.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        if (message.recipient != null && message.hasOwnProperty('recipient'))
          if (!$util.isString(message.recipient)) return 'recipient: string expected';
        return null;
      };

      /**
       * Creates a MsgTransferVaultOwnership message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnership} MsgTransferVaultOwnership
       */
      MsgTransferVaultOwnership.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgTransferVaultOwnership) return object;
        let message = new $root.ununifi.yieldaggregator.MsgTransferVaultOwnership();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        if (object.recipient != null) message.recipient = String(object.recipient);
        return message;
      };

      /**
       * Creates a plain object from a MsgTransferVaultOwnership message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @static
       * @param {ununifi.yieldaggregator.MsgTransferVaultOwnership} message MsgTransferVaultOwnership
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgTransferVaultOwnership.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
          object.recipient = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        if (message.recipient != null && message.hasOwnProperty('recipient')) object.recipient = message.recipient;
        return object;
      };

      /**
       * Converts this MsgTransferVaultOwnership to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnership
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgTransferVaultOwnership.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgTransferVaultOwnership;
    })();

    yieldaggregator.MsgTransferVaultOwnershipResponse = (function () {
      /**
       * Properties of a MsgTransferVaultOwnershipResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgTransferVaultOwnershipResponse
       */

      /**
       * Constructs a new MsgTransferVaultOwnershipResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgTransferVaultOwnershipResponse.
       * @implements IMsgTransferVaultOwnershipResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnershipResponse=} [properties] Properties to set
       */
      function MsgTransferVaultOwnershipResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgTransferVaultOwnershipResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnershipResponse} message MsgTransferVaultOwnershipResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgTransferVaultOwnershipResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgTransferVaultOwnershipResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgTransferVaultOwnershipResponse} message MsgTransferVaultOwnershipResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgTransferVaultOwnershipResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgTransferVaultOwnershipResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} MsgTransferVaultOwnershipResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgTransferVaultOwnershipResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgTransferVaultOwnershipResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} MsgTransferVaultOwnershipResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgTransferVaultOwnershipResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgTransferVaultOwnershipResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgTransferVaultOwnershipResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgTransferVaultOwnershipResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} MsgTransferVaultOwnershipResponse
       */
      MsgTransferVaultOwnershipResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse();
      };

      /**
       * Creates a plain object from a MsgTransferVaultOwnershipResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse} message MsgTransferVaultOwnershipResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgTransferVaultOwnershipResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgTransferVaultOwnershipResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgTransferVaultOwnershipResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgTransferVaultOwnershipResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgTransferVaultOwnershipResponse;
    })();

    yieldaggregator.MsgUpdateParams = (function () {
      /**
       * Properties of a MsgUpdateParams.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgUpdateParams
       * @property {string|null} [sender] MsgUpdateParams sender
       * @property {ununifi.yieldaggregator.IParams|null} [params] MsgUpdateParams params
       */

      /**
       * Constructs a new MsgUpdateParams.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgUpdateParams.
       * @implements IMsgUpdateParams
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgUpdateParams=} [properties] Properties to set
       */
      function MsgUpdateParams(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateParams sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @instance
       */
      MsgUpdateParams.prototype.sender = '';

      /**
       * MsgUpdateParams params.
       * @member {ununifi.yieldaggregator.IParams|null|undefined} params
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @instance
       */
      MsgUpdateParams.prototype.params = null;

      /**
       * Encodes the specified MsgUpdateParams message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParams.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParams.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.yieldaggregator.Params.encode(message.params, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateParams message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParams.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateParams} message MsgUpdateParams message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParams.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateParams message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgUpdateParams} MsgUpdateParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParams.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgUpdateParams();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.params = $root.ununifi.yieldaggregator.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateParams message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgUpdateParams} MsgUpdateParams
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParams.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateParams message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateParams.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.yieldaggregator.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgUpdateParams message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgUpdateParams} MsgUpdateParams
       */
      MsgUpdateParams.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateParams) return object;
        let message = new $root.ununifi.yieldaggregator.MsgUpdateParams();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.yieldaggregator.MsgUpdateParams.params: object expected');
          message.params = $root.ununifi.yieldaggregator.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateParams message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @static
       * @param {ununifi.yieldaggregator.MsgUpdateParams} message MsgUpdateParams
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateParams.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.params = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.yieldaggregator.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this MsgUpdateParams to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgUpdateParams
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateParams.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateParams;
    })();

    yieldaggregator.MsgUpdateParamsResponse = (function () {
      /**
       * Properties of a MsgUpdateParamsResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgUpdateParamsResponse
       */

      /**
       * Constructs a new MsgUpdateParamsResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgUpdateParamsResponse.
       * @implements IMsgUpdateParamsResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgUpdateParamsResponse=} [properties] Properties to set
       */
      function MsgUpdateParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateParamsResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateParamsResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateParamsResponse} message MsgUpdateParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgUpdateParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateParamsResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgUpdateParamsResponse} MsgUpdateParamsResponse
       */
      MsgUpdateParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateParamsResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgUpdateParamsResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgUpdateParamsResponse} message MsgUpdateParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateParamsResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgUpdateParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateParamsResponse;
    })();

    yieldaggregator.MsgRegisterStrategy = (function () {
      /**
       * Properties of a MsgRegisterStrategy.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgRegisterStrategy
       * @property {string|null} [sender] MsgRegisterStrategy sender
       * @property {string|null} [denom] MsgRegisterStrategy denom
       * @property {string|null} [contract_address] MsgRegisterStrategy contract_address
       * @property {string|null} [name] MsgRegisterStrategy name
       * @property {string|null} [description] MsgRegisterStrategy description
       * @property {string|null} [git_url] MsgRegisterStrategy git_url
       */

      /**
       * Constructs a new MsgRegisterStrategy.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgRegisterStrategy.
       * @implements IMsgRegisterStrategy
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategy=} [properties] Properties to set
       */
      function MsgRegisterStrategy(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRegisterStrategy sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @instance
       */
      MsgRegisterStrategy.prototype.sender = '';

      /**
       * MsgRegisterStrategy denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @instance
       */
      MsgRegisterStrategy.prototype.denom = '';

      /**
       * MsgRegisterStrategy contract_address.
       * @member {string} contract_address
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @instance
       */
      MsgRegisterStrategy.prototype.contract_address = '';

      /**
       * MsgRegisterStrategy name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @instance
       */
      MsgRegisterStrategy.prototype.name = '';

      /**
       * MsgRegisterStrategy description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @instance
       */
      MsgRegisterStrategy.prototype.description = '';

      /**
       * MsgRegisterStrategy git_url.
       * @member {string} git_url
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @instance
       */
      MsgRegisterStrategy.prototype.git_url = '';

      /**
       * Encodes the specified MsgRegisterStrategy message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategy.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} message MsgRegisterStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterStrategy.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        if (message.contract_address != null && Object.hasOwnProperty.call(message, 'contract_address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.contract_address);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.description);
        if (message.git_url != null && Object.hasOwnProperty.call(message, 'git_url'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.git_url);
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterStrategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategy.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategy} message MsgRegisterStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterStrategy.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterStrategy message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgRegisterStrategy} MsgRegisterStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterStrategy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgRegisterStrategy();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            case 3:
              message.contract_address = reader.string();
              break;
            case 4:
              message.name = reader.string();
              break;
            case 5:
              message.description = reader.string();
              break;
            case 6:
              message.git_url = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterStrategy message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgRegisterStrategy} MsgRegisterStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterStrategy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterStrategy message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterStrategy.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          if (!$util.isString(message.contract_address)) return 'contract_address: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.git_url != null && message.hasOwnProperty('git_url'))
          if (!$util.isString(message.git_url)) return 'git_url: string expected';
        return null;
      };

      /**
       * Creates a MsgRegisterStrategy message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgRegisterStrategy} MsgRegisterStrategy
       */
      MsgRegisterStrategy.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterStrategy) return object;
        let message = new $root.ununifi.yieldaggregator.MsgRegisterStrategy();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.contract_address != null) message.contract_address = String(object.contract_address);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.git_url != null) message.git_url = String(object.git_url);
        return message;
      };

      /**
       * Creates a plain object from a MsgRegisterStrategy message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @static
       * @param {ununifi.yieldaggregator.MsgRegisterStrategy} message MsgRegisterStrategy
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterStrategy.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.denom = '';
          object.contract_address = '';
          object.name = '';
          object.description = '';
          object.git_url = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          object.contract_address = message.contract_address;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.git_url != null && message.hasOwnProperty('git_url')) object.git_url = message.git_url;
        return object;
      };

      /**
       * Converts this MsgRegisterStrategy to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategy
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterStrategy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterStrategy;
    })();

    yieldaggregator.MsgRegisterStrategyResponse = (function () {
      /**
       * Properties of a MsgRegisterStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgRegisterStrategyResponse
       */

      /**
       * Constructs a new MsgRegisterStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgRegisterStrategyResponse.
       * @implements IMsgRegisterStrategyResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategyResponse=} [properties] Properties to set
       */
      function MsgRegisterStrategyResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRegisterStrategyResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategyResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategyResponse} message MsgRegisterStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterStrategyResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterStrategyResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterStrategyResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterStrategyResponse} message MsgRegisterStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterStrategyResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterStrategyResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgRegisterStrategyResponse} MsgRegisterStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterStrategyResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterStrategyResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgRegisterStrategyResponse} MsgRegisterStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterStrategyResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterStrategyResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterStrategyResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRegisterStrategyResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgRegisterStrategyResponse} MsgRegisterStrategyResponse
       */
      MsgRegisterStrategyResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgRegisterStrategyResponse();
      };

      /**
       * Creates a plain object from a MsgRegisterStrategyResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgRegisterStrategyResponse} message MsgRegisterStrategyResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterStrategyResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRegisterStrategyResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgRegisterStrategyResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterStrategyResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterStrategyResponse;
    })();

    yieldaggregator.MsgUpdateStrategy = (function () {
      /**
       * Properties of a MsgUpdateStrategy.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgUpdateStrategy
       * @property {string|null} [sender] MsgUpdateStrategy sender
       * @property {string|null} [denom] MsgUpdateStrategy denom
       * @property {Long|null} [id] MsgUpdateStrategy id
       * @property {string|null} [name] MsgUpdateStrategy name
       * @property {string|null} [description] MsgUpdateStrategy description
       * @property {string|null} [git_url] MsgUpdateStrategy git_url
       */

      /**
       * Constructs a new MsgUpdateStrategy.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgUpdateStrategy.
       * @implements IMsgUpdateStrategy
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategy=} [properties] Properties to set
       */
      function MsgUpdateStrategy(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUpdateStrategy sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @instance
       */
      MsgUpdateStrategy.prototype.sender = '';

      /**
       * MsgUpdateStrategy denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @instance
       */
      MsgUpdateStrategy.prototype.denom = '';

      /**
       * MsgUpdateStrategy id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @instance
       */
      MsgUpdateStrategy.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgUpdateStrategy name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @instance
       */
      MsgUpdateStrategy.prototype.name = '';

      /**
       * MsgUpdateStrategy description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @instance
       */
      MsgUpdateStrategy.prototype.description = '';

      /**
       * MsgUpdateStrategy git_url.
       * @member {string} git_url
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @instance
       */
      MsgUpdateStrategy.prototype.git_url = '';

      /**
       * Encodes the specified MsgUpdateStrategy message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateStrategy.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategy} message MsgUpdateStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateStrategy.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.description);
        if (message.git_url != null && Object.hasOwnProperty.call(message, 'git_url'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.git_url);
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateStrategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateStrategy.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategy} message MsgUpdateStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateStrategy.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateStrategy message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgUpdateStrategy} MsgUpdateStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateStrategy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgUpdateStrategy();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            case 3:
              message.id = reader.uint64();
              break;
            case 4:
              message.name = reader.string();
              break;
            case 5:
              message.description = reader.string();
              break;
            case 6:
              message.git_url = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateStrategy message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgUpdateStrategy} MsgUpdateStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateStrategy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateStrategy message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateStrategy.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.git_url != null && message.hasOwnProperty('git_url'))
          if (!$util.isString(message.git_url)) return 'git_url: string expected';
        return null;
      };

      /**
       * Creates a MsgUpdateStrategy message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgUpdateStrategy} MsgUpdateStrategy
       */
      MsgUpdateStrategy.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateStrategy) return object;
        let message = new $root.ununifi.yieldaggregator.MsgUpdateStrategy();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.git_url != null) message.git_url = String(object.git_url);
        return message;
      };

      /**
       * Creates a plain object from a MsgUpdateStrategy message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @static
       * @param {ununifi.yieldaggregator.MsgUpdateStrategy} message MsgUpdateStrategy
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateStrategy.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.denom = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.name = '';
          object.description = '';
          object.git_url = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.git_url != null && message.hasOwnProperty('git_url')) object.git_url = message.git_url;
        return object;
      };

      /**
       * Converts this MsgUpdateStrategy to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategy
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateStrategy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateStrategy;
    })();

    yieldaggregator.MsgUpdateStrategyResponse = (function () {
      /**
       * Properties of a MsgUpdateStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgUpdateStrategyResponse
       */

      /**
       * Constructs a new MsgUpdateStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgUpdateStrategyResponse.
       * @implements IMsgUpdateStrategyResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategyResponse=} [properties] Properties to set
       */
      function MsgUpdateStrategyResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUpdateStrategyResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateStrategyResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategyResponse} message MsgUpdateStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateStrategyResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUpdateStrategyResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgUpdateStrategyResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgUpdateStrategyResponse} message MsgUpdateStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUpdateStrategyResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUpdateStrategyResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgUpdateStrategyResponse} MsgUpdateStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateStrategyResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgUpdateStrategyResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUpdateStrategyResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgUpdateStrategyResponse} MsgUpdateStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUpdateStrategyResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUpdateStrategyResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUpdateStrategyResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUpdateStrategyResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgUpdateStrategyResponse} MsgUpdateStrategyResponse
       */
      MsgUpdateStrategyResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgUpdateStrategyResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgUpdateStrategyResponse();
      };

      /**
       * Creates a plain object from a MsgUpdateStrategyResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgUpdateStrategyResponse} message MsgUpdateStrategyResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUpdateStrategyResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUpdateStrategyResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgUpdateStrategyResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUpdateStrategyResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUpdateStrategyResponse;
    })();

    yieldaggregator.MsgDeleteVault = (function () {
      /**
       * Properties of a MsgDeleteVault.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgDeleteVault
       * @property {string|null} [sender] MsgDeleteVault sender
       * @property {Long|null} [vault_id] MsgDeleteVault vault_id
       */

      /**
       * Constructs a new MsgDeleteVault.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgDeleteVault.
       * @implements IMsgDeleteVault
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgDeleteVault=} [properties] Properties to set
       */
      function MsgDeleteVault(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgDeleteVault sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @instance
       */
      MsgDeleteVault.prototype.sender = '';

      /**
       * MsgDeleteVault vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @instance
       */
      MsgDeleteVault.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified MsgDeleteVault message. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgDeleteVault} message MsgDeleteVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDeleteVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.vault_id);
        return writer;
      };

      /**
       * Encodes the specified MsgDeleteVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @static
       * @param {ununifi.yieldaggregator.IMsgDeleteVault} message MsgDeleteVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDeleteVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDeleteVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgDeleteVault} MsgDeleteVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDeleteVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgDeleteVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.vault_id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDeleteVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgDeleteVault} MsgDeleteVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDeleteVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDeleteVault message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDeleteVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        return null;
      };

      /**
       * Creates a MsgDeleteVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgDeleteVault} MsgDeleteVault
       */
      MsgDeleteVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgDeleteVault) return object;
        let message = new $root.ununifi.yieldaggregator.MsgDeleteVault();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a MsgDeleteVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @static
       * @param {ununifi.yieldaggregator.MsgDeleteVault} message MsgDeleteVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDeleteVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        return object;
      };

      /**
       * Converts this MsgDeleteVault to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgDeleteVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDeleteVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDeleteVault;
    })();

    yieldaggregator.MsgDeleteVaultResponse = (function () {
      /**
       * Properties of a MsgDeleteVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgDeleteVaultResponse
       */

      /**
       * Constructs a new MsgDeleteVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgDeleteVaultResponse.
       * @implements IMsgDeleteVaultResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgDeleteVaultResponse=} [properties] Properties to set
       */
      function MsgDeleteVaultResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgDeleteVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgDeleteVaultResponse} message MsgDeleteVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDeleteVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgDeleteVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgDeleteVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgDeleteVaultResponse} message MsgDeleteVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgDeleteVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgDeleteVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgDeleteVaultResponse} MsgDeleteVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDeleteVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgDeleteVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgDeleteVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgDeleteVaultResponse} MsgDeleteVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgDeleteVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgDeleteVaultResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgDeleteVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgDeleteVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgDeleteVaultResponse} MsgDeleteVaultResponse
       */
      MsgDeleteVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgDeleteVaultResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgDeleteVaultResponse();
      };

      /**
       * Creates a plain object from a MsgDeleteVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgDeleteVaultResponse} message MsgDeleteVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgDeleteVaultResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgDeleteVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgDeleteVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgDeleteVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgDeleteVaultResponse;
    })();

    yieldaggregator.MsgRegisterDenomInfos = (function () {
      /**
       * Properties of a MsgRegisterDenomInfos.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgRegisterDenomInfos
       * @property {string|null} [sender] MsgRegisterDenomInfos sender
       * @property {Array.<ununifi.yieldaggregator.IDenomInfo>|null} [info] MsgRegisterDenomInfos info
       */

      /**
       * Constructs a new MsgRegisterDenomInfos.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgRegisterDenomInfos.
       * @implements IMsgRegisterDenomInfos
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfos=} [properties] Properties to set
       */
      function MsgRegisterDenomInfos(properties) {
        this.info = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRegisterDenomInfos sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @instance
       */
      MsgRegisterDenomInfos.prototype.sender = '';

      /**
       * MsgRegisterDenomInfos info.
       * @member {Array.<ununifi.yieldaggregator.IDenomInfo>} info
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @instance
       */
      MsgRegisterDenomInfos.prototype.info = $util.emptyArray;

      /**
       * Encodes the specified MsgRegisterDenomInfos message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterDenomInfos.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfos} message MsgRegisterDenomInfos message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterDenomInfos.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.info != null && message.info.length)
          for (let i = 0; i < message.info.length; ++i)
            $root.ununifi.yieldaggregator.DenomInfo.encode(message.info[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterDenomInfos message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterDenomInfos.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfos} message MsgRegisterDenomInfos message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterDenomInfos.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterDenomInfos message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgRegisterDenomInfos} MsgRegisterDenomInfos
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterDenomInfos.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgRegisterDenomInfos();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              if (!(message.info && message.info.length)) message.info = [];
              message.info.push($root.ununifi.yieldaggregator.DenomInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterDenomInfos message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgRegisterDenomInfos} MsgRegisterDenomInfos
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterDenomInfos.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterDenomInfos message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterDenomInfos.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.info != null && message.hasOwnProperty('info')) {
          if (!Array.isArray(message.info)) return 'info: array expected';
          for (let i = 0; i < message.info.length; ++i) {
            let error = $root.ununifi.yieldaggregator.DenomInfo.verify(message.info[i]);
            if (error) return 'info.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgRegisterDenomInfos message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgRegisterDenomInfos} MsgRegisterDenomInfos
       */
      MsgRegisterDenomInfos.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterDenomInfos) return object;
        let message = new $root.ununifi.yieldaggregator.MsgRegisterDenomInfos();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.info) {
          if (!Array.isArray(object.info)) throw TypeError('.ununifi.yieldaggregator.MsgRegisterDenomInfos.info: array expected');
          message.info = [];
          for (let i = 0; i < object.info.length; ++i) {
            if (typeof object.info[i] !== 'object') throw TypeError('.ununifi.yieldaggregator.MsgRegisterDenomInfos.info: object expected');
            message.info[i] = $root.ununifi.yieldaggregator.DenomInfo.fromObject(object.info[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgRegisterDenomInfos message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @static
       * @param {ununifi.yieldaggregator.MsgRegisterDenomInfos} message MsgRegisterDenomInfos
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterDenomInfos.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.info = [];
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.info && message.info.length) {
          object.info = [];
          for (let j = 0; j < message.info.length; ++j)
            object.info[j] = $root.ununifi.yieldaggregator.DenomInfo.toObject(message.info[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgRegisterDenomInfos to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfos
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterDenomInfos.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterDenomInfos;
    })();

    yieldaggregator.MsgRegisterDenomInfosResponse = (function () {
      /**
       * Properties of a MsgRegisterDenomInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgRegisterDenomInfosResponse
       */

      /**
       * Constructs a new MsgRegisterDenomInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgRegisterDenomInfosResponse.
       * @implements IMsgRegisterDenomInfosResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfosResponse=} [properties] Properties to set
       */
      function MsgRegisterDenomInfosResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRegisterDenomInfosResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterDenomInfosResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfosResponse} message MsgRegisterDenomInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterDenomInfosResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterDenomInfosResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterDenomInfosResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterDenomInfosResponse} message MsgRegisterDenomInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterDenomInfosResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterDenomInfosResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgRegisterDenomInfosResponse} MsgRegisterDenomInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterDenomInfosResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgRegisterDenomInfosResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterDenomInfosResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgRegisterDenomInfosResponse} MsgRegisterDenomInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterDenomInfosResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterDenomInfosResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterDenomInfosResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRegisterDenomInfosResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgRegisterDenomInfosResponse} MsgRegisterDenomInfosResponse
       */
      MsgRegisterDenomInfosResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterDenomInfosResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgRegisterDenomInfosResponse();
      };

      /**
       * Creates a plain object from a MsgRegisterDenomInfosResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgRegisterDenomInfosResponse} message MsgRegisterDenomInfosResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterDenomInfosResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRegisterDenomInfosResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgRegisterDenomInfosResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterDenomInfosResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterDenomInfosResponse;
    })();

    yieldaggregator.MsgRegisterSymbolInfos = (function () {
      /**
       * Properties of a MsgRegisterSymbolInfos.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgRegisterSymbolInfos
       * @property {string|null} [sender] MsgRegisterSymbolInfos sender
       * @property {Array.<ununifi.yieldaggregator.ISymbolInfo>|null} [info] MsgRegisterSymbolInfos info
       */

      /**
       * Constructs a new MsgRegisterSymbolInfos.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgRegisterSymbolInfos.
       * @implements IMsgRegisterSymbolInfos
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfos=} [properties] Properties to set
       */
      function MsgRegisterSymbolInfos(properties) {
        this.info = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRegisterSymbolInfos sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @instance
       */
      MsgRegisterSymbolInfos.prototype.sender = '';

      /**
       * MsgRegisterSymbolInfos info.
       * @member {Array.<ununifi.yieldaggregator.ISymbolInfo>} info
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @instance
       */
      MsgRegisterSymbolInfos.prototype.info = $util.emptyArray;

      /**
       * Encodes the specified MsgRegisterSymbolInfos message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterSymbolInfos.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfos} message MsgRegisterSymbolInfos message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterSymbolInfos.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.info != null && message.info.length)
          for (let i = 0; i < message.info.length; ++i)
            $root.ununifi.yieldaggregator.SymbolInfo.encode(message.info[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterSymbolInfos message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterSymbolInfos.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfos} message MsgRegisterSymbolInfos message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterSymbolInfos.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterSymbolInfos message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgRegisterSymbolInfos} MsgRegisterSymbolInfos
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterSymbolInfos.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgRegisterSymbolInfos();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              if (!(message.info && message.info.length)) message.info = [];
              message.info.push($root.ununifi.yieldaggregator.SymbolInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterSymbolInfos message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgRegisterSymbolInfos} MsgRegisterSymbolInfos
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterSymbolInfos.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterSymbolInfos message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterSymbolInfos.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.info != null && message.hasOwnProperty('info')) {
          if (!Array.isArray(message.info)) return 'info: array expected';
          for (let i = 0; i < message.info.length; ++i) {
            let error = $root.ununifi.yieldaggregator.SymbolInfo.verify(message.info[i]);
            if (error) return 'info.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgRegisterSymbolInfos message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgRegisterSymbolInfos} MsgRegisterSymbolInfos
       */
      MsgRegisterSymbolInfos.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterSymbolInfos) return object;
        let message = new $root.ununifi.yieldaggregator.MsgRegisterSymbolInfos();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.info) {
          if (!Array.isArray(object.info)) throw TypeError('.ununifi.yieldaggregator.MsgRegisterSymbolInfos.info: array expected');
          message.info = [];
          for (let i = 0; i < object.info.length; ++i) {
            if (typeof object.info[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.MsgRegisterSymbolInfos.info: object expected');
            message.info[i] = $root.ununifi.yieldaggregator.SymbolInfo.fromObject(object.info[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgRegisterSymbolInfos message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @static
       * @param {ununifi.yieldaggregator.MsgRegisterSymbolInfos} message MsgRegisterSymbolInfos
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterSymbolInfos.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.info = [];
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.info && message.info.length) {
          object.info = [];
          for (let j = 0; j < message.info.length; ++j)
            object.info[j] = $root.ununifi.yieldaggregator.SymbolInfo.toObject(message.info[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgRegisterSymbolInfos to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfos
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterSymbolInfos.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterSymbolInfos;
    })();

    yieldaggregator.MsgRegisterSymbolInfosResponse = (function () {
      /**
       * Properties of a MsgRegisterSymbolInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgRegisterSymbolInfosResponse
       */

      /**
       * Constructs a new MsgRegisterSymbolInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgRegisterSymbolInfosResponse.
       * @implements IMsgRegisterSymbolInfosResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfosResponse=} [properties] Properties to set
       */
      function MsgRegisterSymbolInfosResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgRegisterSymbolInfosResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfosResponse} message MsgRegisterSymbolInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterSymbolInfosResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterSymbolInfosResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgRegisterSymbolInfosResponse} message MsgRegisterSymbolInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterSymbolInfosResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterSymbolInfosResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse} MsgRegisterSymbolInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterSymbolInfosResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterSymbolInfosResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse} MsgRegisterSymbolInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterSymbolInfosResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterSymbolInfosResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterSymbolInfosResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgRegisterSymbolInfosResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse} MsgRegisterSymbolInfosResponse
       */
      MsgRegisterSymbolInfosResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse();
      };

      /**
       * Creates a plain object from a MsgRegisterSymbolInfosResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse} message MsgRegisterSymbolInfosResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterSymbolInfosResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgRegisterSymbolInfosResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgRegisterSymbolInfosResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterSymbolInfosResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterSymbolInfosResponse;
    })();

    yieldaggregator.MsgSetIntermediaryAccountInfo = (function () {
      /**
       * Properties of a MsgSetIntermediaryAccountInfo.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgSetIntermediaryAccountInfo
       * @property {string|null} [sender] MsgSetIntermediaryAccountInfo sender
       * @property {Array.<ununifi.yieldaggregator.IChainAddress>|null} [addrs] MsgSetIntermediaryAccountInfo addrs
       */

      /**
       * Constructs a new MsgSetIntermediaryAccountInfo.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgSetIntermediaryAccountInfo.
       * @implements IMsgSetIntermediaryAccountInfo
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfo=} [properties] Properties to set
       */
      function MsgSetIntermediaryAccountInfo(properties) {
        this.addrs = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgSetIntermediaryAccountInfo sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @instance
       */
      MsgSetIntermediaryAccountInfo.prototype.sender = '';

      /**
       * MsgSetIntermediaryAccountInfo addrs.
       * @member {Array.<ununifi.yieldaggregator.IChainAddress>} addrs
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @instance
       */
      MsgSetIntermediaryAccountInfo.prototype.addrs = $util.emptyArray;

      /**
       * Encodes the specified MsgSetIntermediaryAccountInfo message. Does not implicitly {@link ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @static
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfo} message MsgSetIntermediaryAccountInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetIntermediaryAccountInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.addrs != null && message.addrs.length)
          for (let i = 0; i < message.addrs.length; ++i)
            $root.ununifi.yieldaggregator.ChainAddress.encode(message.addrs[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgSetIntermediaryAccountInfo message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @static
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfo} message MsgSetIntermediaryAccountInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetIntermediaryAccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSetIntermediaryAccountInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo} MsgSetIntermediaryAccountInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetIntermediaryAccountInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              if (!(message.addrs && message.addrs.length)) message.addrs = [];
              message.addrs.push($root.ununifi.yieldaggregator.ChainAddress.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSetIntermediaryAccountInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo} MsgSetIntermediaryAccountInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetIntermediaryAccountInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSetIntermediaryAccountInfo message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSetIntermediaryAccountInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.addrs != null && message.hasOwnProperty('addrs')) {
          if (!Array.isArray(message.addrs)) return 'addrs: array expected';
          for (let i = 0; i < message.addrs.length; ++i) {
            let error = $root.ununifi.yieldaggregator.ChainAddress.verify(message.addrs[i]);
            if (error) return 'addrs.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgSetIntermediaryAccountInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo} MsgSetIntermediaryAccountInfo
       */
      MsgSetIntermediaryAccountInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo) return object;
        let message = new $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.addrs) {
          if (!Array.isArray(object.addrs)) throw TypeError('.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo.addrs: array expected');
          message.addrs = [];
          for (let i = 0; i < object.addrs.length; ++i) {
            if (typeof object.addrs[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo.addrs: object expected');
            message.addrs[i] = $root.ununifi.yieldaggregator.ChainAddress.fromObject(object.addrs[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgSetIntermediaryAccountInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @static
       * @param {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo} message MsgSetIntermediaryAccountInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSetIntermediaryAccountInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.addrs = [];
        if (options.defaults) object.sender = '';
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.addrs && message.addrs.length) {
          object.addrs = [];
          for (let j = 0; j < message.addrs.length; ++j)
            object.addrs[j] = $root.ununifi.yieldaggregator.ChainAddress.toObject(message.addrs[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgSetIntermediaryAccountInfo to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSetIntermediaryAccountInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSetIntermediaryAccountInfo;
    })();

    yieldaggregator.MsgSetIntermediaryAccountInfoResponse = (function () {
      /**
       * Properties of a MsgSetIntermediaryAccountInfoResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgSetIntermediaryAccountInfoResponse
       */

      /**
       * Constructs a new MsgSetIntermediaryAccountInfoResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgSetIntermediaryAccountInfoResponse.
       * @implements IMsgSetIntermediaryAccountInfoResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfoResponse=} [properties] Properties to set
       */
      function MsgSetIntermediaryAccountInfoResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgSetIntermediaryAccountInfoResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfoResponse} message MsgSetIntermediaryAccountInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetIntermediaryAccountInfoResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgSetIntermediaryAccountInfoResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgSetIntermediaryAccountInfoResponse} message MsgSetIntermediaryAccountInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgSetIntermediaryAccountInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgSetIntermediaryAccountInfoResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse} MsgSetIntermediaryAccountInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetIntermediaryAccountInfoResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgSetIntermediaryAccountInfoResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse} MsgSetIntermediaryAccountInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgSetIntermediaryAccountInfoResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgSetIntermediaryAccountInfoResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgSetIntermediaryAccountInfoResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgSetIntermediaryAccountInfoResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse} MsgSetIntermediaryAccountInfoResponse
       */
      MsgSetIntermediaryAccountInfoResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse();
      };

      /**
       * Creates a plain object from a MsgSetIntermediaryAccountInfoResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse} message MsgSetIntermediaryAccountInfoResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgSetIntermediaryAccountInfoResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgSetIntermediaryAccountInfoResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgSetIntermediaryAccountInfoResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgSetIntermediaryAccountInfoResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgSetIntermediaryAccountInfoResponse;
    })();

    yieldaggregator.MsgReinitVaultTransfer = (function () {
      /**
       * Properties of a MsgReinitVaultTransfer.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgReinitVaultTransfer
       * @property {string|null} [sender] MsgReinitVaultTransfer sender
       * @property {Long|null} [vault_id] MsgReinitVaultTransfer vault_id
       * @property {string|null} [strategy_denom] MsgReinitVaultTransfer strategy_denom
       * @property {Long|null} [strategy_id] MsgReinitVaultTransfer strategy_id
       * @property {cosmos.base.v1beta1.ICoin|null} [amount] MsgReinitVaultTransfer amount
       */

      /**
       * Constructs a new MsgReinitVaultTransfer.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgReinitVaultTransfer.
       * @implements IMsgReinitVaultTransfer
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransfer=} [properties] Properties to set
       */
      function MsgReinitVaultTransfer(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgReinitVaultTransfer sender.
       * @member {string} sender
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @instance
       */
      MsgReinitVaultTransfer.prototype.sender = '';

      /**
       * MsgReinitVaultTransfer vault_id.
       * @member {Long} vault_id
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @instance
       */
      MsgReinitVaultTransfer.prototype.vault_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgReinitVaultTransfer strategy_denom.
       * @member {string} strategy_denom
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @instance
       */
      MsgReinitVaultTransfer.prototype.strategy_denom = '';

      /**
       * MsgReinitVaultTransfer strategy_id.
       * @member {Long} strategy_id
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @instance
       */
      MsgReinitVaultTransfer.prototype.strategy_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * MsgReinitVaultTransfer amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} amount
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @instance
       */
      MsgReinitVaultTransfer.prototype.amount = null;

      /**
       * Encodes the specified MsgReinitVaultTransfer message. Does not implicitly {@link ununifi.yieldaggregator.MsgReinitVaultTransfer.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @static
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransfer} message MsgReinitVaultTransfer message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReinitVaultTransfer.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.vault_id != null && Object.hasOwnProperty.call(message, 'vault_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.vault_id);
        if (message.strategy_denom != null && Object.hasOwnProperty.call(message, 'strategy_denom'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.strategy_denom);
        if (message.strategy_id != null && Object.hasOwnProperty.call(message, 'strategy_id'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.strategy_id);
        if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.amount, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgReinitVaultTransfer message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgReinitVaultTransfer.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @static
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransfer} message MsgReinitVaultTransfer message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReinitVaultTransfer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgReinitVaultTransfer message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgReinitVaultTransfer} MsgReinitVaultTransfer
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReinitVaultTransfer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgReinitVaultTransfer();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.vault_id = reader.uint64();
              break;
            case 3:
              message.strategy_denom = reader.string();
              break;
            case 4:
              message.strategy_id = reader.uint64();
              break;
            case 5:
              message.amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgReinitVaultTransfer message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgReinitVaultTransfer} MsgReinitVaultTransfer
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReinitVaultTransfer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgReinitVaultTransfer message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgReinitVaultTransfer.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (
            !$util.isInteger(message.vault_id) &&
            !(message.vault_id && $util.isInteger(message.vault_id.low) && $util.isInteger(message.vault_id.high))
          )
            return 'vault_id: integer|Long expected';
        if (message.strategy_denom != null && message.hasOwnProperty('strategy_denom'))
          if (!$util.isString(message.strategy_denom)) return 'strategy_denom: string expected';
        if (message.strategy_id != null && message.hasOwnProperty('strategy_id'))
          if (
            !$util.isInteger(message.strategy_id) &&
            !(message.strategy_id && $util.isInteger(message.strategy_id.low) && $util.isInteger(message.strategy_id.high))
          )
            return 'strategy_id: integer|Long expected';
        if (message.amount != null && message.hasOwnProperty('amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.amount);
          if (error) return 'amount.' + error;
        }
        return null;
      };

      /**
       * Creates a MsgReinitVaultTransfer message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgReinitVaultTransfer} MsgReinitVaultTransfer
       */
      MsgReinitVaultTransfer.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgReinitVaultTransfer) return object;
        let message = new $root.ununifi.yieldaggregator.MsgReinitVaultTransfer();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.vault_id != null)
          if ($util.Long) (message.vault_id = $util.Long.fromValue(object.vault_id)).unsigned = true;
          else if (typeof object.vault_id === 'string') message.vault_id = parseInt(object.vault_id, 10);
          else if (typeof object.vault_id === 'number') message.vault_id = object.vault_id;
          else if (typeof object.vault_id === 'object')
            message.vault_id = new $util.LongBits(object.vault_id.low >>> 0, object.vault_id.high >>> 0).toNumber(true);
        if (object.strategy_denom != null) message.strategy_denom = String(object.strategy_denom);
        if (object.strategy_id != null)
          if ($util.Long) (message.strategy_id = $util.Long.fromValue(object.strategy_id)).unsigned = true;
          else if (typeof object.strategy_id === 'string') message.strategy_id = parseInt(object.strategy_id, 10);
          else if (typeof object.strategy_id === 'number') message.strategy_id = object.strategy_id;
          else if (typeof object.strategy_id === 'object')
            message.strategy_id = new $util.LongBits(object.strategy_id.low >>> 0, object.strategy_id.high >>> 0).toNumber(true);
        if (object.amount != null) {
          if (typeof object.amount !== 'object') throw TypeError('.ununifi.yieldaggregator.MsgReinitVaultTransfer.amount: object expected');
          message.amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgReinitVaultTransfer message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @static
       * @param {ununifi.yieldaggregator.MsgReinitVaultTransfer} message MsgReinitVaultTransfer
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgReinitVaultTransfer.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.vault_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.vault_id = options.longs === String ? '0' : 0;
          object.strategy_denom = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.strategy_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.strategy_id = options.longs === String ? '0' : 0;
          object.amount = null;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.vault_id != null && message.hasOwnProperty('vault_id'))
          if (typeof message.vault_id === 'number')
            object.vault_id = options.longs === String ? String(message.vault_id) : message.vault_id;
          else
            object.vault_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.vault_id)
                : options.longs === Number
                ? new $util.LongBits(message.vault_id.low >>> 0, message.vault_id.high >>> 0).toNumber(true)
                : message.vault_id;
        if (message.strategy_denom != null && message.hasOwnProperty('strategy_denom')) object.strategy_denom = message.strategy_denom;
        if (message.strategy_id != null && message.hasOwnProperty('strategy_id'))
          if (typeof message.strategy_id === 'number')
            object.strategy_id = options.longs === String ? String(message.strategy_id) : message.strategy_id;
          else
            object.strategy_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.strategy_id)
                : options.longs === Number
                ? new $util.LongBits(message.strategy_id.low >>> 0, message.strategy_id.high >>> 0).toNumber(true)
                : message.strategy_id;
        if (message.amount != null && message.hasOwnProperty('amount'))
          object.amount = $root.cosmos.base.v1beta1.Coin.toObject(message.amount, options);
        return object;
      };

      /**
       * Converts this MsgReinitVaultTransfer to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransfer
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgReinitVaultTransfer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgReinitVaultTransfer;
    })();

    yieldaggregator.MsgReinitVaultTransferResponse = (function () {
      /**
       * Properties of a MsgReinitVaultTransferResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IMsgReinitVaultTransferResponse
       */

      /**
       * Constructs a new MsgReinitVaultTransferResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a MsgReinitVaultTransferResponse.
       * @implements IMsgReinitVaultTransferResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransferResponse=} [properties] Properties to set
       */
      function MsgReinitVaultTransferResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgReinitVaultTransferResponse message. Does not implicitly {@link ununifi.yieldaggregator.MsgReinitVaultTransferResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransferResponse} message MsgReinitVaultTransferResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReinitVaultTransferResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgReinitVaultTransferResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.MsgReinitVaultTransferResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @static
       * @param {ununifi.yieldaggregator.IMsgReinitVaultTransferResponse} message MsgReinitVaultTransferResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgReinitVaultTransferResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgReinitVaultTransferResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.MsgReinitVaultTransferResponse} MsgReinitVaultTransferResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReinitVaultTransferResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.MsgReinitVaultTransferResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgReinitVaultTransferResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.MsgReinitVaultTransferResponse} MsgReinitVaultTransferResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgReinitVaultTransferResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgReinitVaultTransferResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgReinitVaultTransferResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgReinitVaultTransferResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.MsgReinitVaultTransferResponse} MsgReinitVaultTransferResponse
       */
      MsgReinitVaultTransferResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.MsgReinitVaultTransferResponse) return object;
        return new $root.ununifi.yieldaggregator.MsgReinitVaultTransferResponse();
      };

      /**
       * Creates a plain object from a MsgReinitVaultTransferResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @static
       * @param {ununifi.yieldaggregator.MsgReinitVaultTransferResponse} message MsgReinitVaultTransferResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgReinitVaultTransferResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgReinitVaultTransferResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.MsgReinitVaultTransferResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgReinitVaultTransferResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgReinitVaultTransferResponse;
    })();

    yieldaggregator.StrategyWeight = (function () {
      /**
       * Properties of a StrategyWeight.
       * @memberof ununifi.yieldaggregator
       * @interface IStrategyWeight
       * @property {string|null} [denom] StrategyWeight denom
       * @property {Long|null} [strategy_id] StrategyWeight strategy_id
       * @property {string|null} [weight] StrategyWeight weight
       */

      /**
       * Constructs a new StrategyWeight.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a StrategyWeight.
       * @implements IStrategyWeight
       * @constructor
       * @param {ununifi.yieldaggregator.IStrategyWeight=} [properties] Properties to set
       */
      function StrategyWeight(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * StrategyWeight denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @instance
       */
      StrategyWeight.prototype.denom = '';

      /**
       * StrategyWeight strategy_id.
       * @member {Long} strategy_id
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @instance
       */
      StrategyWeight.prototype.strategy_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * StrategyWeight weight.
       * @member {string} weight
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @instance
       */
      StrategyWeight.prototype.weight = '';

      /**
       * Encodes the specified StrategyWeight message. Does not implicitly {@link ununifi.yieldaggregator.StrategyWeight.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @static
       * @param {ununifi.yieldaggregator.IStrategyWeight} message StrategyWeight message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      StrategyWeight.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.strategy_id != null && Object.hasOwnProperty.call(message, 'strategy_id'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.strategy_id);
        if (message.weight != null && Object.hasOwnProperty.call(message, 'weight'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.weight);
        return writer;
      };

      /**
       * Encodes the specified StrategyWeight message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.StrategyWeight.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @static
       * @param {ununifi.yieldaggregator.IStrategyWeight} message StrategyWeight message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      StrategyWeight.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a StrategyWeight message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.StrategyWeight} StrategyWeight
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      StrategyWeight.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.StrategyWeight();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.strategy_id = reader.uint64();
              break;
            case 3:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a StrategyWeight message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.StrategyWeight} StrategyWeight
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      StrategyWeight.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a StrategyWeight message.
       * @function verify
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      StrategyWeight.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.strategy_id != null && message.hasOwnProperty('strategy_id'))
          if (
            !$util.isInteger(message.strategy_id) &&
            !(message.strategy_id && $util.isInteger(message.strategy_id.low) && $util.isInteger(message.strategy_id.high))
          )
            return 'strategy_id: integer|Long expected';
        if (message.weight != null && message.hasOwnProperty('weight'))
          if (!$util.isString(message.weight)) return 'weight: string expected';
        return null;
      };

      /**
       * Creates a StrategyWeight message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.StrategyWeight} StrategyWeight
       */
      StrategyWeight.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.StrategyWeight) return object;
        let message = new $root.ununifi.yieldaggregator.StrategyWeight();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.strategy_id != null)
          if ($util.Long) (message.strategy_id = $util.Long.fromValue(object.strategy_id)).unsigned = true;
          else if (typeof object.strategy_id === 'string') message.strategy_id = parseInt(object.strategy_id, 10);
          else if (typeof object.strategy_id === 'number') message.strategy_id = object.strategy_id;
          else if (typeof object.strategy_id === 'object')
            message.strategy_id = new $util.LongBits(object.strategy_id.low >>> 0, object.strategy_id.high >>> 0).toNumber(true);
        if (object.weight != null) message.weight = String(object.weight);
        return message;
      };

      /**
       * Creates a plain object from a StrategyWeight message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @static
       * @param {ununifi.yieldaggregator.StrategyWeight} message StrategyWeight
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      StrategyWeight.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.strategy_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.strategy_id = options.longs === String ? '0' : 0;
          object.weight = '';
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.strategy_id != null && message.hasOwnProperty('strategy_id'))
          if (typeof message.strategy_id === 'number')
            object.strategy_id = options.longs === String ? String(message.strategy_id) : message.strategy_id;
          else
            object.strategy_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.strategy_id)
                : options.longs === Number
                ? new $util.LongBits(message.strategy_id.low >>> 0, message.strategy_id.high >>> 0).toNumber(true)
                : message.strategy_id;
        if (message.weight != null && message.hasOwnProperty('weight')) object.weight = message.weight;
        return object;
      };

      /**
       * Converts this StrategyWeight to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.StrategyWeight
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      StrategyWeight.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return StrategyWeight;
    })();

    yieldaggregator.Vault = (function () {
      /**
       * Properties of a Vault.
       * @memberof ununifi.yieldaggregator
       * @interface IVault
       * @property {Long|null} [id] Vault id
       * @property {string|null} [symbol] Vault symbol
       * @property {string|null} [name] Vault name
       * @property {string|null} [description] Vault description
       * @property {string|null} [owner] Vault owner
       * @property {cosmos.base.v1beta1.ICoin|null} [owner_deposit] Vault owner_deposit
       * @property {string|null} [withdraw_commission_rate] Vault withdraw_commission_rate
       * @property {string|null} [withdraw_reserve_rate] Vault withdraw_reserve_rate
       * @property {Array.<ununifi.yieldaggregator.IStrategyWeight>|null} [strategy_weights] Vault strategy_weights
       * @property {string|null} [fee_collector_address] Vault fee_collector_address
       */

      /**
       * Constructs a new Vault.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a Vault.
       * @implements IVault
       * @constructor
       * @param {ununifi.yieldaggregator.IVault=} [properties] Properties to set
       */
      function Vault(properties) {
        this.strategy_weights = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Vault id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Vault symbol.
       * @member {string} symbol
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.symbol = '';

      /**
       * Vault name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.name = '';

      /**
       * Vault description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.description = '';

      /**
       * Vault owner.
       * @member {string} owner
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.owner = '';

      /**
       * Vault owner_deposit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} owner_deposit
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.owner_deposit = null;

      /**
       * Vault withdraw_commission_rate.
       * @member {string} withdraw_commission_rate
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.withdraw_commission_rate = '';

      /**
       * Vault withdraw_reserve_rate.
       * @member {string} withdraw_reserve_rate
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.withdraw_reserve_rate = '';

      /**
       * Vault strategy_weights.
       * @member {Array.<ununifi.yieldaggregator.IStrategyWeight>} strategy_weights
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.strategy_weights = $util.emptyArray;

      /**
       * Vault fee_collector_address.
       * @member {string} fee_collector_address
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       */
      Vault.prototype.fee_collector_address = '';

      /**
       * Encodes the specified Vault message. Does not implicitly {@link ununifi.yieldaggregator.Vault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.Vault
       * @static
       * @param {ununifi.yieldaggregator.IVault} message Vault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Vault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.symbol);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.description);
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.owner);
        if (message.owner_deposit != null && Object.hasOwnProperty.call(message, 'owner_deposit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.owner_deposit, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
        if (message.withdraw_commission_rate != null && Object.hasOwnProperty.call(message, 'withdraw_commission_rate'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.withdraw_commission_rate);
        if (message.withdraw_reserve_rate != null && Object.hasOwnProperty.call(message, 'withdraw_reserve_rate'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.withdraw_reserve_rate);
        if (message.strategy_weights != null && message.strategy_weights.length)
          for (let i = 0; i < message.strategy_weights.length; ++i)
            $root.ununifi.yieldaggregator.StrategyWeight.encode(
              message.strategy_weights[i],
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
        if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, 'fee_collector_address'))
          writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.fee_collector_address);
        return writer;
      };

      /**
       * Encodes the specified Vault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.Vault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.Vault
       * @static
       * @param {ununifi.yieldaggregator.IVault} message Vault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Vault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Vault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.Vault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.Vault} Vault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Vault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.Vault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.symbol = reader.string();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.description = reader.string();
              break;
            case 5:
              message.owner = reader.string();
              break;
            case 6:
              message.owner_deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 7:
              message.withdraw_commission_rate = reader.string();
              break;
            case 8:
              message.withdraw_reserve_rate = reader.string();
              break;
            case 9:
              if (!(message.strategy_weights && message.strategy_weights.length)) message.strategy_weights = [];
              message.strategy_weights.push($root.ununifi.yieldaggregator.StrategyWeight.decode(reader, reader.uint32()));
              break;
            case 10:
              message.fee_collector_address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Vault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.Vault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.Vault} Vault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Vault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Vault message.
       * @function verify
       * @memberof ununifi.yieldaggregator.Vault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Vault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.owner_deposit != null && message.hasOwnProperty('owner_deposit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.owner_deposit);
          if (error) return 'owner_deposit.' + error;
        }
        if (message.withdraw_commission_rate != null && message.hasOwnProperty('withdraw_commission_rate'))
          if (!$util.isString(message.withdraw_commission_rate)) return 'withdraw_commission_rate: string expected';
        if (message.withdraw_reserve_rate != null && message.hasOwnProperty('withdraw_reserve_rate'))
          if (!$util.isString(message.withdraw_reserve_rate)) return 'withdraw_reserve_rate: string expected';
        if (message.strategy_weights != null && message.hasOwnProperty('strategy_weights')) {
          if (!Array.isArray(message.strategy_weights)) return 'strategy_weights: array expected';
          for (let i = 0; i < message.strategy_weights.length; ++i) {
            let error = $root.ununifi.yieldaggregator.StrategyWeight.verify(message.strategy_weights[i]);
            if (error) return 'strategy_weights.' + error;
          }
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          if (!$util.isString(message.fee_collector_address)) return 'fee_collector_address: string expected';
        return null;
      };

      /**
       * Creates a Vault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.Vault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.Vault} Vault
       */
      Vault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.Vault) return object;
        let message = new $root.ununifi.yieldaggregator.Vault();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.owner != null) message.owner = String(object.owner);
        if (object.owner_deposit != null) {
          if (typeof object.owner_deposit !== 'object') throw TypeError('.ununifi.yieldaggregator.Vault.owner_deposit: object expected');
          message.owner_deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.owner_deposit);
        }
        if (object.withdraw_commission_rate != null) message.withdraw_commission_rate = String(object.withdraw_commission_rate);
        if (object.withdraw_reserve_rate != null) message.withdraw_reserve_rate = String(object.withdraw_reserve_rate);
        if (object.strategy_weights) {
          if (!Array.isArray(object.strategy_weights)) throw TypeError('.ununifi.yieldaggregator.Vault.strategy_weights: array expected');
          message.strategy_weights = [];
          for (let i = 0; i < object.strategy_weights.length; ++i) {
            if (typeof object.strategy_weights[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.Vault.strategy_weights: object expected');
            message.strategy_weights[i] = $root.ununifi.yieldaggregator.StrategyWeight.fromObject(object.strategy_weights[i]);
          }
        }
        if (object.fee_collector_address != null) message.fee_collector_address = String(object.fee_collector_address);
        return message;
      };

      /**
       * Creates a plain object from a Vault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.Vault
       * @static
       * @param {ununifi.yieldaggregator.Vault} message Vault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Vault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.strategy_weights = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.symbol = '';
          object.name = '';
          object.description = '';
          object.owner = '';
          object.owner_deposit = null;
          object.withdraw_commission_rate = '';
          object.withdraw_reserve_rate = '';
          object.fee_collector_address = '';
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.owner_deposit != null && message.hasOwnProperty('owner_deposit'))
          object.owner_deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.owner_deposit, options);
        if (message.withdraw_commission_rate != null && message.hasOwnProperty('withdraw_commission_rate'))
          object.withdraw_commission_rate = message.withdraw_commission_rate;
        if (message.withdraw_reserve_rate != null && message.hasOwnProperty('withdraw_reserve_rate'))
          object.withdraw_reserve_rate = message.withdraw_reserve_rate;
        if (message.strategy_weights && message.strategy_weights.length) {
          object.strategy_weights = [];
          for (let j = 0; j < message.strategy_weights.length; ++j)
            object.strategy_weights[j] = $root.ununifi.yieldaggregator.StrategyWeight.toObject(message.strategy_weights[j], options);
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          object.fee_collector_address = message.fee_collector_address;
        return object;
      };

      /**
       * Converts this Vault to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.Vault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Vault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Vault;
    })();

    yieldaggregator.Strategy = (function () {
      /**
       * Properties of a Strategy.
       * @memberof ununifi.yieldaggregator
       * @interface IStrategy
       * @property {string|null} [denom] Strategy denom
       * @property {Long|null} [id] Strategy id
       * @property {string|null} [contract_address] Strategy contract_address
       * @property {string|null} [name] Strategy name
       * @property {string|null} [description] Strategy description
       * @property {string|null} [git_url] Strategy git_url
       */

      /**
       * Constructs a new Strategy.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a Strategy.
       * @implements IStrategy
       * @constructor
       * @param {ununifi.yieldaggregator.IStrategy=} [properties] Properties to set
       */
      function Strategy(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Strategy denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.Strategy
       * @instance
       */
      Strategy.prototype.denom = '';

      /**
       * Strategy id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.Strategy
       * @instance
       */
      Strategy.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Strategy contract_address.
       * @member {string} contract_address
       * @memberof ununifi.yieldaggregator.Strategy
       * @instance
       */
      Strategy.prototype.contract_address = '';

      /**
       * Strategy name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.Strategy
       * @instance
       */
      Strategy.prototype.name = '';

      /**
       * Strategy description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.Strategy
       * @instance
       */
      Strategy.prototype.description = '';

      /**
       * Strategy git_url.
       * @member {string} git_url
       * @memberof ununifi.yieldaggregator.Strategy
       * @instance
       */
      Strategy.prototype.git_url = '';

      /**
       * Encodes the specified Strategy message. Does not implicitly {@link ununifi.yieldaggregator.Strategy.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.Strategy
       * @static
       * @param {ununifi.yieldaggregator.IStrategy} message Strategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Strategy.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.id);
        if (message.contract_address != null && Object.hasOwnProperty.call(message, 'contract_address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.contract_address);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.description);
        if (message.git_url != null && Object.hasOwnProperty.call(message, 'git_url'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.git_url);
        return writer;
      };

      /**
       * Encodes the specified Strategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.Strategy.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.Strategy
       * @static
       * @param {ununifi.yieldaggregator.IStrategy} message Strategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Strategy.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Strategy message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.Strategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.Strategy} Strategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Strategy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.Strategy();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.id = reader.uint64();
              break;
            case 3:
              message.contract_address = reader.string();
              break;
            case 4:
              message.name = reader.string();
              break;
            case 5:
              message.description = reader.string();
              break;
            case 6:
              message.git_url = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Strategy message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.Strategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.Strategy} Strategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Strategy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Strategy message.
       * @function verify
       * @memberof ununifi.yieldaggregator.Strategy
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Strategy.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          if (!$util.isString(message.contract_address)) return 'contract_address: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.git_url != null && message.hasOwnProperty('git_url'))
          if (!$util.isString(message.git_url)) return 'git_url: string expected';
        return null;
      };

      /**
       * Creates a Strategy message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.Strategy
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.Strategy} Strategy
       */
      Strategy.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.Strategy) return object;
        let message = new $root.ununifi.yieldaggregator.Strategy();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.contract_address != null) message.contract_address = String(object.contract_address);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.git_url != null) message.git_url = String(object.git_url);
        return message;
      };

      /**
       * Creates a plain object from a Strategy message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.Strategy
       * @static
       * @param {ununifi.yieldaggregator.Strategy} message Strategy
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Strategy.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.contract_address = '';
          object.name = '';
          object.description = '';
          object.git_url = '';
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          object.contract_address = message.contract_address;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.git_url != null && message.hasOwnProperty('git_url')) object.git_url = message.git_url;
        return object;
      };

      /**
       * Converts this Strategy to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.Strategy
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Strategy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Strategy;
    })();

    yieldaggregator.TransferChannel = (function () {
      /**
       * Properties of a TransferChannel.
       * @memberof ununifi.yieldaggregator
       * @interface ITransferChannel
       * @property {string|null} [send_chain_id] TransferChannel send_chain_id
       * @property {string|null} [recv_chain_id] TransferChannel recv_chain_id
       * @property {string|null} [channel_id] TransferChannel channel_id
       */

      /**
       * Constructs a new TransferChannel.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a TransferChannel.
       * @implements ITransferChannel
       * @constructor
       * @param {ununifi.yieldaggregator.ITransferChannel=} [properties] Properties to set
       */
      function TransferChannel(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * TransferChannel send_chain_id.
       * @member {string} send_chain_id
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @instance
       */
      TransferChannel.prototype.send_chain_id = '';

      /**
       * TransferChannel recv_chain_id.
       * @member {string} recv_chain_id
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @instance
       */
      TransferChannel.prototype.recv_chain_id = '';

      /**
       * TransferChannel channel_id.
       * @member {string} channel_id
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @instance
       */
      TransferChannel.prototype.channel_id = '';

      /**
       * Encodes the specified TransferChannel message. Does not implicitly {@link ununifi.yieldaggregator.TransferChannel.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @static
       * @param {ununifi.yieldaggregator.ITransferChannel} message TransferChannel message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TransferChannel.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.send_chain_id != null && Object.hasOwnProperty.call(message, 'send_chain_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.send_chain_id);
        if (message.recv_chain_id != null && Object.hasOwnProperty.call(message, 'recv_chain_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.recv_chain_id);
        if (message.channel_id != null && Object.hasOwnProperty.call(message, 'channel_id'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.channel_id);
        return writer;
      };

      /**
       * Encodes the specified TransferChannel message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.TransferChannel.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @static
       * @param {ununifi.yieldaggregator.ITransferChannel} message TransferChannel message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      TransferChannel.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a TransferChannel message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.TransferChannel} TransferChannel
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TransferChannel.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.TransferChannel();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.send_chain_id = reader.string();
              break;
            case 2:
              message.recv_chain_id = reader.string();
              break;
            case 3:
              message.channel_id = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a TransferChannel message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.TransferChannel} TransferChannel
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      TransferChannel.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a TransferChannel message.
       * @function verify
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      TransferChannel.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.send_chain_id != null && message.hasOwnProperty('send_chain_id'))
          if (!$util.isString(message.send_chain_id)) return 'send_chain_id: string expected';
        if (message.recv_chain_id != null && message.hasOwnProperty('recv_chain_id'))
          if (!$util.isString(message.recv_chain_id)) return 'recv_chain_id: string expected';
        if (message.channel_id != null && message.hasOwnProperty('channel_id'))
          if (!$util.isString(message.channel_id)) return 'channel_id: string expected';
        return null;
      };

      /**
       * Creates a TransferChannel message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.TransferChannel} TransferChannel
       */
      TransferChannel.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.TransferChannel) return object;
        let message = new $root.ununifi.yieldaggregator.TransferChannel();
        if (object.send_chain_id != null) message.send_chain_id = String(object.send_chain_id);
        if (object.recv_chain_id != null) message.recv_chain_id = String(object.recv_chain_id);
        if (object.channel_id != null) message.channel_id = String(object.channel_id);
        return message;
      };

      /**
       * Creates a plain object from a TransferChannel message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @static
       * @param {ununifi.yieldaggregator.TransferChannel} message TransferChannel
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      TransferChannel.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.send_chain_id = '';
          object.recv_chain_id = '';
          object.channel_id = '';
        }
        if (message.send_chain_id != null && message.hasOwnProperty('send_chain_id')) object.send_chain_id = message.send_chain_id;
        if (message.recv_chain_id != null && message.hasOwnProperty('recv_chain_id')) object.recv_chain_id = message.recv_chain_id;
        if (message.channel_id != null && message.hasOwnProperty('channel_id')) object.channel_id = message.channel_id;
        return object;
      };

      /**
       * Converts this TransferChannel to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.TransferChannel
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      TransferChannel.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return TransferChannel;
    })();

    yieldaggregator.SymbolInfo = (function () {
      /**
       * Properties of a SymbolInfo.
       * @memberof ununifi.yieldaggregator
       * @interface ISymbolInfo
       * @property {string|null} [symbol] SymbolInfo symbol
       * @property {string|null} [native_chain_id] SymbolInfo native_chain_id
       * @property {Array.<ununifi.yieldaggregator.ITransferChannel>|null} [channels] SymbolInfo channels
       */

      /**
       * Constructs a new SymbolInfo.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a SymbolInfo.
       * @implements ISymbolInfo
       * @constructor
       * @param {ununifi.yieldaggregator.ISymbolInfo=} [properties] Properties to set
       */
      function SymbolInfo(properties) {
        this.channels = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * SymbolInfo symbol.
       * @member {string} symbol
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @instance
       */
      SymbolInfo.prototype.symbol = '';

      /**
       * SymbolInfo native_chain_id.
       * @member {string} native_chain_id
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @instance
       */
      SymbolInfo.prototype.native_chain_id = '';

      /**
       * SymbolInfo channels.
       * @member {Array.<ununifi.yieldaggregator.ITransferChannel>} channels
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @instance
       */
      SymbolInfo.prototype.channels = $util.emptyArray;

      /**
       * Encodes the specified SymbolInfo message. Does not implicitly {@link ununifi.yieldaggregator.SymbolInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @static
       * @param {ununifi.yieldaggregator.ISymbolInfo} message SymbolInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SymbolInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.symbol);
        if (message.native_chain_id != null && Object.hasOwnProperty.call(message, 'native_chain_id'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.native_chain_id);
        if (message.channels != null && message.channels.length)
          for (let i = 0; i < message.channels.length; ++i)
            $root.ununifi.yieldaggregator.TransferChannel.encode(
              message.channels[i],
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified SymbolInfo message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.SymbolInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @static
       * @param {ununifi.yieldaggregator.ISymbolInfo} message SymbolInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SymbolInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a SymbolInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.SymbolInfo} SymbolInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SymbolInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.SymbolInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.symbol = reader.string();
              break;
            case 2:
              message.native_chain_id = reader.string();
              break;
            case 3:
              if (!(message.channels && message.channels.length)) message.channels = [];
              message.channels.push($root.ununifi.yieldaggregator.TransferChannel.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a SymbolInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.SymbolInfo} SymbolInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SymbolInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a SymbolInfo message.
       * @function verify
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      SymbolInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.native_chain_id != null && message.hasOwnProperty('native_chain_id'))
          if (!$util.isString(message.native_chain_id)) return 'native_chain_id: string expected';
        if (message.channels != null && message.hasOwnProperty('channels')) {
          if (!Array.isArray(message.channels)) return 'channels: array expected';
          for (let i = 0; i < message.channels.length; ++i) {
            let error = $root.ununifi.yieldaggregator.TransferChannel.verify(message.channels[i]);
            if (error) return 'channels.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a SymbolInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.SymbolInfo} SymbolInfo
       */
      SymbolInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.SymbolInfo) return object;
        let message = new $root.ununifi.yieldaggregator.SymbolInfo();
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.native_chain_id != null) message.native_chain_id = String(object.native_chain_id);
        if (object.channels) {
          if (!Array.isArray(object.channels)) throw TypeError('.ununifi.yieldaggregator.SymbolInfo.channels: array expected');
          message.channels = [];
          for (let i = 0; i < object.channels.length; ++i) {
            if (typeof object.channels[i] !== 'object') throw TypeError('.ununifi.yieldaggregator.SymbolInfo.channels: object expected');
            message.channels[i] = $root.ununifi.yieldaggregator.TransferChannel.fromObject(object.channels[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a SymbolInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @static
       * @param {ununifi.yieldaggregator.SymbolInfo} message SymbolInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      SymbolInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.channels = [];
        if (options.defaults) {
          object.symbol = '';
          object.native_chain_id = '';
        }
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.native_chain_id != null && message.hasOwnProperty('native_chain_id')) object.native_chain_id = message.native_chain_id;
        if (message.channels && message.channels.length) {
          object.channels = [];
          for (let j = 0; j < message.channels.length; ++j)
            object.channels[j] = $root.ununifi.yieldaggregator.TransferChannel.toObject(message.channels[j], options);
        }
        return object;
      };

      /**
       * Converts this SymbolInfo to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.SymbolInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      SymbolInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return SymbolInfo;
    })();

    yieldaggregator.DenomInfo = (function () {
      /**
       * Properties of a DenomInfo.
       * @memberof ununifi.yieldaggregator
       * @interface IDenomInfo
       * @property {string|null} [denom] DenomInfo denom
       * @property {string|null} [symbol] DenomInfo symbol
       * @property {Array.<ununifi.yieldaggregator.ITransferChannel>|null} [channels] DenomInfo channels
       */

      /**
       * Constructs a new DenomInfo.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a DenomInfo.
       * @implements IDenomInfo
       * @constructor
       * @param {ununifi.yieldaggregator.IDenomInfo=} [properties] Properties to set
       */
      function DenomInfo(properties) {
        this.channels = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * DenomInfo denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @instance
       */
      DenomInfo.prototype.denom = '';

      /**
       * DenomInfo symbol.
       * @member {string} symbol
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @instance
       */
      DenomInfo.prototype.symbol = '';

      /**
       * DenomInfo channels.
       * @member {Array.<ununifi.yieldaggregator.ITransferChannel>} channels
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @instance
       */
      DenomInfo.prototype.channels = $util.emptyArray;

      /**
       * Encodes the specified DenomInfo message. Does not implicitly {@link ununifi.yieldaggregator.DenomInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @static
       * @param {ununifi.yieldaggregator.IDenomInfo} message DenomInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DenomInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.symbol);
        if (message.channels != null && message.channels.length)
          for (let i = 0; i < message.channels.length; ++i)
            $root.ununifi.yieldaggregator.TransferChannel.encode(
              message.channels[i],
              writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified DenomInfo message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.DenomInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @static
       * @param {ununifi.yieldaggregator.IDenomInfo} message DenomInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DenomInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DenomInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.DenomInfo} DenomInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DenomInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.DenomInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.symbol = reader.string();
              break;
            case 3:
              if (!(message.channels && message.channels.length)) message.channels = [];
              message.channels.push($root.ununifi.yieldaggregator.TransferChannel.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a DenomInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.DenomInfo} DenomInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DenomInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DenomInfo message.
       * @function verify
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DenomInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        if (message.channels != null && message.hasOwnProperty('channels')) {
          if (!Array.isArray(message.channels)) return 'channels: array expected';
          for (let i = 0; i < message.channels.length; ++i) {
            let error = $root.ununifi.yieldaggregator.TransferChannel.verify(message.channels[i]);
            if (error) return 'channels.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a DenomInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.DenomInfo} DenomInfo
       */
      DenomInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.DenomInfo) return object;
        let message = new $root.ununifi.yieldaggregator.DenomInfo();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.symbol != null) message.symbol = String(object.symbol);
        if (object.channels) {
          if (!Array.isArray(object.channels)) throw TypeError('.ununifi.yieldaggregator.DenomInfo.channels: array expected');
          message.channels = [];
          for (let i = 0; i < object.channels.length; ++i) {
            if (typeof object.channels[i] !== 'object') throw TypeError('.ununifi.yieldaggregator.DenomInfo.channels: object expected');
            message.channels[i] = $root.ununifi.yieldaggregator.TransferChannel.fromObject(object.channels[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a DenomInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @static
       * @param {ununifi.yieldaggregator.DenomInfo} message DenomInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DenomInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.channels = [];
        if (options.defaults) {
          object.denom = '';
          object.symbol = '';
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        if (message.channels && message.channels.length) {
          object.channels = [];
          for (let j = 0; j < message.channels.length; ++j)
            object.channels[j] = $root.ununifi.yieldaggregator.TransferChannel.toObject(message.channels[j], options);
        }
        return object;
      };

      /**
       * Converts this DenomInfo to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.DenomInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DenomInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return DenomInfo;
    })();

    yieldaggregator.ChainAddress = (function () {
      /**
       * Properties of a ChainAddress.
       * @memberof ununifi.yieldaggregator
       * @interface IChainAddress
       * @property {string|null} [chain_id] ChainAddress chain_id
       * @property {string|null} [address] ChainAddress address
       */

      /**
       * Constructs a new ChainAddress.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a ChainAddress.
       * @implements IChainAddress
       * @constructor
       * @param {ununifi.yieldaggregator.IChainAddress=} [properties] Properties to set
       */
      function ChainAddress(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ChainAddress chain_id.
       * @member {string} chain_id
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @instance
       */
      ChainAddress.prototype.chain_id = '';

      /**
       * ChainAddress address.
       * @member {string} address
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @instance
       */
      ChainAddress.prototype.address = '';

      /**
       * Encodes the specified ChainAddress message. Does not implicitly {@link ununifi.yieldaggregator.ChainAddress.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @static
       * @param {ununifi.yieldaggregator.IChainAddress} message ChainAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ChainAddress.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.chain_id != null && Object.hasOwnProperty.call(message, 'chain_id'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.chain_id);
        if (message.address != null && Object.hasOwnProperty.call(message, 'address'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.address);
        return writer;
      };

      /**
       * Encodes the specified ChainAddress message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.ChainAddress.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @static
       * @param {ununifi.yieldaggregator.IChainAddress} message ChainAddress message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ChainAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ChainAddress message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.ChainAddress} ChainAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ChainAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.ChainAddress();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chain_id = reader.string();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ChainAddress message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.ChainAddress} ChainAddress
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ChainAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ChainAddress message.
       * @function verify
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ChainAddress.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.chain_id != null && message.hasOwnProperty('chain_id'))
          if (!$util.isString(message.chain_id)) return 'chain_id: string expected';
        if (message.address != null && message.hasOwnProperty('address'))
          if (!$util.isString(message.address)) return 'address: string expected';
        return null;
      };

      /**
       * Creates a ChainAddress message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.ChainAddress} ChainAddress
       */
      ChainAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.ChainAddress) return object;
        let message = new $root.ununifi.yieldaggregator.ChainAddress();
        if (object.chain_id != null) message.chain_id = String(object.chain_id);
        if (object.address != null) message.address = String(object.address);
        return message;
      };

      /**
       * Creates a plain object from a ChainAddress message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @static
       * @param {ununifi.yieldaggregator.ChainAddress} message ChainAddress
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ChainAddress.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.chain_id = '';
          object.address = '';
        }
        if (message.chain_id != null && message.hasOwnProperty('chain_id')) object.chain_id = message.chain_id;
        if (message.address != null && message.hasOwnProperty('address')) object.address = message.address;
        return object;
      };

      /**
       * Converts this ChainAddress to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.ChainAddress
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ChainAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ChainAddress;
    })();

    yieldaggregator.IntermediaryAccountInfo = (function () {
      /**
       * Properties of an IntermediaryAccountInfo.
       * @memberof ununifi.yieldaggregator
       * @interface IIntermediaryAccountInfo
       * @property {Array.<ununifi.yieldaggregator.IChainAddress>|null} [addrs] IntermediaryAccountInfo addrs
       */

      /**
       * Constructs a new IntermediaryAccountInfo.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents an IntermediaryAccountInfo.
       * @implements IIntermediaryAccountInfo
       * @constructor
       * @param {ununifi.yieldaggregator.IIntermediaryAccountInfo=} [properties] Properties to set
       */
      function IntermediaryAccountInfo(properties) {
        this.addrs = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * IntermediaryAccountInfo addrs.
       * @member {Array.<ununifi.yieldaggregator.IChainAddress>} addrs
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @instance
       */
      IntermediaryAccountInfo.prototype.addrs = $util.emptyArray;

      /**
       * Encodes the specified IntermediaryAccountInfo message. Does not implicitly {@link ununifi.yieldaggregator.IntermediaryAccountInfo.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @static
       * @param {ununifi.yieldaggregator.IIntermediaryAccountInfo} message IntermediaryAccountInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IntermediaryAccountInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.addrs != null && message.addrs.length)
          for (let i = 0; i < message.addrs.length; ++i)
            $root.ununifi.yieldaggregator.ChainAddress.encode(message.addrs[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified IntermediaryAccountInfo message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.IntermediaryAccountInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @static
       * @param {ununifi.yieldaggregator.IIntermediaryAccountInfo} message IntermediaryAccountInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      IntermediaryAccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an IntermediaryAccountInfo message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.IntermediaryAccountInfo} IntermediaryAccountInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IntermediaryAccountInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.IntermediaryAccountInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.addrs && message.addrs.length)) message.addrs = [];
              message.addrs.push($root.ununifi.yieldaggregator.ChainAddress.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an IntermediaryAccountInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.IntermediaryAccountInfo} IntermediaryAccountInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      IntermediaryAccountInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an IntermediaryAccountInfo message.
       * @function verify
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      IntermediaryAccountInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.addrs != null && message.hasOwnProperty('addrs')) {
          if (!Array.isArray(message.addrs)) return 'addrs: array expected';
          for (let i = 0; i < message.addrs.length; ++i) {
            let error = $root.ununifi.yieldaggregator.ChainAddress.verify(message.addrs[i]);
            if (error) return 'addrs.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an IntermediaryAccountInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.IntermediaryAccountInfo} IntermediaryAccountInfo
       */
      IntermediaryAccountInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.IntermediaryAccountInfo) return object;
        let message = new $root.ununifi.yieldaggregator.IntermediaryAccountInfo();
        if (object.addrs) {
          if (!Array.isArray(object.addrs)) throw TypeError('.ununifi.yieldaggregator.IntermediaryAccountInfo.addrs: array expected');
          message.addrs = [];
          for (let i = 0; i < object.addrs.length; ++i) {
            if (typeof object.addrs[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.IntermediaryAccountInfo.addrs: object expected');
            message.addrs[i] = $root.ununifi.yieldaggregator.ChainAddress.fromObject(object.addrs[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an IntermediaryAccountInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @static
       * @param {ununifi.yieldaggregator.IntermediaryAccountInfo} message IntermediaryAccountInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      IntermediaryAccountInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.addrs = [];
        if (message.addrs && message.addrs.length) {
          object.addrs = [];
          for (let j = 0; j < message.addrs.length; ++j)
            object.addrs[j] = $root.ununifi.yieldaggregator.ChainAddress.toObject(message.addrs[j], options);
        }
        return object;
      };

      /**
       * Converts this IntermediaryAccountInfo to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.IntermediaryAccountInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      IntermediaryAccountInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return IntermediaryAccountInfo;
    })();

    yieldaggregator.LegacyStrategyWeight = (function () {
      /**
       * Properties of a LegacyStrategyWeight.
       * @memberof ununifi.yieldaggregator
       * @interface ILegacyStrategyWeight
       * @property {Long|null} [strategy_id] LegacyStrategyWeight strategy_id
       * @property {string|null} [weight] LegacyStrategyWeight weight
       */

      /**
       * Constructs a new LegacyStrategyWeight.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a LegacyStrategyWeight.
       * @implements ILegacyStrategyWeight
       * @constructor
       * @param {ununifi.yieldaggregator.ILegacyStrategyWeight=} [properties] Properties to set
       */
      function LegacyStrategyWeight(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * LegacyStrategyWeight strategy_id.
       * @member {Long} strategy_id
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @instance
       */
      LegacyStrategyWeight.prototype.strategy_id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * LegacyStrategyWeight weight.
       * @member {string} weight
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @instance
       */
      LegacyStrategyWeight.prototype.weight = '';

      /**
       * Encodes the specified LegacyStrategyWeight message. Does not implicitly {@link ununifi.yieldaggregator.LegacyStrategyWeight.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @static
       * @param {ununifi.yieldaggregator.ILegacyStrategyWeight} message LegacyStrategyWeight message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LegacyStrategyWeight.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategy_id != null && Object.hasOwnProperty.call(message, 'strategy_id'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.strategy_id);
        if (message.weight != null && Object.hasOwnProperty.call(message, 'weight'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.weight);
        return writer;
      };

      /**
       * Encodes the specified LegacyStrategyWeight message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.LegacyStrategyWeight.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @static
       * @param {ununifi.yieldaggregator.ILegacyStrategyWeight} message LegacyStrategyWeight message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LegacyStrategyWeight.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a LegacyStrategyWeight message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.LegacyStrategyWeight} LegacyStrategyWeight
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LegacyStrategyWeight.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.LegacyStrategyWeight();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.strategy_id = reader.uint64();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a LegacyStrategyWeight message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.LegacyStrategyWeight} LegacyStrategyWeight
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LegacyStrategyWeight.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a LegacyStrategyWeight message.
       * @function verify
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      LegacyStrategyWeight.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategy_id != null && message.hasOwnProperty('strategy_id'))
          if (
            !$util.isInteger(message.strategy_id) &&
            !(message.strategy_id && $util.isInteger(message.strategy_id.low) && $util.isInteger(message.strategy_id.high))
          )
            return 'strategy_id: integer|Long expected';
        if (message.weight != null && message.hasOwnProperty('weight'))
          if (!$util.isString(message.weight)) return 'weight: string expected';
        return null;
      };

      /**
       * Creates a LegacyStrategyWeight message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.LegacyStrategyWeight} LegacyStrategyWeight
       */
      LegacyStrategyWeight.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.LegacyStrategyWeight) return object;
        let message = new $root.ununifi.yieldaggregator.LegacyStrategyWeight();
        if (object.strategy_id != null)
          if ($util.Long) (message.strategy_id = $util.Long.fromValue(object.strategy_id)).unsigned = true;
          else if (typeof object.strategy_id === 'string') message.strategy_id = parseInt(object.strategy_id, 10);
          else if (typeof object.strategy_id === 'number') message.strategy_id = object.strategy_id;
          else if (typeof object.strategy_id === 'object')
            message.strategy_id = new $util.LongBits(object.strategy_id.low >>> 0, object.strategy_id.high >>> 0).toNumber(true);
        if (object.weight != null) message.weight = String(object.weight);
        return message;
      };

      /**
       * Creates a plain object from a LegacyStrategyWeight message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @static
       * @param {ununifi.yieldaggregator.LegacyStrategyWeight} message LegacyStrategyWeight
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      LegacyStrategyWeight.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.strategy_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.strategy_id = options.longs === String ? '0' : 0;
          object.weight = '';
        }
        if (message.strategy_id != null && message.hasOwnProperty('strategy_id'))
          if (typeof message.strategy_id === 'number')
            object.strategy_id = options.longs === String ? String(message.strategy_id) : message.strategy_id;
          else
            object.strategy_id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.strategy_id)
                : options.longs === Number
                ? new $util.LongBits(message.strategy_id.low >>> 0, message.strategy_id.high >>> 0).toNumber(true)
                : message.strategy_id;
        if (message.weight != null && message.hasOwnProperty('weight')) object.weight = message.weight;
        return object;
      };

      /**
       * Converts this LegacyStrategyWeight to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.LegacyStrategyWeight
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      LegacyStrategyWeight.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return LegacyStrategyWeight;
    })();

    yieldaggregator.LegacyVault = (function () {
      /**
       * Properties of a LegacyVault.
       * @memberof ununifi.yieldaggregator
       * @interface ILegacyVault
       * @property {Long|null} [id] LegacyVault id
       * @property {string|null} [denom] LegacyVault denom
       * @property {string|null} [name] LegacyVault name
       * @property {string|null} [description] LegacyVault description
       * @property {string|null} [owner] LegacyVault owner
       * @property {cosmos.base.v1beta1.ICoin|null} [owner_deposit] LegacyVault owner_deposit
       * @property {string|null} [withdraw_commission_rate] LegacyVault withdraw_commission_rate
       * @property {string|null} [withdraw_reserve_rate] LegacyVault withdraw_reserve_rate
       * @property {Array.<ununifi.yieldaggregator.ILegacyStrategyWeight>|null} [strategy_weights] LegacyVault strategy_weights
       * @property {string|null} [fee_collector_address] LegacyVault fee_collector_address
       */

      /**
       * Constructs a new LegacyVault.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a LegacyVault.
       * @implements ILegacyVault
       * @constructor
       * @param {ununifi.yieldaggregator.ILegacyVault=} [properties] Properties to set
       */
      function LegacyVault(properties) {
        this.strategy_weights = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * LegacyVault id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * LegacyVault denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.denom = '';

      /**
       * LegacyVault name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.name = '';

      /**
       * LegacyVault description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.description = '';

      /**
       * LegacyVault owner.
       * @member {string} owner
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.owner = '';

      /**
       * LegacyVault owner_deposit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} owner_deposit
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.owner_deposit = null;

      /**
       * LegacyVault withdraw_commission_rate.
       * @member {string} withdraw_commission_rate
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.withdraw_commission_rate = '';

      /**
       * LegacyVault withdraw_reserve_rate.
       * @member {string} withdraw_reserve_rate
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.withdraw_reserve_rate = '';

      /**
       * LegacyVault strategy_weights.
       * @member {Array.<ununifi.yieldaggregator.ILegacyStrategyWeight>} strategy_weights
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.strategy_weights = $util.emptyArray;

      /**
       * LegacyVault fee_collector_address.
       * @member {string} fee_collector_address
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       */
      LegacyVault.prototype.fee_collector_address = '';

      /**
       * Encodes the specified LegacyVault message. Does not implicitly {@link ununifi.yieldaggregator.LegacyVault.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @static
       * @param {ununifi.yieldaggregator.ILegacyVault} message LegacyVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LegacyVault.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.denom);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.name);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.description);
        if (message.owner != null && Object.hasOwnProperty.call(message, 'owner'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.owner);
        if (message.owner_deposit != null && Object.hasOwnProperty.call(message, 'owner_deposit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.owner_deposit, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
        if (message.withdraw_commission_rate != null && Object.hasOwnProperty.call(message, 'withdraw_commission_rate'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.withdraw_commission_rate);
        if (message.withdraw_reserve_rate != null && Object.hasOwnProperty.call(message, 'withdraw_reserve_rate'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.withdraw_reserve_rate);
        if (message.strategy_weights != null && message.strategy_weights.length)
          for (let i = 0; i < message.strategy_weights.length; ++i)
            $root.ununifi.yieldaggregator.LegacyStrategyWeight.encode(
              message.strategy_weights[i],
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
        if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, 'fee_collector_address'))
          writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.fee_collector_address);
        return writer;
      };

      /**
       * Encodes the specified LegacyVault message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.LegacyVault.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @static
       * @param {ununifi.yieldaggregator.ILegacyVault} message LegacyVault message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LegacyVault.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a LegacyVault message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.LegacyVault} LegacyVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LegacyVault.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.LegacyVault();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.denom = reader.string();
              break;
            case 3:
              message.name = reader.string();
              break;
            case 4:
              message.description = reader.string();
              break;
            case 5:
              message.owner = reader.string();
              break;
            case 6:
              message.owner_deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 7:
              message.withdraw_commission_rate = reader.string();
              break;
            case 8:
              message.withdraw_reserve_rate = reader.string();
              break;
            case 9:
              if (!(message.strategy_weights && message.strategy_weights.length)) message.strategy_weights = [];
              message.strategy_weights.push($root.ununifi.yieldaggregator.LegacyStrategyWeight.decode(reader, reader.uint32()));
              break;
            case 10:
              message.fee_collector_address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a LegacyVault message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.LegacyVault} LegacyVault
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LegacyVault.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a LegacyVault message.
       * @function verify
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      LegacyVault.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.owner != null && message.hasOwnProperty('owner')) if (!$util.isString(message.owner)) return 'owner: string expected';
        if (message.owner_deposit != null && message.hasOwnProperty('owner_deposit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.owner_deposit);
          if (error) return 'owner_deposit.' + error;
        }
        if (message.withdraw_commission_rate != null && message.hasOwnProperty('withdraw_commission_rate'))
          if (!$util.isString(message.withdraw_commission_rate)) return 'withdraw_commission_rate: string expected';
        if (message.withdraw_reserve_rate != null && message.hasOwnProperty('withdraw_reserve_rate'))
          if (!$util.isString(message.withdraw_reserve_rate)) return 'withdraw_reserve_rate: string expected';
        if (message.strategy_weights != null && message.hasOwnProperty('strategy_weights')) {
          if (!Array.isArray(message.strategy_weights)) return 'strategy_weights: array expected';
          for (let i = 0; i < message.strategy_weights.length; ++i) {
            let error = $root.ununifi.yieldaggregator.LegacyStrategyWeight.verify(message.strategy_weights[i]);
            if (error) return 'strategy_weights.' + error;
          }
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          if (!$util.isString(message.fee_collector_address)) return 'fee_collector_address: string expected';
        return null;
      };

      /**
       * Creates a LegacyVault message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.LegacyVault} LegacyVault
       */
      LegacyVault.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.LegacyVault) return object;
        let message = new $root.ununifi.yieldaggregator.LegacyVault();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.name != null) message.name = String(object.name);
        if (object.description != null) message.description = String(object.description);
        if (object.owner != null) message.owner = String(object.owner);
        if (object.owner_deposit != null) {
          if (typeof object.owner_deposit !== 'object')
            throw TypeError('.ununifi.yieldaggregator.LegacyVault.owner_deposit: object expected');
          message.owner_deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.owner_deposit);
        }
        if (object.withdraw_commission_rate != null) message.withdraw_commission_rate = String(object.withdraw_commission_rate);
        if (object.withdraw_reserve_rate != null) message.withdraw_reserve_rate = String(object.withdraw_reserve_rate);
        if (object.strategy_weights) {
          if (!Array.isArray(object.strategy_weights))
            throw TypeError('.ununifi.yieldaggregator.LegacyVault.strategy_weights: array expected');
          message.strategy_weights = [];
          for (let i = 0; i < object.strategy_weights.length; ++i) {
            if (typeof object.strategy_weights[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.LegacyVault.strategy_weights: object expected');
            message.strategy_weights[i] = $root.ununifi.yieldaggregator.LegacyStrategyWeight.fromObject(object.strategy_weights[i]);
          }
        }
        if (object.fee_collector_address != null) message.fee_collector_address = String(object.fee_collector_address);
        return message;
      };

      /**
       * Creates a plain object from a LegacyVault message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @static
       * @param {ununifi.yieldaggregator.LegacyVault} message LegacyVault
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      LegacyVault.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.strategy_weights = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.denom = '';
          object.name = '';
          object.description = '';
          object.owner = '';
          object.owner_deposit = null;
          object.withdraw_commission_rate = '';
          object.withdraw_reserve_rate = '';
          object.fee_collector_address = '';
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.owner != null && message.hasOwnProperty('owner')) object.owner = message.owner;
        if (message.owner_deposit != null && message.hasOwnProperty('owner_deposit'))
          object.owner_deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.owner_deposit, options);
        if (message.withdraw_commission_rate != null && message.hasOwnProperty('withdraw_commission_rate'))
          object.withdraw_commission_rate = message.withdraw_commission_rate;
        if (message.withdraw_reserve_rate != null && message.hasOwnProperty('withdraw_reserve_rate'))
          object.withdraw_reserve_rate = message.withdraw_reserve_rate;
        if (message.strategy_weights && message.strategy_weights.length) {
          object.strategy_weights = [];
          for (let j = 0; j < message.strategy_weights.length; ++j)
            object.strategy_weights[j] = $root.ununifi.yieldaggregator.LegacyStrategyWeight.toObject(message.strategy_weights[j], options);
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          object.fee_collector_address = message.fee_collector_address;
        return object;
      };

      /**
       * Converts this LegacyVault to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.LegacyVault
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      LegacyVault.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return LegacyVault;
    })();

    yieldaggregator.LegacyStrategy = (function () {
      /**
       * Properties of a LegacyStrategy.
       * @memberof ununifi.yieldaggregator
       * @interface ILegacyStrategy
       * @property {string|null} [denom] LegacyStrategy denom
       * @property {Long|null} [id] LegacyStrategy id
       * @property {string|null} [contract_address] LegacyStrategy contract_address
       * @property {string|null} [name] LegacyStrategy name
       * @property {string|null} [git_url] LegacyStrategy git_url
       */

      /**
       * Constructs a new LegacyStrategy.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a LegacyStrategy.
       * @implements ILegacyStrategy
       * @constructor
       * @param {ununifi.yieldaggregator.ILegacyStrategy=} [properties] Properties to set
       */
      function LegacyStrategy(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * LegacyStrategy denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @instance
       */
      LegacyStrategy.prototype.denom = '';

      /**
       * LegacyStrategy id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @instance
       */
      LegacyStrategy.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * LegacyStrategy contract_address.
       * @member {string} contract_address
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @instance
       */
      LegacyStrategy.prototype.contract_address = '';

      /**
       * LegacyStrategy name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @instance
       */
      LegacyStrategy.prototype.name = '';

      /**
       * LegacyStrategy git_url.
       * @member {string} git_url
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @instance
       */
      LegacyStrategy.prototype.git_url = '';

      /**
       * Encodes the specified LegacyStrategy message. Does not implicitly {@link ununifi.yieldaggregator.LegacyStrategy.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @static
       * @param {ununifi.yieldaggregator.ILegacyStrategy} message LegacyStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LegacyStrategy.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.id);
        if (message.contract_address != null && Object.hasOwnProperty.call(message, 'contract_address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.contract_address);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.name);
        if (message.git_url != null && Object.hasOwnProperty.call(message, 'git_url'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.git_url);
        return writer;
      };

      /**
       * Encodes the specified LegacyStrategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.LegacyStrategy.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @static
       * @param {ununifi.yieldaggregator.ILegacyStrategy} message LegacyStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      LegacyStrategy.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a LegacyStrategy message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.LegacyStrategy} LegacyStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LegacyStrategy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.LegacyStrategy();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.id = reader.uint64();
              break;
            case 3:
              message.contract_address = reader.string();
              break;
            case 4:
              message.name = reader.string();
              break;
            case 5:
              message.git_url = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a LegacyStrategy message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.LegacyStrategy} LegacyStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      LegacyStrategy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a LegacyStrategy message.
       * @function verify
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      LegacyStrategy.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          if (!$util.isString(message.contract_address)) return 'contract_address: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.git_url != null && message.hasOwnProperty('git_url'))
          if (!$util.isString(message.git_url)) return 'git_url: string expected';
        return null;
      };

      /**
       * Creates a LegacyStrategy message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.LegacyStrategy} LegacyStrategy
       */
      LegacyStrategy.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.LegacyStrategy) return object;
        let message = new $root.ununifi.yieldaggregator.LegacyStrategy();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.contract_address != null) message.contract_address = String(object.contract_address);
        if (object.name != null) message.name = String(object.name);
        if (object.git_url != null) message.git_url = String(object.git_url);
        return message;
      };

      /**
       * Creates a plain object from a LegacyStrategy message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @static
       * @param {ununifi.yieldaggregator.LegacyStrategy} message LegacyStrategy
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      LegacyStrategy.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.contract_address = '';
          object.name = '';
          object.git_url = '';
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          object.contract_address = message.contract_address;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.git_url != null && message.hasOwnProperty('git_url')) object.git_url = message.git_url;
        return object;
      };

      /**
       * Converts this LegacyStrategy to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.LegacyStrategy
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      LegacyStrategy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return LegacyStrategy;
    })();

    yieldaggregator.ProposalAddStrategy = (function () {
      /**
       * Properties of a ProposalAddStrategy.
       * @memberof ununifi.yieldaggregator
       * @interface IProposalAddStrategy
       * @property {string|null} [title] ProposalAddStrategy title
       * @property {string|null} [description] ProposalAddStrategy description
       * @property {string|null} [denom] ProposalAddStrategy denom
       * @property {string|null} [contract_address] ProposalAddStrategy contract_address
       * @property {string|null} [name] ProposalAddStrategy name
       * @property {string|null} [git_url] ProposalAddStrategy git_url
       */

      /**
       * Constructs a new ProposalAddStrategy.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a ProposalAddStrategy.
       * @implements IProposalAddStrategy
       * @constructor
       * @param {ununifi.yieldaggregator.IProposalAddStrategy=} [properties] Properties to set
       */
      function ProposalAddStrategy(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ProposalAddStrategy title.
       * @member {string} title
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @instance
       */
      ProposalAddStrategy.prototype.title = '';

      /**
       * ProposalAddStrategy description.
       * @member {string} description
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @instance
       */
      ProposalAddStrategy.prototype.description = '';

      /**
       * ProposalAddStrategy denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @instance
       */
      ProposalAddStrategy.prototype.denom = '';

      /**
       * ProposalAddStrategy contract_address.
       * @member {string} contract_address
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @instance
       */
      ProposalAddStrategy.prototype.contract_address = '';

      /**
       * ProposalAddStrategy name.
       * @member {string} name
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @instance
       */
      ProposalAddStrategy.prototype.name = '';

      /**
       * ProposalAddStrategy git_url.
       * @member {string} git_url
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @instance
       */
      ProposalAddStrategy.prototype.git_url = '';

      /**
       * Encodes the specified ProposalAddStrategy message. Does not implicitly {@link ununifi.yieldaggregator.ProposalAddStrategy.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @static
       * @param {ununifi.yieldaggregator.IProposalAddStrategy} message ProposalAddStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ProposalAddStrategy.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.title != null && Object.hasOwnProperty.call(message, 'title'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.title);
        if (message.description != null && Object.hasOwnProperty.call(message, 'description'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.description);
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.denom);
        if (message.contract_address != null && Object.hasOwnProperty.call(message, 'contract_address'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.contract_address);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.name);
        if (message.git_url != null && Object.hasOwnProperty.call(message, 'git_url'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.git_url);
        return writer;
      };

      /**
       * Encodes the specified ProposalAddStrategy message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.ProposalAddStrategy.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @static
       * @param {ununifi.yieldaggregator.IProposalAddStrategy} message ProposalAddStrategy message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ProposalAddStrategy.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ProposalAddStrategy message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.ProposalAddStrategy} ProposalAddStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ProposalAddStrategy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.ProposalAddStrategy();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.denom = reader.string();
              break;
            case 4:
              message.contract_address = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.git_url = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ProposalAddStrategy message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.ProposalAddStrategy} ProposalAddStrategy
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ProposalAddStrategy.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ProposalAddStrategy message.
       * @function verify
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ProposalAddStrategy.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.title != null && message.hasOwnProperty('title')) if (!$util.isString(message.title)) return 'title: string expected';
        if (message.description != null && message.hasOwnProperty('description'))
          if (!$util.isString(message.description)) return 'description: string expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          if (!$util.isString(message.contract_address)) return 'contract_address: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.git_url != null && message.hasOwnProperty('git_url'))
          if (!$util.isString(message.git_url)) return 'git_url: string expected';
        return null;
      };

      /**
       * Creates a ProposalAddStrategy message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.ProposalAddStrategy} ProposalAddStrategy
       */
      ProposalAddStrategy.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.ProposalAddStrategy) return object;
        let message = new $root.ununifi.yieldaggregator.ProposalAddStrategy();
        if (object.title != null) message.title = String(object.title);
        if (object.description != null) message.description = String(object.description);
        if (object.denom != null) message.denom = String(object.denom);
        if (object.contract_address != null) message.contract_address = String(object.contract_address);
        if (object.name != null) message.name = String(object.name);
        if (object.git_url != null) message.git_url = String(object.git_url);
        return message;
      };

      /**
       * Creates a plain object from a ProposalAddStrategy message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @static
       * @param {ununifi.yieldaggregator.ProposalAddStrategy} message ProposalAddStrategy
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ProposalAddStrategy.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.title = '';
          object.description = '';
          object.denom = '';
          object.contract_address = '';
          object.name = '';
          object.git_url = '';
        }
        if (message.title != null && message.hasOwnProperty('title')) object.title = message.title;
        if (message.description != null && message.hasOwnProperty('description')) object.description = message.description;
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          object.contract_address = message.contract_address;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.git_url != null && message.hasOwnProperty('git_url')) object.git_url = message.git_url;
        return object;
      };

      /**
       * Converts this ProposalAddStrategy to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.ProposalAddStrategy
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ProposalAddStrategy.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ProposalAddStrategy;
    })();

    yieldaggregator.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof ununifi.yieldaggregator
       * @interface IParams
       * @property {string|null} [commission_rate] Params commission_rate
       * @property {cosmos.base.v1beta1.ICoin|null} [vault_creation_fee] Params vault_creation_fee
       * @property {cosmos.base.v1beta1.ICoin|null} [vault_creation_deposit] Params vault_creation_deposit
       * @property {string|null} [fee_collector_address] Params fee_collector_address
       * @property {Long|null} [ibc_transfer_timeout_nanos] Params ibc_transfer_timeout_nanos
       */

      /**
       * Constructs a new Params.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {ununifi.yieldaggregator.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Params commission_rate.
       * @member {string} commission_rate
       * @memberof ununifi.yieldaggregator.Params
       * @instance
       */
      Params.prototype.commission_rate = '';

      /**
       * Params vault_creation_fee.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} vault_creation_fee
       * @memberof ununifi.yieldaggregator.Params
       * @instance
       */
      Params.prototype.vault_creation_fee = null;

      /**
       * Params vault_creation_deposit.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} vault_creation_deposit
       * @memberof ununifi.yieldaggregator.Params
       * @instance
       */
      Params.prototype.vault_creation_deposit = null;

      /**
       * Params fee_collector_address.
       * @member {string} fee_collector_address
       * @memberof ununifi.yieldaggregator.Params
       * @instance
       */
      Params.prototype.fee_collector_address = '';

      /**
       * Params ibc_transfer_timeout_nanos.
       * @member {Long} ibc_transfer_timeout_nanos
       * @memberof ununifi.yieldaggregator.Params
       * @instance
       */
      Params.prototype.ibc_transfer_timeout_nanos = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified Params message. Does not implicitly {@link ununifi.yieldaggregator.Params.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.Params
       * @static
       * @param {ununifi.yieldaggregator.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.commission_rate != null && Object.hasOwnProperty.call(message, 'commission_rate'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.commission_rate);
        if (message.vault_creation_fee != null && Object.hasOwnProperty.call(message, 'vault_creation_fee'))
          $root.cosmos.base.v1beta1.Coin.encode(message.vault_creation_fee, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.vault_creation_deposit != null && Object.hasOwnProperty.call(message, 'vault_creation_deposit'))
          $root.cosmos.base.v1beta1.Coin.encode(message.vault_creation_deposit, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.fee_collector_address != null && Object.hasOwnProperty.call(message, 'fee_collector_address'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.fee_collector_address);
        if (message.ibc_transfer_timeout_nanos != null && Object.hasOwnProperty.call(message, 'ibc_transfer_timeout_nanos'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).uint64(message.ibc_transfer_timeout_nanos);
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.Params
       * @static
       * @param {ununifi.yieldaggregator.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission_rate = reader.string();
              break;
            case 2:
              message.vault_creation_fee = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 3:
              message.vault_creation_deposit = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.fee_collector_address = reader.string();
              break;
            case 5:
              message.ibc_transfer_timeout_nanos = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof ununifi.yieldaggregator.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.commission_rate != null && message.hasOwnProperty('commission_rate'))
          if (!$util.isString(message.commission_rate)) return 'commission_rate: string expected';
        if (message.vault_creation_fee != null && message.hasOwnProperty('vault_creation_fee')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.vault_creation_fee);
          if (error) return 'vault_creation_fee.' + error;
        }
        if (message.vault_creation_deposit != null && message.hasOwnProperty('vault_creation_deposit')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.vault_creation_deposit);
          if (error) return 'vault_creation_deposit.' + error;
        }
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          if (!$util.isString(message.fee_collector_address)) return 'fee_collector_address: string expected';
        if (message.ibc_transfer_timeout_nanos != null && message.hasOwnProperty('ibc_transfer_timeout_nanos'))
          if (
            !$util.isInteger(message.ibc_transfer_timeout_nanos) &&
            !(
              message.ibc_transfer_timeout_nanos &&
              $util.isInteger(message.ibc_transfer_timeout_nanos.low) &&
              $util.isInteger(message.ibc_transfer_timeout_nanos.high)
            )
          )
            return 'ibc_transfer_timeout_nanos: integer|Long expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.Params) return object;
        let message = new $root.ununifi.yieldaggregator.Params();
        if (object.commission_rate != null) message.commission_rate = String(object.commission_rate);
        if (object.vault_creation_fee != null) {
          if (typeof object.vault_creation_fee !== 'object')
            throw TypeError('.ununifi.yieldaggregator.Params.vault_creation_fee: object expected');
          message.vault_creation_fee = $root.cosmos.base.v1beta1.Coin.fromObject(object.vault_creation_fee);
        }
        if (object.vault_creation_deposit != null) {
          if (typeof object.vault_creation_deposit !== 'object')
            throw TypeError('.ununifi.yieldaggregator.Params.vault_creation_deposit: object expected');
          message.vault_creation_deposit = $root.cosmos.base.v1beta1.Coin.fromObject(object.vault_creation_deposit);
        }
        if (object.fee_collector_address != null) message.fee_collector_address = String(object.fee_collector_address);
        if (object.ibc_transfer_timeout_nanos != null)
          if ($util.Long) (message.ibc_transfer_timeout_nanos = $util.Long.fromValue(object.ibc_transfer_timeout_nanos)).unsigned = true;
          else if (typeof object.ibc_transfer_timeout_nanos === 'string')
            message.ibc_transfer_timeout_nanos = parseInt(object.ibc_transfer_timeout_nanos, 10);
          else if (typeof object.ibc_transfer_timeout_nanos === 'number')
            message.ibc_transfer_timeout_nanos = object.ibc_transfer_timeout_nanos;
          else if (typeof object.ibc_transfer_timeout_nanos === 'object')
            message.ibc_transfer_timeout_nanos = new $util.LongBits(
              object.ibc_transfer_timeout_nanos.low >>> 0,
              object.ibc_transfer_timeout_nanos.high >>> 0,
            ).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.Params
       * @static
       * @param {ununifi.yieldaggregator.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.commission_rate = '';
          object.vault_creation_fee = null;
          object.vault_creation_deposit = null;
          object.fee_collector_address = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.ibc_transfer_timeout_nanos =
              options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.ibc_transfer_timeout_nanos = options.longs === String ? '0' : 0;
        }
        if (message.commission_rate != null && message.hasOwnProperty('commission_rate')) object.commission_rate = message.commission_rate;
        if (message.vault_creation_fee != null && message.hasOwnProperty('vault_creation_fee'))
          object.vault_creation_fee = $root.cosmos.base.v1beta1.Coin.toObject(message.vault_creation_fee, options);
        if (message.vault_creation_deposit != null && message.hasOwnProperty('vault_creation_deposit'))
          object.vault_creation_deposit = $root.cosmos.base.v1beta1.Coin.toObject(message.vault_creation_deposit, options);
        if (message.fee_collector_address != null && message.hasOwnProperty('fee_collector_address'))
          object.fee_collector_address = message.fee_collector_address;
        if (message.ibc_transfer_timeout_nanos != null && message.hasOwnProperty('ibc_transfer_timeout_nanos'))
          if (typeof message.ibc_transfer_timeout_nanos === 'number')
            object.ibc_transfer_timeout_nanos =
              options.longs === String ? String(message.ibc_transfer_timeout_nanos) : message.ibc_transfer_timeout_nanos;
          else
            object.ibc_transfer_timeout_nanos =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.ibc_transfer_timeout_nanos)
                : options.longs === Number
                ? new $util.LongBits(message.ibc_transfer_timeout_nanos.low >>> 0, message.ibc_transfer_timeout_nanos.high >>> 0).toNumber(
                    true,
                  )
                : message.ibc_transfer_timeout_nanos;
        return object;
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    yieldaggregator.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof ununifi.yieldaggregator
       * @interface IGenesisState
       * @property {ununifi.yieldaggregator.IParams|null} [params] GenesisState params
       * @property {Array.<ununifi.yieldaggregator.IVault>|null} [vaults] GenesisState vaults
       * @property {Array.<ununifi.yieldaggregator.IStrategy>|null} [strategies] GenesisState strategies
       */

      /**
       * Constructs a new GenesisState.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {ununifi.yieldaggregator.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.vaults = [];
        this.strategies = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {ununifi.yieldaggregator.IParams|null|undefined} params
       * @memberof ununifi.yieldaggregator.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState vaults.
       * @member {Array.<ununifi.yieldaggregator.IVault>} vaults
       * @memberof ununifi.yieldaggregator.GenesisState
       * @instance
       */
      GenesisState.prototype.vaults = $util.emptyArray;

      /**
       * GenesisState strategies.
       * @member {Array.<ununifi.yieldaggregator.IStrategy>} strategies
       * @memberof ununifi.yieldaggregator.GenesisState
       * @instance
       */
      GenesisState.prototype.strategies = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link ununifi.yieldaggregator.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.GenesisState
       * @static
       * @param {ununifi.yieldaggregator.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.yieldaggregator.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.vaults != null && message.vaults.length)
          for (let i = 0; i < message.vaults.length; ++i)
            $root.ununifi.yieldaggregator.Vault.encode(message.vaults[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.strategies != null && message.strategies.length)
          for (let i = 0; i < message.strategies.length; ++i)
            $root.ununifi.yieldaggregator.Strategy.encode(message.strategies[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.GenesisState
       * @static
       * @param {ununifi.yieldaggregator.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.yieldaggregator.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.vaults && message.vaults.length)) message.vaults = [];
              message.vaults.push($root.ununifi.yieldaggregator.Vault.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.strategies && message.strategies.length)) message.strategies = [];
              message.strategies.push($root.ununifi.yieldaggregator.Strategy.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof ununifi.yieldaggregator.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.yieldaggregator.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.vaults != null && message.hasOwnProperty('vaults')) {
          if (!Array.isArray(message.vaults)) return 'vaults: array expected';
          for (let i = 0; i < message.vaults.length; ++i) {
            let error = $root.ununifi.yieldaggregator.Vault.verify(message.vaults[i]);
            if (error) return 'vaults.' + error;
          }
        }
        if (message.strategies != null && message.hasOwnProperty('strategies')) {
          if (!Array.isArray(message.strategies)) return 'strategies: array expected';
          for (let i = 0; i < message.strategies.length; ++i) {
            let error = $root.ununifi.yieldaggregator.Strategy.verify(message.strategies[i]);
            if (error) return 'strategies.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.GenesisState) return object;
        let message = new $root.ununifi.yieldaggregator.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.yieldaggregator.GenesisState.params: object expected');
          message.params = $root.ununifi.yieldaggregator.Params.fromObject(object.params);
        }
        if (object.vaults) {
          if (!Array.isArray(object.vaults)) throw TypeError('.ununifi.yieldaggregator.GenesisState.vaults: array expected');
          message.vaults = [];
          for (let i = 0; i < object.vaults.length; ++i) {
            if (typeof object.vaults[i] !== 'object') throw TypeError('.ununifi.yieldaggregator.GenesisState.vaults: object expected');
            message.vaults[i] = $root.ununifi.yieldaggregator.Vault.fromObject(object.vaults[i]);
          }
        }
        if (object.strategies) {
          if (!Array.isArray(object.strategies)) throw TypeError('.ununifi.yieldaggregator.GenesisState.strategies: array expected');
          message.strategies = [];
          for (let i = 0; i < object.strategies.length; ++i) {
            if (typeof object.strategies[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.GenesisState.strategies: object expected');
            message.strategies[i] = $root.ununifi.yieldaggregator.Strategy.fromObject(object.strategies[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.GenesisState
       * @static
       * @param {ununifi.yieldaggregator.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.vaults = [];
          object.strategies = [];
        }
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.yieldaggregator.Params.toObject(message.params, options);
        if (message.vaults && message.vaults.length) {
          object.vaults = [];
          for (let j = 0; j < message.vaults.length; ++j)
            object.vaults[j] = $root.ununifi.yieldaggregator.Vault.toObject(message.vaults[j], options);
        }
        if (message.strategies && message.strategies.length) {
          object.strategies = [];
          for (let j = 0; j < message.strategies.length; ++j)
            object.strategies[j] = $root.ununifi.yieldaggregator.Strategy.toObject(message.strategies[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    yieldaggregator.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#params}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.ununifi.yieldaggregator.QueryParamsRequest,
            $root.ununifi.yieldaggregator.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#vaultAll}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef VaultAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryAllVaultResponse} [response] QueryAllVaultResponse
       */

      /**
       * Calls VaultAll.
       * @function vaultAll
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} request QueryAllVaultRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.VaultAllCallback} callback Node-style callback called with the error, if any, and QueryAllVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.vaultAll = function vaultAll(request, callback) {
          return this.rpcCall(
            vaultAll,
            $root.ununifi.yieldaggregator.QueryAllVaultRequest,
            $root.ununifi.yieldaggregator.QueryAllVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'VaultAll' },
      );

      /**
       * Calls VaultAll.
       * @function vaultAll
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} request QueryAllVaultRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryAllVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#vaultAllByShareHolder}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef VaultAllByShareHolderCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse} [response] QueryAllVaultByShareHolderResponse
       */

      /**
       * Calls VaultAllByShareHolder.
       * @function vaultAllByShareHolder
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderRequest} request QueryAllVaultByShareHolderRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.VaultAllByShareHolderCallback} callback Node-style callback called with the error, if any, and QueryAllVaultByShareHolderResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.vaultAllByShareHolder = function vaultAllByShareHolder(request, callback) {
          return this.rpcCall(
            vaultAllByShareHolder,
            $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest,
            $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'VaultAllByShareHolder' },
      );

      /**
       * Calls VaultAllByShareHolder.
       * @function vaultAllByShareHolder
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderRequest} request QueryAllVaultByShareHolderRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#vault}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef VaultCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryGetVaultResponse} [response] QueryGetVaultResponse
       */

      /**
       * Calls Vault.
       * @function vault
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} request QueryGetVaultRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.VaultCallback} callback Node-style callback called with the error, if any, and QueryGetVaultResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.vault = function vault(request, callback) {
          return this.rpcCall(
            vault,
            $root.ununifi.yieldaggregator.QueryGetVaultRequest,
            $root.ununifi.yieldaggregator.QueryGetVaultResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Vault' },
      );

      /**
       * Calls Vault.
       * @function vault
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} request QueryGetVaultRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryGetVaultResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#strategyAll}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef StrategyAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryAllStrategyResponse} [response] QueryAllStrategyResponse
       */

      /**
       * Calls StrategyAll.
       * @function strategyAll
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} request QueryAllStrategyRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.StrategyAllCallback} callback Node-style callback called with the error, if any, and QueryAllStrategyResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.strategyAll = function strategyAll(request, callback) {
          return this.rpcCall(
            strategyAll,
            $root.ununifi.yieldaggregator.QueryAllStrategyRequest,
            $root.ununifi.yieldaggregator.QueryAllStrategyResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'StrategyAll' },
      );

      /**
       * Calls StrategyAll.
       * @function strategyAll
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} request QueryAllStrategyRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryAllStrategyResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#strategy}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef StrategyCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryGetStrategyResponse} [response] QueryGetStrategyResponse
       */

      /**
       * Calls Strategy.
       * @function strategy
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} request QueryGetStrategyRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.StrategyCallback} callback Node-style callback called with the error, if any, and QueryGetStrategyResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.strategy = function strategy(request, callback) {
          return this.rpcCall(
            strategy,
            $root.ununifi.yieldaggregator.QueryGetStrategyRequest,
            $root.ununifi.yieldaggregator.QueryGetStrategyResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Strategy' },
      );

      /**
       * Calls Strategy.
       * @function strategy
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} request QueryGetStrategyRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryGetStrategyResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#estimateMintAmount}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef EstimateMintAmountCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} [response] QueryEstimateMintAmountResponse
       */

      /**
       * Calls EstimateMintAmount.
       * @function estimateMintAmount
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} request QueryEstimateMintAmountRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.EstimateMintAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateMintAmountResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateMintAmount = function estimateMintAmount(request, callback) {
          return this.rpcCall(
            estimateMintAmount,
            $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest,
            $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateMintAmount' },
      );

      /**
       * Calls EstimateMintAmount.
       * @function estimateMintAmount
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} request QueryEstimateMintAmountRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryEstimateMintAmountResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#estimateRedeemAmount}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef EstimateRedeemAmountCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} [response] QueryEstimateRedeemAmountResponse
       */

      /**
       * Calls EstimateRedeemAmount.
       * @function estimateRedeemAmount
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} request QueryEstimateRedeemAmountRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.EstimateRedeemAmountCallback} callback Node-style callback called with the error, if any, and QueryEstimateRedeemAmountResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.estimateRedeemAmount = function estimateRedeemAmount(request, callback) {
          return this.rpcCall(
            estimateRedeemAmount,
            $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest,
            $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'EstimateRedeemAmount' },
      );

      /**
       * Calls EstimateRedeemAmount.
       * @function estimateRedeemAmount
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} request QueryEstimateRedeemAmountRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#denomInfos}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef DenomInfosCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryDenomInfosResponse} [response] QueryDenomInfosResponse
       */

      /**
       * Calls DenomInfos.
       * @function denomInfos
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryDenomInfosRequest} request QueryDenomInfosRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.DenomInfosCallback} callback Node-style callback called with the error, if any, and QueryDenomInfosResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.denomInfos = function denomInfos(request, callback) {
          return this.rpcCall(
            denomInfos,
            $root.ununifi.yieldaggregator.QueryDenomInfosRequest,
            $root.ununifi.yieldaggregator.QueryDenomInfosResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'DenomInfos' },
      );

      /**
       * Calls DenomInfos.
       * @function denomInfos
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryDenomInfosRequest} request QueryDenomInfosRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryDenomInfosResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#symbolInfos}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef SymbolInfosCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QuerySymbolInfosResponse} [response] QuerySymbolInfosResponse
       */

      /**
       * Calls SymbolInfos.
       * @function symbolInfos
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosRequest} request QuerySymbolInfosRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.SymbolInfosCallback} callback Node-style callback called with the error, if any, and QuerySymbolInfosResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.symbolInfos = function symbolInfos(request, callback) {
          return this.rpcCall(
            symbolInfos,
            $root.ununifi.yieldaggregator.QuerySymbolInfosRequest,
            $root.ununifi.yieldaggregator.QuerySymbolInfosResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'SymbolInfos' },
      );

      /**
       * Calls SymbolInfos.
       * @function symbolInfos
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosRequest} request QuerySymbolInfosRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QuerySymbolInfosResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link ununifi.yieldaggregator.Query#intermediaryAccountInfo}.
       * @memberof ununifi.yieldaggregator.Query
       * @typedef IntermediaryAccountInfoCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse} [response] QueryIntermediaryAccountInfoResponse
       */

      /**
       * Calls IntermediaryAccountInfo.
       * @function intermediaryAccountInfo
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoRequest} request QueryIntermediaryAccountInfoRequest message or plain object
       * @param {ununifi.yieldaggregator.Query.IntermediaryAccountInfoCallback} callback Node-style callback called with the error, if any, and QueryIntermediaryAccountInfoResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.intermediaryAccountInfo = function intermediaryAccountInfo(request, callback) {
          return this.rpcCall(
            intermediaryAccountInfo,
            $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest,
            $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'IntermediaryAccountInfo' },
      );

      /**
       * Calls IntermediaryAccountInfo.
       * @function intermediaryAccountInfo
       * @memberof ununifi.yieldaggregator.Query
       * @instance
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoRequest} request QueryIntermediaryAccountInfoRequest message or plain object
       * @returns {Promise<ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    yieldaggregator.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryParamsRequest) return object;
        return new $root.ununifi.yieldaggregator.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    yieldaggregator.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryParamsResponse
       * @property {ununifi.yieldaggregator.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {ununifi.yieldaggregator.IParams|null|undefined} params
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.ununifi.yieldaggregator.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.ununifi.yieldaggregator.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.ununifi.yieldaggregator.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryParamsResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.ununifi.yieldaggregator.QueryParamsResponse.params: object expected');
          message.params = $root.ununifi.yieldaggregator.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.ununifi.yieldaggregator.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    yieldaggregator.QueryAllVaultRequest = (function () {
      /**
       * Properties of a QueryAllVaultRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryAllVaultRequest
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllVaultRequest pagination
       */

      /**
       * Constructs a new QueryAllVaultRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryAllVaultRequest.
       * @implements IQueryAllVaultRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryAllVaultRequest=} [properties] Properties to set
       */
      function QueryAllVaultRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllVaultRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @instance
       */
      QueryAllVaultRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllVaultRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} message QueryAllVaultRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllVaultRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultRequest} message QueryAllVaultRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllVaultRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryAllVaultRequest} QueryAllVaultRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryAllVaultRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllVaultRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryAllVaultRequest} QueryAllVaultRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllVaultRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllVaultRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllVaultRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryAllVaultRequest} QueryAllVaultRequest
       */
      QueryAllVaultRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryAllVaultRequest) return object;
        let message = new $root.ununifi.yieldaggregator.QueryAllVaultRequest();
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.yieldaggregator.QueryAllVaultRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllVaultRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryAllVaultRequest} message QueryAllVaultRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllVaultRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.pagination = null;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllVaultRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryAllVaultRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllVaultRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllVaultRequest;
    })();

    yieldaggregator.VaultContainer = (function () {
      /**
       * Properties of a VaultContainer.
       * @memberof ununifi.yieldaggregator
       * @interface IVaultContainer
       * @property {ununifi.yieldaggregator.IVault|null} [vault] VaultContainer vault
       * @property {string|null} [total_bonded_amount] VaultContainer total_bonded_amount
       * @property {string|null} [total_unbonding_amount] VaultContainer total_unbonding_amount
       * @property {string|null} [withdraw_reserve] VaultContainer withdraw_reserve
       * @property {string|null} [total_pending_deposit] VaultContainer total_pending_deposit
       */

      /**
       * Constructs a new VaultContainer.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a VaultContainer.
       * @implements IVaultContainer
       * @constructor
       * @param {ununifi.yieldaggregator.IVaultContainer=} [properties] Properties to set
       */
      function VaultContainer(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * VaultContainer vault.
       * @member {ununifi.yieldaggregator.IVault|null|undefined} vault
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @instance
       */
      VaultContainer.prototype.vault = null;

      /**
       * VaultContainer total_bonded_amount.
       * @member {string} total_bonded_amount
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @instance
       */
      VaultContainer.prototype.total_bonded_amount = '';

      /**
       * VaultContainer total_unbonding_amount.
       * @member {string} total_unbonding_amount
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @instance
       */
      VaultContainer.prototype.total_unbonding_amount = '';

      /**
       * VaultContainer withdraw_reserve.
       * @member {string} withdraw_reserve
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @instance
       */
      VaultContainer.prototype.withdraw_reserve = '';

      /**
       * VaultContainer total_pending_deposit.
       * @member {string} total_pending_deposit
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @instance
       */
      VaultContainer.prototype.total_pending_deposit = '';

      /**
       * Encodes the specified VaultContainer message. Does not implicitly {@link ununifi.yieldaggregator.VaultContainer.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @static
       * @param {ununifi.yieldaggregator.IVaultContainer} message VaultContainer message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      VaultContainer.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vault != null && Object.hasOwnProperty.call(message, 'vault'))
          $root.ununifi.yieldaggregator.Vault.encode(message.vault, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.total_bonded_amount != null && Object.hasOwnProperty.call(message, 'total_bonded_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.total_bonded_amount);
        if (message.total_unbonding_amount != null && Object.hasOwnProperty.call(message, 'total_unbonding_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.total_unbonding_amount);
        if (message.withdraw_reserve != null && Object.hasOwnProperty.call(message, 'withdraw_reserve'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.withdraw_reserve);
        if (message.total_pending_deposit != null && Object.hasOwnProperty.call(message, 'total_pending_deposit'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.total_pending_deposit);
        return writer;
      };

      /**
       * Encodes the specified VaultContainer message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.VaultContainer.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @static
       * @param {ununifi.yieldaggregator.IVaultContainer} message VaultContainer message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      VaultContainer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a VaultContainer message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.VaultContainer} VaultContainer
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      VaultContainer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.VaultContainer();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vault = $root.ununifi.yieldaggregator.Vault.decode(reader, reader.uint32());
              break;
            case 2:
              message.total_bonded_amount = reader.string();
              break;
            case 3:
              message.total_unbonding_amount = reader.string();
              break;
            case 4:
              message.withdraw_reserve = reader.string();
              break;
            case 5:
              message.total_pending_deposit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a VaultContainer message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.VaultContainer} VaultContainer
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      VaultContainer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a VaultContainer message.
       * @function verify
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      VaultContainer.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vault != null && message.hasOwnProperty('vault')) {
          let error = $root.ununifi.yieldaggregator.Vault.verify(message.vault);
          if (error) return 'vault.' + error;
        }
        if (message.total_bonded_amount != null && message.hasOwnProperty('total_bonded_amount'))
          if (!$util.isString(message.total_bonded_amount)) return 'total_bonded_amount: string expected';
        if (message.total_unbonding_amount != null && message.hasOwnProperty('total_unbonding_amount'))
          if (!$util.isString(message.total_unbonding_amount)) return 'total_unbonding_amount: string expected';
        if (message.withdraw_reserve != null && message.hasOwnProperty('withdraw_reserve'))
          if (!$util.isString(message.withdraw_reserve)) return 'withdraw_reserve: string expected';
        if (message.total_pending_deposit != null && message.hasOwnProperty('total_pending_deposit'))
          if (!$util.isString(message.total_pending_deposit)) return 'total_pending_deposit: string expected';
        return null;
      };

      /**
       * Creates a VaultContainer message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.VaultContainer} VaultContainer
       */
      VaultContainer.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.VaultContainer) return object;
        let message = new $root.ununifi.yieldaggregator.VaultContainer();
        if (object.vault != null) {
          if (typeof object.vault !== 'object') throw TypeError('.ununifi.yieldaggregator.VaultContainer.vault: object expected');
          message.vault = $root.ununifi.yieldaggregator.Vault.fromObject(object.vault);
        }
        if (object.total_bonded_amount != null) message.total_bonded_amount = String(object.total_bonded_amount);
        if (object.total_unbonding_amount != null) message.total_unbonding_amount = String(object.total_unbonding_amount);
        if (object.withdraw_reserve != null) message.withdraw_reserve = String(object.withdraw_reserve);
        if (object.total_pending_deposit != null) message.total_pending_deposit = String(object.total_pending_deposit);
        return message;
      };

      /**
       * Creates a plain object from a VaultContainer message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @static
       * @param {ununifi.yieldaggregator.VaultContainer} message VaultContainer
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      VaultContainer.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.vault = null;
          object.total_bonded_amount = '';
          object.total_unbonding_amount = '';
          object.withdraw_reserve = '';
          object.total_pending_deposit = '';
        }
        if (message.vault != null && message.hasOwnProperty('vault'))
          object.vault = $root.ununifi.yieldaggregator.Vault.toObject(message.vault, options);
        if (message.total_bonded_amount != null && message.hasOwnProperty('total_bonded_amount'))
          object.total_bonded_amount = message.total_bonded_amount;
        if (message.total_unbonding_amount != null && message.hasOwnProperty('total_unbonding_amount'))
          object.total_unbonding_amount = message.total_unbonding_amount;
        if (message.withdraw_reserve != null && message.hasOwnProperty('withdraw_reserve'))
          object.withdraw_reserve = message.withdraw_reserve;
        if (message.total_pending_deposit != null && message.hasOwnProperty('total_pending_deposit'))
          object.total_pending_deposit = message.total_pending_deposit;
        return object;
      };

      /**
       * Converts this VaultContainer to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.VaultContainer
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      VaultContainer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return VaultContainer;
    })();

    yieldaggregator.QueryAllVaultResponse = (function () {
      /**
       * Properties of a QueryAllVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryAllVaultResponse
       * @property {Array.<ununifi.yieldaggregator.IVaultContainer>|null} [vaults] QueryAllVaultResponse vaults
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllVaultResponse pagination
       */

      /**
       * Constructs a new QueryAllVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryAllVaultResponse.
       * @implements IQueryAllVaultResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryAllVaultResponse=} [properties] Properties to set
       */
      function QueryAllVaultResponse(properties) {
        this.vaults = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllVaultResponse vaults.
       * @member {Array.<ununifi.yieldaggregator.IVaultContainer>} vaults
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @instance
       */
      QueryAllVaultResponse.prototype.vaults = $util.emptyArray;

      /**
       * QueryAllVaultResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @instance
       */
      QueryAllVaultResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultResponse} message QueryAllVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vaults != null && message.vaults.length)
          for (let i = 0; i < message.vaults.length; ++i)
            $root.ununifi.yieldaggregator.VaultContainer.encode(
              message.vaults[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultResponse} message QueryAllVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryAllVaultResponse} QueryAllVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryAllVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.vaults && message.vaults.length)) message.vaults = [];
              message.vaults.push($root.ununifi.yieldaggregator.VaultContainer.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryAllVaultResponse} QueryAllVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllVaultResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vaults != null && message.hasOwnProperty('vaults')) {
          if (!Array.isArray(message.vaults)) return 'vaults: array expected';
          for (let i = 0; i < message.vaults.length; ++i) {
            let error = $root.ununifi.yieldaggregator.VaultContainer.verify(message.vaults[i]);
            if (error) return 'vaults.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryAllVaultResponse} QueryAllVaultResponse
       */
      QueryAllVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryAllVaultResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryAllVaultResponse();
        if (object.vaults) {
          if (!Array.isArray(object.vaults)) throw TypeError('.ununifi.yieldaggregator.QueryAllVaultResponse.vaults: array expected');
          message.vaults = [];
          for (let i = 0; i < object.vaults.length; ++i) {
            if (typeof object.vaults[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.QueryAllVaultResponse.vaults: object expected');
            message.vaults[i] = $root.ununifi.yieldaggregator.VaultContainer.fromObject(object.vaults[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.yieldaggregator.QueryAllVaultResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryAllVaultResponse} message QueryAllVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllVaultResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.vaults = [];
        if (options.defaults) object.pagination = null;
        if (message.vaults && message.vaults.length) {
          object.vaults = [];
          for (let j = 0; j < message.vaults.length; ++j)
            object.vaults[j] = $root.ununifi.yieldaggregator.VaultContainer.toObject(message.vaults[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryAllVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllVaultResponse;
    })();

    yieldaggregator.QueryAllVaultByShareHolderRequest = (function () {
      /**
       * Properties of a QueryAllVaultByShareHolderRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryAllVaultByShareHolderRequest
       * @property {string|null} [share_holder] QueryAllVaultByShareHolderRequest share_holder
       */

      /**
       * Constructs a new QueryAllVaultByShareHolderRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryAllVaultByShareHolderRequest.
       * @implements IQueryAllVaultByShareHolderRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderRequest=} [properties] Properties to set
       */
      function QueryAllVaultByShareHolderRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllVaultByShareHolderRequest share_holder.
       * @member {string} share_holder
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @instance
       */
      QueryAllVaultByShareHolderRequest.prototype.share_holder = '';

      /**
       * Encodes the specified QueryAllVaultByShareHolderRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderRequest} message QueryAllVaultByShareHolderRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultByShareHolderRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.share_holder != null && Object.hasOwnProperty.call(message, 'share_holder'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.share_holder);
        return writer;
      };

      /**
       * Encodes the specified QueryAllVaultByShareHolderRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderRequest} message QueryAllVaultByShareHolderRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultByShareHolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllVaultByShareHolderRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest} QueryAllVaultByShareHolderRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultByShareHolderRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.share_holder = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllVaultByShareHolderRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest} QueryAllVaultByShareHolderRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultByShareHolderRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllVaultByShareHolderRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllVaultByShareHolderRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.share_holder != null && message.hasOwnProperty('share_holder'))
          if (!$util.isString(message.share_holder)) return 'share_holder: string expected';
        return null;
      };

      /**
       * Creates a QueryAllVaultByShareHolderRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest} QueryAllVaultByShareHolderRequest
       */
      QueryAllVaultByShareHolderRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest) return object;
        let message = new $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest();
        if (object.share_holder != null) message.share_holder = String(object.share_holder);
        return message;
      };

      /**
       * Creates a plain object from a QueryAllVaultByShareHolderRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest} message QueryAllVaultByShareHolderRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllVaultByShareHolderRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.share_holder = '';
        if (message.share_holder != null && message.hasOwnProperty('share_holder')) object.share_holder = message.share_holder;
        return object;
      };

      /**
       * Converts this QueryAllVaultByShareHolderRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllVaultByShareHolderRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllVaultByShareHolderRequest;
    })();

    yieldaggregator.QueryAllVaultByShareHolderResponse = (function () {
      /**
       * Properties of a QueryAllVaultByShareHolderResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryAllVaultByShareHolderResponse
       * @property {Array.<ununifi.yieldaggregator.IVaultContainer>|null} [vaults] QueryAllVaultByShareHolderResponse vaults
       */

      /**
       * Constructs a new QueryAllVaultByShareHolderResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryAllVaultByShareHolderResponse.
       * @implements IQueryAllVaultByShareHolderResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderResponse=} [properties] Properties to set
       */
      function QueryAllVaultByShareHolderResponse(properties) {
        this.vaults = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllVaultByShareHolderResponse vaults.
       * @member {Array.<ununifi.yieldaggregator.IVaultContainer>} vaults
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @instance
       */
      QueryAllVaultByShareHolderResponse.prototype.vaults = $util.emptyArray;

      /**
       * Encodes the specified QueryAllVaultByShareHolderResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderResponse} message QueryAllVaultByShareHolderResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultByShareHolderResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vaults != null && message.vaults.length)
          for (let i = 0; i < message.vaults.length; ++i)
            $root.ununifi.yieldaggregator.VaultContainer.encode(
              message.vaults[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllVaultByShareHolderResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllVaultByShareHolderResponse} message QueryAllVaultByShareHolderResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllVaultByShareHolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllVaultByShareHolderResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse} QueryAllVaultByShareHolderResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultByShareHolderResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.vaults && message.vaults.length)) message.vaults = [];
              message.vaults.push($root.ununifi.yieldaggregator.VaultContainer.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllVaultByShareHolderResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse} QueryAllVaultByShareHolderResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllVaultByShareHolderResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllVaultByShareHolderResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllVaultByShareHolderResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vaults != null && message.hasOwnProperty('vaults')) {
          if (!Array.isArray(message.vaults)) return 'vaults: array expected';
          for (let i = 0; i < message.vaults.length; ++i) {
            let error = $root.ununifi.yieldaggregator.VaultContainer.verify(message.vaults[i]);
            if (error) return 'vaults.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryAllVaultByShareHolderResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse} QueryAllVaultByShareHolderResponse
       */
      QueryAllVaultByShareHolderResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse();
        if (object.vaults) {
          if (!Array.isArray(object.vaults))
            throw TypeError('.ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse.vaults: array expected');
          message.vaults = [];
          for (let i = 0; i < object.vaults.length; ++i) {
            if (typeof object.vaults[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse.vaults: object expected');
            message.vaults[i] = $root.ununifi.yieldaggregator.VaultContainer.fromObject(object.vaults[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllVaultByShareHolderResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse} message QueryAllVaultByShareHolderResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllVaultByShareHolderResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.vaults = [];
        if (message.vaults && message.vaults.length) {
          object.vaults = [];
          for (let j = 0; j < message.vaults.length; ++j)
            object.vaults[j] = $root.ununifi.yieldaggregator.VaultContainer.toObject(message.vaults[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryAllVaultByShareHolderResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryAllVaultByShareHolderResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllVaultByShareHolderResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllVaultByShareHolderResponse;
    })();

    yieldaggregator.QueryGetVaultRequest = (function () {
      /**
       * Properties of a QueryGetVaultRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryGetVaultRequest
       * @property {Long|null} [id] QueryGetVaultRequest id
       */

      /**
       * Constructs a new QueryGetVaultRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryGetVaultRequest.
       * @implements IQueryGetVaultRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryGetVaultRequest=} [properties] Properties to set
       */
      function QueryGetVaultRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetVaultRequest id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @instance
       */
      QueryGetVaultRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryGetVaultRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} message QueryGetVaultRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetVaultRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetVaultRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetVaultRequest} message QueryGetVaultRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetVaultRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetVaultRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryGetVaultRequest} QueryGetVaultRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetVaultRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryGetVaultRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetVaultRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryGetVaultRequest} QueryGetVaultRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetVaultRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetVaultRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetVaultRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryGetVaultRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryGetVaultRequest} QueryGetVaultRequest
       */
      QueryGetVaultRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryGetVaultRequest) return object;
        let message = new $root.ununifi.yieldaggregator.QueryGetVaultRequest();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetVaultRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryGetVaultRequest} message QueryGetVaultRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetVaultRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this QueryGetVaultRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryGetVaultRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetVaultRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetVaultRequest;
    })();

    yieldaggregator.QueryGetVaultResponse = (function () {
      /**
       * Properties of a QueryGetVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryGetVaultResponse
       * @property {ununifi.yieldaggregator.IVault|null} [vault] QueryGetVaultResponse vault
       * @property {string|null} [total_bonded_amount] QueryGetVaultResponse total_bonded_amount
       * @property {string|null} [total_unbonding_amount] QueryGetVaultResponse total_unbonding_amount
       * @property {string|null} [withdraw_reserve] QueryGetVaultResponse withdraw_reserve
       * @property {string|null} [total_pending_deposit] QueryGetVaultResponse total_pending_deposit
       * @property {Array.<ununifi.yieldaggregator.IStrategy>|null} [strategies] QueryGetVaultResponse strategies
       */

      /**
       * Constructs a new QueryGetVaultResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryGetVaultResponse.
       * @implements IQueryGetVaultResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryGetVaultResponse=} [properties] Properties to set
       */
      function QueryGetVaultResponse(properties) {
        this.strategies = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetVaultResponse vault.
       * @member {ununifi.yieldaggregator.IVault|null|undefined} vault
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @instance
       */
      QueryGetVaultResponse.prototype.vault = null;

      /**
       * QueryGetVaultResponse total_bonded_amount.
       * @member {string} total_bonded_amount
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @instance
       */
      QueryGetVaultResponse.prototype.total_bonded_amount = '';

      /**
       * QueryGetVaultResponse total_unbonding_amount.
       * @member {string} total_unbonding_amount
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @instance
       */
      QueryGetVaultResponse.prototype.total_unbonding_amount = '';

      /**
       * QueryGetVaultResponse withdraw_reserve.
       * @member {string} withdraw_reserve
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @instance
       */
      QueryGetVaultResponse.prototype.withdraw_reserve = '';

      /**
       * QueryGetVaultResponse total_pending_deposit.
       * @member {string} total_pending_deposit
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @instance
       */
      QueryGetVaultResponse.prototype.total_pending_deposit = '';

      /**
       * QueryGetVaultResponse strategies.
       * @member {Array.<ununifi.yieldaggregator.IStrategy>} strategies
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @instance
       */
      QueryGetVaultResponse.prototype.strategies = $util.emptyArray;

      /**
       * Encodes the specified QueryGetVaultResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetVaultResponse} message QueryGetVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetVaultResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.vault != null && Object.hasOwnProperty.call(message, 'vault'))
          $root.ununifi.yieldaggregator.Vault.encode(message.vault, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.total_bonded_amount != null && Object.hasOwnProperty.call(message, 'total_bonded_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.total_bonded_amount);
        if (message.total_unbonding_amount != null && Object.hasOwnProperty.call(message, 'total_unbonding_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.total_unbonding_amount);
        if (message.withdraw_reserve != null && Object.hasOwnProperty.call(message, 'withdraw_reserve'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.withdraw_reserve);
        if (message.total_pending_deposit != null && Object.hasOwnProperty.call(message, 'total_pending_deposit'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.total_pending_deposit);
        if (message.strategies != null && message.strategies.length)
          for (let i = 0; i < message.strategies.length; ++i)
            $root.ununifi.yieldaggregator.Strategy.encode(message.strategies[i], writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetVaultResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetVaultResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetVaultResponse} message QueryGetVaultResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetVaultResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetVaultResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryGetVaultResponse} QueryGetVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetVaultResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryGetVaultResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vault = $root.ununifi.yieldaggregator.Vault.decode(reader, reader.uint32());
              break;
            case 2:
              message.total_bonded_amount = reader.string();
              break;
            case 3:
              message.total_unbonding_amount = reader.string();
              break;
            case 4:
              message.withdraw_reserve = reader.string();
              break;
            case 5:
              message.total_pending_deposit = reader.string();
              break;
            case 6:
              if (!(message.strategies && message.strategies.length)) message.strategies = [];
              message.strategies.push($root.ununifi.yieldaggregator.Strategy.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetVaultResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryGetVaultResponse} QueryGetVaultResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetVaultResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetVaultResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetVaultResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.vault != null && message.hasOwnProperty('vault')) {
          let error = $root.ununifi.yieldaggregator.Vault.verify(message.vault);
          if (error) return 'vault.' + error;
        }
        if (message.total_bonded_amount != null && message.hasOwnProperty('total_bonded_amount'))
          if (!$util.isString(message.total_bonded_amount)) return 'total_bonded_amount: string expected';
        if (message.total_unbonding_amount != null && message.hasOwnProperty('total_unbonding_amount'))
          if (!$util.isString(message.total_unbonding_amount)) return 'total_unbonding_amount: string expected';
        if (message.withdraw_reserve != null && message.hasOwnProperty('withdraw_reserve'))
          if (!$util.isString(message.withdraw_reserve)) return 'withdraw_reserve: string expected';
        if (message.total_pending_deposit != null && message.hasOwnProperty('total_pending_deposit'))
          if (!$util.isString(message.total_pending_deposit)) return 'total_pending_deposit: string expected';
        if (message.strategies != null && message.hasOwnProperty('strategies')) {
          if (!Array.isArray(message.strategies)) return 'strategies: array expected';
          for (let i = 0; i < message.strategies.length; ++i) {
            let error = $root.ununifi.yieldaggregator.Strategy.verify(message.strategies[i]);
            if (error) return 'strategies.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryGetVaultResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryGetVaultResponse} QueryGetVaultResponse
       */
      QueryGetVaultResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryGetVaultResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryGetVaultResponse();
        if (object.vault != null) {
          if (typeof object.vault !== 'object') throw TypeError('.ununifi.yieldaggregator.QueryGetVaultResponse.vault: object expected');
          message.vault = $root.ununifi.yieldaggregator.Vault.fromObject(object.vault);
        }
        if (object.total_bonded_amount != null) message.total_bonded_amount = String(object.total_bonded_amount);
        if (object.total_unbonding_amount != null) message.total_unbonding_amount = String(object.total_unbonding_amount);
        if (object.withdraw_reserve != null) message.withdraw_reserve = String(object.withdraw_reserve);
        if (object.total_pending_deposit != null) message.total_pending_deposit = String(object.total_pending_deposit);
        if (object.strategies) {
          if (!Array.isArray(object.strategies))
            throw TypeError('.ununifi.yieldaggregator.QueryGetVaultResponse.strategies: array expected');
          message.strategies = [];
          for (let i = 0; i < object.strategies.length; ++i) {
            if (typeof object.strategies[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.QueryGetVaultResponse.strategies: object expected');
            message.strategies[i] = $root.ununifi.yieldaggregator.Strategy.fromObject(object.strategies[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetVaultResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryGetVaultResponse} message QueryGetVaultResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetVaultResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.strategies = [];
        if (options.defaults) {
          object.vault = null;
          object.total_bonded_amount = '';
          object.total_unbonding_amount = '';
          object.withdraw_reserve = '';
          object.total_pending_deposit = '';
        }
        if (message.vault != null && message.hasOwnProperty('vault'))
          object.vault = $root.ununifi.yieldaggregator.Vault.toObject(message.vault, options);
        if (message.total_bonded_amount != null && message.hasOwnProperty('total_bonded_amount'))
          object.total_bonded_amount = message.total_bonded_amount;
        if (message.total_unbonding_amount != null && message.hasOwnProperty('total_unbonding_amount'))
          object.total_unbonding_amount = message.total_unbonding_amount;
        if (message.withdraw_reserve != null && message.hasOwnProperty('withdraw_reserve'))
          object.withdraw_reserve = message.withdraw_reserve;
        if (message.total_pending_deposit != null && message.hasOwnProperty('total_pending_deposit'))
          object.total_pending_deposit = message.total_pending_deposit;
        if (message.strategies && message.strategies.length) {
          object.strategies = [];
          for (let j = 0; j < message.strategies.length; ++j)
            object.strategies[j] = $root.ununifi.yieldaggregator.Strategy.toObject(message.strategies[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryGetVaultResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryGetVaultResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetVaultResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetVaultResponse;
    })();

    yieldaggregator.QueryAllStrategyRequest = (function () {
      /**
       * Properties of a QueryAllStrategyRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryAllStrategyRequest
       * @property {string|null} [denom] QueryAllStrategyRequest denom
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllStrategyRequest pagination
       */

      /**
       * Constructs a new QueryAllStrategyRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryAllStrategyRequest.
       * @implements IQueryAllStrategyRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest=} [properties] Properties to set
       */
      function QueryAllStrategyRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllStrategyRequest denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @instance
       */
      QueryAllStrategyRequest.prototype.denom = '';

      /**
       * QueryAllStrategyRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @instance
       */
      QueryAllStrategyRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllStrategyRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} message QueryAllStrategyRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllStrategyRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllStrategyRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllStrategyRequest} message QueryAllStrategyRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllStrategyRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllStrategyRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryAllStrategyRequest} QueryAllStrategyRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllStrategyRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryAllStrategyRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllStrategyRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryAllStrategyRequest} QueryAllStrategyRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllStrategyRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllStrategyRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllStrategyRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllStrategyRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryAllStrategyRequest} QueryAllStrategyRequest
       */
      QueryAllStrategyRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryAllStrategyRequest) return object;
        let message = new $root.ununifi.yieldaggregator.QueryAllStrategyRequest();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.yieldaggregator.QueryAllStrategyRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllStrategyRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryAllStrategyRequest} message QueryAllStrategyRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllStrategyRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          object.pagination = null;
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllStrategyRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryAllStrategyRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllStrategyRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllStrategyRequest;
    })();

    yieldaggregator.QueryAllStrategyResponse = (function () {
      /**
       * Properties of a QueryAllStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryAllStrategyResponse
       * @property {Array.<ununifi.yieldaggregator.IStrategyContainer>|null} [strategies] QueryAllStrategyResponse strategies
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllStrategyResponse pagination
       */

      /**
       * Constructs a new QueryAllStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryAllStrategyResponse.
       * @implements IQueryAllStrategyResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryAllStrategyResponse=} [properties] Properties to set
       */
      function QueryAllStrategyResponse(properties) {
        this.strategies = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllStrategyResponse strategies.
       * @member {Array.<ununifi.yieldaggregator.IStrategyContainer>} strategies
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @instance
       */
      QueryAllStrategyResponse.prototype.strategies = $util.emptyArray;

      /**
       * QueryAllStrategyResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @instance
       */
      QueryAllStrategyResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllStrategyResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllStrategyResponse} message QueryAllStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllStrategyResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategies != null && message.strategies.length)
          for (let i = 0; i < message.strategies.length; ++i)
            $root.ununifi.yieldaggregator.StrategyContainer.encode(
              message.strategies[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllStrategyResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryAllStrategyResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryAllStrategyResponse} message QueryAllStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllStrategyResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllStrategyResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryAllStrategyResponse} QueryAllStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllStrategyResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryAllStrategyResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.strategies && message.strategies.length)) message.strategies = [];
              message.strategies.push($root.ununifi.yieldaggregator.StrategyContainer.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllStrategyResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryAllStrategyResponse} QueryAllStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllStrategyResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllStrategyResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllStrategyResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategies != null && message.hasOwnProperty('strategies')) {
          if (!Array.isArray(message.strategies)) return 'strategies: array expected';
          for (let i = 0; i < message.strategies.length; ++i) {
            let error = $root.ununifi.yieldaggregator.StrategyContainer.verify(message.strategies[i]);
            if (error) return 'strategies.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllStrategyResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryAllStrategyResponse} QueryAllStrategyResponse
       */
      QueryAllStrategyResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryAllStrategyResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryAllStrategyResponse();
        if (object.strategies) {
          if (!Array.isArray(object.strategies))
            throw TypeError('.ununifi.yieldaggregator.QueryAllStrategyResponse.strategies: array expected');
          message.strategies = [];
          for (let i = 0; i < object.strategies.length; ++i) {
            if (typeof object.strategies[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.QueryAllStrategyResponse.strategies: object expected');
            message.strategies[i] = $root.ununifi.yieldaggregator.StrategyContainer.fromObject(object.strategies[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.ununifi.yieldaggregator.QueryAllStrategyResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllStrategyResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryAllStrategyResponse} message QueryAllStrategyResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllStrategyResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.strategies = [];
        if (options.defaults) object.pagination = null;
        if (message.strategies && message.strategies.length) {
          object.strategies = [];
          for (let j = 0; j < message.strategies.length; ++j)
            object.strategies[j] = $root.ununifi.yieldaggregator.StrategyContainer.toObject(message.strategies[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllStrategyResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryAllStrategyResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllStrategyResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllStrategyResponse;
    })();

    yieldaggregator.QueryGetStrategyRequest = (function () {
      /**
       * Properties of a QueryGetStrategyRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryGetStrategyRequest
       * @property {string|null} [denom] QueryGetStrategyRequest denom
       * @property {Long|null} [id] QueryGetStrategyRequest id
       */

      /**
       * Constructs a new QueryGetStrategyRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryGetStrategyRequest.
       * @implements IQueryGetStrategyRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest=} [properties] Properties to set
       */
      function QueryGetStrategyRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetStrategyRequest denom.
       * @member {string} denom
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @instance
       */
      QueryGetStrategyRequest.prototype.denom = '';

      /**
       * QueryGetStrategyRequest id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @instance
       */
      QueryGetStrategyRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryGetStrategyRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} message QueryGetStrategyRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetStrategyRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetStrategyRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetStrategyRequest} message QueryGetStrategyRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetStrategyRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetStrategyRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryGetStrategyRequest} QueryGetStrategyRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetStrategyRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryGetStrategyRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetStrategyRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryGetStrategyRequest} QueryGetStrategyRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetStrategyRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetStrategyRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetStrategyRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryGetStrategyRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryGetStrategyRequest} QueryGetStrategyRequest
       */
      QueryGetStrategyRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryGetStrategyRequest) return object;
        let message = new $root.ununifi.yieldaggregator.QueryGetStrategyRequest();
        if (object.denom != null) message.denom = String(object.denom);
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetStrategyRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryGetStrategyRequest} message QueryGetStrategyRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetStrategyRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.denom = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        }
        if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this QueryGetStrategyRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryGetStrategyRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetStrategyRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetStrategyRequest;
    })();

    yieldaggregator.StrategyContainer = (function () {
      /**
       * Properties of a StrategyContainer.
       * @memberof ununifi.yieldaggregator
       * @interface IStrategyContainer
       * @property {ununifi.yieldaggregator.IStrategy|null} [strategy] StrategyContainer strategy
       * @property {string|null} [deposit_fee_rate] StrategyContainer deposit_fee_rate
       * @property {string|null} [withdraw_fee_rate] StrategyContainer withdraw_fee_rate
       * @property {string|null} [performance_fee_rate] StrategyContainer performance_fee_rate
       * @property {string|null} [symbol] StrategyContainer symbol
       */

      /**
       * Constructs a new StrategyContainer.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a StrategyContainer.
       * @implements IStrategyContainer
       * @constructor
       * @param {ununifi.yieldaggregator.IStrategyContainer=} [properties] Properties to set
       */
      function StrategyContainer(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * StrategyContainer strategy.
       * @member {ununifi.yieldaggregator.IStrategy|null|undefined} strategy
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @instance
       */
      StrategyContainer.prototype.strategy = null;

      /**
       * StrategyContainer deposit_fee_rate.
       * @member {string} deposit_fee_rate
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @instance
       */
      StrategyContainer.prototype.deposit_fee_rate = '';

      /**
       * StrategyContainer withdraw_fee_rate.
       * @member {string} withdraw_fee_rate
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @instance
       */
      StrategyContainer.prototype.withdraw_fee_rate = '';

      /**
       * StrategyContainer performance_fee_rate.
       * @member {string} performance_fee_rate
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @instance
       */
      StrategyContainer.prototype.performance_fee_rate = '';

      /**
       * StrategyContainer symbol.
       * @member {string} symbol
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @instance
       */
      StrategyContainer.prototype.symbol = '';

      /**
       * Encodes the specified StrategyContainer message. Does not implicitly {@link ununifi.yieldaggregator.StrategyContainer.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @static
       * @param {ununifi.yieldaggregator.IStrategyContainer} message StrategyContainer message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      StrategyContainer.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategy != null && Object.hasOwnProperty.call(message, 'strategy'))
          $root.ununifi.yieldaggregator.Strategy.encode(message.strategy, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.deposit_fee_rate != null && Object.hasOwnProperty.call(message, 'deposit_fee_rate'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.deposit_fee_rate);
        if (message.withdraw_fee_rate != null && Object.hasOwnProperty.call(message, 'withdraw_fee_rate'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.withdraw_fee_rate);
        if (message.performance_fee_rate != null && Object.hasOwnProperty.call(message, 'performance_fee_rate'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.performance_fee_rate);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.symbol);
        return writer;
      };

      /**
       * Encodes the specified StrategyContainer message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.StrategyContainer.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @static
       * @param {ununifi.yieldaggregator.IStrategyContainer} message StrategyContainer message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      StrategyContainer.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a StrategyContainer message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.StrategyContainer} StrategyContainer
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      StrategyContainer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.StrategyContainer();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.strategy = $root.ununifi.yieldaggregator.Strategy.decode(reader, reader.uint32());
              break;
            case 2:
              message.deposit_fee_rate = reader.string();
              break;
            case 3:
              message.withdraw_fee_rate = reader.string();
              break;
            case 4:
              message.performance_fee_rate = reader.string();
              break;
            case 5:
              message.symbol = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a StrategyContainer message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.StrategyContainer} StrategyContainer
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      StrategyContainer.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a StrategyContainer message.
       * @function verify
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      StrategyContainer.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategy != null && message.hasOwnProperty('strategy')) {
          let error = $root.ununifi.yieldaggregator.Strategy.verify(message.strategy);
          if (error) return 'strategy.' + error;
        }
        if (message.deposit_fee_rate != null && message.hasOwnProperty('deposit_fee_rate'))
          if (!$util.isString(message.deposit_fee_rate)) return 'deposit_fee_rate: string expected';
        if (message.withdraw_fee_rate != null && message.hasOwnProperty('withdraw_fee_rate'))
          if (!$util.isString(message.withdraw_fee_rate)) return 'withdraw_fee_rate: string expected';
        if (message.performance_fee_rate != null && message.hasOwnProperty('performance_fee_rate'))
          if (!$util.isString(message.performance_fee_rate)) return 'performance_fee_rate: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        return null;
      };

      /**
       * Creates a StrategyContainer message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.StrategyContainer} StrategyContainer
       */
      StrategyContainer.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.StrategyContainer) return object;
        let message = new $root.ununifi.yieldaggregator.StrategyContainer();
        if (object.strategy != null) {
          if (typeof object.strategy !== 'object') throw TypeError('.ununifi.yieldaggregator.StrategyContainer.strategy: object expected');
          message.strategy = $root.ununifi.yieldaggregator.Strategy.fromObject(object.strategy);
        }
        if (object.deposit_fee_rate != null) message.deposit_fee_rate = String(object.deposit_fee_rate);
        if (object.withdraw_fee_rate != null) message.withdraw_fee_rate = String(object.withdraw_fee_rate);
        if (object.performance_fee_rate != null) message.performance_fee_rate = String(object.performance_fee_rate);
        if (object.symbol != null) message.symbol = String(object.symbol);
        return message;
      };

      /**
       * Creates a plain object from a StrategyContainer message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @static
       * @param {ununifi.yieldaggregator.StrategyContainer} message StrategyContainer
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      StrategyContainer.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.strategy = null;
          object.deposit_fee_rate = '';
          object.withdraw_fee_rate = '';
          object.performance_fee_rate = '';
          object.symbol = '';
        }
        if (message.strategy != null && message.hasOwnProperty('strategy'))
          object.strategy = $root.ununifi.yieldaggregator.Strategy.toObject(message.strategy, options);
        if (message.deposit_fee_rate != null && message.hasOwnProperty('deposit_fee_rate'))
          object.deposit_fee_rate = message.deposit_fee_rate;
        if (message.withdraw_fee_rate != null && message.hasOwnProperty('withdraw_fee_rate'))
          object.withdraw_fee_rate = message.withdraw_fee_rate;
        if (message.performance_fee_rate != null && message.hasOwnProperty('performance_fee_rate'))
          object.performance_fee_rate = message.performance_fee_rate;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        return object;
      };

      /**
       * Converts this StrategyContainer to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.StrategyContainer
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      StrategyContainer.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return StrategyContainer;
    })();

    yieldaggregator.QueryGetStrategyResponse = (function () {
      /**
       * Properties of a QueryGetStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryGetStrategyResponse
       * @property {ununifi.yieldaggregator.IStrategyContainer|null} [strategy] QueryGetStrategyResponse strategy
       */

      /**
       * Constructs a new QueryGetStrategyResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryGetStrategyResponse.
       * @implements IQueryGetStrategyResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryGetStrategyResponse=} [properties] Properties to set
       */
      function QueryGetStrategyResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetStrategyResponse strategy.
       * @member {ununifi.yieldaggregator.IStrategyContainer|null|undefined} strategy
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @instance
       */
      QueryGetStrategyResponse.prototype.strategy = null;

      /**
       * Encodes the specified QueryGetStrategyResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetStrategyResponse} message QueryGetStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetStrategyResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.strategy != null && Object.hasOwnProperty.call(message, 'strategy'))
          $root.ununifi.yieldaggregator.StrategyContainer.encode(
            message.strategy,
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetStrategyResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryGetStrategyResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryGetStrategyResponse} message QueryGetStrategyResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetStrategyResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetStrategyResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryGetStrategyResponse} QueryGetStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetStrategyResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryGetStrategyResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.strategy = $root.ununifi.yieldaggregator.StrategyContainer.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetStrategyResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryGetStrategyResponse} QueryGetStrategyResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetStrategyResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetStrategyResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetStrategyResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.strategy != null && message.hasOwnProperty('strategy')) {
          let error = $root.ununifi.yieldaggregator.StrategyContainer.verify(message.strategy);
          if (error) return 'strategy.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetStrategyResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryGetStrategyResponse} QueryGetStrategyResponse
       */
      QueryGetStrategyResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryGetStrategyResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryGetStrategyResponse();
        if (object.strategy != null) {
          if (typeof object.strategy !== 'object')
            throw TypeError('.ununifi.yieldaggregator.QueryGetStrategyResponse.strategy: object expected');
          message.strategy = $root.ununifi.yieldaggregator.StrategyContainer.fromObject(object.strategy);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetStrategyResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryGetStrategyResponse} message QueryGetStrategyResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetStrategyResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.strategy = null;
        if (message.strategy != null && message.hasOwnProperty('strategy'))
          object.strategy = $root.ununifi.yieldaggregator.StrategyContainer.toObject(message.strategy, options);
        return object;
      };

      /**
       * Converts this QueryGetStrategyResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryGetStrategyResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetStrategyResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetStrategyResponse;
    })();

    yieldaggregator.QueryEstimateMintAmountRequest = (function () {
      /**
       * Properties of a QueryEstimateMintAmountRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryEstimateMintAmountRequest
       * @property {Long|null} [id] QueryEstimateMintAmountRequest id
       * @property {string|null} [deposit_amount] QueryEstimateMintAmountRequest deposit_amount
       */

      /**
       * Constructs a new QueryEstimateMintAmountRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryEstimateMintAmountRequest.
       * @implements IQueryEstimateMintAmountRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest=} [properties] Properties to set
       */
      function QueryEstimateMintAmountRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateMintAmountRequest id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @instance
       */
      QueryEstimateMintAmountRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateMintAmountRequest deposit_amount.
       * @member {string} deposit_amount
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @instance
       */
      QueryEstimateMintAmountRequest.prototype.deposit_amount = '';

      /**
       * Encodes the specified QueryEstimateMintAmountRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} message QueryEstimateMintAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintAmountRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.deposit_amount != null && Object.hasOwnProperty.call(message, 'deposit_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.deposit_amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateMintAmountRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountRequest} message QueryEstimateMintAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateMintAmountRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} QueryEstimateMintAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintAmountRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.deposit_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateMintAmountRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} QueryEstimateMintAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintAmountRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateMintAmountRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateMintAmountRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.deposit_amount != null && message.hasOwnProperty('deposit_amount'))
          if (!$util.isString(message.deposit_amount)) return 'deposit_amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateMintAmountRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} QueryEstimateMintAmountRequest
       */
      QueryEstimateMintAmountRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest) return object;
        let message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountRequest();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.deposit_amount != null) message.deposit_amount = String(object.deposit_amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateMintAmountRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryEstimateMintAmountRequest} message QueryEstimateMintAmountRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateMintAmountRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.deposit_amount = '';
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.deposit_amount != null && message.hasOwnProperty('deposit_amount')) object.deposit_amount = message.deposit_amount;
        return object;
      };

      /**
       * Converts this QueryEstimateMintAmountRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateMintAmountRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateMintAmountRequest;
    })();

    yieldaggregator.QueryEstimateMintAmountResponse = (function () {
      /**
       * Properties of a QueryEstimateMintAmountResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryEstimateMintAmountResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [mint_amount] QueryEstimateMintAmountResponse mint_amount
       */

      /**
       * Constructs a new QueryEstimateMintAmountResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryEstimateMintAmountResponse.
       * @implements IQueryEstimateMintAmountResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountResponse=} [properties] Properties to set
       */
      function QueryEstimateMintAmountResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateMintAmountResponse mint_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} mint_amount
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @instance
       */
      QueryEstimateMintAmountResponse.prototype.mint_amount = null;

      /**
       * Encodes the specified QueryEstimateMintAmountResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountResponse} message QueryEstimateMintAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintAmountResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.mint_amount != null && Object.hasOwnProperty.call(message, 'mint_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.mint_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateMintAmountResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateMintAmountResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateMintAmountResponse} message QueryEstimateMintAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateMintAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateMintAmountResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} QueryEstimateMintAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintAmountResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mint_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateMintAmountResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} QueryEstimateMintAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateMintAmountResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateMintAmountResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateMintAmountResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.mint_amount != null && message.hasOwnProperty('mint_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.mint_amount);
          if (error) return 'mint_amount.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryEstimateMintAmountResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} QueryEstimateMintAmountResponse
       */
      QueryEstimateMintAmountResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryEstimateMintAmountResponse();
        if (object.mint_amount != null) {
          if (typeof object.mint_amount !== 'object')
            throw TypeError('.ununifi.yieldaggregator.QueryEstimateMintAmountResponse.mint_amount: object expected');
          message.mint_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.mint_amount);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateMintAmountResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryEstimateMintAmountResponse} message QueryEstimateMintAmountResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateMintAmountResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.mint_amount = null;
        if (message.mint_amount != null && message.hasOwnProperty('mint_amount'))
          object.mint_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.mint_amount, options);
        return object;
      };

      /**
       * Converts this QueryEstimateMintAmountResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryEstimateMintAmountResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateMintAmountResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateMintAmountResponse;
    })();

    yieldaggregator.QueryEstimateRedeemAmountRequest = (function () {
      /**
       * Properties of a QueryEstimateRedeemAmountRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryEstimateRedeemAmountRequest
       * @property {Long|null} [id] QueryEstimateRedeemAmountRequest id
       * @property {string|null} [burn_amount] QueryEstimateRedeemAmountRequest burn_amount
       */

      /**
       * Constructs a new QueryEstimateRedeemAmountRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryEstimateRedeemAmountRequest.
       * @implements IQueryEstimateRedeemAmountRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest=} [properties] Properties to set
       */
      function QueryEstimateRedeemAmountRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemAmountRequest id.
       * @member {Long} id
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @instance
       */
      QueryEstimateRedeemAmountRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * QueryEstimateRedeemAmountRequest burn_amount.
       * @member {string} burn_amount
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @instance
       */
      QueryEstimateRedeemAmountRequest.prototype.burn_amount = '';

      /**
       * Encodes the specified QueryEstimateRedeemAmountRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} message QueryEstimateRedeemAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemAmountRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.burn_amount != null && Object.hasOwnProperty.call(message, 'burn_amount'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.burn_amount);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemAmountRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountRequest} message QueryEstimateRedeemAmountRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemAmountRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemAmountRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} QueryEstimateRedeemAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemAmountRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.burn_amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemAmountRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} QueryEstimateRedeemAmountRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemAmountRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemAmountRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemAmountRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.burn_amount != null && message.hasOwnProperty('burn_amount'))
          if (!$util.isString(message.burn_amount)) return 'burn_amount: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemAmountRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} QueryEstimateRedeemAmountRequest
       */
      QueryEstimateRedeemAmountRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest) return object;
        let message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.burn_amount != null) message.burn_amount = String(object.burn_amount);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemAmountRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest} message QueryEstimateRedeemAmountRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemAmountRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.burn_amount = '';
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.burn_amount != null && message.hasOwnProperty('burn_amount')) object.burn_amount = message.burn_amount;
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemAmountRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemAmountRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemAmountRequest;
    })();

    yieldaggregator.QueryEstimateRedeemAmountResponse = (function () {
      /**
       * Properties of a QueryEstimateRedeemAmountResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryEstimateRedeemAmountResponse
       * @property {cosmos.base.v1beta1.ICoin|null} [share_amount] QueryEstimateRedeemAmountResponse share_amount
       * @property {string|null} [fee] QueryEstimateRedeemAmountResponse fee
       * @property {string|null} [redeem_amount] QueryEstimateRedeemAmountResponse redeem_amount
       * @property {string|null} [total_amount] QueryEstimateRedeemAmountResponse total_amount
       * @property {string|null} [symbol] QueryEstimateRedeemAmountResponse symbol
       */

      /**
       * Constructs a new QueryEstimateRedeemAmountResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryEstimateRedeemAmountResponse.
       * @implements IQueryEstimateRedeemAmountResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountResponse=} [properties] Properties to set
       */
      function QueryEstimateRedeemAmountResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryEstimateRedeemAmountResponse share_amount.
       * @member {cosmos.base.v1beta1.ICoin|null|undefined} share_amount
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @instance
       */
      QueryEstimateRedeemAmountResponse.prototype.share_amount = null;

      /**
       * QueryEstimateRedeemAmountResponse fee.
       * @member {string} fee
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @instance
       */
      QueryEstimateRedeemAmountResponse.prototype.fee = '';

      /**
       * QueryEstimateRedeemAmountResponse redeem_amount.
       * @member {string} redeem_amount
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @instance
       */
      QueryEstimateRedeemAmountResponse.prototype.redeem_amount = '';

      /**
       * QueryEstimateRedeemAmountResponse total_amount.
       * @member {string} total_amount
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @instance
       */
      QueryEstimateRedeemAmountResponse.prototype.total_amount = '';

      /**
       * QueryEstimateRedeemAmountResponse symbol.
       * @member {string} symbol
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @instance
       */
      QueryEstimateRedeemAmountResponse.prototype.symbol = '';

      /**
       * Encodes the specified QueryEstimateRedeemAmountResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountResponse} message QueryEstimateRedeemAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemAmountResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.share_amount != null && Object.hasOwnProperty.call(message, 'share_amount'))
          $root.cosmos.base.v1beta1.Coin.encode(message.share_amount, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.fee != null && Object.hasOwnProperty.call(message, 'fee'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.fee);
        if (message.redeem_amount != null && Object.hasOwnProperty.call(message, 'redeem_amount'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.redeem_amount);
        if (message.total_amount != null && Object.hasOwnProperty.call(message, 'total_amount'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.total_amount);
        if (message.symbol != null && Object.hasOwnProperty.call(message, 'symbol'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.symbol);
        return writer;
      };

      /**
       * Encodes the specified QueryEstimateRedeemAmountResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryEstimateRedeemAmountResponse} message QueryEstimateRedeemAmountResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryEstimateRedeemAmountResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryEstimateRedeemAmountResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} QueryEstimateRedeemAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemAmountResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.share_amount = $root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32());
              break;
            case 2:
              message.fee = reader.string();
              break;
            case 3:
              message.redeem_amount = reader.string();
              break;
            case 4:
              message.total_amount = reader.string();
              break;
            case 5:
              message.symbol = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryEstimateRedeemAmountResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} QueryEstimateRedeemAmountResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryEstimateRedeemAmountResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryEstimateRedeemAmountResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryEstimateRedeemAmountResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.share_amount != null && message.hasOwnProperty('share_amount')) {
          let error = $root.cosmos.base.v1beta1.Coin.verify(message.share_amount);
          if (error) return 'share_amount.' + error;
        }
        if (message.fee != null && message.hasOwnProperty('fee')) if (!$util.isString(message.fee)) return 'fee: string expected';
        if (message.redeem_amount != null && message.hasOwnProperty('redeem_amount'))
          if (!$util.isString(message.redeem_amount)) return 'redeem_amount: string expected';
        if (message.total_amount != null && message.hasOwnProperty('total_amount'))
          if (!$util.isString(message.total_amount)) return 'total_amount: string expected';
        if (message.symbol != null && message.hasOwnProperty('symbol'))
          if (!$util.isString(message.symbol)) return 'symbol: string expected';
        return null;
      };

      /**
       * Creates a QueryEstimateRedeemAmountResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} QueryEstimateRedeemAmountResponse
       */
      QueryEstimateRedeemAmountResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse();
        if (object.share_amount != null) {
          if (typeof object.share_amount !== 'object')
            throw TypeError('.ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse.share_amount: object expected');
          message.share_amount = $root.cosmos.base.v1beta1.Coin.fromObject(object.share_amount);
        }
        if (object.fee != null) message.fee = String(object.fee);
        if (object.redeem_amount != null) message.redeem_amount = String(object.redeem_amount);
        if (object.total_amount != null) message.total_amount = String(object.total_amount);
        if (object.symbol != null) message.symbol = String(object.symbol);
        return message;
      };

      /**
       * Creates a plain object from a QueryEstimateRedeemAmountResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse} message QueryEstimateRedeemAmountResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryEstimateRedeemAmountResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.share_amount = null;
          object.fee = '';
          object.redeem_amount = '';
          object.total_amount = '';
          object.symbol = '';
        }
        if (message.share_amount != null && message.hasOwnProperty('share_amount'))
          object.share_amount = $root.cosmos.base.v1beta1.Coin.toObject(message.share_amount, options);
        if (message.fee != null && message.hasOwnProperty('fee')) object.fee = message.fee;
        if (message.redeem_amount != null && message.hasOwnProperty('redeem_amount')) object.redeem_amount = message.redeem_amount;
        if (message.total_amount != null && message.hasOwnProperty('total_amount')) object.total_amount = message.total_amount;
        if (message.symbol != null && message.hasOwnProperty('symbol')) object.symbol = message.symbol;
        return object;
      };

      /**
       * Converts this QueryEstimateRedeemAmountResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryEstimateRedeemAmountResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryEstimateRedeemAmountResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryEstimateRedeemAmountResponse;
    })();

    yieldaggregator.QueryDenomInfosRequest = (function () {
      /**
       * Properties of a QueryDenomInfosRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryDenomInfosRequest
       */

      /**
       * Constructs a new QueryDenomInfosRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryDenomInfosRequest.
       * @implements IQueryDenomInfosRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryDenomInfosRequest=} [properties] Properties to set
       */
      function QueryDenomInfosRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryDenomInfosRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryDenomInfosRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryDenomInfosRequest} message QueryDenomInfosRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomInfosRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryDenomInfosRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryDenomInfosRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryDenomInfosRequest} message QueryDenomInfosRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomInfosRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDenomInfosRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryDenomInfosRequest} QueryDenomInfosRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomInfosRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryDenomInfosRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDenomInfosRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryDenomInfosRequest} QueryDenomInfosRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomInfosRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDenomInfosRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDenomInfosRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryDenomInfosRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryDenomInfosRequest} QueryDenomInfosRequest
       */
      QueryDenomInfosRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryDenomInfosRequest) return object;
        return new $root.ununifi.yieldaggregator.QueryDenomInfosRequest();
      };

      /**
       * Creates a plain object from a QueryDenomInfosRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryDenomInfosRequest} message QueryDenomInfosRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDenomInfosRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryDenomInfosRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryDenomInfosRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDenomInfosRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDenomInfosRequest;
    })();

    yieldaggregator.QueryDenomInfosResponse = (function () {
      /**
       * Properties of a QueryDenomInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryDenomInfosResponse
       * @property {Array.<ununifi.yieldaggregator.IDenomInfo>|null} [info] QueryDenomInfosResponse info
       */

      /**
       * Constructs a new QueryDenomInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryDenomInfosResponse.
       * @implements IQueryDenomInfosResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryDenomInfosResponse=} [properties] Properties to set
       */
      function QueryDenomInfosResponse(properties) {
        this.info = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryDenomInfosResponse info.
       * @member {Array.<ununifi.yieldaggregator.IDenomInfo>} info
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @instance
       */
      QueryDenomInfosResponse.prototype.info = $util.emptyArray;

      /**
       * Encodes the specified QueryDenomInfosResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryDenomInfosResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryDenomInfosResponse} message QueryDenomInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomInfosResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.info != null && message.info.length)
          for (let i = 0; i < message.info.length; ++i)
            $root.ununifi.yieldaggregator.DenomInfo.encode(message.info[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryDenomInfosResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryDenomInfosResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryDenomInfosResponse} message QueryDenomInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryDenomInfosResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryDenomInfosResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryDenomInfosResponse} QueryDenomInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomInfosResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryDenomInfosResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.info && message.info.length)) message.info = [];
              message.info.push($root.ununifi.yieldaggregator.DenomInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryDenomInfosResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryDenomInfosResponse} QueryDenomInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryDenomInfosResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryDenomInfosResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryDenomInfosResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.info != null && message.hasOwnProperty('info')) {
          if (!Array.isArray(message.info)) return 'info: array expected';
          for (let i = 0; i < message.info.length; ++i) {
            let error = $root.ununifi.yieldaggregator.DenomInfo.verify(message.info[i]);
            if (error) return 'info.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryDenomInfosResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryDenomInfosResponse} QueryDenomInfosResponse
       */
      QueryDenomInfosResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryDenomInfosResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryDenomInfosResponse();
        if (object.info) {
          if (!Array.isArray(object.info)) throw TypeError('.ununifi.yieldaggregator.QueryDenomInfosResponse.info: array expected');
          message.info = [];
          for (let i = 0; i < object.info.length; ++i) {
            if (typeof object.info[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.QueryDenomInfosResponse.info: object expected');
            message.info[i] = $root.ununifi.yieldaggregator.DenomInfo.fromObject(object.info[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryDenomInfosResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryDenomInfosResponse} message QueryDenomInfosResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryDenomInfosResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.info = [];
        if (message.info && message.info.length) {
          object.info = [];
          for (let j = 0; j < message.info.length; ++j)
            object.info[j] = $root.ununifi.yieldaggregator.DenomInfo.toObject(message.info[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryDenomInfosResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryDenomInfosResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryDenomInfosResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryDenomInfosResponse;
    })();

    yieldaggregator.QuerySymbolInfosRequest = (function () {
      /**
       * Properties of a QuerySymbolInfosRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQuerySymbolInfosRequest
       */

      /**
       * Constructs a new QuerySymbolInfosRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QuerySymbolInfosRequest.
       * @implements IQuerySymbolInfosRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosRequest=} [properties] Properties to set
       */
      function QuerySymbolInfosRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QuerySymbolInfosRequest message. Does not implicitly {@link ununifi.yieldaggregator.QuerySymbolInfosRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @static
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosRequest} message QuerySymbolInfosRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QuerySymbolInfosRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QuerySymbolInfosRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QuerySymbolInfosRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @static
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosRequest} message QuerySymbolInfosRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QuerySymbolInfosRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QuerySymbolInfosRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QuerySymbolInfosRequest} QuerySymbolInfosRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QuerySymbolInfosRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QuerySymbolInfosRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QuerySymbolInfosRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QuerySymbolInfosRequest} QuerySymbolInfosRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QuerySymbolInfosRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QuerySymbolInfosRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QuerySymbolInfosRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QuerySymbolInfosRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QuerySymbolInfosRequest} QuerySymbolInfosRequest
       */
      QuerySymbolInfosRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QuerySymbolInfosRequest) return object;
        return new $root.ununifi.yieldaggregator.QuerySymbolInfosRequest();
      };

      /**
       * Creates a plain object from a QuerySymbolInfosRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @static
       * @param {ununifi.yieldaggregator.QuerySymbolInfosRequest} message QuerySymbolInfosRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QuerySymbolInfosRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QuerySymbolInfosRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QuerySymbolInfosRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QuerySymbolInfosRequest;
    })();

    yieldaggregator.QuerySymbolInfosResponse = (function () {
      /**
       * Properties of a QuerySymbolInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQuerySymbolInfosResponse
       * @property {Array.<ununifi.yieldaggregator.ISymbolInfo>|null} [info] QuerySymbolInfosResponse info
       */

      /**
       * Constructs a new QuerySymbolInfosResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QuerySymbolInfosResponse.
       * @implements IQuerySymbolInfosResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosResponse=} [properties] Properties to set
       */
      function QuerySymbolInfosResponse(properties) {
        this.info = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QuerySymbolInfosResponse info.
       * @member {Array.<ununifi.yieldaggregator.ISymbolInfo>} info
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @instance
       */
      QuerySymbolInfosResponse.prototype.info = $util.emptyArray;

      /**
       * Encodes the specified QuerySymbolInfosResponse message. Does not implicitly {@link ununifi.yieldaggregator.QuerySymbolInfosResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosResponse} message QuerySymbolInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QuerySymbolInfosResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.info != null && message.info.length)
          for (let i = 0; i < message.info.length; ++i)
            $root.ununifi.yieldaggregator.SymbolInfo.encode(message.info[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QuerySymbolInfosResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QuerySymbolInfosResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.IQuerySymbolInfosResponse} message QuerySymbolInfosResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QuerySymbolInfosResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QuerySymbolInfosResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QuerySymbolInfosResponse} QuerySymbolInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QuerySymbolInfosResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QuerySymbolInfosResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.info && message.info.length)) message.info = [];
              message.info.push($root.ununifi.yieldaggregator.SymbolInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QuerySymbolInfosResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QuerySymbolInfosResponse} QuerySymbolInfosResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QuerySymbolInfosResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QuerySymbolInfosResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QuerySymbolInfosResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.info != null && message.hasOwnProperty('info')) {
          if (!Array.isArray(message.info)) return 'info: array expected';
          for (let i = 0; i < message.info.length; ++i) {
            let error = $root.ununifi.yieldaggregator.SymbolInfo.verify(message.info[i]);
            if (error) return 'info.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QuerySymbolInfosResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QuerySymbolInfosResponse} QuerySymbolInfosResponse
       */
      QuerySymbolInfosResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QuerySymbolInfosResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QuerySymbolInfosResponse();
        if (object.info) {
          if (!Array.isArray(object.info)) throw TypeError('.ununifi.yieldaggregator.QuerySymbolInfosResponse.info: array expected');
          message.info = [];
          for (let i = 0; i < object.info.length; ++i) {
            if (typeof object.info[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.QuerySymbolInfosResponse.info: object expected');
            message.info[i] = $root.ununifi.yieldaggregator.SymbolInfo.fromObject(object.info[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QuerySymbolInfosResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @static
       * @param {ununifi.yieldaggregator.QuerySymbolInfosResponse} message QuerySymbolInfosResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QuerySymbolInfosResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.info = [];
        if (message.info && message.info.length) {
          object.info = [];
          for (let j = 0; j < message.info.length; ++j)
            object.info[j] = $root.ununifi.yieldaggregator.SymbolInfo.toObject(message.info[j], options);
        }
        return object;
      };

      /**
       * Converts this QuerySymbolInfosResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QuerySymbolInfosResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QuerySymbolInfosResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QuerySymbolInfosResponse;
    })();

    yieldaggregator.QueryIntermediaryAccountInfoRequest = (function () {
      /**
       * Properties of a QueryIntermediaryAccountInfoRequest.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryIntermediaryAccountInfoRequest
       */

      /**
       * Constructs a new QueryIntermediaryAccountInfoRequest.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryIntermediaryAccountInfoRequest.
       * @implements IQueryIntermediaryAccountInfoRequest
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoRequest=} [properties] Properties to set
       */
      function QueryIntermediaryAccountInfoRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryIntermediaryAccountInfoRequest message. Does not implicitly {@link ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoRequest} message QueryIntermediaryAccountInfoRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIntermediaryAccountInfoRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryIntermediaryAccountInfoRequest message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @static
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoRequest} message QueryIntermediaryAccountInfoRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIntermediaryAccountInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryIntermediaryAccountInfoRequest message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest} QueryIntermediaryAccountInfoRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIntermediaryAccountInfoRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryIntermediaryAccountInfoRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest} QueryIntermediaryAccountInfoRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIntermediaryAccountInfoRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryIntermediaryAccountInfoRequest message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryIntermediaryAccountInfoRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryIntermediaryAccountInfoRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest} QueryIntermediaryAccountInfoRequest
       */
      QueryIntermediaryAccountInfoRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest) return object;
        return new $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest();
      };

      /**
       * Creates a plain object from a QueryIntermediaryAccountInfoRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @static
       * @param {ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest} message QueryIntermediaryAccountInfoRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryIntermediaryAccountInfoRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryIntermediaryAccountInfoRequest to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryIntermediaryAccountInfoRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryIntermediaryAccountInfoRequest;
    })();

    yieldaggregator.QueryIntermediaryAccountInfoResponse = (function () {
      /**
       * Properties of a QueryIntermediaryAccountInfoResponse.
       * @memberof ununifi.yieldaggregator
       * @interface IQueryIntermediaryAccountInfoResponse
       * @property {Array.<ununifi.yieldaggregator.IChainAddress>|null} [addrs] QueryIntermediaryAccountInfoResponse addrs
       */

      /**
       * Constructs a new QueryIntermediaryAccountInfoResponse.
       * @memberof ununifi.yieldaggregator
       * @classdesc Represents a QueryIntermediaryAccountInfoResponse.
       * @implements IQueryIntermediaryAccountInfoResponse
       * @constructor
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoResponse=} [properties] Properties to set
       */
      function QueryIntermediaryAccountInfoResponse(properties) {
        this.addrs = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryIntermediaryAccountInfoResponse addrs.
       * @member {Array.<ununifi.yieldaggregator.IChainAddress>} addrs
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @instance
       */
      QueryIntermediaryAccountInfoResponse.prototype.addrs = $util.emptyArray;

      /**
       * Encodes the specified QueryIntermediaryAccountInfoResponse message. Does not implicitly {@link ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse.verify|verify} messages.
       * @function encode
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoResponse} message QueryIntermediaryAccountInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIntermediaryAccountInfoResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.addrs != null && message.addrs.length)
          for (let i = 0; i < message.addrs.length; ++i)
            $root.ununifi.yieldaggregator.ChainAddress.encode(message.addrs[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryIntermediaryAccountInfoResponse message, length delimited. Does not implicitly {@link ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @static
       * @param {ununifi.yieldaggregator.IQueryIntermediaryAccountInfoResponse} message QueryIntermediaryAccountInfoResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryIntermediaryAccountInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryIntermediaryAccountInfoResponse message from the specified reader or buffer.
       * @function decode
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse} QueryIntermediaryAccountInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIntermediaryAccountInfoResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.addrs && message.addrs.length)) message.addrs = [];
              message.addrs.push($root.ununifi.yieldaggregator.ChainAddress.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryIntermediaryAccountInfoResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse} QueryIntermediaryAccountInfoResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryIntermediaryAccountInfoResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryIntermediaryAccountInfoResponse message.
       * @function verify
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryIntermediaryAccountInfoResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.addrs != null && message.hasOwnProperty('addrs')) {
          if (!Array.isArray(message.addrs)) return 'addrs: array expected';
          for (let i = 0; i < message.addrs.length; ++i) {
            let error = $root.ununifi.yieldaggregator.ChainAddress.verify(message.addrs[i]);
            if (error) return 'addrs.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a QueryIntermediaryAccountInfoResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse} QueryIntermediaryAccountInfoResponse
       */
      QueryIntermediaryAccountInfoResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse) return object;
        let message = new $root.ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse();
        if (object.addrs) {
          if (!Array.isArray(object.addrs))
            throw TypeError('.ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse.addrs: array expected');
          message.addrs = [];
          for (let i = 0; i < object.addrs.length; ++i) {
            if (typeof object.addrs[i] !== 'object')
              throw TypeError('.ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse.addrs: object expected');
            message.addrs[i] = $root.ununifi.yieldaggregator.ChainAddress.fromObject(object.addrs[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryIntermediaryAccountInfoResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @static
       * @param {ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse} message QueryIntermediaryAccountInfoResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryIntermediaryAccountInfoResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.addrs = [];
        if (message.addrs && message.addrs.length) {
          object.addrs = [];
          for (let j = 0; j < message.addrs.length; ++j)
            object.addrs[j] = $root.ununifi.yieldaggregator.ChainAddress.toObject(message.addrs[j], options);
        }
        return object;
      };

      /**
       * Converts this QueryIntermediaryAccountInfoResponse to JSON.
       * @function toJSON
       * @memberof ununifi.yieldaggregator.QueryIntermediaryAccountInfoResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryIntermediaryAccountInfoResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryIntermediaryAccountInfoResponse;
    })();

    return yieldaggregator;
  })();

  return ununifi;
})());

export const cosmos = ($root.cosmos = (() => {
  /**
   * Namespace cosmos.
   * @exports cosmos
   * @namespace
   */
  const cosmos = {};

  cosmos.base = (function () {
    /**
     * Namespace base.
     * @memberof cosmos
     * @namespace
     */
    const base = {};

    base.v1beta1 = (function () {
      /**
       * Namespace v1beta1.
       * @memberof cosmos.base
       * @namespace
       */
      const v1beta1 = {};

      v1beta1.Coin = (function () {
        /**
         * Properties of a Coin.
         * @memberof cosmos.base.v1beta1
         * @interface ICoin
         * @property {string|null} [denom] Coin denom
         * @property {string|null} [amount] Coin amount
         */

        /**
         * Constructs a new Coin.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a Coin.
         * @implements ICoin
         * @constructor
         * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set
         */
        function Coin(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Coin denom.
         * @member {string} denom
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         */
        Coin.prototype.denom = '';

        /**
         * Coin amount.
         * @member {string} amount
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         */
        Coin.prototype.amount = '';

        /**
         * Encodes the specified Coin message. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified Coin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coin message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.Coin();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Coin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coin message.
         * @function verify
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coin.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          return null;
        };

        /**
         * Creates a Coin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.Coin} Coin
         */
        Coin.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.Coin) return object;
          let message = new $root.cosmos.base.v1beta1.Coin();
          if (object.denom != null) message.denom = String(object.denom);
          if (object.amount != null) message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from a Coin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.Coin
         * @static
         * @param {cosmos.base.v1beta1.Coin} message Coin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coin.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.denom = '';
            object.amount = '';
          }
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          return object;
        };

        /**
         * Converts this Coin to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.Coin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coin;
      })();

      v1beta1.DecCoin = (function () {
        /**
         * Properties of a DecCoin.
         * @memberof cosmos.base.v1beta1
         * @interface IDecCoin
         * @property {string|null} [denom] DecCoin denom
         * @property {string|null} [amount] DecCoin amount
         */

        /**
         * Constructs a new DecCoin.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a DecCoin.
         * @implements IDecCoin
         * @constructor
         * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set
         */
        function DecCoin(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecCoin denom.
         * @member {string} denom
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         */
        DecCoin.prototype.denom = '';

        /**
         * DecCoin amount.
         * @member {string} amount
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         */
        DecCoin.prototype.amount = '';

        /**
         * Encodes the specified DecCoin message. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecCoin.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.denom != null && Object.hasOwnProperty.call(message, 'denom'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);
          if (message.amount != null && Object.hasOwnProperty.call(message, 'amount'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);
          return writer;
        };

        /**
         * Encodes the specified DecCoin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecCoin.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecCoin message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecCoin.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.DecCoin();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.denom = reader.string();
                break;
              case 2:
                message.amount = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DecCoin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecCoin.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecCoin message.
         * @function verify
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecCoin.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.denom != null && message.hasOwnProperty('denom')) if (!$util.isString(message.denom)) return 'denom: string expected';
          if (message.amount != null && message.hasOwnProperty('amount'))
            if (!$util.isString(message.amount)) return 'amount: string expected';
          return null;
        };

        /**
         * Creates a DecCoin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin
         */
        DecCoin.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.DecCoin) return object;
          let message = new $root.cosmos.base.v1beta1.DecCoin();
          if (object.denom != null) message.denom = String(object.denom);
          if (object.amount != null) message.amount = String(object.amount);
          return message;
        };

        /**
         * Creates a plain object from a DecCoin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.DecCoin
         * @static
         * @param {cosmos.base.v1beta1.DecCoin} message DecCoin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecCoin.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.denom = '';
            object.amount = '';
          }
          if (message.denom != null && message.hasOwnProperty('denom')) object.denom = message.denom;
          if (message.amount != null && message.hasOwnProperty('amount')) object.amount = message.amount;
          return object;
        };

        /**
         * Converts this DecCoin to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.DecCoin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecCoin.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecCoin;
      })();

      v1beta1.IntProto = (function () {
        /**
         * Properties of an IntProto.
         * @memberof cosmos.base.v1beta1
         * @interface IIntProto
         * @property {string|null} [int] IntProto int
         */

        /**
         * Constructs a new IntProto.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents an IntProto.
         * @implements IIntProto
         * @constructor
         * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set
         */
        function IntProto(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * IntProto int.
         * @member {string} int
         * @memberof cosmos.base.v1beta1.IntProto
         * @instance
         */
        IntProto.prototype.int = '';

        /**
         * Encodes the specified IntProto message. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.int != null && Object.hasOwnProperty.call(message, 'int'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.int);
          return writer;
        };

        /**
         * Encodes the specified IntProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IntProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IntProto message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.IntProto();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.int = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an IntProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IntProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IntProto message.
         * @function verify
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IntProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.int != null && message.hasOwnProperty('int')) if (!$util.isString(message.int)) return 'int: string expected';
          return null;
        };

        /**
         * Creates an IntProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.IntProto} IntProto
         */
        IntProto.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.IntProto) return object;
          let message = new $root.cosmos.base.v1beta1.IntProto();
          if (object.int != null) message.int = String(object.int);
          return message;
        };

        /**
         * Creates a plain object from an IntProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.IntProto
         * @static
         * @param {cosmos.base.v1beta1.IntProto} message IntProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IntProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) object.int = '';
          if (message.int != null && message.hasOwnProperty('int')) object.int = message.int;
          return object;
        };

        /**
         * Converts this IntProto to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.IntProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IntProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IntProto;
      })();

      v1beta1.DecProto = (function () {
        /**
         * Properties of a DecProto.
         * @memberof cosmos.base.v1beta1
         * @interface IDecProto
         * @property {string|null} [dec] DecProto dec
         */

        /**
         * Constructs a new DecProto.
         * @memberof cosmos.base.v1beta1
         * @classdesc Represents a DecProto.
         * @implements IDecProto
         * @constructor
         * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set
         */
        function DecProto(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecProto dec.
         * @member {string} dec
         * @memberof cosmos.base.v1beta1.DecProto
         * @instance
         */
        DecProto.prototype.dec = '';

        /**
         * Encodes the specified DecProto message. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
         * @function encode
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecProto.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.dec != null && Object.hasOwnProperty.call(message, 'dec'))
            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.dec);
          return writer;
        };

        /**
         * Encodes the specified DecProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecProto message from the specified reader or buffer.
         * @function decode
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.cosmos.base.v1beta1.DecProto();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.dec = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a DecProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecProto message.
         * @function verify
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecProto.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.dec != null && message.hasOwnProperty('dec')) if (!$util.isString(message.dec)) return 'dec: string expected';
          return null;
        };

        /**
         * Creates a DecProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cosmos.base.v1beta1.DecProto} DecProto
         */
        DecProto.fromObject = function fromObject(object) {
          if (object instanceof $root.cosmos.base.v1beta1.DecProto) return object;
          let message = new $root.cosmos.base.v1beta1.DecProto();
          if (object.dec != null) message.dec = String(object.dec);
          return message;
        };

        /**
         * Creates a plain object from a DecProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cosmos.base.v1beta1.DecProto
         * @static
         * @param {cosmos.base.v1beta1.DecProto} message DecProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecProto.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) object.dec = '';
          if (message.dec != null && message.hasOwnProperty('dec')) object.dec = message.dec;
          return object;
        };

        /**
         * Converts this DecProto to JSON.
         * @function toJSON
         * @memberof cosmos.base.v1beta1.DecProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecProto;
      })();

      return v1beta1;
    })();

    base.query = (function () {
      /**
       * Namespace query.
       * @memberof cosmos.base
       * @namespace
       */
      const query = {};

      query.v1beta1 = (function () {
        /**
         * Namespace v1beta1.
         * @memberof cosmos.base.query
         * @namespace
         */
        const v1beta1 = {};

        v1beta1.PageRequest = (function () {
          /**
           * Properties of a PageRequest.
           * @memberof cosmos.base.query.v1beta1
           * @interface IPageRequest
           * @property {Uint8Array|null} [key] PageRequest key
           * @property {Long|null} [offset] PageRequest offset
           * @property {Long|null} [limit] PageRequest limit
           * @property {boolean|null} [count_total] PageRequest count_total
           */

          /**
           * Constructs a new PageRequest.
           * @memberof cosmos.base.query.v1beta1
           * @classdesc Represents a PageRequest.
           * @implements IPageRequest
           * @constructor
           * @param {cosmos.base.query.v1beta1.IPageRequest=} [properties] Properties to set
           */
          function PageRequest(properties) {
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * PageRequest key.
           * @member {Uint8Array} key
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.key = $util.newBuffer([]);

          /**
           * PageRequest offset.
           * @member {Long} offset
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * PageRequest limit.
           * @member {Long} limit
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * PageRequest count_total.
           * @member {boolean} count_total
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           */
          PageRequest.prototype.count_total = false;

          /**
           * Encodes the specified PageRequest message. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageRequest.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, 'key'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.key);
            if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))
              writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.offset);
            if (message.limit != null && Object.hasOwnProperty.call(message, 'limit'))
              writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.limit);
            if (message.count_total != null && Object.hasOwnProperty.call(message, 'count_total'))
              writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.count_total);
            return writer;
          };

          /**
           * Encodes the specified PageRequest message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageRequest.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {cosmos.base.query.v1beta1.IPageRequest} message PageRequest message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a PageRequest message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.query.v1beta1.PageRequest();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.key = reader.bytes();
                  break;
                case 2:
                  message.offset = reader.uint64();
                  break;
                case 3:
                  message.limit = reader.uint64();
                  break;
                case 4:
                  message.count_total = reader.bool();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a PageRequest message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a PageRequest message.
           * @function verify
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          PageRequest.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.key != null && message.hasOwnProperty('key'))
              if (!((message.key && typeof message.key.length === 'number') || $util.isString(message.key))) return 'key: buffer expected';
            if (message.offset != null && message.hasOwnProperty('offset'))
              if (
                !$util.isInteger(message.offset) &&
                !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high))
              )
                return 'offset: integer|Long expected';
            if (message.limit != null && message.hasOwnProperty('limit'))
              if (
                !$util.isInteger(message.limit) &&
                !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high))
              )
                return 'limit: integer|Long expected';
            if (message.count_total != null && message.hasOwnProperty('count_total'))
              if (typeof message.count_total !== 'boolean') return 'count_total: boolean expected';
            return null;
          };

          /**
           * Creates a PageRequest message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.query.v1beta1.PageRequest} PageRequest
           */
          PageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.query.v1beta1.PageRequest) return object;
            let message = new $root.cosmos.base.query.v1beta1.PageRequest();
            if (object.key != null)
              if (typeof object.key === 'string')
                $util.base64.decode(object.key, (message.key = $util.newBuffer($util.base64.length(object.key))), 0);
              else if (object.key.length) message.key = object.key;
            if (object.offset != null)
              if ($util.Long) (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
              else if (typeof object.offset === 'string') message.offset = parseInt(object.offset, 10);
              else if (typeof object.offset === 'number') message.offset = object.offset;
              else if (typeof object.offset === 'object')
                message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
            if (object.limit != null)
              if ($util.Long) (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
              else if (typeof object.limit === 'string') message.limit = parseInt(object.limit, 10);
              else if (typeof object.limit === 'number') message.limit = object.limit;
              else if (typeof object.limit === 'object')
                message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
            if (object.count_total != null) message.count_total = Boolean(object.count_total);
            return message;
          };

          /**
           * Creates a plain object from a PageRequest message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @static
           * @param {cosmos.base.query.v1beta1.PageRequest} message PageRequest
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          PageRequest.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              if (options.bytes === String) object.key = '';
              else {
                object.key = [];
                if (options.bytes !== Array) object.key = $util.newBuffer(object.key);
              }
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.offset = options.longs === String ? '0' : 0;
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.limit = options.longs === String ? '0' : 0;
              object.count_total = false;
            }
            if (message.key != null && message.hasOwnProperty('key'))
              object.key =
                options.bytes === String
                  ? $util.base64.encode(message.key, 0, message.key.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.key)
                  : message.key;
            if (message.offset != null && message.hasOwnProperty('offset'))
              if (typeof message.offset === 'number') object.offset = options.longs === String ? String(message.offset) : message.offset;
              else
                object.offset =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.offset)
                    : options.longs === Number
                    ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true)
                    : message.offset;
            if (message.limit != null && message.hasOwnProperty('limit'))
              if (typeof message.limit === 'number') object.limit = options.longs === String ? String(message.limit) : message.limit;
              else
                object.limit =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.limit)
                    : options.longs === Number
                    ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true)
                    : message.limit;
            if (message.count_total != null && message.hasOwnProperty('count_total')) object.count_total = message.count_total;
            return object;
          };

          /**
           * Converts this PageRequest to JSON.
           * @function toJSON
           * @memberof cosmos.base.query.v1beta1.PageRequest
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          PageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return PageRequest;
        })();

        v1beta1.PageResponse = (function () {
          /**
           * Properties of a PageResponse.
           * @memberof cosmos.base.query.v1beta1
           * @interface IPageResponse
           * @property {Uint8Array|null} [next_key] PageResponse next_key
           * @property {Long|null} [total] PageResponse total
           */

          /**
           * Constructs a new PageResponse.
           * @memberof cosmos.base.query.v1beta1
           * @classdesc Represents a PageResponse.
           * @implements IPageResponse
           * @constructor
           * @param {cosmos.base.query.v1beta1.IPageResponse=} [properties] Properties to set
           */
          function PageResponse(properties) {
            if (properties)
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
          }

          /**
           * PageResponse next_key.
           * @member {Uint8Array} next_key
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @instance
           */
          PageResponse.prototype.next_key = $util.newBuffer([]);

          /**
           * PageResponse total.
           * @member {Long} total
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @instance
           */
          PageResponse.prototype.total = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

          /**
           * Encodes the specified PageResponse message. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
           * @function encode
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageResponse.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.next_key != null && Object.hasOwnProperty.call(message, 'next_key'))
              writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.next_key);
            if (message.total != null && Object.hasOwnProperty.call(message, 'total'))
              writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.total);
            return writer;
          };

          /**
           * Encodes the specified PageResponse message, length delimited. Does not implicitly {@link cosmos.base.query.v1beta1.PageResponse.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {cosmos.base.query.v1beta1.IPageResponse} message PageResponse message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          PageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a PageResponse message from the specified reader or buffer.
           * @function decode
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.cosmos.base.query.v1beta1.PageResponse();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.next_key = reader.bytes();
                  break;
                case 2:
                  message.total = reader.uint64();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a PageResponse message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          PageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a PageResponse message.
           * @function verify
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          PageResponse.verify = function verify(message) {
            if (typeof message !== 'object' || message === null) return 'object expected';
            if (message.next_key != null && message.hasOwnProperty('next_key'))
              if (!((message.next_key && typeof message.next_key.length === 'number') || $util.isString(message.next_key)))
                return 'next_key: buffer expected';
            if (message.total != null && message.hasOwnProperty('total'))
              if (
                !$util.isInteger(message.total) &&
                !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high))
              )
                return 'total: integer|Long expected';
            return null;
          };

          /**
           * Creates a PageResponse message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cosmos.base.query.v1beta1.PageResponse} PageResponse
           */
          PageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.cosmos.base.query.v1beta1.PageResponse) return object;
            let message = new $root.cosmos.base.query.v1beta1.PageResponse();
            if (object.next_key != null)
              if (typeof object.next_key === 'string')
                $util.base64.decode(object.next_key, (message.next_key = $util.newBuffer($util.base64.length(object.next_key))), 0);
              else if (object.next_key.length) message.next_key = object.next_key;
            if (object.total != null)
              if ($util.Long) (message.total = $util.Long.fromValue(object.total)).unsigned = true;
              else if (typeof object.total === 'string') message.total = parseInt(object.total, 10);
              else if (typeof object.total === 'number') message.total = object.total;
              else if (typeof object.total === 'object')
                message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
            return message;
          };

          /**
           * Creates a plain object from a PageResponse message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @static
           * @param {cosmos.base.query.v1beta1.PageResponse} message PageResponse
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          PageResponse.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              if (options.bytes === String) object.next_key = '';
              else {
                object.next_key = [];
                if (options.bytes !== Array) object.next_key = $util.newBuffer(object.next_key);
              }
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else object.total = options.longs === String ? '0' : 0;
            }
            if (message.next_key != null && message.hasOwnProperty('next_key'))
              object.next_key =
                options.bytes === String
                  ? $util.base64.encode(message.next_key, 0, message.next_key.length)
                  : options.bytes === Array
                  ? Array.prototype.slice.call(message.next_key)
                  : message.next_key;
            if (message.total != null && message.hasOwnProperty('total'))
              if (typeof message.total === 'number') object.total = options.longs === String ? String(message.total) : message.total;
              else
                object.total =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.total)
                    : options.longs === Number
                    ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true)
                    : message.total;
            return object;
          };

          /**
           * Converts this PageResponse to JSON.
           * @function toJSON
           * @memberof cosmos.base.query.v1beta1.PageResponse
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          PageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          return PageResponse;
        })();

        return v1beta1;
      })();

      return query;
    })();

    return base;
  })();

  cosmos.msg = (function () {
    /**
     * Namespace msg.
     * @memberof cosmos
     * @namespace
     */
    const msg = {};

    msg.v1 = (function () {
      /**
       * Namespace v1.
       * @memberof cosmos.msg
       * @namespace
       */
      const v1 = {};

      return v1;
    })();

    return msg;
  })();

  return cosmos;
})());

export const google = ($root.google = (() => {
  /**
   * Namespace google.
   * @exports google
   * @namespace
   */
  const google = {};

  google.protobuf = (function () {
    /**
     * Namespace protobuf.
     * @memberof google
     * @namespace
     */
    const protobuf = {};

    protobuf.Any = (function () {
      /**
       * Properties of an Any.
       * @memberof google.protobuf
       * @interface IAny
       * @property {string|null} [type_url] Any type_url
       * @property {Uint8Array|null} [value] Any value
       */

      /**
       * Constructs a new Any.
       * @memberof google.protobuf
       * @classdesc Represents an Any.
       * @implements IAny
       * @constructor
       * @param {google.protobuf.IAny=} [properties] Properties to set
       */
      function Any(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Any type_url.
       * @member {string} type_url
       * @memberof google.protobuf.Any
       * @instance
       */
      Any.prototype.type_url = '';

      /**
       * Any value.
       * @member {Uint8Array} value
       * @memberof google.protobuf.Any
       * @instance
       */
      Any.prototype.value = $util.newBuffer([]);

      /**
       * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.IAny} message Any message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Any.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.type_url != null && Object.hasOwnProperty.call(message, 'type_url'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.type_url);
        if (message.value != null && Object.hasOwnProperty.call(message, 'value'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.value);
        return writer;
      };

      /**
       * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.IAny} message Any message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Any.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an Any message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Any
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Any} Any
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Any.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.Any();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type_url = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an Any message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Any
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Any} Any
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Any.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an Any message.
       * @function verify
       * @memberof google.protobuf.Any
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Any.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.type_url != null && message.hasOwnProperty('type_url'))
          if (!$util.isString(message.type_url)) return 'type_url: string expected';
        if (message.value != null && message.hasOwnProperty('value'))
          if (!((message.value && typeof message.value.length === 'number') || $util.isString(message.value)))
            return 'value: buffer expected';
        return null;
      };

      /**
       * Creates an Any message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Any
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Any} Any
       */
      Any.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Any) return object;
        let message = new $root.google.protobuf.Any();
        if (object.type_url != null) message.type_url = String(object.type_url);
        if (object.value != null)
          if (typeof object.value === 'string')
            $util.base64.decode(object.value, (message.value = $util.newBuffer($util.base64.length(object.value))), 0);
          else if (object.value.length) message.value = object.value;
        return message;
      };

      /**
       * Creates a plain object from an Any message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Any
       * @static
       * @param {google.protobuf.Any} message Any
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Any.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.type_url = '';
          if (options.bytes === String) object.value = '';
          else {
            object.value = [];
            if (options.bytes !== Array) object.value = $util.newBuffer(object.value);
          }
        }
        if (message.type_url != null && message.hasOwnProperty('type_url')) object.type_url = message.type_url;
        if (message.value != null && message.hasOwnProperty('value'))
          object.value =
            options.bytes === String
              ? $util.base64.encode(message.value, 0, message.value.length)
              : options.bytes === Array
              ? Array.prototype.slice.call(message.value)
              : message.value;
        return object;
      };

      /**
       * Converts this Any to JSON.
       * @function toJSON
       * @memberof google.protobuf.Any
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Any.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Any;
    })();

    protobuf.Timestamp = (function () {
      /**
       * Properties of a Timestamp.
       * @memberof google.protobuf
       * @interface ITimestamp
       * @property {Long|null} [seconds] Timestamp seconds
       * @property {number|null} [nanos] Timestamp nanos
       */

      /**
       * Constructs a new Timestamp.
       * @memberof google.protobuf
       * @classdesc Represents a Timestamp.
       * @implements ITimestamp
       * @constructor
       * @param {google.protobuf.ITimestamp=} [properties] Properties to set
       */
      function Timestamp(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Timestamp seconds.
       * @member {Long} seconds
       * @memberof google.protobuf.Timestamp
       * @instance
       */
      Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Timestamp nanos.
       * @member {number} nanos
       * @memberof google.protobuf.Timestamp
       * @instance
       */
      Timestamp.prototype.nanos = 0;

      /**
       * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Timestamp.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.seconds != null && Object.hasOwnProperty.call(message, 'seconds'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
        if (message.nanos != null && Object.hasOwnProperty.call(message, 'nanos'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
        return writer;
      };

      /**
       * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Timestamp message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Timestamp} Timestamp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Timestamp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.Timestamp();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Timestamp message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Timestamp} Timestamp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Timestamp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Timestamp message.
       * @function verify
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Timestamp.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (
            !$util.isInteger(message.seconds) &&
            !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))
          )
            return 'seconds: integer|Long expected';
        if (message.nanos != null && message.hasOwnProperty('nanos')) if (!$util.isInteger(message.nanos)) return 'nanos: integer expected';
        return null;
      };

      /**
       * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Timestamp} Timestamp
       */
      Timestamp.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Timestamp) return object;
        let message = new $root.google.protobuf.Timestamp();
        if (object.seconds != null)
          if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
          else if (typeof object.seconds === 'string') message.seconds = parseInt(object.seconds, 10);
          else if (typeof object.seconds === 'number') message.seconds = object.seconds;
          else if (typeof object.seconds === 'object')
            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
        if (object.nanos != null) message.nanos = object.nanos | 0;
        return message;
      };

      /**
       * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.Timestamp} message Timestamp
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Timestamp.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.seconds = options.longs === String ? '0' : 0;
          object.nanos = 0;
        }
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (typeof message.seconds === 'number') object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
          else
            object.seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.seconds)
                : options.longs === Number
                ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                : message.seconds;
        if (message.nanos != null && message.hasOwnProperty('nanos')) object.nanos = message.nanos;
        return object;
      };

      /**
       * Converts this Timestamp to JSON.
       * @function toJSON
       * @memberof google.protobuf.Timestamp
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Timestamp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Timestamp;
    })();

    protobuf.FileDescriptorSet = (function () {
      /**
       * Properties of a FileDescriptorSet.
       * @memberof google.protobuf
       * @interface IFileDescriptorSet
       * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
       */

      /**
       * Constructs a new FileDescriptorSet.
       * @memberof google.protobuf
       * @classdesc Represents a FileDescriptorSet.
       * @implements IFileDescriptorSet
       * @constructor
       * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
       */
      function FileDescriptorSet(properties) {
        this.file = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileDescriptorSet file.
       * @member {Array.<google.protobuf.IFileDescriptorProto>} file
       * @memberof google.protobuf.FileDescriptorSet
       * @instance
       */
      FileDescriptorSet.prototype.file = $util.emptyArray;

      /**
       * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorSet.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.file != null && message.file.length)
          for (let i = 0; i < message.file.length; ++i)
            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileDescriptorSet message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorSet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FileDescriptorSet();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.file && message.file.length)) message.file = [];
              message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileDescriptorSet message.
       * @function verify
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileDescriptorSet.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.file != null && message.hasOwnProperty('file')) {
          if (!Array.isArray(message.file)) return 'file: array expected';
          for (let i = 0; i < message.file.length; ++i) {
            let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
            if (error) return 'file.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
       */
      FileDescriptorSet.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileDescriptorSet) return object;
        let message = new $root.google.protobuf.FileDescriptorSet();
        if (object.file) {
          if (!Array.isArray(object.file)) throw TypeError('.google.protobuf.FileDescriptorSet.file: array expected');
          message.file = [];
          for (let i = 0; i < object.file.length; ++i) {
            if (typeof object.file[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorSet.file: object expected');
            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileDescriptorSet
       * @static
       * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileDescriptorSet.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.file = [];
        if (message.file && message.file.length) {
          object.file = [];
          for (let j = 0; j < message.file.length; ++j)
            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
        }
        return object;
      };

      /**
       * Converts this FileDescriptorSet to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileDescriptorSet
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileDescriptorSet.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FileDescriptorSet;
    })();

    protobuf.FileDescriptorProto = (function () {
      /**
       * Properties of a FileDescriptorProto.
       * @memberof google.protobuf
       * @interface IFileDescriptorProto
       * @property {string|null} [name] FileDescriptorProto name
       * @property {string|null} ["package"] FileDescriptorProto package
       * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
       * @property {Array.<number>|null} [public_dependency] FileDescriptorProto public_dependency
       * @property {Array.<number>|null} [weak_dependency] FileDescriptorProto weak_dependency
       * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
       * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
       * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
       * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
       * @property {string|null} [syntax] FileDescriptorProto syntax
       */

      /**
       * Constructs a new FileDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a FileDescriptorProto.
       * @implements IFileDescriptorProto
       * @constructor
       * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
       */
      function FileDescriptorProto(properties) {
        this.dependency = [];
        this.public_dependency = [];
        this.weak_dependency = [];
        this.message_type = [];
        this.enum_type = [];
        this.service = [];
        this.extension = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.name = '';

      /**
       * FileDescriptorProto package.
       * @member {string} package
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype['package'] = '';

      /**
       * FileDescriptorProto dependency.
       * @member {Array.<string>} dependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.dependency = $util.emptyArray;

      /**
       * FileDescriptorProto public_dependency.
       * @member {Array.<number>} public_dependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.public_dependency = $util.emptyArray;

      /**
       * FileDescriptorProto weak_dependency.
       * @member {Array.<number>} weak_dependency
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.weak_dependency = $util.emptyArray;

      /**
       * FileDescriptorProto message_type.
       * @member {Array.<google.protobuf.IDescriptorProto>} message_type
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.message_type = $util.emptyArray;

      /**
       * FileDescriptorProto enum_type.
       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.enum_type = $util.emptyArray;

      /**
       * FileDescriptorProto service.
       * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.service = $util.emptyArray;

      /**
       * FileDescriptorProto extension.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.extension = $util.emptyArray;

      /**
       * FileDescriptorProto options.
       * @member {google.protobuf.IFileOptions|null|undefined} options
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.options = null;

      /**
       * FileDescriptorProto source_code_info.
       * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.source_code_info = null;

      /**
       * FileDescriptorProto syntax.
       * @member {string} syntax
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       */
      FileDescriptorProto.prototype.syntax = '';

      /**
       * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message['package'] != null && Object.hasOwnProperty.call(message, 'package'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message['package']);
        if (message.dependency != null && message.dependency.length)
          for (let i = 0; i < message.dependency.length; ++i) writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.dependency[i]);
        if (message.message_type != null && message.message_type.length)
          for (let i = 0; i < message.message_type.length; ++i)
            $root.google.protobuf.DescriptorProto.encode(
              message.message_type[i],
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
        if (message.enum_type != null && message.enum_type.length)
          for (let i = 0; i < message.enum_type.length; ++i)
            $root.google.protobuf.EnumDescriptorProto.encode(
              message.enum_type[i],
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
        if (message.service != null && message.service.length)
          for (let i = 0; i < message.service.length; ++i)
            $root.google.protobuf.ServiceDescriptorProto.encode(
              message.service[i],
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
        if (message.extension != null && message.extension.length)
          for (let i = 0; i < message.extension.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(
              message.extension[i],
              writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.source_code_info != null && Object.hasOwnProperty.call(message, 'source_code_info'))
          $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
        if (message.public_dependency != null && message.public_dependency.length)
          for (let i = 0; i < message.public_dependency.length; ++i)
            writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.public_dependency[i]);
        if (message.weak_dependency != null && message.weak_dependency.length)
          for (let i = 0; i < message.weak_dependency.length; ++i)
            writer.uint32(/* id 11, wireType 0 =*/ 88).int32(message.weak_dependency[i]);
        if (message.syntax != null && Object.hasOwnProperty.call(message, 'syntax'))
          writer.uint32(/* id 12, wireType 2 =*/ 98).string(message.syntax);
        return writer;
      };

      /**
       * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FileDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message['package'] = reader.string();
              break;
            case 3:
              if (!(message.dependency && message.dependency.length)) message.dependency = [];
              message.dependency.push(reader.string());
              break;
            case 10:
              if (!(message.public_dependency && message.public_dependency.length)) message.public_dependency = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) message.public_dependency.push(reader.int32());
              } else message.public_dependency.push(reader.int32());
              break;
            case 11:
              if (!(message.weak_dependency && message.weak_dependency.length)) message.weak_dependency = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) message.weak_dependency.push(reader.int32());
              } else message.weak_dependency.push(reader.int32());
              break;
            case 4:
              if (!(message.message_type && message.message_type.length)) message.message_type = [];
              message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.enum_type && message.enum_type.length)) message.enum_type = [];
              message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 6:
              if (!(message.service && message.service.length)) message.service = [];
              message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 7:
              if (!(message.extension && message.extension.length)) message.extension = [];
              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 8:
              message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
              break;
            case 9:
              message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
              break;
            case 12:
              message.syntax = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message['package'] != null && message.hasOwnProperty('package'))
          if (!$util.isString(message['package'])) return 'package: string expected';
        if (message.dependency != null && message.hasOwnProperty('dependency')) {
          if (!Array.isArray(message.dependency)) return 'dependency: array expected';
          for (let i = 0; i < message.dependency.length; ++i)
            if (!$util.isString(message.dependency[i])) return 'dependency: string[] expected';
        }
        if (message.public_dependency != null && message.hasOwnProperty('public_dependency')) {
          if (!Array.isArray(message.public_dependency)) return 'public_dependency: array expected';
          for (let i = 0; i < message.public_dependency.length; ++i)
            if (!$util.isInteger(message.public_dependency[i])) return 'public_dependency: integer[] expected';
        }
        if (message.weak_dependency != null && message.hasOwnProperty('weak_dependency')) {
          if (!Array.isArray(message.weak_dependency)) return 'weak_dependency: array expected';
          for (let i = 0; i < message.weak_dependency.length; ++i)
            if (!$util.isInteger(message.weak_dependency[i])) return 'weak_dependency: integer[] expected';
        }
        if (message.message_type != null && message.hasOwnProperty('message_type')) {
          if (!Array.isArray(message.message_type)) return 'message_type: array expected';
          for (let i = 0; i < message.message_type.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
            if (error) return 'message_type.' + error;
          }
        }
        if (message.enum_type != null && message.hasOwnProperty('enum_type')) {
          if (!Array.isArray(message.enum_type)) return 'enum_type: array expected';
          for (let i = 0; i < message.enum_type.length; ++i) {
            let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
            if (error) return 'enum_type.' + error;
          }
        }
        if (message.service != null && message.hasOwnProperty('service')) {
          if (!Array.isArray(message.service)) return 'service: array expected';
          for (let i = 0; i < message.service.length; ++i) {
            let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
            if (error) return 'service.' + error;
          }
        }
        if (message.extension != null && message.hasOwnProperty('extension')) {
          if (!Array.isArray(message.extension)) return 'extension: array expected';
          for (let i = 0; i < message.extension.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
            if (error) return 'extension.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.FileOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        if (message.source_code_info != null && message.hasOwnProperty('source_code_info')) {
          let error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
          if (error) return 'source_code_info.' + error;
        }
        if (message.syntax != null && message.hasOwnProperty('syntax'))
          if (!$util.isString(message.syntax)) return 'syntax: string expected';
        return null;
      };

      /**
       * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
       */
      FileDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileDescriptorProto) return object;
        let message = new $root.google.protobuf.FileDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object['package'] != null) message['package'] = String(object['package']);
        if (object.dependency) {
          if (!Array.isArray(object.dependency)) throw TypeError('.google.protobuf.FileDescriptorProto.dependency: array expected');
          message.dependency = [];
          for (let i = 0; i < object.dependency.length; ++i) message.dependency[i] = String(object.dependency[i]);
        }
        if (object.public_dependency) {
          if (!Array.isArray(object.public_dependency))
            throw TypeError('.google.protobuf.FileDescriptorProto.public_dependency: array expected');
          message.public_dependency = [];
          for (let i = 0; i < object.public_dependency.length; ++i) message.public_dependency[i] = object.public_dependency[i] | 0;
        }
        if (object.weak_dependency) {
          if (!Array.isArray(object.weak_dependency))
            throw TypeError('.google.protobuf.FileDescriptorProto.weak_dependency: array expected');
          message.weak_dependency = [];
          for (let i = 0; i < object.weak_dependency.length; ++i) message.weak_dependency[i] = object.weak_dependency[i] | 0;
        }
        if (object.message_type) {
          if (!Array.isArray(object.message_type)) throw TypeError('.google.protobuf.FileDescriptorProto.message_type: array expected');
          message.message_type = [];
          for (let i = 0; i < object.message_type.length; ++i) {
            if (typeof object.message_type[i] !== 'object')
              throw TypeError('.google.protobuf.FileDescriptorProto.message_type: object expected');
            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
          }
        }
        if (object.enum_type) {
          if (!Array.isArray(object.enum_type)) throw TypeError('.google.protobuf.FileDescriptorProto.enum_type: array expected');
          message.enum_type = [];
          for (let i = 0; i < object.enum_type.length; ++i) {
            if (typeof object.enum_type[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.enum_type: object expected');
            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
          }
        }
        if (object.service) {
          if (!Array.isArray(object.service)) throw TypeError('.google.protobuf.FileDescriptorProto.service: array expected');
          message.service = [];
          for (let i = 0; i < object.service.length; ++i) {
            if (typeof object.service[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.service: object expected');
            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
          }
        }
        if (object.extension) {
          if (!Array.isArray(object.extension)) throw TypeError('.google.protobuf.FileDescriptorProto.extension: array expected');
          message.extension = [];
          for (let i = 0; i < object.extension.length; ++i) {
            if (typeof object.extension[i] !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.extension: object expected');
            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.FileDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
        }
        if (object.source_code_info != null) {
          if (typeof object.source_code_info !== 'object')
            throw TypeError('.google.protobuf.FileDescriptorProto.source_code_info: object expected');
          message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
        }
        if (object.syntax != null) message.syntax = String(object.syntax);
        return message;
      };

      /**
       * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileDescriptorProto
       * @static
       * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.dependency = [];
          object.message_type = [];
          object.enum_type = [];
          object.service = [];
          object.extension = [];
          object.public_dependency = [];
          object.weak_dependency = [];
        }
        if (options.defaults) {
          object.name = '';
          object['package'] = '';
          object.options = null;
          object.source_code_info = null;
          object.syntax = '';
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message['package'] != null && message.hasOwnProperty('package')) object['package'] = message['package'];
        if (message.dependency && message.dependency.length) {
          object.dependency = [];
          for (let j = 0; j < message.dependency.length; ++j) object.dependency[j] = message.dependency[j];
        }
        if (message.message_type && message.message_type.length) {
          object.message_type = [];
          for (let j = 0; j < message.message_type.length; ++j)
            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
        }
        if (message.enum_type && message.enum_type.length) {
          object.enum_type = [];
          for (let j = 0; j < message.enum_type.length; ++j)
            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
        }
        if (message.service && message.service.length) {
          object.service = [];
          for (let j = 0; j < message.service.length; ++j)
            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
        }
        if (message.extension && message.extension.length) {
          object.extension = [];
          for (let j = 0; j < message.extension.length; ++j)
            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
        if (message.source_code_info != null && message.hasOwnProperty('source_code_info'))
          object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
        if (message.public_dependency && message.public_dependency.length) {
          object.public_dependency = [];
          for (let j = 0; j < message.public_dependency.length; ++j) object.public_dependency[j] = message.public_dependency[j];
        }
        if (message.weak_dependency && message.weak_dependency.length) {
          object.weak_dependency = [];
          for (let j = 0; j < message.weak_dependency.length; ++j) object.weak_dependency[j] = message.weak_dependency[j];
        }
        if (message.syntax != null && message.hasOwnProperty('syntax')) object.syntax = message.syntax;
        return object;
      };

      /**
       * Converts this FileDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return FileDescriptorProto;
    })();

    protobuf.DescriptorProto = (function () {
      /**
       * Properties of a DescriptorProto.
       * @memberof google.protobuf
       * @interface IDescriptorProto
       * @property {string|null} [name] DescriptorProto name
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
       * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
       * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
       * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneof_decl] DescriptorProto oneof_decl
       * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
       * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reserved_range] DescriptorProto reserved_range
       * @property {Array.<string>|null} [reserved_name] DescriptorProto reserved_name
       */

      /**
       * Constructs a new DescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a DescriptorProto.
       * @implements IDescriptorProto
       * @constructor
       * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
       */
      function DescriptorProto(properties) {
        this.field = [];
        this.extension = [];
        this.nested_type = [];
        this.enum_type = [];
        this.extension_range = [];
        this.oneof_decl = [];
        this.reserved_range = [];
        this.reserved_name = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * DescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.name = '';

      /**
       * DescriptorProto field.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.field = $util.emptyArray;

      /**
       * DescriptorProto extension.
       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.extension = $util.emptyArray;

      /**
       * DescriptorProto nested_type.
       * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.nested_type = $util.emptyArray;

      /**
       * DescriptorProto enum_type.
       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.enum_type = $util.emptyArray;

      /**
       * DescriptorProto extension_range.
       * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.extension_range = $util.emptyArray;

      /**
       * DescriptorProto oneof_decl.
       * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneof_decl
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.oneof_decl = $util.emptyArray;

      /**
       * DescriptorProto options.
       * @member {google.protobuf.IMessageOptions|null|undefined} options
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.options = null;

      /**
       * DescriptorProto reserved_range.
       * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reserved_range
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.reserved_range = $util.emptyArray;

      /**
       * DescriptorProto reserved_name.
       * @member {Array.<string>} reserved_name
       * @memberof google.protobuf.DescriptorProto
       * @instance
       */
      DescriptorProto.prototype.reserved_name = $util.emptyArray;

      /**
       * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.field != null && message.field.length)
          for (let i = 0; i < message.field.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        if (message.nested_type != null && message.nested_type.length)
          for (let i = 0; i < message.nested_type.length; ++i)
            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        if (message.enum_type != null && message.enum_type.length)
          for (let i = 0; i < message.enum_type.length; ++i)
            $root.google.protobuf.EnumDescriptorProto.encode(
              message.enum_type[i],
              writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
            ).ldelim();
        if (message.extension_range != null && message.extension_range.length)
          for (let i = 0; i < message.extension_range.length; ++i)
            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(
              message.extension_range[i],
              writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
            ).ldelim();
        if (message.extension != null && message.extension.length)
          for (let i = 0; i < message.extension.length; ++i)
            $root.google.protobuf.FieldDescriptorProto.encode(
              message.extension[i],
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
        if (message.oneof_decl != null && message.oneof_decl.length)
          for (let i = 0; i < message.oneof_decl.length; ++i)
            $root.google.protobuf.OneofDescriptorProto.encode(
              message.oneof_decl[i],
              writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
            ).ldelim();
        if (message.reserved_range != null && message.reserved_range.length)
          for (let i = 0; i < message.reserved_range.length; ++i)
            $root.google.protobuf.DescriptorProto.ReservedRange.encode(
              message.reserved_range[i],
              writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
            ).ldelim();
        if (message.reserved_name != null && message.reserved_name.length)
          for (let i = 0; i < message.reserved_name.length; ++i)
            writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.reserved_name[i]);
        return writer;
      };

      /**
       * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a DescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.DescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.field && message.field.length)) message.field = [];
              message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 6:
              if (!(message.extension && message.extension.length)) message.extension = [];
              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              if (!(message.nested_type && message.nested_type.length)) message.nested_type = [];
              message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
              break;
            case 4:
              if (!(message.enum_type && message.enum_type.length)) message.enum_type = [];
              message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 5:
              if (!(message.extension_range && message.extension_range.length)) message.extension_range = [];
              message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
              break;
            case 8:
              if (!(message.oneof_decl && message.oneof_decl.length)) message.oneof_decl = [];
              message.oneof_decl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 7:
              message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
              break;
            case 9:
              if (!(message.reserved_range && message.reserved_range.length)) message.reserved_range = [];
              message.reserved_range.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
              break;
            case 10:
              if (!(message.reserved_name && message.reserved_name.length)) message.reserved_name = [];
              message.reserved_name.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a DescriptorProto message.
       * @function verify
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      DescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.field != null && message.hasOwnProperty('field')) {
          if (!Array.isArray(message.field)) return 'field: array expected';
          for (let i = 0; i < message.field.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
            if (error) return 'field.' + error;
          }
        }
        if (message.extension != null && message.hasOwnProperty('extension')) {
          if (!Array.isArray(message.extension)) return 'extension: array expected';
          for (let i = 0; i < message.extension.length; ++i) {
            let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
            if (error) return 'extension.' + error;
          }
        }
        if (message.nested_type != null && message.hasOwnProperty('nested_type')) {
          if (!Array.isArray(message.nested_type)) return 'nested_type: array expected';
          for (let i = 0; i < message.nested_type.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
            if (error) return 'nested_type.' + error;
          }
        }
        if (message.enum_type != null && message.hasOwnProperty('enum_type')) {
          if (!Array.isArray(message.enum_type)) return 'enum_type: array expected';
          for (let i = 0; i < message.enum_type.length; ++i) {
            let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
            if (error) return 'enum_type.' + error;
          }
        }
        if (message.extension_range != null && message.hasOwnProperty('extension_range')) {
          if (!Array.isArray(message.extension_range)) return 'extension_range: array expected';
          for (let i = 0; i < message.extension_range.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
            if (error) return 'extension_range.' + error;
          }
        }
        if (message.oneof_decl != null && message.hasOwnProperty('oneof_decl')) {
          if (!Array.isArray(message.oneof_decl)) return 'oneof_decl: array expected';
          for (let i = 0; i < message.oneof_decl.length; ++i) {
            let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneof_decl[i]);
            if (error) return 'oneof_decl.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.MessageOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        if (message.reserved_range != null && message.hasOwnProperty('reserved_range')) {
          if (!Array.isArray(message.reserved_range)) return 'reserved_range: array expected';
          for (let i = 0; i < message.reserved_range.length; ++i) {
            let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reserved_range[i]);
            if (error) return 'reserved_range.' + error;
          }
        }
        if (message.reserved_name != null && message.hasOwnProperty('reserved_name')) {
          if (!Array.isArray(message.reserved_name)) return 'reserved_name: array expected';
          for (let i = 0; i < message.reserved_name.length; ++i)
            if (!$util.isString(message.reserved_name[i])) return 'reserved_name: string[] expected';
        }
        return null;
      };

      /**
       * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.DescriptorProto} DescriptorProto
       */
      DescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.DescriptorProto) return object;
        let message = new $root.google.protobuf.DescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.field) {
          if (!Array.isArray(object.field)) throw TypeError('.google.protobuf.DescriptorProto.field: array expected');
          message.field = [];
          for (let i = 0; i < object.field.length; ++i) {
            if (typeof object.field[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.field: object expected');
            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
          }
        }
        if (object.extension) {
          if (!Array.isArray(object.extension)) throw TypeError('.google.protobuf.DescriptorProto.extension: array expected');
          message.extension = [];
          for (let i = 0; i < object.extension.length; ++i) {
            if (typeof object.extension[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.extension: object expected');
            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
          }
        }
        if (object.nested_type) {
          if (!Array.isArray(object.nested_type)) throw TypeError('.google.protobuf.DescriptorProto.nested_type: array expected');
          message.nested_type = [];
          for (let i = 0; i < object.nested_type.length; ++i) {
            if (typeof object.nested_type[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.nested_type: object expected');
            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
          }
        }
        if (object.enum_type) {
          if (!Array.isArray(object.enum_type)) throw TypeError('.google.protobuf.DescriptorProto.enum_type: array expected');
          message.enum_type = [];
          for (let i = 0; i < object.enum_type.length; ++i) {
            if (typeof object.enum_type[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.enum_type: object expected');
            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
          }
        }
        if (object.extension_range) {
          if (!Array.isArray(object.extension_range)) throw TypeError('.google.protobuf.DescriptorProto.extension_range: array expected');
          message.extension_range = [];
          for (let i = 0; i < object.extension_range.length; ++i) {
            if (typeof object.extension_range[i] !== 'object')
              throw TypeError('.google.protobuf.DescriptorProto.extension_range: object expected');
            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
          }
        }
        if (object.oneof_decl) {
          if (!Array.isArray(object.oneof_decl)) throw TypeError('.google.protobuf.DescriptorProto.oneof_decl: array expected');
          message.oneof_decl = [];
          for (let i = 0; i < object.oneof_decl.length; ++i) {
            if (typeof object.oneof_decl[i] !== 'object') throw TypeError('.google.protobuf.DescriptorProto.oneof_decl: object expected');
            message.oneof_decl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneof_decl[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.DescriptorProto.options: object expected');
          message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
        }
        if (object.reserved_range) {
          if (!Array.isArray(object.reserved_range)) throw TypeError('.google.protobuf.DescriptorProto.reserved_range: array expected');
          message.reserved_range = [];
          for (let i = 0; i < object.reserved_range.length; ++i) {
            if (typeof object.reserved_range[i] !== 'object')
              throw TypeError('.google.protobuf.DescriptorProto.reserved_range: object expected');
            message.reserved_range[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reserved_range[i]);
          }
        }
        if (object.reserved_name) {
          if (!Array.isArray(object.reserved_name)) throw TypeError('.google.protobuf.DescriptorProto.reserved_name: array expected');
          message.reserved_name = [];
          for (let i = 0; i < object.reserved_name.length; ++i) message.reserved_name[i] = String(object.reserved_name[i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.DescriptorProto
       * @static
       * @param {google.protobuf.DescriptorProto} message DescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      DescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.field = [];
          object.nested_type = [];
          object.enum_type = [];
          object.extension_range = [];
          object.extension = [];
          object.oneof_decl = [];
          object.reserved_range = [];
          object.reserved_name = [];
        }
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.field && message.field.length) {
          object.field = [];
          for (let j = 0; j < message.field.length; ++j)
            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
        }
        if (message.nested_type && message.nested_type.length) {
          object.nested_type = [];
          for (let j = 0; j < message.nested_type.length; ++j)
            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
        }
        if (message.enum_type && message.enum_type.length) {
          object.enum_type = [];
          for (let j = 0; j < message.enum_type.length; ++j)
            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
        }
        if (message.extension_range && message.extension_range.length) {
          object.extension_range = [];
          for (let j = 0; j < message.extension_range.length; ++j)
            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
        }
        if (message.extension && message.extension.length) {
          object.extension = [];
          for (let j = 0; j < message.extension.length; ++j)
            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
        if (message.oneof_decl && message.oneof_decl.length) {
          object.oneof_decl = [];
          for (let j = 0; j < message.oneof_decl.length; ++j)
            object.oneof_decl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneof_decl[j], options);
        }
        if (message.reserved_range && message.reserved_range.length) {
          object.reserved_range = [];
          for (let j = 0; j < message.reserved_range.length; ++j)
            object.reserved_range[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reserved_range[j], options);
        }
        if (message.reserved_name && message.reserved_name.length) {
          object.reserved_name = [];
          for (let j = 0; j < message.reserved_name.length; ++j) object.reserved_name[j] = message.reserved_name[j];
        }
        return object;
      };

      /**
       * Converts this DescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.DescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      DescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      DescriptorProto.ExtensionRange = (function () {
        /**
         * Properties of an ExtensionRange.
         * @memberof google.protobuf.DescriptorProto
         * @interface IExtensionRange
         * @property {number|null} [start] ExtensionRange start
         * @property {number|null} [end] ExtensionRange end
         */

        /**
         * Constructs a new ExtensionRange.
         * @memberof google.protobuf.DescriptorProto
         * @classdesc Represents an ExtensionRange.
         * @implements IExtensionRange
         * @constructor
         * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
         */
        function ExtensionRange(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExtensionRange start.
         * @member {number} start
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         */
        ExtensionRange.prototype.start = 0;

        /**
         * ExtensionRange end.
         * @member {number} end
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         */
        ExtensionRange.prototype.end = 0;

        /**
         * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtensionRange.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExtensionRange message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtensionRange.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.start = reader.int32();
                break;
              case 2:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExtensionRange message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExtensionRange.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.start != null && message.hasOwnProperty('start'))
            if (!$util.isInteger(message.start)) return 'start: integer expected';
          if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
          return null;
        };

        /**
         * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
         */
        ExtensionRange.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange) return object;
          let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
          if (object.start != null) message.start = object.start | 0;
          if (object.end != null) message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @static
         * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExtensionRange.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.start = 0;
            object.end = 0;
          }
          if (message.start != null && message.hasOwnProperty('start')) object.start = message.start;
          if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
          return object;
        };

        /**
         * Converts this ExtensionRange to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto.ExtensionRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExtensionRange.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExtensionRange;
      })();

      DescriptorProto.ReservedRange = (function () {
        /**
         * Properties of a ReservedRange.
         * @memberof google.protobuf.DescriptorProto
         * @interface IReservedRange
         * @property {number|null} [start] ReservedRange start
         * @property {number|null} [end] ReservedRange end
         */

        /**
         * Constructs a new ReservedRange.
         * @memberof google.protobuf.DescriptorProto
         * @classdesc Represents a ReservedRange.
         * @implements IReservedRange
         * @constructor
         * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
         */
        function ReservedRange(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReservedRange start.
         * @member {number} start
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         */
        ReservedRange.prototype.start = 0;

        /**
         * ReservedRange end.
         * @member {number} end
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         */
        ReservedRange.prototype.end = 0;

        /**
         * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReservedRange.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, 'start'))
            writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.start);
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReservedRange message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReservedRange.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.DescriptorProto.ReservedRange();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.start = reader.int32();
                break;
              case 2:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReservedRange.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReservedRange message.
         * @function verify
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReservedRange.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.start != null && message.hasOwnProperty('start'))
            if (!$util.isInteger(message.start)) return 'start: integer expected';
          if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
          return null;
        };

        /**
         * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
         */
        ReservedRange.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange) return object;
          let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
          if (object.start != null) message.start = object.start | 0;
          if (object.end != null) message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @static
         * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReservedRange.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.start = 0;
            object.end = 0;
          }
          if (message.start != null && message.hasOwnProperty('start')) object.start = message.start;
          if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
          return object;
        };

        /**
         * Converts this ReservedRange to JSON.
         * @function toJSON
         * @memberof google.protobuf.DescriptorProto.ReservedRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReservedRange.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReservedRange;
      })();

      return DescriptorProto;
    })();

    protobuf.FieldDescriptorProto = (function () {
      /**
       * Properties of a FieldDescriptorProto.
       * @memberof google.protobuf
       * @interface IFieldDescriptorProto
       * @property {string|null} [name] FieldDescriptorProto name
       * @property {number|null} [number] FieldDescriptorProto number
       * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
       * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
       * @property {string|null} [type_name] FieldDescriptorProto type_name
       * @property {string|null} [extendee] FieldDescriptorProto extendee
       * @property {string|null} [default_value] FieldDescriptorProto default_value
       * @property {number|null} [oneof_index] FieldDescriptorProto oneof_index
       * @property {string|null} [json_name] FieldDescriptorProto json_name
       * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
       */

      /**
       * Constructs a new FieldDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a FieldDescriptorProto.
       * @implements IFieldDescriptorProto
       * @constructor
       * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
       */
      function FieldDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FieldDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.name = '';

      /**
       * FieldDescriptorProto number.
       * @member {number} number
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.number = 0;

      /**
       * FieldDescriptorProto label.
       * @member {google.protobuf.FieldDescriptorProto.Label} label
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.label = 1;

      /**
       * FieldDescriptorProto type.
       * @member {google.protobuf.FieldDescriptorProto.Type} type
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.type = 1;

      /**
       * FieldDescriptorProto type_name.
       * @member {string} type_name
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.type_name = '';

      /**
       * FieldDescriptorProto extendee.
       * @member {string} extendee
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.extendee = '';

      /**
       * FieldDescriptorProto default_value.
       * @member {string} default_value
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.default_value = '';

      /**
       * FieldDescriptorProto oneof_index.
       * @member {number} oneof_index
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.oneof_index = 0;

      /**
       * FieldDescriptorProto json_name.
       * @member {string} json_name
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.json_name = '';

      /**
       * FieldDescriptorProto options.
       * @member {google.protobuf.IFieldOptions|null|undefined} options
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       */
      FieldDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.extendee != null && Object.hasOwnProperty.call(message, 'extendee'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.extendee);
        if (message.number != null && Object.hasOwnProperty.call(message, 'number'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.number);
        if (message.label != null && Object.hasOwnProperty.call(message, 'label'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.label);
        if (message.type != null && Object.hasOwnProperty.call(message, 'type'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.type);
        if (message.type_name != null && Object.hasOwnProperty.call(message, 'type_name'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.type_name);
        if (message.default_value != null && Object.hasOwnProperty.call(message, 'default_value'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.default_value);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.oneof_index != null && Object.hasOwnProperty.call(message, 'oneof_index'))
          writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.oneof_index);
        if (message.json_name != null && Object.hasOwnProperty.call(message, 'json_name'))
          writer.uint32(/* id 10, wireType 2 =*/ 82).string(message.json_name);
        return writer;
      };

      /**
       * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FieldDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FieldDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 3:
              message.number = reader.int32();
              break;
            case 4:
              message.label = reader.int32();
              break;
            case 5:
              message.type = reader.int32();
              break;
            case 6:
              message.type_name = reader.string();
              break;
            case 2:
              message.extendee = reader.string();
              break;
            case 7:
              message.default_value = reader.string();
              break;
            case 9:
              message.oneof_index = reader.int32();
              break;
            case 10:
              message.json_name = reader.string();
              break;
            case 8:
              message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FieldDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FieldDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.number != null && message.hasOwnProperty('number'))
          if (!$util.isInteger(message.number)) return 'number: integer expected';
        if (message.label != null && message.hasOwnProperty('label'))
          switch (message.label) {
            default:
              return 'label: enum value expected';
            case 1:
            case 2:
            case 3:
              break;
          }
        if (message.type != null && message.hasOwnProperty('type'))
          switch (message.type) {
            default:
              return 'type: enum value expected';
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
              break;
          }
        if (message.type_name != null && message.hasOwnProperty('type_name'))
          if (!$util.isString(message.type_name)) return 'type_name: string expected';
        if (message.extendee != null && message.hasOwnProperty('extendee'))
          if (!$util.isString(message.extendee)) return 'extendee: string expected';
        if (message.default_value != null && message.hasOwnProperty('default_value'))
          if (!$util.isString(message.default_value)) return 'default_value: string expected';
        if (message.oneof_index != null && message.hasOwnProperty('oneof_index'))
          if (!$util.isInteger(message.oneof_index)) return 'oneof_index: integer expected';
        if (message.json_name != null && message.hasOwnProperty('json_name'))
          if (!$util.isString(message.json_name)) return 'json_name: string expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.FieldOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
       */
      FieldDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FieldDescriptorProto) return object;
        let message = new $root.google.protobuf.FieldDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.number != null) message.number = object.number | 0;
        switch (object.label) {
          case 'LABEL_OPTIONAL':
          case 1:
            message.label = 1;
            break;
          case 'LABEL_REQUIRED':
          case 2:
            message.label = 2;
            break;
          case 'LABEL_REPEATED':
          case 3:
            message.label = 3;
            break;
        }
        switch (object.type) {
          case 'TYPE_DOUBLE':
          case 1:
            message.type = 1;
            break;
          case 'TYPE_FLOAT':
          case 2:
            message.type = 2;
            break;
          case 'TYPE_INT64':
          case 3:
            message.type = 3;
            break;
          case 'TYPE_UINT64':
          case 4:
            message.type = 4;
            break;
          case 'TYPE_INT32':
          case 5:
            message.type = 5;
            break;
          case 'TYPE_FIXED64':
          case 6:
            message.type = 6;
            break;
          case 'TYPE_FIXED32':
          case 7:
            message.type = 7;
            break;
          case 'TYPE_BOOL':
          case 8:
            message.type = 8;
            break;
          case 'TYPE_STRING':
          case 9:
            message.type = 9;
            break;
          case 'TYPE_GROUP':
          case 10:
            message.type = 10;
            break;
          case 'TYPE_MESSAGE':
          case 11:
            message.type = 11;
            break;
          case 'TYPE_BYTES':
          case 12:
            message.type = 12;
            break;
          case 'TYPE_UINT32':
          case 13:
            message.type = 13;
            break;
          case 'TYPE_ENUM':
          case 14:
            message.type = 14;
            break;
          case 'TYPE_SFIXED32':
          case 15:
            message.type = 15;
            break;
          case 'TYPE_SFIXED64':
          case 16:
            message.type = 16;
            break;
          case 'TYPE_SINT32':
          case 17:
            message.type = 17;
            break;
          case 'TYPE_SINT64':
          case 18:
            message.type = 18;
            break;
        }
        if (object.type_name != null) message.type_name = String(object.type_name);
        if (object.extendee != null) message.extendee = String(object.extendee);
        if (object.default_value != null) message.default_value = String(object.default_value);
        if (object.oneof_index != null) message.oneof_index = object.oneof_index | 0;
        if (object.json_name != null) message.json_name = String(object.json_name);
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.FieldDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FieldDescriptorProto
       * @static
       * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FieldDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.extendee = '';
          object.number = 0;
          object.label = options.enums === String ? 'LABEL_OPTIONAL' : 1;
          object.type = options.enums === String ? 'TYPE_DOUBLE' : 1;
          object.type_name = '';
          object.default_value = '';
          object.options = null;
          object.oneof_index = 0;
          object.json_name = '';
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.extendee != null && message.hasOwnProperty('extendee')) object.extendee = message.extendee;
        if (message.number != null && message.hasOwnProperty('number')) object.number = message.number;
        if (message.label != null && message.hasOwnProperty('label'))
          object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
        if (message.type != null && message.hasOwnProperty('type'))
          object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
        if (message.type_name != null && message.hasOwnProperty('type_name')) object.type_name = message.type_name;
        if (message.default_value != null && message.hasOwnProperty('default_value')) object.default_value = message.default_value;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
        if (message.oneof_index != null && message.hasOwnProperty('oneof_index')) object.oneof_index = message.oneof_index;
        if (message.json_name != null && message.hasOwnProperty('json_name')) object.json_name = message.json_name;
        return object;
      };

      /**
       * Converts this FieldDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.FieldDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FieldDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * Type enum.
       * @name google.protobuf.FieldDescriptorProto.Type
       * @enum {number}
       * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
       * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
       * @property {number} TYPE_INT64=3 TYPE_INT64 value
       * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
       * @property {number} TYPE_INT32=5 TYPE_INT32 value
       * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
       * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
       * @property {number} TYPE_BOOL=8 TYPE_BOOL value
       * @property {number} TYPE_STRING=9 TYPE_STRING value
       * @property {number} TYPE_GROUP=10 TYPE_GROUP value
       * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
       * @property {number} TYPE_BYTES=12 TYPE_BYTES value
       * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
       * @property {number} TYPE_ENUM=14 TYPE_ENUM value
       * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
       * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
       * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
       * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
       */
      FieldDescriptorProto.Type = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[1] = 'TYPE_DOUBLE')] = 1;
        values[(valuesById[2] = 'TYPE_FLOAT')] = 2;
        values[(valuesById[3] = 'TYPE_INT64')] = 3;
        values[(valuesById[4] = 'TYPE_UINT64')] = 4;
        values[(valuesById[5] = 'TYPE_INT32')] = 5;
        values[(valuesById[6] = 'TYPE_FIXED64')] = 6;
        values[(valuesById[7] = 'TYPE_FIXED32')] = 7;
        values[(valuesById[8] = 'TYPE_BOOL')] = 8;
        values[(valuesById[9] = 'TYPE_STRING')] = 9;
        values[(valuesById[10] = 'TYPE_GROUP')] = 10;
        values[(valuesById[11] = 'TYPE_MESSAGE')] = 11;
        values[(valuesById[12] = 'TYPE_BYTES')] = 12;
        values[(valuesById[13] = 'TYPE_UINT32')] = 13;
        values[(valuesById[14] = 'TYPE_ENUM')] = 14;
        values[(valuesById[15] = 'TYPE_SFIXED32')] = 15;
        values[(valuesById[16] = 'TYPE_SFIXED64')] = 16;
        values[(valuesById[17] = 'TYPE_SINT32')] = 17;
        values[(valuesById[18] = 'TYPE_SINT64')] = 18;
        return values;
      })();

      /**
       * Label enum.
       * @name google.protobuf.FieldDescriptorProto.Label
       * @enum {number}
       * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
       * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
       * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
       */
      FieldDescriptorProto.Label = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[1] = 'LABEL_OPTIONAL')] = 1;
        values[(valuesById[2] = 'LABEL_REQUIRED')] = 2;
        values[(valuesById[3] = 'LABEL_REPEATED')] = 3;
        return values;
      })();

      return FieldDescriptorProto;
    })();

    protobuf.OneofDescriptorProto = (function () {
      /**
       * Properties of an OneofDescriptorProto.
       * @memberof google.protobuf
       * @interface IOneofDescriptorProto
       * @property {string|null} [name] OneofDescriptorProto name
       * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
       */

      /**
       * Constructs a new OneofDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an OneofDescriptorProto.
       * @implements IOneofDescriptorProto
       * @constructor
       * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
       */
      function OneofDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * OneofDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       */
      OneofDescriptorProto.prototype.name = '';

      /**
       * OneofDescriptorProto options.
       * @member {google.protobuf.IOneofOptions|null|undefined} options
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       */
      OneofDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OneofDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.OneofDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OneofDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OneofDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.OneofOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
       */
      OneofDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.OneofDescriptorProto) return object;
        let message = new $root.google.protobuf.OneofDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.OneofDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.OneofDescriptorProto
       * @static
       * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OneofDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this OneofDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.OneofDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OneofDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OneofDescriptorProto;
    })();

    protobuf.EnumDescriptorProto = (function () {
      /**
       * Properties of an EnumDescriptorProto.
       * @memberof google.protobuf
       * @interface IEnumDescriptorProto
       * @property {string|null} [name] EnumDescriptorProto name
       * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
       * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
       */

      /**
       * Constructs a new EnumDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an EnumDescriptorProto.
       * @implements IEnumDescriptorProto
       * @constructor
       * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
       */
      function EnumDescriptorProto(properties) {
        this.value = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.name = '';

      /**
       * EnumDescriptorProto value.
       * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.value = $util.emptyArray;

      /**
       * EnumDescriptorProto options.
       * @member {google.protobuf.IEnumOptions|null|undefined} options
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       */
      EnumDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.value != null && message.value.length)
          for (let i = 0; i < message.value.length; ++i)
            $root.google.protobuf.EnumValueDescriptorProto.encode(
              message.value[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.value && message.value.length)) message.value = [];
              message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.value != null && message.hasOwnProperty('value')) {
          if (!Array.isArray(message.value)) return 'value: array expected';
          for (let i = 0; i < message.value.length; ++i) {
            let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
            if (error) return 'value.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.EnumOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
       */
      EnumDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumDescriptorProto) return object;
        let message = new $root.google.protobuf.EnumDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.value) {
          if (!Array.isArray(object.value)) throw TypeError('.google.protobuf.EnumDescriptorProto.value: array expected');
          message.value = [];
          for (let i = 0; i < object.value.length; ++i) {
            if (typeof object.value[i] !== 'object') throw TypeError('.google.protobuf.EnumDescriptorProto.value: object expected');
            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.EnumDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumDescriptorProto
       * @static
       * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.value = [];
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.value && message.value.length) {
          object.value = [];
          for (let j = 0; j < message.value.length; ++j)
            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this EnumDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumDescriptorProto;
    })();

    protobuf.EnumValueDescriptorProto = (function () {
      /**
       * Properties of an EnumValueDescriptorProto.
       * @memberof google.protobuf
       * @interface IEnumValueDescriptorProto
       * @property {string|null} [name] EnumValueDescriptorProto name
       * @property {number|null} [number] EnumValueDescriptorProto number
       * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
       */

      /**
       * Constructs a new EnumValueDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents an EnumValueDescriptorProto.
       * @implements IEnumValueDescriptorProto
       * @constructor
       * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
       */
      function EnumValueDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumValueDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.name = '';

      /**
       * EnumValueDescriptorProto number.
       * @member {number} number
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.number = 0;

      /**
       * EnumValueDescriptorProto options.
       * @member {google.protobuf.IEnumValueOptions|null|undefined} options
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       */
      EnumValueDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.number != null && Object.hasOwnProperty.call(message, 'number'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.number);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumValueDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.number = reader.int32();
              break;
            case 3:
              message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumValueDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumValueDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.number != null && message.hasOwnProperty('number'))
          if (!$util.isInteger(message.number)) return 'number: integer expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
       */
      EnumValueDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumValueDescriptorProto) return object;
        let message = new $root.google.protobuf.EnumValueDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.number != null) message.number = object.number | 0;
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.EnumValueDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @static
       * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumValueDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.number = 0;
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.number != null && message.hasOwnProperty('number')) object.number = message.number;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this EnumValueDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumValueDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumValueDescriptorProto;
    })();

    protobuf.ServiceDescriptorProto = (function () {
      /**
       * Properties of a ServiceDescriptorProto.
       * @memberof google.protobuf
       * @interface IServiceDescriptorProto
       * @property {string|null} [name] ServiceDescriptorProto name
       * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
       * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
       */

      /**
       * Constructs a new ServiceDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a ServiceDescriptorProto.
       * @implements IServiceDescriptorProto
       * @constructor
       * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
       */
      function ServiceDescriptorProto(properties) {
        this.method = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ServiceDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.name = '';

      /**
       * ServiceDescriptorProto method.
       * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.method = $util.emptyArray;

      /**
       * ServiceDescriptorProto options.
       * @member {google.protobuf.IServiceOptions|null|undefined} options
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       */
      ServiceDescriptorProto.prototype.options = null;

      /**
       * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.method != null && message.method.length)
          for (let i = 0; i < message.method.length; ++i)
            $root.google.protobuf.MethodDescriptorProto.encode(
              message.method[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.ServiceDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              if (!(message.method && message.method.length)) message.method = [];
              message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
              break;
            case 3:
              message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ServiceDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ServiceDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.method != null && message.hasOwnProperty('method')) {
          if (!Array.isArray(message.method)) return 'method: array expected';
          for (let i = 0; i < message.method.length; ++i) {
            let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
            if (error) return 'method.' + error;
          }
        }
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.ServiceOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        return null;
      };

      /**
       * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
       */
      ServiceDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.ServiceDescriptorProto) return object;
        let message = new $root.google.protobuf.ServiceDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.method) {
          if (!Array.isArray(object.method)) throw TypeError('.google.protobuf.ServiceDescriptorProto.method: array expected');
          message.method = [];
          for (let i = 0; i < object.method.length; ++i) {
            if (typeof object.method[i] !== 'object') throw TypeError('.google.protobuf.ServiceDescriptorProto.method: object expected');
            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
          }
        }
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.ServiceDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
        }
        return message;
      };

      /**
       * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.ServiceDescriptorProto
       * @static
       * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ServiceDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.method = [];
        if (options.defaults) {
          object.name = '';
          object.options = null;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.method && message.method.length) {
          object.method = [];
          for (let j = 0; j < message.method.length; ++j)
            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
        }
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
        return object;
      };

      /**
       * Converts this ServiceDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.ServiceDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ServiceDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ServiceDescriptorProto;
    })();

    protobuf.MethodDescriptorProto = (function () {
      /**
       * Properties of a MethodDescriptorProto.
       * @memberof google.protobuf
       * @interface IMethodDescriptorProto
       * @property {string|null} [name] MethodDescriptorProto name
       * @property {string|null} [input_type] MethodDescriptorProto input_type
       * @property {string|null} [output_type] MethodDescriptorProto output_type
       * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
       * @property {boolean|null} [client_streaming] MethodDescriptorProto client_streaming
       * @property {boolean|null} [server_streaming] MethodDescriptorProto server_streaming
       */

      /**
       * Constructs a new MethodDescriptorProto.
       * @memberof google.protobuf
       * @classdesc Represents a MethodDescriptorProto.
       * @implements IMethodDescriptorProto
       * @constructor
       * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
       */
      function MethodDescriptorProto(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MethodDescriptorProto name.
       * @member {string} name
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.name = '';

      /**
       * MethodDescriptorProto input_type.
       * @member {string} input_type
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.input_type = '';

      /**
       * MethodDescriptorProto output_type.
       * @member {string} output_type
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.output_type = '';

      /**
       * MethodDescriptorProto options.
       * @member {google.protobuf.IMethodOptions|null|undefined} options
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.options = null;

      /**
       * MethodDescriptorProto client_streaming.
       * @member {boolean} client_streaming
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.client_streaming = false;

      /**
       * MethodDescriptorProto server_streaming.
       * @member {boolean} server_streaming
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       */
      MethodDescriptorProto.prototype.server_streaming = false;

      /**
       * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodDescriptorProto.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
        if (message.input_type != null && Object.hasOwnProperty.call(message, 'input_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.input_type);
        if (message.output_type != null && Object.hasOwnProperty.call(message, 'output_type'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.output_type);
        if (message.options != null && Object.hasOwnProperty.call(message, 'options'))
          $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
        if (message.client_streaming != null && Object.hasOwnProperty.call(message, 'client_streaming'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.client_streaming);
        if (message.server_streaming != null && Object.hasOwnProperty.call(message, 'server_streaming'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.server_streaming);
        return writer;
      };

      /**
       * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MethodDescriptorProto message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodDescriptorProto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.MethodDescriptorProto();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.input_type = reader.string();
              break;
            case 3:
              message.output_type = reader.string();
              break;
            case 4:
              message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
              break;
            case 5:
              message.client_streaming = reader.bool();
              break;
            case 6:
              message.server_streaming = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MethodDescriptorProto message.
       * @function verify
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MethodDescriptorProto.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.input_type != null && message.hasOwnProperty('input_type'))
          if (!$util.isString(message.input_type)) return 'input_type: string expected';
        if (message.output_type != null && message.hasOwnProperty('output_type'))
          if (!$util.isString(message.output_type)) return 'output_type: string expected';
        if (message.options != null && message.hasOwnProperty('options')) {
          let error = $root.google.protobuf.MethodOptions.verify(message.options);
          if (error) return 'options.' + error;
        }
        if (message.client_streaming != null && message.hasOwnProperty('client_streaming'))
          if (typeof message.client_streaming !== 'boolean') return 'client_streaming: boolean expected';
        if (message.server_streaming != null && message.hasOwnProperty('server_streaming'))
          if (typeof message.server_streaming !== 'boolean') return 'server_streaming: boolean expected';
        return null;
      };

      /**
       * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
       */
      MethodDescriptorProto.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MethodDescriptorProto) return object;
        let message = new $root.google.protobuf.MethodDescriptorProto();
        if (object.name != null) message.name = String(object.name);
        if (object.input_type != null) message.input_type = String(object.input_type);
        if (object.output_type != null) message.output_type = String(object.output_type);
        if (object.options != null) {
          if (typeof object.options !== 'object') throw TypeError('.google.protobuf.MethodDescriptorProto.options: object expected');
          message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
        }
        if (object.client_streaming != null) message.client_streaming = Boolean(object.client_streaming);
        if (object.server_streaming != null) message.server_streaming = Boolean(object.server_streaming);
        return message;
      };

      /**
       * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MethodDescriptorProto
       * @static
       * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MethodDescriptorProto.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.name = '';
          object.input_type = '';
          object.output_type = '';
          object.options = null;
          object.client_streaming = false;
          object.server_streaming = false;
        }
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.input_type != null && message.hasOwnProperty('input_type')) object.input_type = message.input_type;
        if (message.output_type != null && message.hasOwnProperty('output_type')) object.output_type = message.output_type;
        if (message.options != null && message.hasOwnProperty('options'))
          object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
        if (message.client_streaming != null && message.hasOwnProperty('client_streaming'))
          object.client_streaming = message.client_streaming;
        if (message.server_streaming != null && message.hasOwnProperty('server_streaming'))
          object.server_streaming = message.server_streaming;
        return object;
      };

      /**
       * Converts this MethodDescriptorProto to JSON.
       * @function toJSON
       * @memberof google.protobuf.MethodDescriptorProto
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MethodDescriptorProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MethodDescriptorProto;
    })();

    protobuf.FileOptions = (function () {
      /**
       * Properties of a FileOptions.
       * @memberof google.protobuf
       * @interface IFileOptions
       * @property {string|null} [java_package] FileOptions java_package
       * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
       * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
       * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
       * @property {boolean|null} [java_string_check_utf8] FileOptions java_string_check_utf8
       * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
       * @property {string|null} [go_package] FileOptions go_package
       * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
       * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
       * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
       * @property {boolean|null} [deprecated] FileOptions deprecated
       * @property {boolean|null} [cc_enable_arenas] FileOptions cc_enable_arenas
       * @property {string|null} [objc_class_prefix] FileOptions objc_class_prefix
       * @property {string|null} [csharp_namespace] FileOptions csharp_namespace
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
       */

      /**
       * Constructs a new FileOptions.
       * @memberof google.protobuf
       * @classdesc Represents a FileOptions.
       * @implements IFileOptions
       * @constructor
       * @param {google.protobuf.IFileOptions=} [properties] Properties to set
       */
      function FileOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FileOptions java_package.
       * @member {string} java_package
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_package = '';

      /**
       * FileOptions java_outer_classname.
       * @member {string} java_outer_classname
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_outer_classname = '';

      /**
       * FileOptions java_multiple_files.
       * @member {boolean} java_multiple_files
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_multiple_files = false;

      /**
       * FileOptions java_generate_equals_and_hash.
       * @member {boolean} java_generate_equals_and_hash
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_generate_equals_and_hash = false;

      /**
       * FileOptions java_string_check_utf8.
       * @member {boolean} java_string_check_utf8
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_string_check_utf8 = false;

      /**
       * FileOptions optimize_for.
       * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.optimize_for = 1;

      /**
       * FileOptions go_package.
       * @member {string} go_package
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.go_package = '';

      /**
       * FileOptions cc_generic_services.
       * @member {boolean} cc_generic_services
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.cc_generic_services = false;

      /**
       * FileOptions java_generic_services.
       * @member {boolean} java_generic_services
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.java_generic_services = false;

      /**
       * FileOptions py_generic_services.
       * @member {boolean} py_generic_services
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.py_generic_services = false;

      /**
       * FileOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.deprecated = false;

      /**
       * FileOptions cc_enable_arenas.
       * @member {boolean} cc_enable_arenas
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.cc_enable_arenas = false;

      /**
       * FileOptions objc_class_prefix.
       * @member {string} objc_class_prefix
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.objc_class_prefix = '';

      /**
       * FileOptions csharp_namespace.
       * @member {string} csharp_namespace
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.csharp_namespace = '';

      /**
       * FileOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.FileOptions
       * @instance
       */
      FileOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.java_package != null && Object.hasOwnProperty.call(message, 'java_package'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.java_package);
        if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, 'java_outer_classname'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.java_outer_classname);
        if (message.optimize_for != null && Object.hasOwnProperty.call(message, 'optimize_for'))
          writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.optimize_for);
        if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, 'java_multiple_files'))
          writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.java_multiple_files);
        if (message.go_package != null && Object.hasOwnProperty.call(message, 'go_package'))
          writer.uint32(/* id 11, wireType 2 =*/ 90).string(message.go_package);
        if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, 'cc_generic_services'))
          writer.uint32(/* id 16, wireType 0 =*/ 128).bool(message.cc_generic_services);
        if (message.java_generic_services != null && Object.hasOwnProperty.call(message, 'java_generic_services'))
          writer.uint32(/* id 17, wireType 0 =*/ 136).bool(message.java_generic_services);
        if (message.py_generic_services != null && Object.hasOwnProperty.call(message, 'py_generic_services'))
          writer.uint32(/* id 18, wireType 0 =*/ 144).bool(message.py_generic_services);
        if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, 'java_generate_equals_and_hash'))
          writer.uint32(/* id 20, wireType 0 =*/ 160).bool(message.java_generate_equals_and_hash);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 23, wireType 0 =*/ 184).bool(message.deprecated);
        if (message.java_string_check_utf8 != null && Object.hasOwnProperty.call(message, 'java_string_check_utf8'))
          writer.uint32(/* id 27, wireType 0 =*/ 216).bool(message.java_string_check_utf8);
        if (message.cc_enable_arenas != null && Object.hasOwnProperty.call(message, 'cc_enable_arenas'))
          writer.uint32(/* id 31, wireType 0 =*/ 248).bool(message.cc_enable_arenas);
        if (message.objc_class_prefix != null && Object.hasOwnProperty.call(message, 'objc_class_prefix'))
          writer.uint32(/* id 36, wireType 2 =*/ 290).string(message.objc_class_prefix);
        if (message.csharp_namespace != null && Object.hasOwnProperty.call(message, 'csharp_namespace'))
          writer.uint32(/* id 37, wireType 2 =*/ 298).string(message.csharp_namespace);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FileOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FileOptions} FileOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FileOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.java_package = reader.string();
              break;
            case 8:
              message.java_outer_classname = reader.string();
              break;
            case 10:
              message.java_multiple_files = reader.bool();
              break;
            case 20:
              message.java_generate_equals_and_hash = reader.bool();
              break;
            case 27:
              message.java_string_check_utf8 = reader.bool();
              break;
            case 9:
              message.optimize_for = reader.int32();
              break;
            case 11:
              message.go_package = reader.string();
              break;
            case 16:
              message.cc_generic_services = reader.bool();
              break;
            case 17:
              message.java_generic_services = reader.bool();
              break;
            case 18:
              message.py_generic_services = reader.bool();
              break;
            case 23:
              message.deprecated = reader.bool();
              break;
            case 31:
              message.cc_enable_arenas = reader.bool();
              break;
            case 36:
              message.objc_class_prefix = reader.string();
              break;
            case 37:
              message.csharp_namespace = reader.string();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FileOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FileOptions} FileOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FileOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FileOptions message.
       * @function verify
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FileOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.java_package != null && message.hasOwnProperty('java_package'))
          if (!$util.isString(message.java_package)) return 'java_package: string expected';
        if (message.java_outer_classname != null && message.hasOwnProperty('java_outer_classname'))
          if (!$util.isString(message.java_outer_classname)) return 'java_outer_classname: string expected';
        if (message.java_multiple_files != null && message.hasOwnProperty('java_multiple_files'))
          if (typeof message.java_multiple_files !== 'boolean') return 'java_multiple_files: boolean expected';
        if (message.java_generate_equals_and_hash != null && message.hasOwnProperty('java_generate_equals_and_hash'))
          if (typeof message.java_generate_equals_and_hash !== 'boolean') return 'java_generate_equals_and_hash: boolean expected';
        if (message.java_string_check_utf8 != null && message.hasOwnProperty('java_string_check_utf8'))
          if (typeof message.java_string_check_utf8 !== 'boolean') return 'java_string_check_utf8: boolean expected';
        if (message.optimize_for != null && message.hasOwnProperty('optimize_for'))
          switch (message.optimize_for) {
            default:
              return 'optimize_for: enum value expected';
            case 1:
            case 2:
            case 3:
              break;
          }
        if (message.go_package != null && message.hasOwnProperty('go_package'))
          if (!$util.isString(message.go_package)) return 'go_package: string expected';
        if (message.cc_generic_services != null && message.hasOwnProperty('cc_generic_services'))
          if (typeof message.cc_generic_services !== 'boolean') return 'cc_generic_services: boolean expected';
        if (message.java_generic_services != null && message.hasOwnProperty('java_generic_services'))
          if (typeof message.java_generic_services !== 'boolean') return 'java_generic_services: boolean expected';
        if (message.py_generic_services != null && message.hasOwnProperty('py_generic_services'))
          if (typeof message.py_generic_services !== 'boolean') return 'py_generic_services: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.cc_enable_arenas != null && message.hasOwnProperty('cc_enable_arenas'))
          if (typeof message.cc_enable_arenas !== 'boolean') return 'cc_enable_arenas: boolean expected';
        if (message.objc_class_prefix != null && message.hasOwnProperty('objc_class_prefix'))
          if (!$util.isString(message.objc_class_prefix)) return 'objc_class_prefix: string expected';
        if (message.csharp_namespace != null && message.hasOwnProperty('csharp_namespace'))
          if (!$util.isString(message.csharp_namespace)) return 'csharp_namespace: string expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FileOptions} FileOptions
       */
      FileOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FileOptions) return object;
        let message = new $root.google.protobuf.FileOptions();
        if (object.java_package != null) message.java_package = String(object.java_package);
        if (object.java_outer_classname != null) message.java_outer_classname = String(object.java_outer_classname);
        if (object.java_multiple_files != null) message.java_multiple_files = Boolean(object.java_multiple_files);
        if (object.java_generate_equals_and_hash != null)
          message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
        if (object.java_string_check_utf8 != null) message.java_string_check_utf8 = Boolean(object.java_string_check_utf8);
        switch (object.optimize_for) {
          case 'SPEED':
          case 1:
            message.optimize_for = 1;
            break;
          case 'CODE_SIZE':
          case 2:
            message.optimize_for = 2;
            break;
          case 'LITE_RUNTIME':
          case 3:
            message.optimize_for = 3;
            break;
        }
        if (object.go_package != null) message.go_package = String(object.go_package);
        if (object.cc_generic_services != null) message.cc_generic_services = Boolean(object.cc_generic_services);
        if (object.java_generic_services != null) message.java_generic_services = Boolean(object.java_generic_services);
        if (object.py_generic_services != null) message.py_generic_services = Boolean(object.py_generic_services);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.cc_enable_arenas != null) message.cc_enable_arenas = Boolean(object.cc_enable_arenas);
        if (object.objc_class_prefix != null) message.objc_class_prefix = String(object.objc_class_prefix);
        if (object.csharp_namespace != null) message.csharp_namespace = String(object.csharp_namespace);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.FileOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.FileOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FileOptions
       * @static
       * @param {google.protobuf.FileOptions} message FileOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FileOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.java_package = '';
          object.java_outer_classname = '';
          object.optimize_for = options.enums === String ? 'SPEED' : 1;
          object.java_multiple_files = false;
          object.go_package = '';
          object.cc_generic_services = false;
          object.java_generic_services = false;
          object.py_generic_services = false;
          object.java_generate_equals_and_hash = false;
          object.deprecated = false;
          object.java_string_check_utf8 = false;
          object.cc_enable_arenas = false;
          object.objc_class_prefix = '';
          object.csharp_namespace = '';
        }
        if (message.java_package != null && message.hasOwnProperty('java_package')) object.java_package = message.java_package;
        if (message.java_outer_classname != null && message.hasOwnProperty('java_outer_classname'))
          object.java_outer_classname = message.java_outer_classname;
        if (message.optimize_for != null && message.hasOwnProperty('optimize_for'))
          object.optimize_for =
            options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
        if (message.java_multiple_files != null && message.hasOwnProperty('java_multiple_files'))
          object.java_multiple_files = message.java_multiple_files;
        if (message.go_package != null && message.hasOwnProperty('go_package')) object.go_package = message.go_package;
        if (message.cc_generic_services != null && message.hasOwnProperty('cc_generic_services'))
          object.cc_generic_services = message.cc_generic_services;
        if (message.java_generic_services != null && message.hasOwnProperty('java_generic_services'))
          object.java_generic_services = message.java_generic_services;
        if (message.py_generic_services != null && message.hasOwnProperty('py_generic_services'))
          object.py_generic_services = message.py_generic_services;
        if (message.java_generate_equals_and_hash != null && message.hasOwnProperty('java_generate_equals_and_hash'))
          object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.java_string_check_utf8 != null && message.hasOwnProperty('java_string_check_utf8'))
          object.java_string_check_utf8 = message.java_string_check_utf8;
        if (message.cc_enable_arenas != null && message.hasOwnProperty('cc_enable_arenas'))
          object.cc_enable_arenas = message.cc_enable_arenas;
        if (message.objc_class_prefix != null && message.hasOwnProperty('objc_class_prefix'))
          object.objc_class_prefix = message.objc_class_prefix;
        if (message.csharp_namespace != null && message.hasOwnProperty('csharp_namespace'))
          object.csharp_namespace = message.csharp_namespace;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        return object;
      };

      /**
       * Converts this FileOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.FileOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FileOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * OptimizeMode enum.
       * @name google.protobuf.FileOptions.OptimizeMode
       * @enum {number}
       * @property {number} SPEED=1 SPEED value
       * @property {number} CODE_SIZE=2 CODE_SIZE value
       * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
       */
      FileOptions.OptimizeMode = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[1] = 'SPEED')] = 1;
        values[(valuesById[2] = 'CODE_SIZE')] = 2;
        values[(valuesById[3] = 'LITE_RUNTIME')] = 3;
        return values;
      })();

      return FileOptions;
    })();

    protobuf.MessageOptions = (function () {
      /**
       * Properties of a MessageOptions.
       * @memberof google.protobuf
       * @interface IMessageOptions
       * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
       * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
       * @property {boolean|null} [deprecated] MessageOptions deprecated
       * @property {boolean|null} [map_entry] MessageOptions map_entry
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
       * @property {Array.<string>|null} [".cosmos.msg.v1.signer"] MessageOptions .cosmos.msg.v1.signer
       */

      /**
       * Constructs a new MessageOptions.
       * @memberof google.protobuf
       * @classdesc Represents a MessageOptions.
       * @implements IMessageOptions
       * @constructor
       * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
       */
      function MessageOptions(properties) {
        this.uninterpreted_option = [];
        this['.cosmos.msg.v1.signer'] = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MessageOptions message_set_wire_format.
       * @member {boolean} message_set_wire_format
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.message_set_wire_format = false;

      /**
       * MessageOptions no_standard_descriptor_accessor.
       * @member {boolean} no_standard_descriptor_accessor
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.no_standard_descriptor_accessor = false;

      /**
       * MessageOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.deprecated = false;

      /**
       * MessageOptions map_entry.
       * @member {boolean} map_entry
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.map_entry = false;

      /**
       * MessageOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * MessageOptions .cosmos.msg.v1.signer.
       * @member {Array.<string>} .cosmos.msg.v1.signer
       * @memberof google.protobuf.MessageOptions
       * @instance
       */
      MessageOptions.prototype['.cosmos.msg.v1.signer'] = $util.emptyArray;

      /**
       * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MessageOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, 'message_set_wire_format'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.message_set_wire_format);
        if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, 'no_standard_descriptor_accessor'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.no_standard_descriptor_accessor);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
        if (message.map_entry != null && Object.hasOwnProperty.call(message, 'map_entry'))
          writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.map_entry);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.cosmos.msg.v1.signer'] != null && message['.cosmos.msg.v1.signer'].length)
          for (let i = 0; i < message['.cosmos.msg.v1.signer'].length; ++i)
            writer.uint32(/* id 11110000, wireType 2 =*/ 88880002).string(message['.cosmos.msg.v1.signer'][i]);
        return writer;
      };

      /**
       * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MessageOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MessageOptions} MessageOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MessageOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.MessageOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message_set_wire_format = reader.bool();
              break;
            case 2:
              message.no_standard_descriptor_accessor = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 7:
              message.map_entry = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 11110000:
              if (!(message['.cosmos.msg.v1.signer'] && message['.cosmos.msg.v1.signer'].length)) message['.cosmos.msg.v1.signer'] = [];
              message['.cosmos.msg.v1.signer'].push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MessageOptions} MessageOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MessageOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MessageOptions message.
       * @function verify
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MessageOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.message_set_wire_format != null && message.hasOwnProperty('message_set_wire_format'))
          if (typeof message.message_set_wire_format !== 'boolean') return 'message_set_wire_format: boolean expected';
        if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty('no_standard_descriptor_accessor'))
          if (typeof message.no_standard_descriptor_accessor !== 'boolean') return 'no_standard_descriptor_accessor: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.map_entry != null && message.hasOwnProperty('map_entry'))
          if (typeof message.map_entry !== 'boolean') return 'map_entry: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.cosmos.msg.v1.signer'] != null && message.hasOwnProperty('.cosmos.msg.v1.signer')) {
          if (!Array.isArray(message['.cosmos.msg.v1.signer'])) return '.cosmos.msg.v1.signer: array expected';
          for (let i = 0; i < message['.cosmos.msg.v1.signer'].length; ++i)
            if (!$util.isString(message['.cosmos.msg.v1.signer'][i])) return '.cosmos.msg.v1.signer: string[] expected';
        }
        return null;
      };

      /**
       * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MessageOptions} MessageOptions
       */
      MessageOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MessageOptions) return object;
        let message = new $root.google.protobuf.MessageOptions();
        if (object.message_set_wire_format != null) message.message_set_wire_format = Boolean(object.message_set_wire_format);
        if (object.no_standard_descriptor_accessor != null)
          message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.map_entry != null) message.map_entry = Boolean(object.map_entry);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.MessageOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.MessageOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.cosmos.msg.v1.signer']) {
          if (!Array.isArray(object['.cosmos.msg.v1.signer']))
            throw TypeError('.google.protobuf.MessageOptions..cosmos.msg.v1.signer: array expected');
          message['.cosmos.msg.v1.signer'] = [];
          for (let i = 0; i < object['.cosmos.msg.v1.signer'].length; ++i)
            message['.cosmos.msg.v1.signer'][i] = String(object['.cosmos.msg.v1.signer'][i]);
        }
        return message;
      };

      /**
       * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MessageOptions
       * @static
       * @param {google.protobuf.MessageOptions} message MessageOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MessageOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.uninterpreted_option = [];
          object['.cosmos.msg.v1.signer'] = [];
        }
        if (options.defaults) {
          object.message_set_wire_format = false;
          object.no_standard_descriptor_accessor = false;
          object.deprecated = false;
          object.map_entry = false;
        }
        if (message.message_set_wire_format != null && message.hasOwnProperty('message_set_wire_format'))
          object.message_set_wire_format = message.message_set_wire_format;
        if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty('no_standard_descriptor_accessor'))
          object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.map_entry != null && message.hasOwnProperty('map_entry')) object.map_entry = message.map_entry;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.cosmos.msg.v1.signer'] && message['.cosmos.msg.v1.signer'].length) {
          object['.cosmos.msg.v1.signer'] = [];
          for (let j = 0; j < message['.cosmos.msg.v1.signer'].length; ++j)
            object['.cosmos.msg.v1.signer'][j] = message['.cosmos.msg.v1.signer'][j];
        }
        return object;
      };

      /**
       * Converts this MessageOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.MessageOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MessageOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MessageOptions;
    })();

    protobuf.FieldOptions = (function () {
      /**
       * Properties of a FieldOptions.
       * @memberof google.protobuf
       * @interface IFieldOptions
       * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
       * @property {boolean|null} [packed] FieldOptions packed
       * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
       * @property {boolean|null} [lazy] FieldOptions lazy
       * @property {boolean|null} [deprecated] FieldOptions deprecated
       * @property {boolean|null} [weak] FieldOptions weak
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
       */

      /**
       * Constructs a new FieldOptions.
       * @memberof google.protobuf
       * @classdesc Represents a FieldOptions.
       * @implements IFieldOptions
       * @constructor
       * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
       */
      function FieldOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * FieldOptions ctype.
       * @member {google.protobuf.FieldOptions.CType} ctype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.ctype = 0;

      /**
       * FieldOptions packed.
       * @member {boolean} packed
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.packed = false;

      /**
       * FieldOptions jstype.
       * @member {google.protobuf.FieldOptions.JSType} jstype
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.jstype = 0;

      /**
       * FieldOptions lazy.
       * @member {boolean} lazy
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.lazy = false;

      /**
       * FieldOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.deprecated = false;

      /**
       * FieldOptions weak.
       * @member {boolean} weak
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.weak = false;

      /**
       * FieldOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.FieldOptions
       * @instance
       */
      FieldOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.ctype != null && Object.hasOwnProperty.call(message, 'ctype'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.ctype);
        if (message.packed != null && Object.hasOwnProperty.call(message, 'packed'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.packed);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
        if (message.lazy != null && Object.hasOwnProperty.call(message, 'lazy'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.lazy);
        if (message.jstype != null && Object.hasOwnProperty.call(message, 'jstype'))
          writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.jstype);
        if (message.weak != null && Object.hasOwnProperty.call(message, 'weak'))
          writer.uint32(/* id 10, wireType 0 =*/ 80).bool(message.weak);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a FieldOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.FieldOptions} FieldOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.FieldOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ctype = reader.int32();
              break;
            case 2:
              message.packed = reader.bool();
              break;
            case 6:
              message.jstype = reader.int32();
              break;
            case 5:
              message.lazy = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 10:
              message.weak = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.FieldOptions} FieldOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      FieldOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a FieldOptions message.
       * @function verify
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      FieldOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.ctype != null && message.hasOwnProperty('ctype'))
          switch (message.ctype) {
            default:
              return 'ctype: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.packed != null && message.hasOwnProperty('packed'))
          if (typeof message.packed !== 'boolean') return 'packed: boolean expected';
        if (message.jstype != null && message.hasOwnProperty('jstype'))
          switch (message.jstype) {
            default:
              return 'jstype: enum value expected';
            case 0:
            case 1:
            case 2:
              break;
          }
        if (message.lazy != null && message.hasOwnProperty('lazy')) if (typeof message.lazy !== 'boolean') return 'lazy: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.weak != null && message.hasOwnProperty('weak')) if (typeof message.weak !== 'boolean') return 'weak: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.FieldOptions} FieldOptions
       */
      FieldOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.FieldOptions) return object;
        let message = new $root.google.protobuf.FieldOptions();
        switch (object.ctype) {
          case 'STRING':
          case 0:
            message.ctype = 0;
            break;
          case 'CORD':
          case 1:
            message.ctype = 1;
            break;
          case 'STRING_PIECE':
          case 2:
            message.ctype = 2;
            break;
        }
        if (object.packed != null) message.packed = Boolean(object.packed);
        switch (object.jstype) {
          case 'JS_NORMAL':
          case 0:
            message.jstype = 0;
            break;
          case 'JS_STRING':
          case 1:
            message.jstype = 1;
            break;
          case 'JS_NUMBER':
          case 2:
            message.jstype = 2;
            break;
        }
        if (object.lazy != null) message.lazy = Boolean(object.lazy);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.weak != null) message.weak = Boolean(object.weak);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.FieldOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.FieldOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.FieldOptions
       * @static
       * @param {google.protobuf.FieldOptions} message FieldOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      FieldOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.ctype = options.enums === String ? 'STRING' : 0;
          object.packed = false;
          object.deprecated = false;
          object.lazy = false;
          object.jstype = options.enums === String ? 'JS_NORMAL' : 0;
          object.weak = false;
        }
        if (message.ctype != null && message.hasOwnProperty('ctype'))
          object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
        if (message.packed != null && message.hasOwnProperty('packed')) object.packed = message.packed;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.lazy != null && message.hasOwnProperty('lazy')) object.lazy = message.lazy;
        if (message.jstype != null && message.hasOwnProperty('jstype'))
          object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
        if (message.weak != null && message.hasOwnProperty('weak')) object.weak = message.weak;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        return object;
      };

      /**
       * Converts this FieldOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.FieldOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      FieldOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * CType enum.
       * @name google.protobuf.FieldOptions.CType
       * @enum {number}
       * @property {number} STRING=0 STRING value
       * @property {number} CORD=1 CORD value
       * @property {number} STRING_PIECE=2 STRING_PIECE value
       */
      FieldOptions.CType = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'STRING')] = 0;
        values[(valuesById[1] = 'CORD')] = 1;
        values[(valuesById[2] = 'STRING_PIECE')] = 2;
        return values;
      })();

      /**
       * JSType enum.
       * @name google.protobuf.FieldOptions.JSType
       * @enum {number}
       * @property {number} JS_NORMAL=0 JS_NORMAL value
       * @property {number} JS_STRING=1 JS_STRING value
       * @property {number} JS_NUMBER=2 JS_NUMBER value
       */
      FieldOptions.JSType = (function () {
        const valuesById = {},
          values = Object.create(valuesById);
        values[(valuesById[0] = 'JS_NORMAL')] = 0;
        values[(valuesById[1] = 'JS_STRING')] = 1;
        values[(valuesById[2] = 'JS_NUMBER')] = 2;
        return values;
      })();

      return FieldOptions;
    })();

    protobuf.OneofOptions = (function () {
      /**
       * Properties of an OneofOptions.
       * @memberof google.protobuf
       * @interface IOneofOptions
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] OneofOptions uninterpreted_option
       */

      /**
       * Constructs a new OneofOptions.
       * @memberof google.protobuf
       * @classdesc Represents an OneofOptions.
       * @implements IOneofOptions
       * @constructor
       * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
       */
      function OneofOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * OneofOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.OneofOptions
       * @instance
       */
      OneofOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an OneofOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.OneofOptions} OneofOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.OneofOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.OneofOptions} OneofOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      OneofOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an OneofOptions message.
       * @function verify
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      OneofOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.OneofOptions} OneofOptions
       */
      OneofOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.OneofOptions) return object;
        let message = new $root.google.protobuf.OneofOptions();
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.OneofOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.OneofOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.OneofOptions
       * @static
       * @param {google.protobuf.OneofOptions} message OneofOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      OneofOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        return object;
      };

      /**
       * Converts this OneofOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.OneofOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      OneofOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return OneofOptions;
    })();

    protobuf.EnumOptions = (function () {
      /**
       * Properties of an EnumOptions.
       * @memberof google.protobuf
       * @interface IEnumOptions
       * @property {boolean|null} [allow_alias] EnumOptions allow_alias
       * @property {boolean|null} [deprecated] EnumOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
       */

      /**
       * Constructs a new EnumOptions.
       * @memberof google.protobuf
       * @classdesc Represents an EnumOptions.
       * @implements IEnumOptions
       * @constructor
       * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
       */
      function EnumOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumOptions allow_alias.
       * @member {boolean} allow_alias
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.allow_alias = false;

      /**
       * EnumOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.deprecated = false;

      /**
       * EnumOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.EnumOptions
       * @instance
       */
      EnumOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.allow_alias != null && Object.hasOwnProperty.call(message, 'allow_alias'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.allow_alias);
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumOptions} EnumOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.allow_alias = reader.bool();
              break;
            case 3:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumOptions} EnumOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumOptions message.
       * @function verify
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.allow_alias != null && message.hasOwnProperty('allow_alias'))
          if (typeof message.allow_alias !== 'boolean') return 'allow_alias: boolean expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumOptions} EnumOptions
       */
      EnumOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumOptions) return object;
        let message = new $root.google.protobuf.EnumOptions();
        if (object.allow_alias != null) message.allow_alias = Boolean(object.allow_alias);
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.EnumOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.EnumOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumOptions
       * @static
       * @param {google.protobuf.EnumOptions} message EnumOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.allow_alias = false;
          object.deprecated = false;
        }
        if (message.allow_alias != null && message.hasOwnProperty('allow_alias')) object.allow_alias = message.allow_alias;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        return object;
      };

      /**
       * Converts this EnumOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumOptions;
    })();

    protobuf.EnumValueOptions = (function () {
      /**
       * Properties of an EnumValueOptions.
       * @memberof google.protobuf
       * @interface IEnumValueOptions
       * @property {boolean|null} [deprecated] EnumValueOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
       */

      /**
       * Constructs a new EnumValueOptions.
       * @memberof google.protobuf
       * @classdesc Represents an EnumValueOptions.
       * @implements IEnumValueOptions
       * @constructor
       * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
       */
      function EnumValueOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * EnumValueOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       */
      EnumValueOptions.prototype.deprecated = false;

      /**
       * EnumValueOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       */
      EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an EnumValueOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.EnumValueOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an EnumValueOptions message.
       * @function verify
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      EnumValueOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        return null;
      };

      /**
       * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
       */
      EnumValueOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.EnumValueOptions) return object;
        let message = new $root.google.protobuf.EnumValueOptions();
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.EnumValueOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.EnumValueOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.EnumValueOptions
       * @static
       * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      EnumValueOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) object.deprecated = false;
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        return object;
      };

      /**
       * Converts this EnumValueOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.EnumValueOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      EnumValueOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return EnumValueOptions;
    })();

    protobuf.ServiceOptions = (function () {
      /**
       * Properties of a ServiceOptions.
       * @memberof google.protobuf
       * @interface IServiceOptions
       * @property {boolean|null} [deprecated] ServiceOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
       * @property {boolean|null} [".cosmos.msg.v1.service"] ServiceOptions .cosmos.msg.v1.service
       */

      /**
       * Constructs a new ServiceOptions.
       * @memberof google.protobuf
       * @classdesc Represents a ServiceOptions.
       * @implements IServiceOptions
       * @constructor
       * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
       */
      function ServiceOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * ServiceOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.ServiceOptions
       * @instance
       */
      ServiceOptions.prototype.deprecated = false;

      /**
       * ServiceOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.ServiceOptions
       * @instance
       */
      ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * ServiceOptions .cosmos.msg.v1.service.
       * @member {boolean} .cosmos.msg.v1.service
       * @memberof google.protobuf.ServiceOptions
       * @instance
       */
      ServiceOptions.prototype['.cosmos.msg.v1.service'] = false;

      /**
       * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.cosmos.msg.v1.service'] != null && Object.hasOwnProperty.call(message, '.cosmos.msg.v1.service'))
          writer.uint32(/* id 11110000, wireType 0 =*/ 88880000).bool(message['.cosmos.msg.v1.service']);
        return writer;
      };

      /**
       * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a ServiceOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.ServiceOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 33:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 11110000:
              message['.cosmos.msg.v1.service'] = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a ServiceOptions message.
       * @function verify
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      ServiceOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.cosmos.msg.v1.service'] != null && message.hasOwnProperty('.cosmos.msg.v1.service'))
          if (typeof message['.cosmos.msg.v1.service'] !== 'boolean') return '.cosmos.msg.v1.service: boolean expected';
        return null;
      };

      /**
       * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.ServiceOptions} ServiceOptions
       */
      ServiceOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.ServiceOptions) return object;
        let message = new $root.google.protobuf.ServiceOptions();
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.ServiceOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.ServiceOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.cosmos.msg.v1.service'] != null) message['.cosmos.msg.v1.service'] = Boolean(object['.cosmos.msg.v1.service']);
        return message;
      };

      /**
       * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.ServiceOptions
       * @static
       * @param {google.protobuf.ServiceOptions} message ServiceOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      ServiceOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.deprecated = false;
          object['.cosmos.msg.v1.service'] = false;
        }
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.cosmos.msg.v1.service'] != null && message.hasOwnProperty('.cosmos.msg.v1.service'))
          object['.cosmos.msg.v1.service'] = message['.cosmos.msg.v1.service'];
        return object;
      };

      /**
       * Converts this ServiceOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.ServiceOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      ServiceOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return ServiceOptions;
    })();

    protobuf.MethodOptions = (function () {
      /**
       * Properties of a MethodOptions.
       * @memberof google.protobuf
       * @interface IMethodOptions
       * @property {boolean|null} [deprecated] MethodOptions deprecated
       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
       * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
       */

      /**
       * Constructs a new MethodOptions.
       * @memberof google.protobuf
       * @classdesc Represents a MethodOptions.
       * @implements IMethodOptions
       * @constructor
       * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
       */
      function MethodOptions(properties) {
        this.uninterpreted_option = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MethodOptions deprecated.
       * @member {boolean} deprecated
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype.deprecated = false;

      /**
       * MethodOptions uninterpreted_option.
       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype.uninterpreted_option = $util.emptyArray;

      /**
       * MethodOptions .google.api.http.
       * @member {google.api.IHttpRule|null|undefined} .google.api.http
       * @memberof google.protobuf.MethodOptions
       * @instance
       */
      MethodOptions.prototype['.google.api.http'] = null;

      /**
       * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodOptions.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.deprecated != null && Object.hasOwnProperty.call(message, 'deprecated'))
          writer.uint32(/* id 33, wireType 0 =*/ 264).bool(message.deprecated);
        if (message.uninterpreted_option != null && message.uninterpreted_option.length)
          for (let i = 0; i < message.uninterpreted_option.length; ++i)
            $root.google.protobuf.UninterpretedOption.encode(
              message.uninterpreted_option[i],
              writer.uint32(/* id 999, wireType 2 =*/ 7994).fork(),
            ).ldelim();
        if (message['.google.api.http'] != null && Object.hasOwnProperty.call(message, '.google.api.http'))
          $root.google.api.HttpRule.encode(
            message['.google.api.http'],
            writer.uint32(/* id 72295728, wireType 2 =*/ 578365826).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MethodOptions message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.MethodOptions} MethodOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.MethodOptions();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 33:
              message.deprecated = reader.bool();
              break;
            case 999:
              if (!(message.uninterpreted_option && message.uninterpreted_option.length)) message.uninterpreted_option = [];
              message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
              break;
            case 72295728:
              message['.google.api.http'] = $root.google.api.HttpRule.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.MethodOptions} MethodOptions
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MethodOptions.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MethodOptions message.
       * @function verify
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MethodOptions.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.deprecated != null && message.hasOwnProperty('deprecated'))
          if (typeof message.deprecated !== 'boolean') return 'deprecated: boolean expected';
        if (message.uninterpreted_option != null && message.hasOwnProperty('uninterpreted_option')) {
          if (!Array.isArray(message.uninterpreted_option)) return 'uninterpreted_option: array expected';
          for (let i = 0; i < message.uninterpreted_option.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
            if (error) return 'uninterpreted_option.' + error;
          }
        }
        if (message['.google.api.http'] != null && message.hasOwnProperty('.google.api.http')) {
          let error = $root.google.api.HttpRule.verify(message['.google.api.http']);
          if (error) return '.google.api.http.' + error;
        }
        return null;
      };

      /**
       * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.MethodOptions} MethodOptions
       */
      MethodOptions.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.MethodOptions) return object;
        let message = new $root.google.protobuf.MethodOptions();
        if (object.deprecated != null) message.deprecated = Boolean(object.deprecated);
        if (object.uninterpreted_option) {
          if (!Array.isArray(object.uninterpreted_option))
            throw TypeError('.google.protobuf.MethodOptions.uninterpreted_option: array expected');
          message.uninterpreted_option = [];
          for (let i = 0; i < object.uninterpreted_option.length; ++i) {
            if (typeof object.uninterpreted_option[i] !== 'object')
              throw TypeError('.google.protobuf.MethodOptions.uninterpreted_option: object expected');
            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
          }
        }
        if (object['.google.api.http'] != null) {
          if (typeof object['.google.api.http'] !== 'object')
            throw TypeError('.google.protobuf.MethodOptions..google.api.http: object expected');
          message['.google.api.http'] = $root.google.api.HttpRule.fromObject(object['.google.api.http']);
        }
        return message;
      };

      /**
       * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.MethodOptions
       * @static
       * @param {google.protobuf.MethodOptions} message MethodOptions
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MethodOptions.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.uninterpreted_option = [];
        if (options.defaults) {
          object.deprecated = false;
          object['.google.api.http'] = null;
        }
        if (message.deprecated != null && message.hasOwnProperty('deprecated')) object.deprecated = message.deprecated;
        if (message.uninterpreted_option && message.uninterpreted_option.length) {
          object.uninterpreted_option = [];
          for (let j = 0; j < message.uninterpreted_option.length; ++j)
            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
        }
        if (message['.google.api.http'] != null && message.hasOwnProperty('.google.api.http'))
          object['.google.api.http'] = $root.google.api.HttpRule.toObject(message['.google.api.http'], options);
        return object;
      };

      /**
       * Converts this MethodOptions to JSON.
       * @function toJSON
       * @memberof google.protobuf.MethodOptions
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MethodOptions.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MethodOptions;
    })();

    protobuf.UninterpretedOption = (function () {
      /**
       * Properties of an UninterpretedOption.
       * @memberof google.protobuf
       * @interface IUninterpretedOption
       * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
       * @property {string|null} [identifier_value] UninterpretedOption identifier_value
       * @property {Long|null} [positive_int_value] UninterpretedOption positive_int_value
       * @property {Long|null} [negative_int_value] UninterpretedOption negative_int_value
       * @property {number|null} [double_value] UninterpretedOption double_value
       * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
       * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
       */

      /**
       * Constructs a new UninterpretedOption.
       * @memberof google.protobuf
       * @classdesc Represents an UninterpretedOption.
       * @implements IUninterpretedOption
       * @constructor
       * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
       */
      function UninterpretedOption(properties) {
        this.name = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * UninterpretedOption name.
       * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.name = $util.emptyArray;

      /**
       * UninterpretedOption identifier_value.
       * @member {string} identifier_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.identifier_value = '';

      /**
       * UninterpretedOption positive_int_value.
       * @member {Long} positive_int_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * UninterpretedOption negative_int_value.
       * @member {Long} negative_int_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * UninterpretedOption double_value.
       * @member {number} double_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.double_value = 0;

      /**
       * UninterpretedOption string_value.
       * @member {Uint8Array} string_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.string_value = $util.newBuffer([]);

      /**
       * UninterpretedOption aggregate_value.
       * @member {string} aggregate_value
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       */
      UninterpretedOption.prototype.aggregate_value = '';

      /**
       * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UninterpretedOption.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.name != null && message.name.length)
          for (let i = 0; i < message.name.length; ++i)
            $root.google.protobuf.UninterpretedOption.NamePart.encode(
              message.name[i],
              writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
            ).ldelim();
        if (message.identifier_value != null && Object.hasOwnProperty.call(message, 'identifier_value'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.identifier_value);
        if (message.positive_int_value != null && Object.hasOwnProperty.call(message, 'positive_int_value'))
          writer.uint32(/* id 4, wireType 0 =*/ 32).uint64(message.positive_int_value);
        if (message.negative_int_value != null && Object.hasOwnProperty.call(message, 'negative_int_value'))
          writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.negative_int_value);
        if (message.double_value != null && Object.hasOwnProperty.call(message, 'double_value'))
          writer.uint32(/* id 6, wireType 1 =*/ 49).double(message.double_value);
        if (message.string_value != null && Object.hasOwnProperty.call(message, 'string_value'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.string_value);
        if (message.aggregate_value != null && Object.hasOwnProperty.call(message, 'aggregate_value'))
          writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.aggregate_value);
        return writer;
      };

      /**
       * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes an UninterpretedOption message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UninterpretedOption.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.UninterpretedOption();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              if (!(message.name && message.name.length)) message.name = [];
              message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
              break;
            case 3:
              message.identifier_value = reader.string();
              break;
            case 4:
              message.positive_int_value = reader.uint64();
              break;
            case 5:
              message.negative_int_value = reader.int64();
              break;
            case 6:
              message.double_value = reader.double();
              break;
            case 7:
              message.string_value = reader.bytes();
              break;
            case 8:
              message.aggregate_value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies an UninterpretedOption message.
       * @function verify
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      UninterpretedOption.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.name != null && message.hasOwnProperty('name')) {
          if (!Array.isArray(message.name)) return 'name: array expected';
          for (let i = 0; i < message.name.length; ++i) {
            let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
            if (error) return 'name.' + error;
          }
        }
        if (message.identifier_value != null && message.hasOwnProperty('identifier_value'))
          if (!$util.isString(message.identifier_value)) return 'identifier_value: string expected';
        if (message.positive_int_value != null && message.hasOwnProperty('positive_int_value'))
          if (
            !$util.isInteger(message.positive_int_value) &&
            !(
              message.positive_int_value &&
              $util.isInteger(message.positive_int_value.low) &&
              $util.isInteger(message.positive_int_value.high)
            )
          )
            return 'positive_int_value: integer|Long expected';
        if (message.negative_int_value != null && message.hasOwnProperty('negative_int_value'))
          if (
            !$util.isInteger(message.negative_int_value) &&
            !(
              message.negative_int_value &&
              $util.isInteger(message.negative_int_value.low) &&
              $util.isInteger(message.negative_int_value.high)
            )
          )
            return 'negative_int_value: integer|Long expected';
        if (message.double_value != null && message.hasOwnProperty('double_value'))
          if (typeof message.double_value !== 'number') return 'double_value: number expected';
        if (message.string_value != null && message.hasOwnProperty('string_value'))
          if (!((message.string_value && typeof message.string_value.length === 'number') || $util.isString(message.string_value)))
            return 'string_value: buffer expected';
        if (message.aggregate_value != null && message.hasOwnProperty('aggregate_value'))
          if (!$util.isString(message.aggregate_value)) return 'aggregate_value: string expected';
        return null;
      };

      /**
       * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
       */
      UninterpretedOption.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.UninterpretedOption) return object;
        let message = new $root.google.protobuf.UninterpretedOption();
        if (object.name) {
          if (!Array.isArray(object.name)) throw TypeError('.google.protobuf.UninterpretedOption.name: array expected');
          message.name = [];
          for (let i = 0; i < object.name.length; ++i) {
            if (typeof object.name[i] !== 'object') throw TypeError('.google.protobuf.UninterpretedOption.name: object expected');
            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
          }
        }
        if (object.identifier_value != null) message.identifier_value = String(object.identifier_value);
        if (object.positive_int_value != null)
          if ($util.Long) (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
          else if (typeof object.positive_int_value === 'string') message.positive_int_value = parseInt(object.positive_int_value, 10);
          else if (typeof object.positive_int_value === 'number') message.positive_int_value = object.positive_int_value;
          else if (typeof object.positive_int_value === 'object')
            message.positive_int_value = new $util.LongBits(
              object.positive_int_value.low >>> 0,
              object.positive_int_value.high >>> 0,
            ).toNumber(true);
        if (object.negative_int_value != null)
          if ($util.Long) (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
          else if (typeof object.negative_int_value === 'string') message.negative_int_value = parseInt(object.negative_int_value, 10);
          else if (typeof object.negative_int_value === 'number') message.negative_int_value = object.negative_int_value;
          else if (typeof object.negative_int_value === 'object')
            message.negative_int_value = new $util.LongBits(
              object.negative_int_value.low >>> 0,
              object.negative_int_value.high >>> 0,
            ).toNumber();
        if (object.double_value != null) message.double_value = Number(object.double_value);
        if (object.string_value != null)
          if (typeof object.string_value === 'string')
            $util.base64.decode(object.string_value, (message.string_value = $util.newBuffer($util.base64.length(object.string_value))), 0);
          else if (object.string_value.length) message.string_value = object.string_value;
        if (object.aggregate_value != null) message.aggregate_value = String(object.aggregate_value);
        return message;
      };

      /**
       * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.UninterpretedOption
       * @static
       * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      UninterpretedOption.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.name = [];
        if (options.defaults) {
          object.identifier_value = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.positive_int_value = options.longs === String ? '0' : 0;
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.negative_int_value = options.longs === String ? '0' : 0;
          object.double_value = 0;
          if (options.bytes === String) object.string_value = '';
          else {
            object.string_value = [];
            if (options.bytes !== Array) object.string_value = $util.newBuffer(object.string_value);
          }
          object.aggregate_value = '';
        }
        if (message.name && message.name.length) {
          object.name = [];
          for (let j = 0; j < message.name.length; ++j)
            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
        }
        if (message.identifier_value != null && message.hasOwnProperty('identifier_value'))
          object.identifier_value = message.identifier_value;
        if (message.positive_int_value != null && message.hasOwnProperty('positive_int_value'))
          if (typeof message.positive_int_value === 'number')
            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
          else
            object.positive_int_value =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.positive_int_value)
                : options.longs === Number
                ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true)
                : message.positive_int_value;
        if (message.negative_int_value != null && message.hasOwnProperty('negative_int_value'))
          if (typeof message.negative_int_value === 'number')
            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
          else
            object.negative_int_value =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.negative_int_value)
                : options.longs === Number
                ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber()
                : message.negative_int_value;
        if (message.double_value != null && message.hasOwnProperty('double_value'))
          object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
        if (message.string_value != null && message.hasOwnProperty('string_value'))
          object.string_value =
            options.bytes === String
              ? $util.base64.encode(message.string_value, 0, message.string_value.length)
              : options.bytes === Array
              ? Array.prototype.slice.call(message.string_value)
              : message.string_value;
        if (message.aggregate_value != null && message.hasOwnProperty('aggregate_value')) object.aggregate_value = message.aggregate_value;
        return object;
      };

      /**
       * Converts this UninterpretedOption to JSON.
       * @function toJSON
       * @memberof google.protobuf.UninterpretedOption
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      UninterpretedOption.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      UninterpretedOption.NamePart = (function () {
        /**
         * Properties of a NamePart.
         * @memberof google.protobuf.UninterpretedOption
         * @interface INamePart
         * @property {string} name_part NamePart name_part
         * @property {boolean} is_extension NamePart is_extension
         */

        /**
         * Constructs a new NamePart.
         * @memberof google.protobuf.UninterpretedOption
         * @classdesc Represents a NamePart.
         * @implements INamePart
         * @constructor
         * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
         */
        function NamePart(properties) {
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * NamePart name_part.
         * @member {string} name_part
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         */
        NamePart.prototype.name_part = '';

        /**
         * NamePart is_extension.
         * @member {boolean} is_extension
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         */
        NamePart.prototype.is_extension = false;

        /**
         * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NamePart.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name_part);
          writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.is_extension);
          return writer;
        };

        /**
         * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NamePart.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NamePart message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NamePart.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.UninterpretedOption.NamePart();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.name_part = reader.string();
                break;
              case 2:
                message.is_extension = reader.bool();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty('name_part')) throw $util.ProtocolError("missing required 'name_part'", { instance: message });
          if (!message.hasOwnProperty('is_extension')) throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
          return message;
        };

        /**
         * Decodes a NamePart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NamePart.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NamePart message.
         * @function verify
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NamePart.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (!$util.isString(message.name_part)) return 'name_part: string expected';
          if (typeof message.is_extension !== 'boolean') return 'is_extension: boolean expected';
          return null;
        };

        /**
         * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
         */
        NamePart.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart) return object;
          let message = new $root.google.protobuf.UninterpretedOption.NamePart();
          if (object.name_part != null) message.name_part = String(object.name_part);
          if (object.is_extension != null) message.is_extension = Boolean(object.is_extension);
          return message;
        };

        /**
         * Creates a plain object from a NamePart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @static
         * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NamePart.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.defaults) {
            object.name_part = '';
            object.is_extension = false;
          }
          if (message.name_part != null && message.hasOwnProperty('name_part')) object.name_part = message.name_part;
          if (message.is_extension != null && message.hasOwnProperty('is_extension')) object.is_extension = message.is_extension;
          return object;
        };

        /**
         * Converts this NamePart to JSON.
         * @function toJSON
         * @memberof google.protobuf.UninterpretedOption.NamePart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NamePart.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NamePart;
      })();

      return UninterpretedOption;
    })();

    protobuf.SourceCodeInfo = (function () {
      /**
       * Properties of a SourceCodeInfo.
       * @memberof google.protobuf
       * @interface ISourceCodeInfo
       * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
       */

      /**
       * Constructs a new SourceCodeInfo.
       * @memberof google.protobuf
       * @classdesc Represents a SourceCodeInfo.
       * @implements ISourceCodeInfo
       * @constructor
       * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
       */
      function SourceCodeInfo(properties) {
        this.location = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * SourceCodeInfo location.
       * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
       * @memberof google.protobuf.SourceCodeInfo
       * @instance
       */
      SourceCodeInfo.prototype.location = $util.emptyArray;

      /**
       * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SourceCodeInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.location != null && message.location.length)
          for (let i = 0; i < message.location.length; ++i)
            $root.google.protobuf.SourceCodeInfo.Location.encode(
              message.location[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a SourceCodeInfo message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SourceCodeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.SourceCodeInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.location && message.location.length)) message.location = [];
              message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a SourceCodeInfo message.
       * @function verify
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      SourceCodeInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.location != null && message.hasOwnProperty('location')) {
          if (!Array.isArray(message.location)) return 'location: array expected';
          for (let i = 0; i < message.location.length; ++i) {
            let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
            if (error) return 'location.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
       */
      SourceCodeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.SourceCodeInfo) return object;
        let message = new $root.google.protobuf.SourceCodeInfo();
        if (object.location) {
          if (!Array.isArray(object.location)) throw TypeError('.google.protobuf.SourceCodeInfo.location: array expected');
          message.location = [];
          for (let i = 0; i < object.location.length; ++i) {
            if (typeof object.location[i] !== 'object') throw TypeError('.google.protobuf.SourceCodeInfo.location: object expected');
            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.SourceCodeInfo
       * @static
       * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      SourceCodeInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.location = [];
        if (message.location && message.location.length) {
          object.location = [];
          for (let j = 0; j < message.location.length; ++j)
            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
        }
        return object;
      };

      /**
       * Converts this SourceCodeInfo to JSON.
       * @function toJSON
       * @memberof google.protobuf.SourceCodeInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      SourceCodeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      SourceCodeInfo.Location = (function () {
        /**
         * Properties of a Location.
         * @memberof google.protobuf.SourceCodeInfo
         * @interface ILocation
         * @property {Array.<number>|null} [path] Location path
         * @property {Array.<number>|null} [span] Location span
         * @property {string|null} [leading_comments] Location leading_comments
         * @property {string|null} [trailing_comments] Location trailing_comments
         * @property {Array.<string>|null} [leading_detached_comments] Location leading_detached_comments
         */

        /**
         * Constructs a new Location.
         * @memberof google.protobuf.SourceCodeInfo
         * @classdesc Represents a Location.
         * @implements ILocation
         * @constructor
         * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
         */
        function Location(properties) {
          this.path = [];
          this.span = [];
          this.leading_detached_comments = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Location path.
         * @member {Array.<number>} path
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.path = $util.emptyArray;

        /**
         * Location span.
         * @member {Array.<number>} span
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.span = $util.emptyArray;

        /**
         * Location leading_comments.
         * @member {string} leading_comments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.leading_comments = '';

        /**
         * Location trailing_comments.
         * @member {string} trailing_comments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.trailing_comments = '';

        /**
         * Location leading_detached_comments.
         * @member {Array.<string>} leading_detached_comments
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         */
        Location.prototype.leading_detached_comments = $util.emptyArray;

        /**
         * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.path != null && message.path.length) {
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
            for (let i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
            writer.ldelim();
          }
          if (message.span != null && message.span.length) {
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
            for (let i = 0; i < message.span.length; ++i) writer.int32(message.span[i]);
            writer.ldelim();
          }
          if (message.leading_comments != null && Object.hasOwnProperty.call(message, 'leading_comments'))
            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.leading_comments);
          if (message.trailing_comments != null && Object.hasOwnProperty.call(message, 'trailing_comments'))
            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.trailing_comments);
          if (message.leading_detached_comments != null && message.leading_detached_comments.length)
            for (let i = 0; i < message.leading_detached_comments.length; ++i)
              writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.leading_detached_comments[i]);
          return writer;
        };

        /**
         * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.SourceCodeInfo.Location();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.path && message.path.length)) message.path = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.path.push(reader.int32());
                } else message.path.push(reader.int32());
                break;
              case 2:
                if (!(message.span && message.span.length)) message.span = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.span.push(reader.int32());
                } else message.span.push(reader.int32());
                break;
              case 3:
                message.leading_comments = reader.string();
                break;
              case 4:
                message.trailing_comments = reader.string();
                break;
              case 6:
                if (!(message.leading_detached_comments && message.leading_detached_comments.length))
                  message.leading_detached_comments = [];
                message.leading_detached_comments.push(reader.string());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes a Location message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Location message.
         * @function verify
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Location.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.path != null && message.hasOwnProperty('path')) {
            if (!Array.isArray(message.path)) return 'path: array expected';
            for (let i = 0; i < message.path.length; ++i) if (!$util.isInteger(message.path[i])) return 'path: integer[] expected';
          }
          if (message.span != null && message.hasOwnProperty('span')) {
            if (!Array.isArray(message.span)) return 'span: array expected';
            for (let i = 0; i < message.span.length; ++i) if (!$util.isInteger(message.span[i])) return 'span: integer[] expected';
          }
          if (message.leading_comments != null && message.hasOwnProperty('leading_comments'))
            if (!$util.isString(message.leading_comments)) return 'leading_comments: string expected';
          if (message.trailing_comments != null && message.hasOwnProperty('trailing_comments'))
            if (!$util.isString(message.trailing_comments)) return 'trailing_comments: string expected';
          if (message.leading_detached_comments != null && message.hasOwnProperty('leading_detached_comments')) {
            if (!Array.isArray(message.leading_detached_comments)) return 'leading_detached_comments: array expected';
            for (let i = 0; i < message.leading_detached_comments.length; ++i)
              if (!$util.isString(message.leading_detached_comments[i])) return 'leading_detached_comments: string[] expected';
          }
          return null;
        };

        /**
         * Creates a Location message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.SourceCodeInfo.Location} Location
         */
        Location.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.SourceCodeInfo.Location) return object;
          let message = new $root.google.protobuf.SourceCodeInfo.Location();
          if (object.path) {
            if (!Array.isArray(object.path)) throw TypeError('.google.protobuf.SourceCodeInfo.Location.path: array expected');
            message.path = [];
            for (let i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
          }
          if (object.span) {
            if (!Array.isArray(object.span)) throw TypeError('.google.protobuf.SourceCodeInfo.Location.span: array expected');
            message.span = [];
            for (let i = 0; i < object.span.length; ++i) message.span[i] = object.span[i] | 0;
          }
          if (object.leading_comments != null) message.leading_comments = String(object.leading_comments);
          if (object.trailing_comments != null) message.trailing_comments = String(object.trailing_comments);
          if (object.leading_detached_comments) {
            if (!Array.isArray(object.leading_detached_comments))
              throw TypeError('.google.protobuf.SourceCodeInfo.Location.leading_detached_comments: array expected');
            message.leading_detached_comments = [];
            for (let i = 0; i < object.leading_detached_comments.length; ++i)
              message.leading_detached_comments[i] = String(object.leading_detached_comments[i]);
          }
          return message;
        };

        /**
         * Creates a plain object from a Location message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @static
         * @param {google.protobuf.SourceCodeInfo.Location} message Location
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Location.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) {
            object.path = [];
            object.span = [];
            object.leading_detached_comments = [];
          }
          if (options.defaults) {
            object.leading_comments = '';
            object.trailing_comments = '';
          }
          if (message.path && message.path.length) {
            object.path = [];
            for (let j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
          }
          if (message.span && message.span.length) {
            object.span = [];
            for (let j = 0; j < message.span.length; ++j) object.span[j] = message.span[j];
          }
          if (message.leading_comments != null && message.hasOwnProperty('leading_comments'))
            object.leading_comments = message.leading_comments;
          if (message.trailing_comments != null && message.hasOwnProperty('trailing_comments'))
            object.trailing_comments = message.trailing_comments;
          if (message.leading_detached_comments && message.leading_detached_comments.length) {
            object.leading_detached_comments = [];
            for (let j = 0; j < message.leading_detached_comments.length; ++j)
              object.leading_detached_comments[j] = message.leading_detached_comments[j];
          }
          return object;
        };

        /**
         * Converts this Location to JSON.
         * @function toJSON
         * @memberof google.protobuf.SourceCodeInfo.Location
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Location.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Location;
      })();

      return SourceCodeInfo;
    })();

    protobuf.GeneratedCodeInfo = (function () {
      /**
       * Properties of a GeneratedCodeInfo.
       * @memberof google.protobuf
       * @interface IGeneratedCodeInfo
       * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
       */

      /**
       * Constructs a new GeneratedCodeInfo.
       * @memberof google.protobuf
       * @classdesc Represents a GeneratedCodeInfo.
       * @implements IGeneratedCodeInfo
       * @constructor
       * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
       */
      function GeneratedCodeInfo(properties) {
        this.annotation = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GeneratedCodeInfo annotation.
       * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
       * @memberof google.protobuf.GeneratedCodeInfo
       * @instance
       */
      GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

      /**
       * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GeneratedCodeInfo.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.annotation != null && message.annotation.length)
          for (let i = 0; i < message.annotation.length; ++i)
            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(
              message.annotation[i],
              writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GeneratedCodeInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.GeneratedCodeInfo();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.annotation && message.annotation.length)) message.annotation = [];
              message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GeneratedCodeInfo message.
       * @function verify
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GeneratedCodeInfo.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.annotation != null && message.hasOwnProperty('annotation')) {
          if (!Array.isArray(message.annotation)) return 'annotation: array expected';
          for (let i = 0; i < message.annotation.length; ++i) {
            let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
            if (error) return 'annotation.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
       */
      GeneratedCodeInfo.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.GeneratedCodeInfo) return object;
        let message = new $root.google.protobuf.GeneratedCodeInfo();
        if (object.annotation) {
          if (!Array.isArray(object.annotation)) throw TypeError('.google.protobuf.GeneratedCodeInfo.annotation: array expected');
          message.annotation = [];
          for (let i = 0; i < object.annotation.length; ++i) {
            if (typeof object.annotation[i] !== 'object') throw TypeError('.google.protobuf.GeneratedCodeInfo.annotation: object expected');
            message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.GeneratedCodeInfo
       * @static
       * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GeneratedCodeInfo.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.annotation = [];
        if (message.annotation && message.annotation.length) {
          object.annotation = [];
          for (let j = 0; j < message.annotation.length; ++j)
            object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
        }
        return object;
      };

      /**
       * Converts this GeneratedCodeInfo to JSON.
       * @function toJSON
       * @memberof google.protobuf.GeneratedCodeInfo
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GeneratedCodeInfo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      GeneratedCodeInfo.Annotation = (function () {
        /**
         * Properties of an Annotation.
         * @memberof google.protobuf.GeneratedCodeInfo
         * @interface IAnnotation
         * @property {Array.<number>|null} [path] Annotation path
         * @property {string|null} [source_file] Annotation source_file
         * @property {number|null} [begin] Annotation begin
         * @property {number|null} [end] Annotation end
         */

        /**
         * Constructs a new Annotation.
         * @memberof google.protobuf.GeneratedCodeInfo
         * @classdesc Represents an Annotation.
         * @implements IAnnotation
         * @constructor
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
         */
        function Annotation(properties) {
          this.path = [];
          if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
        }

        /**
         * Annotation path.
         * @member {Array.<number>} path
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.path = $util.emptyArray;

        /**
         * Annotation source_file.
         * @member {string} source_file
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.source_file = '';

        /**
         * Annotation begin.
         * @member {number} begin
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.begin = 0;

        /**
         * Annotation end.
         * @member {number} end
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         */
        Annotation.prototype.end = 0;

        /**
         * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
         * @function encode
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Annotation.encode = function encode(message, writer) {
          if (!writer) writer = $Writer.create();
          if (message.path != null && message.path.length) {
            writer.uint32(/* id 1, wireType 2 =*/ 10).fork();
            for (let i = 0; i < message.path.length; ++i) writer.int32(message.path[i]);
            writer.ldelim();
          }
          if (message.source_file != null && Object.hasOwnProperty.call(message, 'source_file'))
            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.source_file);
          if (message.begin != null && Object.hasOwnProperty.call(message, 'begin'))
            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.begin);
          if (message.end != null && Object.hasOwnProperty.call(message, 'end'))
            writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.end);
          return writer;
        };

        /**
         * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Annotation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Annotation message from the specified reader or buffer.
         * @function decode
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Annotation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
          let end = length === undefined ? reader.len : reader.pos + length,
            message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.path && message.path.length)) message.path = [];
                if ((tag & 7) === 2) {
                  let end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2) message.path.push(reader.int32());
                } else message.path.push(reader.int32());
                break;
              case 2:
                message.source_file = reader.string();
                break;
              case 3:
                message.begin = reader.int32();
                break;
              case 4:
                message.end = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };

        /**
         * Decodes an Annotation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Annotation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Annotation message.
         * @function verify
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Annotation.verify = function verify(message) {
          if (typeof message !== 'object' || message === null) return 'object expected';
          if (message.path != null && message.hasOwnProperty('path')) {
            if (!Array.isArray(message.path)) return 'path: array expected';
            for (let i = 0; i < message.path.length; ++i) if (!$util.isInteger(message.path[i])) return 'path: integer[] expected';
          }
          if (message.source_file != null && message.hasOwnProperty('source_file'))
            if (!$util.isString(message.source_file)) return 'source_file: string expected';
          if (message.begin != null && message.hasOwnProperty('begin'))
            if (!$util.isInteger(message.begin)) return 'begin: integer expected';
          if (message.end != null && message.hasOwnProperty('end')) if (!$util.isInteger(message.end)) return 'end: integer expected';
          return null;
        };

        /**
         * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
         */
        Annotation.fromObject = function fromObject(object) {
          if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation) return object;
          let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
          if (object.path) {
            if (!Array.isArray(object.path)) throw TypeError('.google.protobuf.GeneratedCodeInfo.Annotation.path: array expected');
            message.path = [];
            for (let i = 0; i < object.path.length; ++i) message.path[i] = object.path[i] | 0;
          }
          if (object.source_file != null) message.source_file = String(object.source_file);
          if (object.begin != null) message.begin = object.begin | 0;
          if (object.end != null) message.end = object.end | 0;
          return message;
        };

        /**
         * Creates a plain object from an Annotation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @static
         * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Annotation.toObject = function toObject(message, options) {
          if (!options) options = {};
          let object = {};
          if (options.arrays || options.defaults) object.path = [];
          if (options.defaults) {
            object.source_file = '';
            object.begin = 0;
            object.end = 0;
          }
          if (message.path && message.path.length) {
            object.path = [];
            for (let j = 0; j < message.path.length; ++j) object.path[j] = message.path[j];
          }
          if (message.source_file != null && message.hasOwnProperty('source_file')) object.source_file = message.source_file;
          if (message.begin != null && message.hasOwnProperty('begin')) object.begin = message.begin;
          if (message.end != null && message.hasOwnProperty('end')) object.end = message.end;
          return object;
        };

        /**
         * Converts this Annotation to JSON.
         * @function toJSON
         * @memberof google.protobuf.GeneratedCodeInfo.Annotation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Annotation.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Annotation;
      })();

      return GeneratedCodeInfo;
    })();

    protobuf.Duration = (function () {
      /**
       * Properties of a Duration.
       * @memberof google.protobuf
       * @interface IDuration
       * @property {Long|null} [seconds] Duration seconds
       * @property {number|null} [nanos] Duration nanos
       */

      /**
       * Constructs a new Duration.
       * @memberof google.protobuf
       * @classdesc Represents a Duration.
       * @implements IDuration
       * @constructor
       * @param {google.protobuf.IDuration=} [properties] Properties to set
       */
      function Duration(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Duration seconds.
       * @member {Long} seconds
       * @memberof google.protobuf.Duration
       * @instance
       */
      Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

      /**
       * Duration nanos.
       * @member {number} nanos
       * @memberof google.protobuf.Duration
       * @instance
       */
      Duration.prototype.nanos = 0;

      /**
       * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Duration
       * @static
       * @param {google.protobuf.IDuration} message Duration message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Duration.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.seconds != null && Object.hasOwnProperty.call(message, 'seconds'))
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
        if (message.nanos != null && Object.hasOwnProperty.call(message, 'nanos'))
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
        return writer;
      };

      /**
       * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Duration
       * @static
       * @param {google.protobuf.IDuration} message Duration message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Duration.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Duration message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Duration
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Duration} Duration
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Duration.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.Duration();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Duration message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Duration
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Duration} Duration
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Duration.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Duration message.
       * @function verify
       * @memberof google.protobuf.Duration
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Duration.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (
            !$util.isInteger(message.seconds) &&
            !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))
          )
            return 'seconds: integer|Long expected';
        if (message.nanos != null && message.hasOwnProperty('nanos')) if (!$util.isInteger(message.nanos)) return 'nanos: integer expected';
        return null;
      };

      /**
       * Creates a Duration message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Duration
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Duration} Duration
       */
      Duration.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Duration) return object;
        let message = new $root.google.protobuf.Duration();
        if (object.seconds != null)
          if ($util.Long) (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
          else if (typeof object.seconds === 'string') message.seconds = parseInt(object.seconds, 10);
          else if (typeof object.seconds === 'number') message.seconds = object.seconds;
          else if (typeof object.seconds === 'object')
            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
        if (object.nanos != null) message.nanos = object.nanos | 0;
        return message;
      };

      /**
       * Creates a plain object from a Duration message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Duration
       * @static
       * @param {google.protobuf.Duration} message Duration
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Duration.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.seconds = options.longs === String ? '0' : 0;
          object.nanos = 0;
        }
        if (message.seconds != null && message.hasOwnProperty('seconds'))
          if (typeof message.seconds === 'number') object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
          else
            object.seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.seconds)
                : options.longs === Number
                ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber()
                : message.seconds;
        if (message.nanos != null && message.hasOwnProperty('nanos')) object.nanos = message.nanos;
        return object;
      };

      /**
       * Converts this Duration to JSON.
       * @function toJSON
       * @memberof google.protobuf.Duration
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Duration.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Duration;
    })();

    return protobuf;
  })();

  google.api = (function () {
    /**
     * Namespace api.
     * @memberof google
     * @namespace
     */
    const api = {};

    api.Http = (function () {
      /**
       * Properties of a Http.
       * @memberof google.api
       * @interface IHttp
       * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
       */

      /**
       * Constructs a new Http.
       * @memberof google.api
       * @classdesc Represents a Http.
       * @implements IHttp
       * @constructor
       * @param {google.api.IHttp=} [properties] Properties to set
       */
      function Http(properties) {
        this.rules = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Http rules.
       * @member {Array.<google.api.IHttpRule>} rules
       * @memberof google.api.Http
       * @instance
       */
      Http.prototype.rules = $util.emptyArray;

      /**
       * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
       * @function encode
       * @memberof google.api.Http
       * @static
       * @param {google.api.IHttp} message Http message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Http.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.rules != null && message.rules.length)
          for (let i = 0; i < message.rules.length; ++i)
            $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.Http
       * @static
       * @param {google.api.IHttp} message Http message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Http.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Http message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.Http
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.Http} Http
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Http.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.api.Http();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.rules && message.rules.length)) message.rules = [];
              message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Http message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.Http
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.Http} Http
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Http.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Http message.
       * @function verify
       * @memberof google.api.Http
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Http.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.rules != null && message.hasOwnProperty('rules')) {
          if (!Array.isArray(message.rules)) return 'rules: array expected';
          for (let i = 0; i < message.rules.length; ++i) {
            let error = $root.google.api.HttpRule.verify(message.rules[i]);
            if (error) return 'rules.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Http message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.Http
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.Http} Http
       */
      Http.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.Http) return object;
        let message = new $root.google.api.Http();
        if (object.rules) {
          if (!Array.isArray(object.rules)) throw TypeError('.google.api.Http.rules: array expected');
          message.rules = [];
          for (let i = 0; i < object.rules.length; ++i) {
            if (typeof object.rules[i] !== 'object') throw TypeError('.google.api.Http.rules: object expected');
            message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Http message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.Http
       * @static
       * @param {google.api.Http} message Http
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Http.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.rules = [];
        if (message.rules && message.rules.length) {
          object.rules = [];
          for (let j = 0; j < message.rules.length; ++j) object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
        }
        return object;
      };

      /**
       * Converts this Http to JSON.
       * @function toJSON
       * @memberof google.api.Http
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Http.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Http;
    })();

    api.HttpRule = (function () {
      /**
       * Properties of a HttpRule.
       * @memberof google.api
       * @interface IHttpRule
       * @property {string|null} [get] HttpRule get
       * @property {string|null} [put] HttpRule put
       * @property {string|null} [post] HttpRule post
       * @property {string|null} ["delete"] HttpRule delete
       * @property {string|null} [patch] HttpRule patch
       * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
       * @property {string|null} [selector] HttpRule selector
       * @property {string|null} [body] HttpRule body
       * @property {Array.<google.api.IHttpRule>|null} [additional_bindings] HttpRule additional_bindings
       */

      /**
       * Constructs a new HttpRule.
       * @memberof google.api
       * @classdesc Represents a HttpRule.
       * @implements IHttpRule
       * @constructor
       * @param {google.api.IHttpRule=} [properties] Properties to set
       */
      function HttpRule(properties) {
        this.additional_bindings = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * HttpRule get.
       * @member {string|null|undefined} get
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.get = null;

      /**
       * HttpRule put.
       * @member {string|null|undefined} put
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.put = null;

      /**
       * HttpRule post.
       * @member {string|null|undefined} post
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.post = null;

      /**
       * HttpRule delete.
       * @member {string|null|undefined} delete
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype['delete'] = null;

      /**
       * HttpRule patch.
       * @member {string|null|undefined} patch
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.patch = null;

      /**
       * HttpRule custom.
       * @member {google.api.ICustomHttpPattern|null|undefined} custom
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.custom = null;

      /**
       * HttpRule selector.
       * @member {string} selector
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.selector = '';

      /**
       * HttpRule body.
       * @member {string} body
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.body = '';

      /**
       * HttpRule additional_bindings.
       * @member {Array.<google.api.IHttpRule>} additional_bindings
       * @memberof google.api.HttpRule
       * @instance
       */
      HttpRule.prototype.additional_bindings = $util.emptyArray;

      // OneOf field names bound to virtual getters and setters
      let $oneOfFields;

      /**
       * HttpRule pattern.
       * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
       * @memberof google.api.HttpRule
       * @instance
       */
      Object.defineProperty(HttpRule.prototype, 'pattern', {
        get: $util.oneOfGetter(($oneOfFields = ['get', 'put', 'post', 'delete', 'patch', 'custom'])),
        set: $util.oneOfSetter($oneOfFields),
      });

      /**
       * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
       * @function encode
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HttpRule.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.selector != null && Object.hasOwnProperty.call(message, 'selector'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.selector);
        if (message.get != null && Object.hasOwnProperty.call(message, 'get'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.get);
        if (message.put != null && Object.hasOwnProperty.call(message, 'put'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.put);
        if (message.post != null && Object.hasOwnProperty.call(message, 'post'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.post);
        if (message['delete'] != null && Object.hasOwnProperty.call(message, 'delete'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message['delete']);
        if (message.patch != null && Object.hasOwnProperty.call(message, 'patch'))
          writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.patch);
        if (message.body != null && Object.hasOwnProperty.call(message, 'body'))
          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.body);
        if (message.custom != null && Object.hasOwnProperty.call(message, 'custom'))
          $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
        if (message.additional_bindings != null && message.additional_bindings.length)
          for (let i = 0; i < message.additional_bindings.length; ++i)
            $root.google.api.HttpRule.encode(message.additional_bindings[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a HttpRule message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.HttpRule
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.HttpRule} HttpRule
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HttpRule.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.api.HttpRule();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.get = reader.string();
              break;
            case 3:
              message.put = reader.string();
              break;
            case 4:
              message.post = reader.string();
              break;
            case 5:
              message['delete'] = reader.string();
              break;
            case 6:
              message.patch = reader.string();
              break;
            case 8:
              message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
              break;
            case 1:
              message.selector = reader.string();
              break;
            case 7:
              message.body = reader.string();
              break;
            case 11:
              if (!(message.additional_bindings && message.additional_bindings.length)) message.additional_bindings = [];
              message.additional_bindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a HttpRule message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.HttpRule
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.HttpRule} HttpRule
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      HttpRule.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a HttpRule message.
       * @function verify
       * @memberof google.api.HttpRule
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      HttpRule.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        let properties = {};
        if (message.get != null && message.hasOwnProperty('get')) {
          properties.pattern = 1;
          if (!$util.isString(message.get)) return 'get: string expected';
        }
        if (message.put != null && message.hasOwnProperty('put')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message.put)) return 'put: string expected';
        }
        if (message.post != null && message.hasOwnProperty('post')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message.post)) return 'post: string expected';
        }
        if (message['delete'] != null && message.hasOwnProperty('delete')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message['delete'])) return 'delete: string expected';
        }
        if (message.patch != null && message.hasOwnProperty('patch')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          if (!$util.isString(message.patch)) return 'patch: string expected';
        }
        if (message.custom != null && message.hasOwnProperty('custom')) {
          if (properties.pattern === 1) return 'pattern: multiple values';
          properties.pattern = 1;
          {
            let error = $root.google.api.CustomHttpPattern.verify(message.custom);
            if (error) return 'custom.' + error;
          }
        }
        if (message.selector != null && message.hasOwnProperty('selector'))
          if (!$util.isString(message.selector)) return 'selector: string expected';
        if (message.body != null && message.hasOwnProperty('body')) if (!$util.isString(message.body)) return 'body: string expected';
        if (message.additional_bindings != null && message.hasOwnProperty('additional_bindings')) {
          if (!Array.isArray(message.additional_bindings)) return 'additional_bindings: array expected';
          for (let i = 0; i < message.additional_bindings.length; ++i) {
            let error = $root.google.api.HttpRule.verify(message.additional_bindings[i]);
            if (error) return 'additional_bindings.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.HttpRule
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.HttpRule} HttpRule
       */
      HttpRule.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.HttpRule) return object;
        let message = new $root.google.api.HttpRule();
        if (object.get != null) message.get = String(object.get);
        if (object.put != null) message.put = String(object.put);
        if (object.post != null) message.post = String(object.post);
        if (object['delete'] != null) message['delete'] = String(object['delete']);
        if (object.patch != null) message.patch = String(object.patch);
        if (object.custom != null) {
          if (typeof object.custom !== 'object') throw TypeError('.google.api.HttpRule.custom: object expected');
          message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
        }
        if (object.selector != null) message.selector = String(object.selector);
        if (object.body != null) message.body = String(object.body);
        if (object.additional_bindings) {
          if (!Array.isArray(object.additional_bindings)) throw TypeError('.google.api.HttpRule.additional_bindings: array expected');
          message.additional_bindings = [];
          for (let i = 0; i < object.additional_bindings.length; ++i) {
            if (typeof object.additional_bindings[i] !== 'object')
              throw TypeError('.google.api.HttpRule.additional_bindings: object expected');
            message.additional_bindings[i] = $root.google.api.HttpRule.fromObject(object.additional_bindings[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.HttpRule
       * @static
       * @param {google.api.HttpRule} message HttpRule
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      HttpRule.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.additional_bindings = [];
        if (options.defaults) {
          object.selector = '';
          object.body = '';
        }
        if (message.selector != null && message.hasOwnProperty('selector')) object.selector = message.selector;
        if (message.get != null && message.hasOwnProperty('get')) {
          object.get = message.get;
          if (options.oneofs) object.pattern = 'get';
        }
        if (message.put != null && message.hasOwnProperty('put')) {
          object.put = message.put;
          if (options.oneofs) object.pattern = 'put';
        }
        if (message.post != null && message.hasOwnProperty('post')) {
          object.post = message.post;
          if (options.oneofs) object.pattern = 'post';
        }
        if (message['delete'] != null && message.hasOwnProperty('delete')) {
          object['delete'] = message['delete'];
          if (options.oneofs) object.pattern = 'delete';
        }
        if (message.patch != null && message.hasOwnProperty('patch')) {
          object.patch = message.patch;
          if (options.oneofs) object.pattern = 'patch';
        }
        if (message.body != null && message.hasOwnProperty('body')) object.body = message.body;
        if (message.custom != null && message.hasOwnProperty('custom')) {
          object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
          if (options.oneofs) object.pattern = 'custom';
        }
        if (message.additional_bindings && message.additional_bindings.length) {
          object.additional_bindings = [];
          for (let j = 0; j < message.additional_bindings.length; ++j)
            object.additional_bindings[j] = $root.google.api.HttpRule.toObject(message.additional_bindings[j], options);
        }
        return object;
      };

      /**
       * Converts this HttpRule to JSON.
       * @function toJSON
       * @memberof google.api.HttpRule
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      HttpRule.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return HttpRule;
    })();

    api.CustomHttpPattern = (function () {
      /**
       * Properties of a CustomHttpPattern.
       * @memberof google.api
       * @interface ICustomHttpPattern
       * @property {string|null} [kind] CustomHttpPattern kind
       * @property {string|null} [path] CustomHttpPattern path
       */

      /**
       * Constructs a new CustomHttpPattern.
       * @memberof google.api
       * @classdesc Represents a CustomHttpPattern.
       * @implements ICustomHttpPattern
       * @constructor
       * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
       */
      function CustomHttpPattern(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * CustomHttpPattern kind.
       * @member {string} kind
       * @memberof google.api.CustomHttpPattern
       * @instance
       */
      CustomHttpPattern.prototype.kind = '';

      /**
       * CustomHttpPattern path.
       * @member {string} path
       * @memberof google.api.CustomHttpPattern
       * @instance
       */
      CustomHttpPattern.prototype.path = '';

      /**
       * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
       * @function encode
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CustomHttpPattern.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.kind != null && Object.hasOwnProperty.call(message, 'kind'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.kind);
        if (message.path != null && Object.hasOwnProperty.call(message, 'path'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.path);
        return writer;
      };

      /**
       * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a CustomHttpPattern message from the specified reader or buffer.
       * @function decode
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CustomHttpPattern.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.api.CustomHttpPattern();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.kind = reader.string();
              break;
            case 2:
              message.path = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a CustomHttpPattern message.
       * @function verify
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      CustomHttpPattern.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.kind != null && message.hasOwnProperty('kind')) if (!$util.isString(message.kind)) return 'kind: string expected';
        if (message.path != null && message.hasOwnProperty('path')) if (!$util.isString(message.path)) return 'path: string expected';
        return null;
      };

      /**
       * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.api.CustomHttpPattern} CustomHttpPattern
       */
      CustomHttpPattern.fromObject = function fromObject(object) {
        if (object instanceof $root.google.api.CustomHttpPattern) return object;
        let message = new $root.google.api.CustomHttpPattern();
        if (object.kind != null) message.kind = String(object.kind);
        if (object.path != null) message.path = String(object.path);
        return message;
      };

      /**
       * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.api.CustomHttpPattern
       * @static
       * @param {google.api.CustomHttpPattern} message CustomHttpPattern
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      CustomHttpPattern.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.kind = '';
          object.path = '';
        }
        if (message.kind != null && message.hasOwnProperty('kind')) object.kind = message.kind;
        if (message.path != null && message.hasOwnProperty('path')) object.path = message.path;
        return object;
      };

      /**
       * Converts this CustomHttpPattern to JSON.
       * @function toJSON
       * @memberof google.api.CustomHttpPattern
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      CustomHttpPattern.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return CustomHttpPattern;
    })();

    return api;
  })();

  return google;
})());

export const nftvault = ($root.nftvault = (() => {
  /**
   * Namespace nftvault.
   * @exports nftvault
   * @namespace
   */
  const nftvault = {};

  nftvault.eventhook = (function () {
    /**
     * Namespace eventhook.
     * @memberof nftvault
     * @namespace
     */
    const eventhook = {};

    eventhook.Msg = (function () {
      /**
       * Constructs a new Msg service.
       * @memberof nftvault.eventhook
       * @classdesc Represents a Msg
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Msg(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Msg.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Msg;

      /**
       * Callback as used by {@link nftvault.eventhook.Msg#registerHook}.
       * @memberof nftvault.eventhook.Msg
       * @typedef RegisterHookCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {nftvault.eventhook.MsgRegisterHookResponse} [response] MsgRegisterHookResponse
       */

      /**
       * Calls RegisterHook.
       * @function registerHook
       * @memberof nftvault.eventhook.Msg
       * @instance
       * @param {nftvault.eventhook.IMsgRegisterHook} request MsgRegisterHook message or plain object
       * @param {nftvault.eventhook.Msg.RegisterHookCallback} callback Node-style callback called with the error, if any, and MsgRegisterHookResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.registerHook = function registerHook(request, callback) {
          return this.rpcCall(
            registerHook,
            $root.nftvault.eventhook.MsgRegisterHook,
            $root.nftvault.eventhook.MsgRegisterHookResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'RegisterHook' },
      );

      /**
       * Calls RegisterHook.
       * @function registerHook
       * @memberof nftvault.eventhook.Msg
       * @instance
       * @param {nftvault.eventhook.IMsgRegisterHook} request MsgRegisterHook message or plain object
       * @returns {Promise<nftvault.eventhook.MsgRegisterHookResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link nftvault.eventhook.Msg#unregisterHook}.
       * @memberof nftvault.eventhook.Msg
       * @typedef UnregisterHookCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {nftvault.eventhook.MsgUnregisterHookResponse} [response] MsgUnregisterHookResponse
       */

      /**
       * Calls UnregisterHook.
       * @function unregisterHook
       * @memberof nftvault.eventhook.Msg
       * @instance
       * @param {nftvault.eventhook.IMsgUnregisterHook} request MsgUnregisterHook message or plain object
       * @param {nftvault.eventhook.Msg.UnregisterHookCallback} callback Node-style callback called with the error, if any, and MsgUnregisterHookResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Msg.prototype.unregisterHook = function unregisterHook(request, callback) {
          return this.rpcCall(
            unregisterHook,
            $root.nftvault.eventhook.MsgUnregisterHook,
            $root.nftvault.eventhook.MsgUnregisterHookResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'UnregisterHook' },
      );

      /**
       * Calls UnregisterHook.
       * @function unregisterHook
       * @memberof nftvault.eventhook.Msg
       * @instance
       * @param {nftvault.eventhook.IMsgUnregisterHook} request MsgUnregisterHook message or plain object
       * @returns {Promise<nftvault.eventhook.MsgUnregisterHookResponse>} Promise
       * @variation 2
       */

      return Msg;
    })();

    eventhook.MsgRegisterHook = (function () {
      /**
       * Properties of a MsgRegisterHook.
       * @memberof nftvault.eventhook
       * @interface IMsgRegisterHook
       * @property {string|null} [sender] MsgRegisterHook sender
       * @property {string|null} [name] MsgRegisterHook name
       * @property {string|null} [contract_address] MsgRegisterHook contract_address
       * @property {string|null} [git_url] MsgRegisterHook git_url
       * @property {string|null} [event_type] MsgRegisterHook event_type
       * @property {Array.<nftvault.eventhook.IKeyValuePair>|null} [event_attributes] MsgRegisterHook event_attributes
       */

      /**
       * Constructs a new MsgRegisterHook.
       * @memberof nftvault.eventhook
       * @classdesc Represents a MsgRegisterHook.
       * @implements IMsgRegisterHook
       * @constructor
       * @param {nftvault.eventhook.IMsgRegisterHook=} [properties] Properties to set
       */
      function MsgRegisterHook(properties) {
        this.event_attributes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRegisterHook sender.
       * @member {string} sender
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @instance
       */
      MsgRegisterHook.prototype.sender = '';

      /**
       * MsgRegisterHook name.
       * @member {string} name
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @instance
       */
      MsgRegisterHook.prototype.name = '';

      /**
       * MsgRegisterHook contract_address.
       * @member {string} contract_address
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @instance
       */
      MsgRegisterHook.prototype.contract_address = '';

      /**
       * MsgRegisterHook git_url.
       * @member {string} git_url
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @instance
       */
      MsgRegisterHook.prototype.git_url = '';

      /**
       * MsgRegisterHook event_type.
       * @member {string} event_type
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @instance
       */
      MsgRegisterHook.prototype.event_type = '';

      /**
       * MsgRegisterHook event_attributes.
       * @member {Array.<nftvault.eventhook.IKeyValuePair>} event_attributes
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @instance
       */
      MsgRegisterHook.prototype.event_attributes = $util.emptyArray;

      /**
       * Encodes the specified MsgRegisterHook message. Does not implicitly {@link nftvault.eventhook.MsgRegisterHook.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @static
       * @param {nftvault.eventhook.IMsgRegisterHook} message MsgRegisterHook message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterHook.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
        if (message.contract_address != null && Object.hasOwnProperty.call(message, 'contract_address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.contract_address);
        if (message.git_url != null && Object.hasOwnProperty.call(message, 'git_url'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.git_url);
        if (message.event_type != null && Object.hasOwnProperty.call(message, 'event_type'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.event_type);
        if (message.event_attributes != null && message.event_attributes.length)
          for (let i = 0; i < message.event_attributes.length; ++i)
            $root.nftvault.eventhook.KeyValuePair.encode(
              message.event_attributes[i],
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterHook message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgRegisterHook.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @static
       * @param {nftvault.eventhook.IMsgRegisterHook} message MsgRegisterHook message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterHook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterHook message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.MsgRegisterHook} MsgRegisterHook
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterHook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.MsgRegisterHook();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.contract_address = reader.string();
              break;
            case 4:
              message.git_url = reader.string();
              break;
            case 5:
              message.event_type = reader.string();
              break;
            case 6:
              if (!(message.event_attributes && message.event_attributes.length)) message.event_attributes = [];
              message.event_attributes.push($root.nftvault.eventhook.KeyValuePair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterHook message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.MsgRegisterHook} MsgRegisterHook
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterHook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterHook message.
       * @function verify
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterHook.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          if (!$util.isString(message.contract_address)) return 'contract_address: string expected';
        if (message.git_url != null && message.hasOwnProperty('git_url'))
          if (!$util.isString(message.git_url)) return 'git_url: string expected';
        if (message.event_type != null && message.hasOwnProperty('event_type'))
          if (!$util.isString(message.event_type)) return 'event_type: string expected';
        if (message.event_attributes != null && message.hasOwnProperty('event_attributes')) {
          if (!Array.isArray(message.event_attributes)) return 'event_attributes: array expected';
          for (let i = 0; i < message.event_attributes.length; ++i) {
            let error = $root.nftvault.eventhook.KeyValuePair.verify(message.event_attributes[i]);
            if (error) return 'event_attributes.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a MsgRegisterHook message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.MsgRegisterHook} MsgRegisterHook
       */
      MsgRegisterHook.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.MsgRegisterHook) return object;
        let message = new $root.nftvault.eventhook.MsgRegisterHook();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.name != null) message.name = String(object.name);
        if (object.contract_address != null) message.contract_address = String(object.contract_address);
        if (object.git_url != null) message.git_url = String(object.git_url);
        if (object.event_type != null) message.event_type = String(object.event_type);
        if (object.event_attributes) {
          if (!Array.isArray(object.event_attributes))
            throw TypeError('.nftvault.eventhook.MsgRegisterHook.event_attributes: array expected');
          message.event_attributes = [];
          for (let i = 0; i < object.event_attributes.length; ++i) {
            if (typeof object.event_attributes[i] !== 'object')
              throw TypeError('.nftvault.eventhook.MsgRegisterHook.event_attributes: object expected');
            message.event_attributes[i] = $root.nftvault.eventhook.KeyValuePair.fromObject(object.event_attributes[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a MsgRegisterHook message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @static
       * @param {nftvault.eventhook.MsgRegisterHook} message MsgRegisterHook
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterHook.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.event_attributes = [];
        if (options.defaults) {
          object.sender = '';
          object.name = '';
          object.contract_address = '';
          object.git_url = '';
          object.event_type = '';
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          object.contract_address = message.contract_address;
        if (message.git_url != null && message.hasOwnProperty('git_url')) object.git_url = message.git_url;
        if (message.event_type != null && message.hasOwnProperty('event_type')) object.event_type = message.event_type;
        if (message.event_attributes && message.event_attributes.length) {
          object.event_attributes = [];
          for (let j = 0; j < message.event_attributes.length; ++j)
            object.event_attributes[j] = $root.nftvault.eventhook.KeyValuePair.toObject(message.event_attributes[j], options);
        }
        return object;
      };

      /**
       * Converts this MsgRegisterHook to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.MsgRegisterHook
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterHook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterHook;
    })();

    eventhook.MsgRegisterHookResponse = (function () {
      /**
       * Properties of a MsgRegisterHookResponse.
       * @memberof nftvault.eventhook
       * @interface IMsgRegisterHookResponse
       * @property {Long|null} [id] MsgRegisterHookResponse id
       */

      /**
       * Constructs a new MsgRegisterHookResponse.
       * @memberof nftvault.eventhook
       * @classdesc Represents a MsgRegisterHookResponse.
       * @implements IMsgRegisterHookResponse
       * @constructor
       * @param {nftvault.eventhook.IMsgRegisterHookResponse=} [properties] Properties to set
       */
      function MsgRegisterHookResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgRegisterHookResponse id.
       * @member {Long} id
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @instance
       */
      MsgRegisterHookResponse.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified MsgRegisterHookResponse message. Does not implicitly {@link nftvault.eventhook.MsgRegisterHookResponse.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @static
       * @param {nftvault.eventhook.IMsgRegisterHookResponse} message MsgRegisterHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterHookResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified MsgRegisterHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgRegisterHookResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @static
       * @param {nftvault.eventhook.IMsgRegisterHookResponse} message MsgRegisterHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgRegisterHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgRegisterHookResponse message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.MsgRegisterHookResponse} MsgRegisterHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterHookResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.MsgRegisterHookResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgRegisterHookResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.MsgRegisterHookResponse} MsgRegisterHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgRegisterHookResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgRegisterHookResponse message.
       * @function verify
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgRegisterHookResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a MsgRegisterHookResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.MsgRegisterHookResponse} MsgRegisterHookResponse
       */
      MsgRegisterHookResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.MsgRegisterHookResponse) return object;
        let message = new $root.nftvault.eventhook.MsgRegisterHookResponse();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a MsgRegisterHookResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @static
       * @param {nftvault.eventhook.MsgRegisterHookResponse} message MsgRegisterHookResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgRegisterHookResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults)
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this MsgRegisterHookResponse to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.MsgRegisterHookResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgRegisterHookResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgRegisterHookResponse;
    })();

    eventhook.MsgUnregisterHook = (function () {
      /**
       * Properties of a MsgUnregisterHook.
       * @memberof nftvault.eventhook
       * @interface IMsgUnregisterHook
       * @property {string|null} [sender] MsgUnregisterHook sender
       * @property {string|null} [event_type] MsgUnregisterHook event_type
       * @property {Long|null} [id] MsgUnregisterHook id
       */

      /**
       * Constructs a new MsgUnregisterHook.
       * @memberof nftvault.eventhook
       * @classdesc Represents a MsgUnregisterHook.
       * @implements IMsgUnregisterHook
       * @constructor
       * @param {nftvault.eventhook.IMsgUnregisterHook=} [properties] Properties to set
       */
      function MsgUnregisterHook(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * MsgUnregisterHook sender.
       * @member {string} sender
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @instance
       */
      MsgUnregisterHook.prototype.sender = '';

      /**
       * MsgUnregisterHook event_type.
       * @member {string} event_type
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @instance
       */
      MsgUnregisterHook.prototype.event_type = '';

      /**
       * MsgUnregisterHook id.
       * @member {Long} id
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @instance
       */
      MsgUnregisterHook.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified MsgUnregisterHook message. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHook.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @static
       * @param {nftvault.eventhook.IMsgUnregisterHook} message MsgUnregisterHook message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUnregisterHook.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.sender != null && Object.hasOwnProperty.call(message, 'sender'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.sender);
        if (message.event_type != null && Object.hasOwnProperty.call(message, 'event_type'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.event_type);
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified MsgUnregisterHook message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHook.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @static
       * @param {nftvault.eventhook.IMsgUnregisterHook} message MsgUnregisterHook message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUnregisterHook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUnregisterHook message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.MsgUnregisterHook} MsgUnregisterHook
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUnregisterHook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.MsgUnregisterHook();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.event_type = reader.string();
              break;
            case 3:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUnregisterHook message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.MsgUnregisterHook} MsgUnregisterHook
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUnregisterHook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUnregisterHook message.
       * @function verify
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUnregisterHook.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.sender != null && message.hasOwnProperty('sender'))
          if (!$util.isString(message.sender)) return 'sender: string expected';
        if (message.event_type != null && message.hasOwnProperty('event_type'))
          if (!$util.isString(message.event_type)) return 'event_type: string expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a MsgUnregisterHook message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.MsgUnregisterHook} MsgUnregisterHook
       */
      MsgUnregisterHook.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.MsgUnregisterHook) return object;
        let message = new $root.nftvault.eventhook.MsgUnregisterHook();
        if (object.sender != null) message.sender = String(object.sender);
        if (object.event_type != null) message.event_type = String(object.event_type);
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a MsgUnregisterHook message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @static
       * @param {nftvault.eventhook.MsgUnregisterHook} message MsgUnregisterHook
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUnregisterHook.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.sender = '';
          object.event_type = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        }
        if (message.sender != null && message.hasOwnProperty('sender')) object.sender = message.sender;
        if (message.event_type != null && message.hasOwnProperty('event_type')) object.event_type = message.event_type;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this MsgUnregisterHook to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.MsgUnregisterHook
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUnregisterHook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUnregisterHook;
    })();

    eventhook.MsgUnregisterHookResponse = (function () {
      /**
       * Properties of a MsgUnregisterHookResponse.
       * @memberof nftvault.eventhook
       * @interface IMsgUnregisterHookResponse
       */

      /**
       * Constructs a new MsgUnregisterHookResponse.
       * @memberof nftvault.eventhook
       * @classdesc Represents a MsgUnregisterHookResponse.
       * @implements IMsgUnregisterHookResponse
       * @constructor
       * @param {nftvault.eventhook.IMsgUnregisterHookResponse=} [properties] Properties to set
       */
      function MsgUnregisterHookResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified MsgUnregisterHookResponse message. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHookResponse.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @static
       * @param {nftvault.eventhook.IMsgUnregisterHookResponse} message MsgUnregisterHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUnregisterHookResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified MsgUnregisterHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.MsgUnregisterHookResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @static
       * @param {nftvault.eventhook.IMsgUnregisterHookResponse} message MsgUnregisterHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      MsgUnregisterHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a MsgUnregisterHookResponse message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.MsgUnregisterHookResponse} MsgUnregisterHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUnregisterHookResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.MsgUnregisterHookResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a MsgUnregisterHookResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.MsgUnregisterHookResponse} MsgUnregisterHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      MsgUnregisterHookResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a MsgUnregisterHookResponse message.
       * @function verify
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      MsgUnregisterHookResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a MsgUnregisterHookResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.MsgUnregisterHookResponse} MsgUnregisterHookResponse
       */
      MsgUnregisterHookResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.MsgUnregisterHookResponse) return object;
        return new $root.nftvault.eventhook.MsgUnregisterHookResponse();
      };

      /**
       * Creates a plain object from a MsgUnregisterHookResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @static
       * @param {nftvault.eventhook.MsgUnregisterHookResponse} message MsgUnregisterHookResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      MsgUnregisterHookResponse.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this MsgUnregisterHookResponse to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.MsgUnregisterHookResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      MsgUnregisterHookResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return MsgUnregisterHookResponse;
    })();

    eventhook.Hook = (function () {
      /**
       * Properties of a Hook.
       * @memberof nftvault.eventhook
       * @interface IHook
       * @property {Long|null} [id] Hook id
       * @property {string|null} [name] Hook name
       * @property {string|null} [contract_address] Hook contract_address
       * @property {string|null} [git_url] Hook git_url
       * @property {string|null} [event_type] Hook event_type
       * @property {Array.<nftvault.eventhook.IKeyValuePair>|null} [event_attributes] Hook event_attributes
       */

      /**
       * Constructs a new Hook.
       * @memberof nftvault.eventhook
       * @classdesc Represents a Hook.
       * @implements IHook
       * @constructor
       * @param {nftvault.eventhook.IHook=} [properties] Properties to set
       */
      function Hook(properties) {
        this.event_attributes = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Hook id.
       * @member {Long} id
       * @memberof nftvault.eventhook.Hook
       * @instance
       */
      Hook.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Hook name.
       * @member {string} name
       * @memberof nftvault.eventhook.Hook
       * @instance
       */
      Hook.prototype.name = '';

      /**
       * Hook contract_address.
       * @member {string} contract_address
       * @memberof nftvault.eventhook.Hook
       * @instance
       */
      Hook.prototype.contract_address = '';

      /**
       * Hook git_url.
       * @member {string} git_url
       * @memberof nftvault.eventhook.Hook
       * @instance
       */
      Hook.prototype.git_url = '';

      /**
       * Hook event_type.
       * @member {string} event_type
       * @memberof nftvault.eventhook.Hook
       * @instance
       */
      Hook.prototype.event_type = '';

      /**
       * Hook event_attributes.
       * @member {Array.<nftvault.eventhook.IKeyValuePair>} event_attributes
       * @memberof nftvault.eventhook.Hook
       * @instance
       */
      Hook.prototype.event_attributes = $util.emptyArray;

      /**
       * Encodes the specified Hook message. Does not implicitly {@link nftvault.eventhook.Hook.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.Hook
       * @static
       * @param {nftvault.eventhook.IHook} message Hook message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Hook.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, 'name'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
        if (message.contract_address != null && Object.hasOwnProperty.call(message, 'contract_address'))
          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.contract_address);
        if (message.git_url != null && Object.hasOwnProperty.call(message, 'git_url'))
          writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.git_url);
        if (message.event_type != null && Object.hasOwnProperty.call(message, 'event_type'))
          writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.event_type);
        if (message.event_attributes != null && message.event_attributes.length)
          for (let i = 0; i < message.event_attributes.length; ++i)
            $root.nftvault.eventhook.KeyValuePair.encode(
              message.event_attributes[i],
              writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
            ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified Hook message, length delimited. Does not implicitly {@link nftvault.eventhook.Hook.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.Hook
       * @static
       * @param {nftvault.eventhook.IHook} message Hook message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Hook.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Hook message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.Hook
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.Hook} Hook
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Hook.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.Hook();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.contract_address = reader.string();
              break;
            case 4:
              message.git_url = reader.string();
              break;
            case 5:
              message.event_type = reader.string();
              break;
            case 6:
              if (!(message.event_attributes && message.event_attributes.length)) message.event_attributes = [];
              message.event_attributes.push($root.nftvault.eventhook.KeyValuePair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Hook message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.Hook
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.Hook} Hook
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Hook.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Hook message.
       * @function verify
       * @memberof nftvault.eventhook.Hook
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Hook.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          if (!$util.isString(message.contract_address)) return 'contract_address: string expected';
        if (message.git_url != null && message.hasOwnProperty('git_url'))
          if (!$util.isString(message.git_url)) return 'git_url: string expected';
        if (message.event_type != null && message.hasOwnProperty('event_type'))
          if (!$util.isString(message.event_type)) return 'event_type: string expected';
        if (message.event_attributes != null && message.hasOwnProperty('event_attributes')) {
          if (!Array.isArray(message.event_attributes)) return 'event_attributes: array expected';
          for (let i = 0; i < message.event_attributes.length; ++i) {
            let error = $root.nftvault.eventhook.KeyValuePair.verify(message.event_attributes[i]);
            if (error) return 'event_attributes.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a Hook message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.Hook
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.Hook} Hook
       */
      Hook.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.Hook) return object;
        let message = new $root.nftvault.eventhook.Hook();
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        if (object.name != null) message.name = String(object.name);
        if (object.contract_address != null) message.contract_address = String(object.contract_address);
        if (object.git_url != null) message.git_url = String(object.git_url);
        if (object.event_type != null) message.event_type = String(object.event_type);
        if (object.event_attributes) {
          if (!Array.isArray(object.event_attributes)) throw TypeError('.nftvault.eventhook.Hook.event_attributes: array expected');
          message.event_attributes = [];
          for (let i = 0; i < object.event_attributes.length; ++i) {
            if (typeof object.event_attributes[i] !== 'object')
              throw TypeError('.nftvault.eventhook.Hook.event_attributes: object expected');
            message.event_attributes[i] = $root.nftvault.eventhook.KeyValuePair.fromObject(object.event_attributes[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a Hook message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.Hook
       * @static
       * @param {nftvault.eventhook.Hook} message Hook
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Hook.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.event_attributes = [];
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
          object.name = '';
          object.contract_address = '';
          object.git_url = '';
          object.event_type = '';
        }
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;
        if (message.contract_address != null && message.hasOwnProperty('contract_address'))
          object.contract_address = message.contract_address;
        if (message.git_url != null && message.hasOwnProperty('git_url')) object.git_url = message.git_url;
        if (message.event_type != null && message.hasOwnProperty('event_type')) object.event_type = message.event_type;
        if (message.event_attributes && message.event_attributes.length) {
          object.event_attributes = [];
          for (let j = 0; j < message.event_attributes.length; ++j)
            object.event_attributes[j] = $root.nftvault.eventhook.KeyValuePair.toObject(message.event_attributes[j], options);
        }
        return object;
      };

      /**
       * Converts this Hook to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.Hook
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Hook.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Hook;
    })();

    eventhook.KeyValuePair = (function () {
      /**
       * Properties of a KeyValuePair.
       * @memberof nftvault.eventhook
       * @interface IKeyValuePair
       * @property {string|null} [key] KeyValuePair key
       * @property {string|null} [value] KeyValuePair value
       */

      /**
       * Constructs a new KeyValuePair.
       * @memberof nftvault.eventhook
       * @classdesc Represents a KeyValuePair.
       * @implements IKeyValuePair
       * @constructor
       * @param {nftvault.eventhook.IKeyValuePair=} [properties] Properties to set
       */
      function KeyValuePair(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * KeyValuePair key.
       * @member {string} key
       * @memberof nftvault.eventhook.KeyValuePair
       * @instance
       */
      KeyValuePair.prototype.key = '';

      /**
       * KeyValuePair value.
       * @member {string} value
       * @memberof nftvault.eventhook.KeyValuePair
       * @instance
       */
      KeyValuePair.prototype.value = '';

      /**
       * Encodes the specified KeyValuePair message. Does not implicitly {@link nftvault.eventhook.KeyValuePair.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.KeyValuePair
       * @static
       * @param {nftvault.eventhook.IKeyValuePair} message KeyValuePair message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      KeyValuePair.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, 'key'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
        if (message.value != null && Object.hasOwnProperty.call(message, 'value'))
          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
        return writer;
      };

      /**
       * Encodes the specified KeyValuePair message, length delimited. Does not implicitly {@link nftvault.eventhook.KeyValuePair.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.KeyValuePair
       * @static
       * @param {nftvault.eventhook.IKeyValuePair} message KeyValuePair message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      KeyValuePair.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a KeyValuePair message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.KeyValuePair
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.KeyValuePair} KeyValuePair
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      KeyValuePair.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.KeyValuePair();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a KeyValuePair message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.KeyValuePair
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.KeyValuePair} KeyValuePair
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      KeyValuePair.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a KeyValuePair message.
       * @function verify
       * @memberof nftvault.eventhook.KeyValuePair
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      KeyValuePair.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.key != null && message.hasOwnProperty('key')) if (!$util.isString(message.key)) return 'key: string expected';
        if (message.value != null && message.hasOwnProperty('value')) if (!$util.isString(message.value)) return 'value: string expected';
        return null;
      };

      /**
       * Creates a KeyValuePair message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.KeyValuePair
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.KeyValuePair} KeyValuePair
       */
      KeyValuePair.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.KeyValuePair) return object;
        let message = new $root.nftvault.eventhook.KeyValuePair();
        if (object.key != null) message.key = String(object.key);
        if (object.value != null) message.value = String(object.value);
        return message;
      };

      /**
       * Creates a plain object from a KeyValuePair message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.KeyValuePair
       * @static
       * @param {nftvault.eventhook.KeyValuePair} message KeyValuePair
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      KeyValuePair.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.key = '';
          object.value = '';
        }
        if (message.key != null && message.hasOwnProperty('key')) object.key = message.key;
        if (message.value != null && message.hasOwnProperty('value')) object.value = message.value;
        return object;
      };

      /**
       * Converts this KeyValuePair to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.KeyValuePair
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      KeyValuePair.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return KeyValuePair;
    })();

    eventhook.GenesisState = (function () {
      /**
       * Properties of a GenesisState.
       * @memberof nftvault.eventhook
       * @interface IGenesisState
       * @property {nftvault.eventhook.IParams|null} [params] GenesisState params
       * @property {Array.<nftvault.eventhook.IHook>|null} [hooks] GenesisState hooks
       */

      /**
       * Constructs a new GenesisState.
       * @memberof nftvault.eventhook
       * @classdesc Represents a GenesisState.
       * @implements IGenesisState
       * @constructor
       * @param {nftvault.eventhook.IGenesisState=} [properties] Properties to set
       */
      function GenesisState(properties) {
        this.hooks = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * GenesisState params.
       * @member {nftvault.eventhook.IParams|null|undefined} params
       * @memberof nftvault.eventhook.GenesisState
       * @instance
       */
      GenesisState.prototype.params = null;

      /**
       * GenesisState hooks.
       * @member {Array.<nftvault.eventhook.IHook>} hooks
       * @memberof nftvault.eventhook.GenesisState
       * @instance
       */
      GenesisState.prototype.hooks = $util.emptyArray;

      /**
       * Encodes the specified GenesisState message. Does not implicitly {@link nftvault.eventhook.GenesisState.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.GenesisState
       * @static
       * @param {nftvault.eventhook.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.nftvault.eventhook.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.hooks != null && message.hooks.length)
          for (let i = 0; i < message.hooks.length; ++i)
            $root.nftvault.eventhook.Hook.encode(message.hooks[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified GenesisState message, length delimited. Does not implicitly {@link nftvault.eventhook.GenesisState.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.GenesisState
       * @static
       * @param {nftvault.eventhook.IGenesisState} message GenesisState message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      GenesisState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.GenesisState();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.nftvault.eventhook.Params.decode(reader, reader.uint32());
              break;
            case 2:
              if (!(message.hooks && message.hooks.length)) message.hooks = [];
              message.hooks.push($root.nftvault.eventhook.Hook.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a GenesisState message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.GenesisState
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.GenesisState} GenesisState
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      GenesisState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a GenesisState message.
       * @function verify
       * @memberof nftvault.eventhook.GenesisState
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      GenesisState.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.nftvault.eventhook.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        if (message.hooks != null && message.hasOwnProperty('hooks')) {
          if (!Array.isArray(message.hooks)) return 'hooks: array expected';
          for (let i = 0; i < message.hooks.length; ++i) {
            let error = $root.nftvault.eventhook.Hook.verify(message.hooks[i]);
            if (error) return 'hooks.' + error;
          }
        }
        return null;
      };

      /**
       * Creates a GenesisState message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.GenesisState
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.GenesisState} GenesisState
       */
      GenesisState.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.GenesisState) return object;
        let message = new $root.nftvault.eventhook.GenesisState();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.nftvault.eventhook.GenesisState.params: object expected');
          message.params = $root.nftvault.eventhook.Params.fromObject(object.params);
        }
        if (object.hooks) {
          if (!Array.isArray(object.hooks)) throw TypeError('.nftvault.eventhook.GenesisState.hooks: array expected');
          message.hooks = [];
          for (let i = 0; i < object.hooks.length; ++i) {
            if (typeof object.hooks[i] !== 'object') throw TypeError('.nftvault.eventhook.GenesisState.hooks: object expected');
            message.hooks[i] = $root.nftvault.eventhook.Hook.fromObject(object.hooks[i]);
          }
        }
        return message;
      };

      /**
       * Creates a plain object from a GenesisState message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.GenesisState
       * @static
       * @param {nftvault.eventhook.GenesisState} message GenesisState
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      GenesisState.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.hooks = [];
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.nftvault.eventhook.Params.toObject(message.params, options);
        if (message.hooks && message.hooks.length) {
          object.hooks = [];
          for (let j = 0; j < message.hooks.length; ++j)
            object.hooks[j] = $root.nftvault.eventhook.Hook.toObject(message.hooks[j], options);
        }
        return object;
      };

      /**
       * Converts this GenesisState to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.GenesisState
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      GenesisState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return GenesisState;
    })();

    eventhook.Params = (function () {
      /**
       * Properties of a Params.
       * @memberof nftvault.eventhook
       * @interface IParams
       */

      /**
       * Constructs a new Params.
       * @memberof nftvault.eventhook
       * @classdesc Represents a Params.
       * @implements IParams
       * @constructor
       * @param {nftvault.eventhook.IParams=} [properties] Properties to set
       */
      function Params(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified Params message. Does not implicitly {@link nftvault.eventhook.Params.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.Params
       * @static
       * @param {nftvault.eventhook.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified Params message, length delimited. Does not implicitly {@link nftvault.eventhook.Params.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.Params
       * @static
       * @param {nftvault.eventhook.IParams} message Params message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Params.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Params message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.Params();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Params message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.Params
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.Params} Params
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Params.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Params message.
       * @function verify
       * @memberof nftvault.eventhook.Params
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Params.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a Params message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.Params
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.Params} Params
       */
      Params.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.Params) return object;
        return new $root.nftvault.eventhook.Params();
      };

      /**
       * Creates a plain object from a Params message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.Params
       * @static
       * @param {nftvault.eventhook.Params} message Params
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Params.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this Params to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.Params
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Params.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return Params;
    })();

    eventhook.Query = (function () {
      /**
       * Constructs a new Query service.
       * @memberof nftvault.eventhook
       * @classdesc Represents a Query
       * @extends $protobuf.rpc.Service
       * @constructor
       * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
       * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
       * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
       */
      function Query(rpcImpl, requestDelimited, responseDelimited) {
        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
      }

      (Query.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Query;

      /**
       * Callback as used by {@link nftvault.eventhook.Query#params}.
       * @memberof nftvault.eventhook.Query
       * @typedef ParamsCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {nftvault.eventhook.QueryParamsResponse} [response] QueryParamsResponse
       */

      /**
       * Calls Params.
       * @function params
       * @memberof nftvault.eventhook.Query
       * @instance
       * @param {nftvault.eventhook.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @param {nftvault.eventhook.Query.ParamsCallback} callback Node-style callback called with the error, if any, and QueryParamsResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.params = function params(request, callback) {
          return this.rpcCall(
            params,
            $root.nftvault.eventhook.QueryParamsRequest,
            $root.nftvault.eventhook.QueryParamsResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Params' },
      );

      /**
       * Calls Params.
       * @function params
       * @memberof nftvault.eventhook.Query
       * @instance
       * @param {nftvault.eventhook.IQueryParamsRequest} request QueryParamsRequest message or plain object
       * @returns {Promise<nftvault.eventhook.QueryParamsResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link nftvault.eventhook.Query#hookAll}.
       * @memberof nftvault.eventhook.Query
       * @typedef HookAllCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {nftvault.eventhook.QueryAllHookResponse} [response] QueryAllHookResponse
       */

      /**
       * Calls HookAll.
       * @function hookAll
       * @memberof nftvault.eventhook.Query
       * @instance
       * @param {nftvault.eventhook.IQueryAllHookRequest} request QueryAllHookRequest message or plain object
       * @param {nftvault.eventhook.Query.HookAllCallback} callback Node-style callback called with the error, if any, and QueryAllHookResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.hookAll = function hookAll(request, callback) {
          return this.rpcCall(
            hookAll,
            $root.nftvault.eventhook.QueryAllHookRequest,
            $root.nftvault.eventhook.QueryAllHookResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'HookAll' },
      );

      /**
       * Calls HookAll.
       * @function hookAll
       * @memberof nftvault.eventhook.Query
       * @instance
       * @param {nftvault.eventhook.IQueryAllHookRequest} request QueryAllHookRequest message or plain object
       * @returns {Promise<nftvault.eventhook.QueryAllHookResponse>} Promise
       * @variation 2
       */

      /**
       * Callback as used by {@link nftvault.eventhook.Query#hook}.
       * @memberof nftvault.eventhook.Query
       * @typedef HookCallback
       * @type {function}
       * @param {Error|null} error Error, if any
       * @param {nftvault.eventhook.QueryGetHookResponse} [response] QueryGetHookResponse
       */

      /**
       * Calls Hook.
       * @function hook
       * @memberof nftvault.eventhook.Query
       * @instance
       * @param {nftvault.eventhook.IQueryGetHookRequest} request QueryGetHookRequest message or plain object
       * @param {nftvault.eventhook.Query.HookCallback} callback Node-style callback called with the error, if any, and QueryGetHookResponse
       * @returns {undefined}
       * @variation 1
       */
      Object.defineProperty(
        (Query.prototype.hook = function hook(request, callback) {
          return this.rpcCall(
            hook,
            $root.nftvault.eventhook.QueryGetHookRequest,
            $root.nftvault.eventhook.QueryGetHookResponse,
            request,
            callback,
          );
        }),
        'name',
        { value: 'Hook' },
      );

      /**
       * Calls Hook.
       * @function hook
       * @memberof nftvault.eventhook.Query
       * @instance
       * @param {nftvault.eventhook.IQueryGetHookRequest} request QueryGetHookRequest message or plain object
       * @returns {Promise<nftvault.eventhook.QueryGetHookResponse>} Promise
       * @variation 2
       */

      return Query;
    })();

    eventhook.QueryParamsRequest = (function () {
      /**
       * Properties of a QueryParamsRequest.
       * @memberof nftvault.eventhook
       * @interface IQueryParamsRequest
       */

      /**
       * Constructs a new QueryParamsRequest.
       * @memberof nftvault.eventhook
       * @classdesc Represents a QueryParamsRequest.
       * @implements IQueryParamsRequest
       * @constructor
       * @param {nftvault.eventhook.IQueryParamsRequest=} [properties] Properties to set
       */
      function QueryParamsRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * Encodes the specified QueryParamsRequest message. Does not implicitly {@link nftvault.eventhook.QueryParamsRequest.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @static
       * @param {nftvault.eventhook.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsRequest message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryParamsRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @static
       * @param {nftvault.eventhook.IQueryParamsRequest} message QueryParamsRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.QueryParamsRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.QueryParamsRequest} QueryParamsRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsRequest message.
       * @function verify
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        return null;
      };

      /**
       * Creates a QueryParamsRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.QueryParamsRequest} QueryParamsRequest
       */
      QueryParamsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.QueryParamsRequest) return object;
        return new $root.nftvault.eventhook.QueryParamsRequest();
      };

      /**
       * Creates a plain object from a QueryParamsRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @static
       * @param {nftvault.eventhook.QueryParamsRequest} message QueryParamsRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsRequest.toObject = function toObject() {
        return {};
      };

      /**
       * Converts this QueryParamsRequest to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.QueryParamsRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsRequest;
    })();

    eventhook.QueryParamsResponse = (function () {
      /**
       * Properties of a QueryParamsResponse.
       * @memberof nftvault.eventhook
       * @interface IQueryParamsResponse
       * @property {nftvault.eventhook.IParams|null} [params] QueryParamsResponse params
       */

      /**
       * Constructs a new QueryParamsResponse.
       * @memberof nftvault.eventhook
       * @classdesc Represents a QueryParamsResponse.
       * @implements IQueryParamsResponse
       * @constructor
       * @param {nftvault.eventhook.IQueryParamsResponse=} [properties] Properties to set
       */
      function QueryParamsResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryParamsResponse params.
       * @member {nftvault.eventhook.IParams|null|undefined} params
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @instance
       */
      QueryParamsResponse.prototype.params = null;

      /**
       * Encodes the specified QueryParamsResponse message. Does not implicitly {@link nftvault.eventhook.QueryParamsResponse.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @static
       * @param {nftvault.eventhook.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.params != null && Object.hasOwnProperty.call(message, 'params'))
          $root.nftvault.eventhook.Params.encode(message.params, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryParamsResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryParamsResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @static
       * @param {nftvault.eventhook.IQueryParamsResponse} message QueryParamsResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryParamsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.QueryParamsResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = $root.nftvault.eventhook.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryParamsResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.QueryParamsResponse} QueryParamsResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryParamsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryParamsResponse message.
       * @function verify
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryParamsResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.params != null && message.hasOwnProperty('params')) {
          let error = $root.nftvault.eventhook.Params.verify(message.params);
          if (error) return 'params.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryParamsResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.QueryParamsResponse} QueryParamsResponse
       */
      QueryParamsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.QueryParamsResponse) return object;
        let message = new $root.nftvault.eventhook.QueryParamsResponse();
        if (object.params != null) {
          if (typeof object.params !== 'object') throw TypeError('.nftvault.eventhook.QueryParamsResponse.params: object expected');
          message.params = $root.nftvault.eventhook.Params.fromObject(object.params);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryParamsResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @static
       * @param {nftvault.eventhook.QueryParamsResponse} message QueryParamsResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryParamsResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.params = null;
        if (message.params != null && message.hasOwnProperty('params'))
          object.params = $root.nftvault.eventhook.Params.toObject(message.params, options);
        return object;
      };

      /**
       * Converts this QueryParamsResponse to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.QueryParamsResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryParamsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryParamsResponse;
    })();

    eventhook.QueryAllHookRequest = (function () {
      /**
       * Properties of a QueryAllHookRequest.
       * @memberof nftvault.eventhook
       * @interface IQueryAllHookRequest
       * @property {string|null} [event_type] QueryAllHookRequest event_type
       * @property {cosmos.base.query.v1beta1.IPageRequest|null} [pagination] QueryAllHookRequest pagination
       */

      /**
       * Constructs a new QueryAllHookRequest.
       * @memberof nftvault.eventhook
       * @classdesc Represents a QueryAllHookRequest.
       * @implements IQueryAllHookRequest
       * @constructor
       * @param {nftvault.eventhook.IQueryAllHookRequest=} [properties] Properties to set
       */
      function QueryAllHookRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllHookRequest event_type.
       * @member {string} event_type
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @instance
       */
      QueryAllHookRequest.prototype.event_type = '';

      /**
       * QueryAllHookRequest pagination.
       * @member {cosmos.base.query.v1beta1.IPageRequest|null|undefined} pagination
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @instance
       */
      QueryAllHookRequest.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllHookRequest message. Does not implicitly {@link nftvault.eventhook.QueryAllHookRequest.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @static
       * @param {nftvault.eventhook.IQueryAllHookRequest} message QueryAllHookRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllHookRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.event_type != null && Object.hasOwnProperty.call(message, 'event_type'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.event_type);
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageRequest.encode(message.pagination, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllHookRequest message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryAllHookRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @static
       * @param {nftvault.eventhook.IQueryAllHookRequest} message QueryAllHookRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllHookRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllHookRequest message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.QueryAllHookRequest} QueryAllHookRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllHookRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.QueryAllHookRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.event_type = reader.string();
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllHookRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.QueryAllHookRequest} QueryAllHookRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllHookRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllHookRequest message.
       * @function verify
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllHookRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.event_type != null && message.hasOwnProperty('event_type'))
          if (!$util.isString(message.event_type)) return 'event_type: string expected';
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageRequest.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllHookRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.QueryAllHookRequest} QueryAllHookRequest
       */
      QueryAllHookRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.QueryAllHookRequest) return object;
        let message = new $root.nftvault.eventhook.QueryAllHookRequest();
        if (object.event_type != null) message.event_type = String(object.event_type);
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object') throw TypeError('.nftvault.eventhook.QueryAllHookRequest.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageRequest.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllHookRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @static
       * @param {nftvault.eventhook.QueryAllHookRequest} message QueryAllHookRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllHookRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.event_type = '';
          object.pagination = null;
        }
        if (message.event_type != null && message.hasOwnProperty('event_type')) object.event_type = message.event_type;
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageRequest.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllHookRequest to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.QueryAllHookRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllHookRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllHookRequest;
    })();

    eventhook.QueryAllHookResponse = (function () {
      /**
       * Properties of a QueryAllHookResponse.
       * @memberof nftvault.eventhook
       * @interface IQueryAllHookResponse
       * @property {Array.<nftvault.eventhook.IHook>|null} [hooks] QueryAllHookResponse hooks
       * @property {cosmos.base.query.v1beta1.IPageResponse|null} [pagination] QueryAllHookResponse pagination
       */

      /**
       * Constructs a new QueryAllHookResponse.
       * @memberof nftvault.eventhook
       * @classdesc Represents a QueryAllHookResponse.
       * @implements IQueryAllHookResponse
       * @constructor
       * @param {nftvault.eventhook.IQueryAllHookResponse=} [properties] Properties to set
       */
      function QueryAllHookResponse(properties) {
        this.hooks = [];
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryAllHookResponse hooks.
       * @member {Array.<nftvault.eventhook.IHook>} hooks
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @instance
       */
      QueryAllHookResponse.prototype.hooks = $util.emptyArray;

      /**
       * QueryAllHookResponse pagination.
       * @member {cosmos.base.query.v1beta1.IPageResponse|null|undefined} pagination
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @instance
       */
      QueryAllHookResponse.prototype.pagination = null;

      /**
       * Encodes the specified QueryAllHookResponse message. Does not implicitly {@link nftvault.eventhook.QueryAllHookResponse.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @static
       * @param {nftvault.eventhook.IQueryAllHookResponse} message QueryAllHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllHookResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.hooks != null && message.hooks.length)
          for (let i = 0; i < message.hooks.length; ++i)
            $root.nftvault.eventhook.Hook.encode(message.hooks[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        if (message.pagination != null && Object.hasOwnProperty.call(message, 'pagination'))
          $root.cosmos.base.query.v1beta1.PageResponse.encode(
            message.pagination,
            writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
          ).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryAllHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryAllHookResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @static
       * @param {nftvault.eventhook.IQueryAllHookResponse} message QueryAllHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryAllHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryAllHookResponse message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.QueryAllHookResponse} QueryAllHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllHookResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.QueryAllHookResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.hooks && message.hooks.length)) message.hooks = [];
              message.hooks.push($root.nftvault.eventhook.Hook.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryAllHookResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.QueryAllHookResponse} QueryAllHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryAllHookResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryAllHookResponse message.
       * @function verify
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryAllHookResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.hooks != null && message.hasOwnProperty('hooks')) {
          if (!Array.isArray(message.hooks)) return 'hooks: array expected';
          for (let i = 0; i < message.hooks.length; ++i) {
            let error = $root.nftvault.eventhook.Hook.verify(message.hooks[i]);
            if (error) return 'hooks.' + error;
          }
        }
        if (message.pagination != null && message.hasOwnProperty('pagination')) {
          let error = $root.cosmos.base.query.v1beta1.PageResponse.verify(message.pagination);
          if (error) return 'pagination.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryAllHookResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.QueryAllHookResponse} QueryAllHookResponse
       */
      QueryAllHookResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.QueryAllHookResponse) return object;
        let message = new $root.nftvault.eventhook.QueryAllHookResponse();
        if (object.hooks) {
          if (!Array.isArray(object.hooks)) throw TypeError('.nftvault.eventhook.QueryAllHookResponse.hooks: array expected');
          message.hooks = [];
          for (let i = 0; i < object.hooks.length; ++i) {
            if (typeof object.hooks[i] !== 'object') throw TypeError('.nftvault.eventhook.QueryAllHookResponse.hooks: object expected');
            message.hooks[i] = $root.nftvault.eventhook.Hook.fromObject(object.hooks[i]);
          }
        }
        if (object.pagination != null) {
          if (typeof object.pagination !== 'object')
            throw TypeError('.nftvault.eventhook.QueryAllHookResponse.pagination: object expected');
          message.pagination = $root.cosmos.base.query.v1beta1.PageResponse.fromObject(object.pagination);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryAllHookResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @static
       * @param {nftvault.eventhook.QueryAllHookResponse} message QueryAllHookResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryAllHookResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.arrays || options.defaults) object.hooks = [];
        if (options.defaults) object.pagination = null;
        if (message.hooks && message.hooks.length) {
          object.hooks = [];
          for (let j = 0; j < message.hooks.length; ++j)
            object.hooks[j] = $root.nftvault.eventhook.Hook.toObject(message.hooks[j], options);
        }
        if (message.pagination != null && message.hasOwnProperty('pagination'))
          object.pagination = $root.cosmos.base.query.v1beta1.PageResponse.toObject(message.pagination, options);
        return object;
      };

      /**
       * Converts this QueryAllHookResponse to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.QueryAllHookResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryAllHookResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryAllHookResponse;
    })();

    eventhook.QueryGetHookRequest = (function () {
      /**
       * Properties of a QueryGetHookRequest.
       * @memberof nftvault.eventhook
       * @interface IQueryGetHookRequest
       * @property {string|null} [event_type] QueryGetHookRequest event_type
       * @property {Long|null} [id] QueryGetHookRequest id
       */

      /**
       * Constructs a new QueryGetHookRequest.
       * @memberof nftvault.eventhook
       * @classdesc Represents a QueryGetHookRequest.
       * @implements IQueryGetHookRequest
       * @constructor
       * @param {nftvault.eventhook.IQueryGetHookRequest=} [properties] Properties to set
       */
      function QueryGetHookRequest(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetHookRequest event_type.
       * @member {string} event_type
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @instance
       */
      QueryGetHookRequest.prototype.event_type = '';

      /**
       * QueryGetHookRequest id.
       * @member {Long} id
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @instance
       */
      QueryGetHookRequest.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

      /**
       * Encodes the specified QueryGetHookRequest message. Does not implicitly {@link nftvault.eventhook.QueryGetHookRequest.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @static
       * @param {nftvault.eventhook.IQueryGetHookRequest} message QueryGetHookRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetHookRequest.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.event_type != null && Object.hasOwnProperty.call(message, 'event_type'))
          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.event_type);
        if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.id);
        return writer;
      };

      /**
       * Encodes the specified QueryGetHookRequest message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryGetHookRequest.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @static
       * @param {nftvault.eventhook.IQueryGetHookRequest} message QueryGetHookRequest message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetHookRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetHookRequest message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.QueryGetHookRequest} QueryGetHookRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetHookRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.QueryGetHookRequest();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.event_type = reader.string();
              break;
            case 2:
              message.id = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetHookRequest message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.QueryGetHookRequest} QueryGetHookRequest
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetHookRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetHookRequest message.
       * @function verify
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetHookRequest.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.event_type != null && message.hasOwnProperty('event_type'))
          if (!$util.isString(message.event_type)) return 'event_type: string expected';
        if (message.id != null && message.hasOwnProperty('id'))
          if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
            return 'id: integer|Long expected';
        return null;
      };

      /**
       * Creates a QueryGetHookRequest message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.QueryGetHookRequest} QueryGetHookRequest
       */
      QueryGetHookRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.QueryGetHookRequest) return object;
        let message = new $root.nftvault.eventhook.QueryGetHookRequest();
        if (object.event_type != null) message.event_type = String(object.event_type);
        if (object.id != null)
          if ($util.Long) (message.id = $util.Long.fromValue(object.id)).unsigned = true;
          else if (typeof object.id === 'string') message.id = parseInt(object.id, 10);
          else if (typeof object.id === 'number') message.id = object.id;
          else if (typeof object.id === 'object') message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
        return message;
      };

      /**
       * Creates a plain object from a QueryGetHookRequest message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @static
       * @param {nftvault.eventhook.QueryGetHookRequest} message QueryGetHookRequest
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetHookRequest.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          object.event_type = '';
          if ($util.Long) {
            let long = new $util.Long(0, 0, true);
            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
          } else object.id = options.longs === String ? '0' : 0;
        }
        if (message.event_type != null && message.hasOwnProperty('event_type')) object.event_type = message.event_type;
        if (message.id != null && message.hasOwnProperty('id'))
          if (typeof message.id === 'number') object.id = options.longs === String ? String(message.id) : message.id;
          else
            object.id =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.id)
                : options.longs === Number
                ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true)
                : message.id;
        return object;
      };

      /**
       * Converts this QueryGetHookRequest to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.QueryGetHookRequest
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetHookRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetHookRequest;
    })();

    eventhook.QueryGetHookResponse = (function () {
      /**
       * Properties of a QueryGetHookResponse.
       * @memberof nftvault.eventhook
       * @interface IQueryGetHookResponse
       * @property {nftvault.eventhook.IHook|null} [hook] QueryGetHookResponse hook
       */

      /**
       * Constructs a new QueryGetHookResponse.
       * @memberof nftvault.eventhook
       * @classdesc Represents a QueryGetHookResponse.
       * @implements IQueryGetHookResponse
       * @constructor
       * @param {nftvault.eventhook.IQueryGetHookResponse=} [properties] Properties to set
       */
      function QueryGetHookResponse(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];
      }

      /**
       * QueryGetHookResponse hook.
       * @member {nftvault.eventhook.IHook|null|undefined} hook
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @instance
       */
      QueryGetHookResponse.prototype.hook = null;

      /**
       * Encodes the specified QueryGetHookResponse message. Does not implicitly {@link nftvault.eventhook.QueryGetHookResponse.verify|verify} messages.
       * @function encode
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @static
       * @param {nftvault.eventhook.IQueryGetHookResponse} message QueryGetHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetHookResponse.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (message.hook != null && Object.hasOwnProperty.call(message, 'hook'))
          $root.nftvault.eventhook.Hook.encode(message.hook, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
        return writer;
      };

      /**
       * Encodes the specified QueryGetHookResponse message, length delimited. Does not implicitly {@link nftvault.eventhook.QueryGetHookResponse.verify|verify} messages.
       * @function encodeDelimited
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @static
       * @param {nftvault.eventhook.IQueryGetHookResponse} message QueryGetHookResponse message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      QueryGetHookResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a QueryGetHookResponse message from the specified reader or buffer.
       * @function decode
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {nftvault.eventhook.QueryGetHookResponse} QueryGetHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetHookResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.nftvault.eventhook.QueryGetHookResponse();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hook = $root.nftvault.eventhook.Hook.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a QueryGetHookResponse message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {nftvault.eventhook.QueryGetHookResponse} QueryGetHookResponse
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      QueryGetHookResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a QueryGetHookResponse message.
       * @function verify
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      QueryGetHookResponse.verify = function verify(message) {
        if (typeof message !== 'object' || message === null) return 'object expected';
        if (message.hook != null && message.hasOwnProperty('hook')) {
          let error = $root.nftvault.eventhook.Hook.verify(message.hook);
          if (error) return 'hook.' + error;
        }
        return null;
      };

      /**
       * Creates a QueryGetHookResponse message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {nftvault.eventhook.QueryGetHookResponse} QueryGetHookResponse
       */
      QueryGetHookResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.nftvault.eventhook.QueryGetHookResponse) return object;
        let message = new $root.nftvault.eventhook.QueryGetHookResponse();
        if (object.hook != null) {
          if (typeof object.hook !== 'object') throw TypeError('.nftvault.eventhook.QueryGetHookResponse.hook: object expected');
          message.hook = $root.nftvault.eventhook.Hook.fromObject(object.hook);
        }
        return message;
      };

      /**
       * Creates a plain object from a QueryGetHookResponse message. Also converts values to other types if specified.
       * @function toObject
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @static
       * @param {nftvault.eventhook.QueryGetHookResponse} message QueryGetHookResponse
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      QueryGetHookResponse.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) object.hook = null;
        if (message.hook != null && message.hasOwnProperty('hook'))
          object.hook = $root.nftvault.eventhook.Hook.toObject(message.hook, options);
        return object;
      };

      /**
       * Converts this QueryGetHookResponse to JSON.
       * @function toJSON
       * @memberof nftvault.eventhook.QueryGetHookResponse
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      QueryGetHookResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      return QueryGetHookResponse;
    })();

    return eventhook;
  })();

  return nftvault;
})());

export { $root as default };
